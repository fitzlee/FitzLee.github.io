---
title: Jvm class结构和加载原理
urlname: jvm_art_class_load
#date: 2016-10-09
top: true
comments: true
#description: 
#tags: [git,hah,hha]
#keywords: git
categories: 03JVM&ART
tags:
    - java
    - jvm
    - class
    - loader
---

## Class类文件结构

### ClassFile结构 

一个Class类文件是由一个ClassFile结构组成：

```
ClassFile {
    u4             magic;               //魔数，固定值0xCAFEBABE
    u2             minor_version;       //次版本号
    u2             major_version;       //主版本号
    u2             constant_pool_count; //常量的个数
    cp_info        constant_pool[constant_pool_count-1];  //具体的常量池内容
    u2             access_flags;        //访问标识
    u2             this_class;          //当前类索引
    u2             super_class;         //父类索引
    u2             interfaces_count;    //接口的个数
    u2             interfaces[interfaces_count];          //具体的接口内容
    u2             fields_count;        //字段的个数
    field_info     fields[fields_count];                  //具体的字段内容
    u2             methods_count;       //方法的个数
    method_info    methods[methods_count];                //具体的方法内容
    u2             attributes_count;    //属性的个数
    attribute_info attributes[attributes_count];          //具体的属性内容
}
```

一个Class文件的大小：26 + cp_info[] + u2[] + field_info[] + method_info[] + attribute_info[]

### ClassFile文件组成

#### 3.1 魔数

每个Class文件头4个字节称为魔数(Magic Number),作用是用于确定这个Class文件是否能被虚拟机所接受，魔数固定值0xCAFEBABE。这是身份识别，比如jpeg等图片文件头也会有魔数。

#### 3.2 版本号

紧跟魔数，也占用4个字节。从第5字节到第8字节存储的分别是 次版本号，主版本号。

#### 3.3 常量池

常量池是Class文件空间最大的数据项之一，长度不固定。

a. 常量池长度 用u2类型代表常量池容量计数值，u2紧跟版本号。u2的大小等于常量池的常量个数+1。对于u2=0的特殊情况，代表没有使用常量池。

b. 常量池内容,格式如下：

```
cp_info {
    u1 tag;
    u1 info[];
}
```

包括两个类常量，字面量和符号引用：

- 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。

- 符号引用：编译语言层面的概念，包括以下3类：

  - 类和接口的全限定名

  - 字段的名称和描述符

  - 方法的名称和描述符

     

常量池中每一项常量都是一个表结构，每个表的开始第一位是u1类型的标志位tag, 代表当前这个常量的类型。在JDK 1.7.中共有14种不同的表结构的类型，如下：

![constant_type](http://gityuan.com/images/jvm/constant_type.png)

Class文件都是二进制格式，可通过`Jdk/bin/javap.exe`工具，分析Class文件字节码。关于javap用法，可通过`javap --help`来查看。



#### 3.4访问标识

2个字节代表，标示用于识别一些类或者接口层次的访问信息.

| 标识名         | 标识值 | 解释                                              |
| -------------- | ------ | ------------------------------------------------- |
| ACC_PUBLIC     | 0x0001 | 声明为public;可以从包外部访问                     |
| ACC_FINAL      | 0x0010 | 被声明为final;不允许子类修改                      |
| ACC_SUPER      | 0x0020 | 当被invokespecial指令调用时，将特殊对待父类的方法 |
| ACC_INTERFACE  | 0x0200 | 接口标识符                                        |
| ACC_ABSTRACT   | 0x0400 | 声明为abstract;不能被实例化                       |
| ACC_SYNTHETIC  | 0x1000 | 声明为synthetic;不存在于源代码，由编译器生成      |
| ACC_ANNOTATION | 0x2000 | 声明为注释类型                                    |
| ACC_ENUM       | 0x4000 | 声明为枚举类型                                    |



#### 3.5 类/父类索引

当前类索引和父类索引占用大小都为u2类型，由于一个类智能继承一个父类，故父类索引只有一个。除了java.lang.Object对象的父类索引为0，其他所有类都有父类。

#### 3.6 接口索引

一个类可以实现多个接口，故利用interfaces_count来记录该类所实现的接口个数，interfaces[interfaces_count]来记录所有实现的接口内容。

#### 3.7 字段表

字段表用于描述类或接口中声明的变量，格式如下：

```
field_info {
    u2             access_flags; //访问标识
    u2             name_index;  //名称索引
    u2             descriptor_index; //描述符索引
    u2             attributes_count; //属性个数
    attribute_info attributes[attributes_count];  //属性表的具体内容
}
```

字段访问标识如下：(表中加粗项是字段独有的)

| 标识名            | 标识值 | 解释                                             |
| ----------------- | ------ | ------------------------------------------------ |
| ACC_PUBLIC        | 0x0001 | 声明为 public; 可以从包外部访问                  |
| ACC_PRIVATE       | 0x0002 | 声明为 private; 只有定义的类可以访问             |
| ACC_PROTECTED     | 0x0004 | 声明为 protected;只有子类和相同package的类可访问 |
| ACC_STATIC        | 0x0008 | 声明为 static；属于类变量                        |
| ACC_FINAL         | 0x0010 | 声明为 final; 对象构造后无法直接修改值           |
| **ACC_VOLATILE**  | 0x0040 | 声明为 volatile; 不会被缓存,直接刷新到主屏幕     |
| **ACC_TRANSIENT** | 0x0080 | 声明为 transient; 不能被序列化                   |
| ACC_SYNTHETIC     | 0x1000 | 声明为 synthetic; 不存在于源代码，由编译器生成   |
| ACC_ENUM          | 0x4000 | 声明为enum                                       |

Java语法中，接口中的字段默认包含ACC_PUBLIC, ACC_STATIC, ACC_FINAL标识。ACC_FINAL，ACC_VOLATILE不能同时选择等规则。

紧跟其后的name_index和descriptor_index是对常量池的引用，分别代表着字段的简单名和方法的描述符。

<!-- more -->

#### 3.8方法表

方法表用于描述类或接口中声明的方法，格式如下：

```
method_info {
    u2             access_flags; //访问标识
    u2             name_index;  //名称索引
    u2             descriptor_index;  //描述符索引
    u2             attributes_count;  //属性个数
    attribute_info attributes[attributes_count]; //属性表的具体内容
}
```

方法访问标识如下：(表中加粗项是方法独有的)

| 标识名               | 标识值 | 解释                                             |
| -------------------- | ------ | ------------------------------------------------ |
| ACC_PUBLIC           | 0x0001 | 声明为 public; 可以从包外部访问                  |
| ACC_PRIVATE          | 0x0002 | 声明为 private; 只有定义的类可以访问             |
| ACC_PROTECTED        | 0x0004 | 声明为 protected;只有子类和相同package的类可访问 |
| ACC_STATIC           | 0x0008 | 声明为 static；属于类变量                        |
| ACC_FINAL            | 0x0010 | 声明为 final; 不能被覆写                         |
| **ACC_SYNCHRONIZED** | 0x0020 | 声明为 synchronized; 同步锁包裹                  |
| ACC_BRIDGE           | 0x0040 | 桥接方法, 由编译器生成                           |
| **ACC_VARARGS**      | 0x0080 | 声明为 接收不定长参数                            |
| **ACC_NATIVE**       | 0x0100 | 声明为 native; 由非Java语言来实现                |
| **ACC_ABSTRACT**     | 0x0400 | 声明为 abstract; 没有提供实现                    |
| **ACC_STRICT**       | 0x0800 | 声明为 strictfp; 浮点模式是FP-strict             |
| ACC_SYNTHETIC        | 0x1000 | 声明为 synthetic; 不存在于源代码，由编译器生成   |

- 对于方法里的Java代码，进过编译器编译成字节码指令后，存放在方法属性表集合中“code”的属性内。
- 当子类没有覆写父类方法，则方法集合中不会出现父类的方法信息。
- Java语言中重载方法，必须与原方法同名，且特征签名不同。特征签名是指方法中各个参数在常量池的字段符号引用的集合，不包括返回值。当时Class文件格式中，特征签名范围更广，允许方法名和特征签名都相同，但返回值不同的方法，合法地共存子啊同一个Class文件中。

#### 3.9 属性表

属性表格式：

```
attribute_info {
    u2 attribute_name_index;   //属性名索引
    u4 attribute_length;       //属性长度
    u1 info[attribute_length]; //属性的具体内容
}
```

属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。 关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。

| 属性名             | 使用位置           | 解释                                                         |
| ------------------ | ------------------ | ------------------------------------------------------------ |
| Code               | 方法表             | 方法体的内容                                                 |
| ConstantValue      | 字段表             | final关键字定义的常量值                                      |
| Deprecated         | 类、方法表、字段表 | 声明为deprecated                                             |
| InnerClasses       | 类文件             | 内部类的列表                                                 |
| LineNumberTable    | Code属性           | Java源码的行号与字节码指令的对应关系                         |
| LocalVariableTable | Code属性           | 方法的局部变量描述                                           |
| Signature          | 类、方法表、字段表 | 用于支持泛型的方法签名，由于Java的泛型采用擦除法，避免类型信息被擦除后导致签名混乱，Signature记录相关信息 |

**Code属性** java程序方法体中的代码，经编译后得到的字节码指令存储在Code属性内，Code属性位于方法表的属性集合中。但与native或者abstract的方法则不会存在Code属性中。

Code属性的格式如下：

```
Code_attribute {
    u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“
    u4 attribute_length; //属性值长度，为整个属性表长度-6
    u2 max_stack;   //操作数栈的最大深度值，jvm运行时根据该值佩服栈帧
    u2 max_locals;  //局部变量表最大存储空间，单位是slot
    u4 code_length; // 字节码指令的个数
    u1 code[code_length]; // 具体的字节码指令
    u2 exception_table_length; //异常的个数
    {   u2 start_pc;
        u2 end_pc;
        u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。
        u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理
    } exception_table[exception_table_length]; //具体的异常内容
    u2 attributes_count;     //属性的个数
    attribute_info attributes[attributes_count]; //具体的属性内容
}
```

- slot是虚拟机未局部变量分配内存使用的最小单位。对于byte/char/float/int/short/boolean/returnAddress等长度不超过32位的局部变量，每个占用1个Slot；对于long和double这两种64位的数据类型则需要2个Slot来存放。
- 实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。
- max_locals，不是所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。
- 虚拟机规范限制严格方法不允许超过65535个字节码，否则拒绝编译。

Code属性是Class文件中最重要的属性，Java程序的幸福课分为代码(方法体中的Java代码)和元数据(包含类、接口、字段、方法定义以及其他信息)两部分。

**ConstantValue属性** ConstantValue属性是指被static关键字修饰的变量（也称为类变量）。

- 类变量: 在类构造器方法或者使用ConstantValue属性来赋值
- 实例变量：在实例构造器方法进行赋值



参考:

http://gityuan.com/2015/10/17/jvm-class-instruction/

https://www.cnblogs.com/avivahe/p/5747113.html



## 类加载时机

1. 类从加载到虚拟机内存~卸载出内存的生命周期(这些阶段通常是交叉混合进行的):

   加载 --> [验证 --> 准备 --> 解析](https://github.com/wususu/Notes/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E8%BF%99%E9%83%A8%E5%88%86%E7%BB%9F%E7%A7%B0%E4%B8%BA%E8%BF%9E%E6%8E%A5) --> 初始化 --> 使用 --> 卸载

2. *主动引用五种必须立即对类进行初始化的情况:*

   1. 遇到new(new实例化对象),getstatic,putstatic(读取/修改类属性,final除外)或invokestatic(调用静态方法)这4条字节码指令时
   2. 使用java.lang.reflect包的方法对类进行反射调用时
   3. 初始化某个类,发现其父类未初始化时(对父类立即初始化)
   4. 虚拟机启动时用户指定的执行主类(包含main()的)
   5. JDK1.7动态语言支持的情况(略)

3. *除上述五种场景外所有的方式都不会触发初始化,称为被动引用:*

   1. 通过子类引用父类的类属性,不会触发子类初始化: 对于静态字段,只有直接定义这个字段的类才会被初始化.通过子类引用父类中定义的类属性,只会触发父类的初始化.
   2. 通过类数组定义来引用类,不会触发此类的初始化(SuperClass[] a=new SuperClass[10]): 类数组是由虚拟机自动生成,直接继承于Object的子类,只会触发`[SuperClass`的初始化.
   3. 使用某一类的常量不会触发该定义类的初始化: 在编译阶段已经将该`定义类`(定义该常量的类)的常量存储到了`调用类`(调用此常量的类)的`常量池`中,以后的每一次引用实际上都转化为`调用类`对自身常量池的引用.
   4. 一个接口在初始化时,并不要求父接口也全初始化,只有真正使用父接口(如引用接口常量)才会初始化.

## 类加载过程

加载、验证、准备、解析、初始化。

*   加载: 根据全限定名来获取定义类的二进制字节流,然后将该字节流所代表的静态结构转化为方法区的运行时数据结构,最后在生成一个代表该类的Class对象,作为方法区这些数据的访问入口.
*   验证:主要时为了确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.包含四个阶段的验证过程:
1. 文件格式验证:保证输入的字节流能够正确地解析并存储在方法区之内,格式上符合描述一个java类型信息的要求
2. 元数据验证:字节码语义信息的验证,以保证描述的信息符合java语言规范.验证点有:这个类是否有父类等.
3. 字节码验证:主要是进行数据流和控制流分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为.
4. 符号引用验证:对符号引用转化为直接引用过程的验证.
*   准备:为类变量分配内存并设置变量的初始值, 这些内存在方法区进行分配.
*   解析:将虚拟机常量池中的符号引用转化为直接引用的过程.解析主要是针对类或接口、字段、类方法、类接口方法四类.
*   初始化:执行静态变量的赋值操作以及静态代码块,完成初识化.初始化过程保证了父类中定义的初始化优先于子类的初始化.但接口不需要执行父类的初始化.

### *加载:*

- 加载过程:

  1. 通过类的权限定名获取类的二进制字节流.
  2. 将这个字节流代表的`静态存储结构`转化为方法区的运行时数据结构.
  3. 在内存中生成代表这个类的Class对象,作为这个类在方法区的各种数据的访问入口.

- 数组类本身不通过类加载器创建,而是由Java虚拟机直接创建的.

  一个数组类的创建遵循以下规则:

  1. 若数组的组件类型是引用类型,则遵循上述加载过程加载这个类型.这个数组将在加载该组件类型的加载器的类名称空间上被标识.
  2. 若数组的组件类型为基本类型,则虚拟机把数组标记为与启动类加载器关联.
  3. 数组可见性与组件类型可见性一致,基本类型默认为public.

- 加载与连接交叉进行(开始时间固定先后).

### *验证:*

目的:确保Class文件的字节流中的信息符合当前虚拟机要求,不会危害虚拟机安全.

- 验证的四个阶段:

  1. 文件格式验证:

  ```
  验证字节流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理:
    a.是否以魔数0xCAFEBABY开头.
    b.主次版本号是否在当前虚拟机处理范围之内.
    c.是否支持常量池中的常量类型(检查常量tag标志).
    d.指向常量的各种索引值是否存在且符合类型.
    e.CONSTANT_Utf8_info型的常量中是否符合UTF8编码.
    f.Class文件中各个部分及文件本身是否有被删除或附加的信息.
    ...
  ```

  1. 元数据验证:

  ```
  对字节码描述的信息进行语义分析,保证其描述的信息符合Java语言规范的要求:
    a.是否有父类(除Object外都须有父类).
    b.是否继承了不允许被继承的类(final).
    c.如果不是抽象类,是否实现了父类或接口中的所有方法.
    d.类中字段,方法是否与父类产生矛盾
    ...
  ```

  1. 字节码验证:

  ```
  通过数据流和控制流分析,确定程序语义是合法符合逻辑的(最复杂的部分):
    a.保证操作数栈的数据类型与指令代码序列都能配合工作.
    b.保证跳转指令不会跳到方法体之外的字节码.
    c.保证方法体中的类型转换是有效的.
    ....
  ```

  1. 符号引用验证:

  ```
  对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验.发生在虚拟机将符号引用转化为直接引用的时候(在解析阶段发生):
    a.符号引用中通过字符串描述的权限定名是否能够找到对应类.
    b.指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段.
    c.符号引用中的类,字段,方法的访问性是否可被当前类访问.
    ...
  ```

  通过-Xverify:none参数可关闭大部分类的验证措施,缩短加载时间.

### *准备:*

正式为类分配内存并设置类变量初始值(数据类型的零值)的阶段,这些变量所使用的内存都将在方法区中进行分配.
这时候进行内存分配的仅包括`类变量`(static修饰的静态变量),而不包括实例变量(实例变量将在对象实例化时随着对象一起分配在Java堆上).

特殊情况: 如果是被final修饰,则一开始就初始化为其指定的值.

### *解析:*

虚拟机将常量池内的符号引用替换为直接引用的过程.

`符号引用`: 以一组符号来描述所引用的目标,符号可以是任何形式的字面量,能无歧义地定位到目标(未必在内存中).(与虚拟机实现的内存布局无关)

`直接引用`: 可以是直接指向目标的指针,相对偏移量或是一个能间接定位到目标的句柄.(和虚拟机实现的内存布局相关)

- 解析动作:
  1. 类或接口解析:
  2. 字段解析
  3. 类方法解析
  4. 接口方法解析 (下面三种与动态语言相关)
  5. 方法类型解析
  6. 方法句柄解析
  7. 调用点限定符解析

### *初始化:*

初始化阶段是根据程序员在程序中制定的主观计划区初始化类变量和其他资源,即执行类构造器()方法的过程.

- <clinit>执行过程的特点和细节:

  1. <clinit>()是由编译器自动收集类中所有`类变量的赋值动作`和`静态语句块(static{})中的语句`合并并而成的. 编译器收集的顺序是由语句在源文件中出现的顺序所决定的 注:静态语句块只能访问到定义静态语句块之前的变量;无法访问在它之后的变量,但却可以赋值.

     ```
      public class Test{
          static{
        	  i = 0;				//赋值语句正常编译通过
        	  System.out.println(i);			//编译器会提示非法向前引用
          }
          static int i = 1;
      }
     ```

  2. 虚拟机会保证在子类<clinit>()方法执行之前,父类的<clinit>()方法已经执行完毕.

  3. 由于父类的<clinit>()先执行,则意味着父类的静态语句块要优先于子类的变量赋值操作.

  4. <clinit>()对于类或接口来说并不是必需的,若没有静态语句块,也没有类变量赋值操作,则可以不生成 <clinit>()方法.

  5. 接口与类不同,执行接口的<clinit>方法不需要先执行父接口的<clinit>()方法.只有使用到父接口中的 类变量时,父接口才会初始化(接口实现类初始化也不会执行接口的<clinit>()方法).

  6. 虚拟机会保证一个类的<clinit>()方法在多线程的情况下能被正确的加锁,同步(如果<clinit>()中有 耗时很长的操作,可能导致多个线程阻塞).



## 类加载器
* 通过一个类的权限定名来获取描述此类的`二进制字节流`.

  1. 类与类加载器:

     `类与加载它的类加载器`一起确立这个类在虚拟机中的唯一性. (来源于同一个class文件的两个类,被同一个虚拟机加载,只要加载的类加载器不同,那这两个类必定不相等)

  2. 双亲委派模型:

     - Java虚拟机的角度存在两种类加载器:

       1. `启动类加载器`Bootstrap ClassLoader(C++实现,虚拟机的一部分).
       2. 其他类加载器(Java语言实现,继承抽象类ClassLoader)

     - 开发人员角度存在四种类加载器:

       1. `启动类加载器`Bootstrap ClassLoader: 加载<JAVA_HOME>\lib目录下,或者被-Xbootclasspath参数指定的路径下的能被虚拟机识别的类库.
       2. `扩展类加载器`Extension CLassLoader: 加载<JAVA_HOME>\lib\ext目录下,或者被java.ext.dirs变量指定的路径下的类库.
       3. `应用程序类加载器`Application ClassLoader(默认类加载器): 一般也称为系统类加载器.加载用户类路径(ClassPath)上所指定的类库.
       4. `自定义类加载器`

     - 双亲委派模型工作流程:

       1. 一个类加载器收到类加载请求,先把请求`委派`给`父类加载器`,因此所有的请求都会传递到顶层的启动类加载器中.
       2. 当父类加载器反馈自己无法完成这个加载请求(它的搜索范围内找不到这个类)时,子加载器才会`尝试自己去加载`.

       - 优点:

         Java类随着类加载器一起具备了一中带有优先级的层次关系.保证了Java类型体系中的基础行为(唯一性).

3. 打破双亲委派模型:  Tomcat 自定义了一套双亲委派模型,当应用使用Spring管理对象时,必然会打破双亲委派模型:  Spring使用线程上下文下载器委托下层加载器加载对象。

为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。 Dubbo的SPI也是采用这种机制实现。



参考：

https://github.com/wususu/Notes/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md

https://blog.csdn.net/ns_code/article/details/17881581



## 双亲委派模型

除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器.顺序依次是:

- Bootstrap ClassLoader: 启动类加载器,加载java_home/lib中的类
- Extension ClassLoader: 扩展类加载器,加载java_home/lib/ext目录下的类库
- Application ClassLoader: 应用程序类加载器,加载用户类路径上指定类库.

双亲委派模型的工作原理是:如果一个类加载器受到了类加载请求,它首先不会自己去尝试加载这个类,而把这个请求委派给父类加载器去完成,每一层次的类加载器都是如此,因此所有的加载请求最终都应该传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成加载请求时,加载器才尝试自己加载.这种方式保证了Oject类(JDK 核心类)在各个加载器加载环境中都是同一个类.


## 双亲委派破坏
https://blog.csdn.net/zhangcanyan/article/details/78993959

双亲委派模型的式作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完全这个加载请求时，子加载器才会尝试自己去加载。

双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前————即 JDK 1.2 发布之前。

JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的。如果基础类又要调用回用户的代码，那该怎么办？

**为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认是应用类加载器。**

双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。

OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（ OSGi 中称为 Bundle） 都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。

在 Java 程序员中基本有一个共识： OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，就可以算是掌握了类加载器的精髓。



## 编译期优化

javac对代码的运行效率几乎没有任何优化措施（JDK1.3之后-O优化参数没有意义了），性能优化主要集中在运行期（后端的即时编译期），javac主要进行了一些针对Java语言编码过程的优化，如语法糖。

### 编译过程

编译过程大概分为3个过程：
![img](https://leibnizhu.gitlab.io/img/jvm/9.png)
javac中的代码是这样的：
![img](https://leibnizhu.gitlab.io/img/jvm/10.png)

1. **解析与填充符号表**过程：首先进行词法、语法分析，将源代码的字符流转换为Token集合，然后根据Token序列构造抽象语法树AST，对应parseFiles()方法；然后填充符号表（记录符号地址和符号信息映射关系），符号表中记录的信息在编译的不同阶段都会用到，对应enterTress()方法；
2. 插入式注解处理器的**注解处理**过程：处理代码中的注解，这个过程中可能影响到语法树的元素，如果影响到了，则要重新回到解析及填充符号表的过程，这样一个循环称作一个Round，直到注解处理器没有对语法树进行修改；
3. **分析与字节码生成**过程：具体又分为**标注检查**（检查变量使用前是否已生命、变量与赋值之间类型是否匹配等问题，以及常量折叠，如”1”+”2”优化为”12”）、**数据及控制流分析**（检查局部变量使用前是否赋值、每条路径是否都有返回值、异常是否都处理了等问题）、**解语法糖**（由desugar()方法完成）、**字节码生成**（收敛生成<clinit>()方法he <init>()方法，将所有生成的信息转换成字节码写入磁盘）等子过程。

### 语法糖

#### 泛型

Java的泛型是伪泛型，只在源码中存在，编译时进行类型擦除变成原生类型（Raw Type），并在调用的地方加上强转类型代码，这是为了兼容旧版本。对于重载方法，如果泛型参数的泛型类型不同而其他参数以及返回类型相同，是不允许重载的，比如以下方法1和方法2不能重载；而如果泛型参数的泛型类型不同，且返回类型不同，则可以重载，比如方法1和方法3（JVM本来就允许）。

```
//方法1和方法2不能重载，方法1和方法3可以重载//方法1public String test(List<Integer>);//方法2public String test(List<String>);//方法3public int test(List<String>);
```

#### 自动装箱/拆箱、遍历循环、变长参数

遍历循环（增强for）的实现是编译时还原为迭代其的实现，因此需要实现Iterable接口。

#### 条件编译

java的条件编译通过条件为常量的if语句实现。如下面代码中，编译后的字节码不会包含调用B()方法的指令。

```
if(true){    A();} else {    B();}
```

## 运行期优化

### 解释器与编译器

许多主流商用JVM包括HotSpot采用解释器与编译器并存的结构，启动的时候使用解释器，保证启动速度，随着运行时间推移，编译器发挥作用，编译为本地代码，提高执行效率。在JVM中这种模式被称为混合模式，可以用`-Xint`强制JVM运行于解释模式，或用`-Xcomp`强制JVM运行于编译模式。HotSpot包含两个及时编译器Client Compiler和Server Compiler，一般简称为C1和C2。

### 热点探测

运行过程中被即时编译器编译的**热点代码**包括被多次调用的**方法**或#**循环体**，对于后者编译器还是会以整个方法作为编译对象。
判断方法或循环体是否热点代码的行为被称为**热点探测**，目前主要的热点探测方法有两种：

1. **基于采样的热点探测**。JVM周期性的检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那么就是热点方法。缺点是容易收到线程阻塞或其他外界因素影响，优点是简单高效；
2. **基于计数器的热点探测**。为每个方法甚至代码块建立计数器，统计执行次数，超过一定阈值就认为是热点方法。缺点是不能获取导方法的调用关系，优点是精确且严谨。

HotSpot使用第二种，准备了**方法调用计数器**和**回边计数器**。前者统计方法被调用的次数，默认的阈值：Client模式1500次，Server模式10000次，可以通过`-XX:CompileThreshold`来设定；后者统计循环体被执行的次数，字节码遇到控制流向后跳转的指令称为回边(Back Edge)，通过`-XX:BackEdgeThreshold`来手动设置阈值。
对于方法调用计数器，一个方法执行时先判断存不存在JIT编译过的版本，存在的话执行编译后版本，不存在的话计数器加一，再判断是否超过阈值，超过的话向即时编译器提交编译申请。其统计的并不是方法被调用的绝对次数，而是一段时间内的调用次数，如果超过一定时间计数器仍不足阈值，则计数值会减少一半，这被成为**热度衰减**(Counter Decay)，这段时间被称为半衰期。热度衰减的动作时在GC时顺便进行的。
回边计数器没有计数热度衰减的过程，记录循环体被调用的绝对次数。
默认配置下，编译是在后台的编译线程进行的，除非用`-XX:-BackgroundCompilation`来禁止后台编译，这样提交编译请求的线程会一直等待编译完成。

### 编译优化技术

JVM几乎所有的优化措施都集中在及时编译器中。

#### 方法内联

方法内联（Method Inlining）指的是将调用的方法代码替换掉调用者的调用语句。目的：

1. 取出调用方法的成本，如建立栈帧；
2. 为其他优化建立良好基础，比如内联可以发现更多的无用代码。

考虑到多态，方法内联的实现并不简单，在编译器无法得出调用的方法是哪个版本的结论（父类还是子类），需要在运行期确定。
JVM引入了类型继承关系分析（Class Hierarchy Analysis，CHA）技术，用于确定目前加载的类中某个接口是否有多于一种的实现、某类是否存在子类、子类是否抽象等信息。进行内联时：

1. 如果目标方法是非虚方法（私有方法、实力构造器、父类方法、静态方法等），那么直接进行内联；
2. 对于虚方法，向CHA查询该方法是否有多个版本可选，如果只有一个版本，则直接进行内联，此时属于激进优化，需要预留逃生门（守护内联），此后如果JVM没有加载到改变方法接受者的继承关系的类，则可以继续使用内联优化的版本，否则抛弃已编译的代码、退回到解释状态进行或重新编译；
3. 如果虚方法有多个版本，则尝试内联缓存（Inline Cache）。发生方法调用前，内联缓存状态为空；第一次调用后，缓存记录下方法接受者的版本信息，每次进行方法调用的时候都比较接受者版本，如果方法接受者版本一样，则继续调用内联缓存进行内联，否则取消内联。

#### 冗余访问消除

冗余访问消除（Redundant Loads Elimination）指的是如果能保证一个方法的两次调用之间的代码不会引起其返回值的更改，那么这第二次调用的结果可以直接用第一次调用结果去赋值，比如一下代码：

```
public void foo1(){    y=b.value;    //其他调用，不会影响b.value的返回值    z=b.value();}
```

以上代码可以优化为：

```
public void foo1(){    y=b.value;    //其他调用，不会影响b.value的返回值    z=y;}
```

#### 复写传播

复写传播（Copy Propagation）指的是去掉重复的变量。

#### 无用代码消除

无用代码消除（Dead Code Elimination），无用代码指的是永远不会izhixing的代码，或者完全没有意义的代码。

#### 公共子表达式消除

Common Subexpression Elimination定义：一个表达式E已经计算过，且计算后到现在E的变量全部没有变化，那么E这次出现成为了公共子表达式，无需重复计算，直接用前面计算结果替换即可。如果消除优化仅限于程序基本块内，则成为局部公共子表达式消除，如果覆盖范围涵盖多个基本块，则成为全局公共子表达式消除。

#### 数组边界检查消除

Java访问数组元素时，会对下标进行上下界范围检查，不满足上下界时会抛出ArrayIndexOutOfBoundsException异常。
编译器根据数据流分析确定数组长度，并判断小表有无月结；在循环中进行数组访问时，也是可以通过数据流分析判定循环变量的取值是否越界，如果能保证循环体中不越界的话循环体中访问数组的语句可以消除边界检查。
还有一种思路时隐式异常处理，将空指针检查和除数为零检查消除，注册一个Segment Fault信号的异常处理器，放在异常处理里面，在这个异常处理器里面再转换为对应的异常并抛出。
还有一些其他的消除操作，比如自动装箱消除、安全点消除、消除反射等等。

#### 逃逸分析

逃逸分析不能直接优化代码，而是为其他优化手段提供优化的依据。逃逸分析指的是分析对象动态作用域：一个对象在方法中被定义后，被外部方法引用，则称为**方法逃逸**，被外部线程引用访问到的话，被称为**线程逃逸**。如果能证明一个对象不会逃逸到方法或线程外，则可以进行以下优化：

1. **栈上分配**（Stack Allocation）：若确认对象没有方法逃逸，可以将其在栈上分配内存，则其占用内存会随着栈帧出栈而被销毁，减少GC压力，而一般应用中不逃逸的局部对象占很大比例；
2. **同步消除**（Synchronization Elimination）：若确认对象没有线程逃逸，可以对该变量实时的同步措施消除；
3. **标量替换**（Scalar Replacement）：**标量**指一个数据无法再分解为更小的数据来表示，如基础数据类型，反之称之为**聚合量**（Aggregate），如对象。若确认一个对象没有逃逸，则可以不创建对象，改为直接创建它会被使用到的成员变量来代替，同时可以保存在栈上，提高读写效率，并为进一步优化创造条件。



参考：https://leibnizhu.gitlab.io/2017/06/09/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/index.html



## 类变量初始化顺序

> 父类静态属性/父类静态代码块->子类静态代码块/子类静态属性->父类普通属性->父类构造方法->子类普通属性->子类构造方法

https://blog.csdn.net/jianggujin/article/details/52228983



## 多态原理