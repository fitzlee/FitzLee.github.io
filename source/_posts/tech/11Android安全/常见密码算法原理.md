---
title: 常见密码算法原理
urlname: android_security_crypto_algo
date: 2017-08-06
comments: true
#description: 
#tags: [git,hah,hha]
#keywords: git
categories: 11Android_Security
tags:
    - 密码算法
    - 安全
---

## PBKDF2是什么？
PBKDF2(Password-Based Key Derivation Function)是一个用来导出密钥的函数，用来生成加密的密码，增加破解的难度，类似bcrypt/scrypt等，可以用来进行密码或者口令的加密存储。主要是盐值+pwd，经过多轮HMAC算法的计算，产生的密文。
PBKDF2函数的定义
DK = PBKDF2(PRF, Password, Salt, c, dkLen)
• PRF是一个伪随机函数，例如HASH_HMAC函数，它会输出长度为hLen的结果。
• Password是用来生成密钥的原文密码。
• Salt是一个加密用的盐值。
• c是进行重复计算的次数。
• dkLen是期望得到的密钥的长度。
• DK是最后产生的密钥。
https://segmentfault.com/a/1190000004261009

## DH和ECDH算法
下面我们以Alice和Bob为例叙述Diffie-Hellman密钥交换的原理。
1,Diffie-Hellman交换过程中涉及到的所有参与者定义一个组，在这个组中定义一个大质数p，底数g。
2,Diffie-Hellman密钥交换是一个两部分的过程，Alice和Bob都需要一个私有的数字a，b。
下面是DH交换的过程图：
本图片来自wiki
下面我们进行一个实例
1.爱丽丝与鲍伯协定使用p=23以及g=5.
2.爱丽丝选择一个秘密整数a=6, 计算A = g^a mod p并发送给鲍伯。 
   A = 5^6 mod 23 = 8.
3.鲍伯选择一个秘密整数b=15, 计算B = g^b mod p并发送给爱丽丝。 
   B = 5^15 mod 23 = 19.
4.爱丽丝计算s = B a mod p 
  19^6 mod 23 = 2.
5.鲍伯计算s = A b mod p 
   8^15 mod 23 = 2.
 
### ECDH密钥交换：
ECDH:
       ECC算法和DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥。ECC是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点P，一个整数k，求解Q=kP很容易；给定一个点P、Q，知道Q=kP，求整数k确是一个难题。ECDH即建立在此数学难题之上。密钥磋商过程：
假设密钥交换双方为Alice、Bob，其有共享曲线参数（椭圆曲线E、阶N、基点G）。
1) Alice生成随机整数a，计算A=a*G。 #生成Alice公钥
2) Bob生成随机整数b，计算B=b*G。 #生产Bob公钥
3) Alice将A传递给Bob。A的传递可以公开，即攻击者可以获取A。
    由于椭圆曲线的离散对数问题是难题，所以攻击者不可以通过A、G计算出a。
4) Bob将B传递给Alice。同理，B的传递可以公开。
5) Bob收到Alice传递的A，计算Q =b*A  #Bob通过自己的私钥和Alice的公钥得到对称密钥Q
6) Alice收到Bob传递的B，计算Q`=a*B  #Alice通过自己的私钥和Bob的公钥得到对称密钥Q'
Alice、Bob双方即得Q=b*A=b*(a*G)=(b*a)*G=(a*b)*G=a*(b*G)=a*B=Q' (交换律和结合律)，即双方得到一致的密钥Q。
        目前Openssl里面的ECC算法的套件支持是ECDSA/ECDH。在国密的SSL套件中，可以使用ECDSA/ECC(密钥加密传输)，ECDSA/ECDH(密钥磋商)两种套件

来自 <http://www.cnblogs.com/fishou/p/4206451.html> 

## SHA家族的对比
https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F

## RSA算法的理解
> I saw different key sizes for RSA algorithm (512, 1024,... [bits] for example) but, is this the length of public key or the length of private key or both are equal in length?
It's the length of the modulus used to compute the RSA key pair. The public key is made of the modulus and the public exponent, while the private key is made of the modulus and the private exponent.
> but the online tools for generating RSA key pairs have different lengths output!
The first picture shows public and private key in PEM format, encoded in Base64 (and not modulus and exponents of the key, which instead are shown in the second picture).
The content of the RSA private key is as follows:
-----BEGIN RSA PRIVATE KEY-----
RSAPrivateKey ::= SEQUENCE {
  version           Version,
  modulus           INTEGER,  -- n
  publicExponent    INTEGER,  -- e
  privateExponent   INTEGER,  -- d
  prime1            INTEGER,  -- p
  prime2            INTEGER,  -- q
  exponent1         INTEGER,  -- d mod (p-1)
  exponent2         INTEGER,  -- d mod (q-1)
  coefficient       INTEGER,  -- (inverse of q) mod p
  otherPrimeInfos   OtherPrimeInfos OPTIONAL
}
-----END RSA PRIVATE KEY-----
while a RSA public key contains only the following data:
-----BEGIN RSA PUBLIC KEY-----
RSAPublicKey ::= SEQUENCE {
    modulus           INTEGER,  -- n
    publicExponent    INTEGER   -- e
}
-----END RSA PUBLIC KEY-----
and this explains why the private key block is larger.
Note that a more standard format for non-RSA public keys is
-----BEGIN PUBLIC KEY-----
PublicKeyInfo ::= SEQUENCE {
  algorithm       AlgorithmIdentifier,
  PublicKey       BIT STRING
}
AlgorithmIdentifier ::= SEQUENCE {
  algorithm       OBJECT IDENTIFIER,
  parameters      ANY DEFINED BY algorithm OPTIONAL
}
-----END PUBLIC KEY-----
More info here.
BTW, since you just posted a screenshot of the private key I strongly hope it was just for tests :)

密钥的长度
C:\herong>java RsaKeyGenerator 128
p: 17902136406704537069
q: 17902136406704537077
m: 320486487924256034368552058949822333168
Modulus: 320486487924256034404356331763231407313
Key size: 128
Public key: 138184930940463531660820083778072069237
Private key: 173448309040289888328993883042709949325
C:\herong>java RsaKeyGenerator 256
p: 248658744261550238073459677814507557459
q: 248658744261550238073459677814507557527
m: 618311710977310434529034534762836648859088873902738200302650613...
Modulus: 618311710977310434529034534762836648864062048787969205064...
Key size: 256
Public key: 394190853336940694532345943348534965939075733405768734...
Private key: 21429568381701961014089098585280129682302896350728470...


https://security.stackexchange.com/questions/90169/rsa-public-key-and-private-key-lengths
https://stackoverflow.com/questions/2921508/trying-to-understand-java-rsa-key-size>

http://www.herongyang.com/Cryptography/RSA-BigInteger-Keys-Generated-by-RsaKeyGenerator-java.html

### update和doFinal
update() adds data to the Cipher’s internal buffer, then returns all currently completely encoded blocks. If there are any encoded blocks left over, they remain in the Cipher’s buffer until the next call, or a call to doFinal(). This means that if you call update() with a four byte array to encrypt, and the buffer size is eight bytes, you will not receive encoded data on the return (you’ll get a null instead). If your next call to update() passes five bytes of data in, you will get an 8 byte (the block size) array back, containing the four bytes passed in on the previous call, the first four bytes from the current call – the remaining byte from the current call is left in the Cipher’s buffer.
doFinal() on the other hand is much simpler: it encrypts the passed data, pads it out to the necessary length, and then returns it. The Cipher is essentially stateless.

来自 <https://segmentfault.com/a/1190000006931511> 

DH算法的中间人攻击
在最初的描述中，迪菲－赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，因此它很容易受到中间人攻击。 一个中间人在信道的中央进行两次迪菲－赫尔曼密钥交换，一次和Alice另一次和Bob，就能够成功的向Alice假装自己是Bob，反之亦然。而攻击者可以解密（读取和存储）任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。

优缺点：
1、 仅当需要时才生成密钥，减小了将密钥存储很长一段时间而致使遭受攻击的机会。
2、 除对全局参数的约定外，密钥交换不需要事先存在的基础结构。
然而，该技术也存在许多不足：
1、 没有提供双方身份的任何信息。
2、 它是计算密集性的，因此容易遭受阻塞性攻击，即对手请求大量的密钥。受攻击者花费了相对多的计算资源来求解无用的幂系数而不是在做真正的工作。
3、 没办法防止重演攻击。
4、 容易遭受中间人的攻击。第三方C在和A通信时扮演B；和B通信时扮演A。A和B都与C协商了一个密钥，然后C就可以监听和传递通信量。中间人的攻击按如下进行：
（1） B在给A的报文中发送他的公开密钥。
（2） C截获并解析该报文。C将B的公开密钥保存下来并给A发送报文，该报文具有B的用户ID但使用C的公开密钥YC，仍按照好像是来自B的样子被发送出去。A收到C的报文后，将YC和B的用户ID存储在一块。类似地，C使用YC向B发送好像来自A的报文。
（3） B基于私有密钥XB和YC计算秘密密钥K1。A基于私有密钥XA和YC计算秘密密钥K2。C使用私有密钥XC和YB计算K1，并使用XC和YA计算K2。
（4） 从现在开始，C就可以转发A发给B的报文或转发B发给A的报文，在途中根据需要修改它们的密文。使得A和B都不知道他们在和C共享通信。

