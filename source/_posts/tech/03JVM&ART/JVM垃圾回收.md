---
title: JVM垃圾回收
urlname: jvm_art_java_gc
date: 2016-12-17
comments: true
#description: 
#tags: [git,hah,hha]
#keywords: git
categories: 03JVM&ART
tags:
    - java
    - 垃圾回收
---

### GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？
*   标记清理：首先标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记的对象。缺点是效率低，且存在内存碎片。主要用于老生代垃圾回收。
*   标记整理：首先标记所有需要回收的对象，在标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。用于老年代。
*   复制算法：将内存按容量划分为大小相等的一块，每次只用其中一块。当内存用完了，将还存活的对象复制到另一块内存，然后把已使用过的内存空间一次清理掉。实现简单，高效。一般用于新生代。一般是将内存分为一块较大的Eden空间和两块较小的Survivor空间。HotSpot虚拟机默认比例是8:1,。每次使用Eden和一块Survivor，当回收时将这两块内存中还存活的对象复制到Survivor然后清理掉刚才Eden和Survivor的空间。如果复制过程内存不够使用则向老年代分配担保。
*   分代收集算法：根据对象的生存周期将内存划分为新生代和老年代，根据年代的特点采用最适当的收集算法。

### GC收集器有哪些？CMS收集器与G1收集器的特点。

*   Serial: 单线程收集器，只会使用一个CPU或一条收集器线程去完成，垃圾回收工作，更重要的是在进行垃圾回收时，必须暂停其他所有的工作线程。（Stop the world）。简单高效，用于新生代。
*   ParNew: 是Serial收集器的多线程版本，垃圾回收时采用多线程方式进行回收。默认情况下使用的线程数是cpu数量。除了serial收集器，目前只有它能和CMS收集器配合工作。是server模式下首选的新生代收集器。
*   Parallel Scavenge: 使用复制算法收集器，也是一个并行的多线程收集器。Parallel Scavenge收集器与其他收集器关注点不同，其它收集器主要关注缩短垃圾回收时用户线程的停顿时间。而它关心吞吐量，即运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)。停顿时间越短越适合需要与用户交互的程序，高吞吐量则可以最高效率的利用CPU时间。
*   Serial Old: 老年代，单线程收集器，使用标记整理算法。主要有两个用途，一是和Parallel Scavenge 收集器配合使用，二是作为CMS的后备方案在并发收集器发生Concurrent Mode Failure时候使用。
*   Parallel Old:并行的老年代版本收集器，使用标记整理算法。主要与Parallel Scavenge配合使用。
*   CMS：是以获得最短回收停顿时间为目标的收集器，使用标记清除算法。整个过程包括4个：
1. 初始标记: 标记Gc ROOTS能直接关联到的对象
2. 并发标记：进行Roots Traceing的过程
1. 重新标记：修正并发标记期间因用户继续工作导致标记产生变动
1. 并发清除：并发清除数据。 初始标记和重新标记需要stop the world. 并发标记和并发清除过程用户线程和收集器线程可以并行执行。
*   G1(Garbage First): 基于标记-整理算法的收集器,不会产生空间碎片.它可以精确控制停顿,能够让使用者明确指定一个长度为M毫秒的时间片段内,消耗集上的时间不超过N秒.是不牺牲吞吐量的前提下完成低停顿的.G1将整个java堆(新生和老生)划分为大小相同的区,并跟踪这些区上发生的变化.在后台维护一个优先列表,每次根据允许的收集时间优先回收垃圾最多的区域.

现在公司中很多都采用了G1 垃圾回收期，建议大家多深入了解下G1，更多参考: [G1垃圾回收器](https://github.com/zhengjianglong915/note-of-interview/blob/master/java/G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.md)


### GC的两种判定方法：引用计数与根搜索算法

*   引用计数： 给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1，当引用失效时，计数器值减1,。任何时候计数器都为0的对象就是不可能再被使用的。它很难解决对象之间相互循环引用问题。
*   根搜索算法（GC Roots Traceing）: 通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。

### GC Roots对象一般是：
虚拟机栈中的引用对象，方法区中类静态属性引用的对象，方法区常量引用的对象等。

## Java中的四种引用

Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。

*   强引用：程序代码中的普通引用。如Object obj = new Object(),只要强引用存在，垃圾回收器就不会回收。在不使用对象时应及时将引用设置为null，便于垃圾回收。
*   软引用：描述一些有用但并非必须的对象。对于软引用关联的对象在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。SoftRefence
*   弱引用：描述非必须对象，比软引用弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakRefence
*   虚引用：最弱的引用，不管是否有虚引用存在，完全不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的是希望能够在这个对象被垃圾回收器之前收到系统通知。PhantomReference

相关参考：[Java 如何有效地避免OOM：善于利用软引用和弱引用](https://www.cnblogs.com/dolphin0520/p/3784171.html)


### OOM你遇到过哪些情况
*   java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。
*   java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。
*   java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数**-Xss**来设置栈的大小。

