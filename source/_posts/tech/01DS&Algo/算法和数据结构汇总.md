---
title: 算法与数据结构详解
urlname: ds_algo_details
date: 2016-05-06
comments: true
#description: 
#tags: [git,hah,hha]
#keywords: git
categories: 01Ds&Algorithms
tags:
    - 算法
    - 数据结构
    - 书籍推荐
---


数据结构和算法
以weiss的数据结构和算法，以及算法导论为纲，另外参考July和左程云的书籍和代码。

https://github.com/julycoding/The-Art-Of-Programming-By-July

## 数据结构
 
### 数组

### 链表
http://www.cnblogs.com/wangyingli/p/5928258.html
http://www.cnblogs.com/flash610/archive/2013/05/14/3078251.html
https://blog.csdn.net/u010275850/article/details/46011951
https://blog.csdn.net/ajian005/article/details/53196224
https://blog.csdn.net/judyge/article/details/42396079
可分为：单链表，双向链表，双端链表，循环链表。
双向和双端区别：https://blog.csdn.net/qq_29606255/article/details/76408285

数据结构 |	实现方式
---|---
栈 | 数组/单链表
队列 |	数组/双端链表
优先级队列 |	数组/堆/有序链表
双端队列 |	双向链表

### 栈Stack、队列Queue
栈比较简单：Stack，LinkedList等
队列几种特殊的：
https://blog.csdn.net/beautiful_face/article/details/76693412
https://blog.csdn.net/u011983531/article/details/78651466
https://www.cnblogs.com/lemon-flm/p/7877898.html
Queue的实现
1. 没有实现的阻塞接口的LinkedList： 实现了java.util.Queue接口和java.util.AbstractQueue接口
　　内置的不阻塞队列： PriorityQueue 和 ConcurrentLinkedQueue
　　PriorityQueue 和 ConcurrentLinkedQueue 类在 Collection Framework 中加入两个具体集合实现。 
　　PriorityQueue 类实质上维护了一个有序列表。加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable 实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。
　　ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大 小，　　　　    　　ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。

2. 实现阻塞接口的：
　　java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。
五个队列所提供的各有不同：
　　* ArrayBlockingQueue ：一个由数组支持的有界队列。
　　* LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。
　　* PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。
　　* DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。
　　* SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。

### 优先队列(堆)
https://www.cnblogs.com/wuchanming/p/3809496.html
可分为：二叉堆，d-堆，左式堆，斜堆，二项队列

### 跳表
https://www.cnblogs.com/a8457013/p/8251967.html


### 树

树的分类
https://zh.wikipedia.org/wiki/AVL%E6%A0%91
```
- 二叉树	
**二叉查找树（BST）** 笛卡尔树 MVP树 Top tree T树
- 自平衡二叉查找树	
AA树 **AVL树** 左倾红黑树 **红黑树** 替罪羊树 **伸展树** 树堆 加权平衡树
- B树	
**B+树** B*树 Bx树 UB树 2-3树 2-3-4树 (a,b)-树 Dancing tree H树
- 堆	
**二叉堆** 二项堆 斐波那契堆 左偏树 配对堆 斜堆 Van Emde Boas tree
- Trie	
**后缀树** 基数树 三叉查找树 X-快速前缀树 Y-快速前缀树
```
以上标黑的为重点关注项
AVL树：https://zh.wikipedia.org/wiki/AVL%E6%A0%91
伸展树Splay:
Treap树：
SBTree树
RBTree树
B树
R树
区间树
二叉堆
Trie树


### 图
**图的分类**
http://www.cnblogs.com/wangyingli/p/5974508.html
https://blog.csdn.net/xujingzhou/article/details/79874835

**图算法**
https://blog.csdn.net/simanstar/article/details/78906825
https://blog.csdn.net/wsh6759/article/details/7008407
https://blog.csdn.net/gqtcgq/article/details/45618279


最短路径的Floyd算法
拓扑排序
union-find算法
无环加权有向图的最短路径算法
关键路径
计算无向图中连通分量的Kosaraju算法
有向图中含必经点的最短路径问题
TSP问题
还有A*算法


### 散列

## 算法

### 查找算法
http://www.cnblogs.com/wangyingli/p/5994282.html

### 排序算法
http://www.cnblogs.com/wangyingli/p/5994256.html

### 分治算法

### 贪心算法

### 动态规划

### 回溯算法

### 随机化算法


## 方案设计


1.分治法：

   将问题分成单独的阶段，每个阶段互相不干扰很独立，如10米长的木棍，切成10段，每段去解决每一段的问题。（阶段没有关系）

2.贪心法

    站在全局的角度，也是将问题堪称分为多个阶段，只不过阶段和阶段之间有一定的递进关系，如从5毛，1元，2毛，1毛，2元中，去找最少的钱币构成10块钱。首先是站在全局的角度，先从中取其最大值，为第一阶段，然后在从剩余的当中在找最大值，构成第二阶段。。。。。。如此往复，这就是贪心法。

3.动态规划

    是阶段和阶段之间有重复，举例说明：求一个数组的最长递增子序列。假设数组有10个元素，那么如何求解呢？将10个元素划分成10个阶段，第一个阶段，从第一个元素中求解，第二个阶段在第一个阶段求其解，第三个阶段在第一个，第二个阶段综合的基础上求解，第四个阶段在第1,2,3个阶段求其解，最后。。。。第k个阶段在第1,2....k-1个阶段求其最优解。

4.递归算法

    个人感觉和动态规划反着来的样子，有点像，问题规模为10，转化为问题规模为9的问题，，问题规模为9的问题，转化为8.。。。。。

5.回溯法和分支限界法

  都属于组合优化问题，就是按照过程向下面去寻找最优解，在寻找最优解的过程，不断的剪取枝条，来减少搜索情况。不行就换思路。


  递推，搜索，贪心和动态规划的思想都是通过拆分问题，定义状态和状态之间的关系，从而最初阶段的状态到达最终状态的方式解决问题。

每个阶段只有一个状态－>递推

每个阶段的所有状态都计算出来，从中选取最优的－>搜索

每个阶段的最优状态都是由上一个阶段的最优状态得到的－>贪心

每个阶段的最优状态可以从之前的某个阶段的某个（或某些）状态直接得到－>动态规划

一个问题会有多种状态的定义和阶段的划分，某一种定义有后效性不代表该问题不适合用哪种方法。

贪心，动归这类的问题本质都是对搜索的剪枝

适用于哪种方法来解决，在于你怎么看待这个世界～

https://segmentfault.com/a/1190000006022019#articleHeader11