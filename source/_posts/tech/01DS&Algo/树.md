---
title: 树
urlname: ds_algo_tree
date: 2016-05-10
comments: true
#description: 
#tags: [git,hah,hha]
#keywords: git
categories: 01Ds&Algorithms
tags:
    - 数据结构
    - 树
---

AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？
https://www.zhihu.com/question/30527705

从B树、B+树、B*树谈到R 树
http://blog.csdn.net/v_JULY_v/article/details/6530142/

B树、B-树、B+树、B*树 定义
https://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html


## AVL树：
https://zh.wikipedia.org/wiki/AVL%E6%A0%91
**特点**
在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的o(n)复杂度。
**旋转**
以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。
![image.png](https://upload-images.jianshu.io/upload_images/11010834-1f978dff9019b5bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**点数计算**
![image.png](https://upload-images.jianshu.io/upload_images/11010834-88fcc40b33371628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##伸展树Splay：
https://blog.csdn.net/u014634338/article/details/49586689
http://www.cnblogs.com/skywang12345/p/3604286.html
https://www.cnblogs.com/kuangbin/archive/2012/10/07/2714068.html
**背景和特点**
考虑到局部性原理（刚被访问的内容下次可能仍会被访问，查找次数多的内容可能下一次会被访问），为了使整个查找时间更小，被查频率高的那些节点应当经常处于靠近树根的位置。这样，很容易得想到以下这个方案：每次查找节点之后对树进行重构，把被查找的节点搬移到树根，这种自调整形式的二叉查找树就是伸展树。每次对伸展树进行操作后，它均会通过旋转的方法把被访问节点旋转到树根的位置。
特点是不会保证树一直是平衡的，被访问节点旋转到树根，我们通常将节点自底向上旋转，直至该节点成为树根为止。“旋转”的巧妙之处就是在不打乱数列中数据大小关系（指中序遍历结果是全序的）情况下，所有基本操作的平摊复杂度仍为O（log n）

**旋转思路参考**
https://blog.csdn.net/u014634338/article/details/49586689

**效率对比**
伸展树(splay tree)，它对于m次连续搜索操作有很好的效率。伸展树会在一次搜索后，对树进行一些特殊的操作。这些操作的理念与AVL树有些类似，即通过旋转，来改变树节点的分布，并减小树的深度。但伸展树并没有AVL的平衡要求，任意节点的左右子树可以相差任意深度。与二叉搜索树类似，伸展树的单次搜索也可能需要n次操作。但伸展树可以保证，m次的连续搜索操作的复杂度为mlog(n)的量级，而不是mn量级。
https://www.cnblogs.com/wxgblogs/p/5506234.html

1. 优势
**可靠的性能**——它的平均效率不输于其他[平衡树]
**存储所需的内存少**——伸展树无需记录额外的什么值来维护树的信息，相对于其他平衡树，内存占用要小。
由于Splay Tree仅仅是不断调整，并没有引入额外的标记，因而树结构与标准红黑树没有任何不同，从空间角度来看，它比[Treap](https://baike.baidu.com/item/Treap)、[SBT](https://baike.baidu.com/item/SBT)、AVL要高效得多。因为结构不变，因此只要是通过左旋和右旋进行的操作对Splay Tree性质都没有丝毫影响，因而它也提供了BST中最丰富的功能，包括快速的拆分和合并，并且实现极为便捷。这一点是其它结构较难实现的。其时间效率也相当稳定，和Treap基本相当，常数较高。
2. 缺点
伸展树最显著的缺点是它有可能会变成一条。这种情况可能发生在以非降顺序访问n个元素之后。然而均摊的最坏情况是对数级的——O(log*n*)


## treap树
https://blog.csdn.net/chen_tr/article/details/50924073
https://blog.csdn.net/u014634338/article/details/49612159
https://blog.csdn.net/yang_yulei/article/details/46005845
**特点和背景**
Treap，顾名思义就是Tree+Heap。这么命名的原因就是它使用了二叉堆的性质来保持二叉树的平衡。 
我们知道，一个二叉（大根）堆满足这样的性质：一个节点的两个儿子的值都小于节点本身的值。如果一个二叉查找树满足这样的性质，那么它就被称作Treap。 Treap并不是二叉堆，二叉堆必须是完全二叉树，而Treap可以并不一定是。
但是等等，这样的设定似乎和二叉查找树矛盾啊。一个要求节点值小于右儿子的值，一个要求节点值大于右儿子的值，这显然是不可能做到的。 
只有一种方法能够解决，就是让每个节点有2个值，其中一个满足二叉查找树的性质，一个满足大根堆的性质。为方便起见，下面把满足二叉查找树性质的值称作key，把满足大根堆性质的值称作prio（priority的简称）。 
每个节点的key我们是无法改变了，为了保证Treap的平衡性，我们需要在prio上做一点文章。其实也没有什么复杂的，就是让每个节点的prio都取一个随机值，这样我们就可以保证这棵树“基本平衡”。

**旋转**
分类：左旋转和右旋转
方法：一般先按照二叉查找方法，找到对应节点的位置，随机选取一个prio值，如果此时不满足堆得特性，那么就进行旋转

## SBTree树
http://www.cnblogs.com/gtarcoder/p/4724288.html
https://blog.csdn.net/murmured/article/details/17029131
https://www.cnblogs.com/zgmf_x20a/archive/2008/11/14/1333205.html

**特点**
  Size Balanced Tree(SBT)是目前速度最快的平衡二叉搜索树，且能够进行多种搜索操作，区间操作；和AVL、红黑树、伸展树、Treap类似，SBT也是通过对节点的旋转来维持树的平衡，而相比其他平衡树，SBT维持平衡所需要的额外数据很少，只需要维持以当前节点为根的子树的大小；且SBT的编写复杂度低。因此具有空间优势、速度优势、编写优势。



## RBTree 红黑树
http://www.cnblogs.com/Lynn-Zhang/p/5653943.html
https://tech.meituan.com/redblack-tree.html
https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md
http://www.cnblogs.com/skywang12345/p/3245399.html

**特点**
黑树的查找、插入、删除的时间复杂度最坏为O(log n)
```
1）每个结点要么是红的，要么是黑的。  
2）根结点是黑的。  
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。  
```
![image.png](https://upload-images.jianshu.io/upload_images/11010834-89eea2b464178aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**旋转和着色变换**
基本操作是左旋转和右旋转。
http://www.cnblogs.com/Lynn-Zhang/p/5653943.html

**算法复杂度证明**
1. 证明：一棵有 n 个内部节点的红黑树的高度至多为 2lg(n+1)
2. 最长路径至多是最短路径的两倍
3. 内部节点最多，内部节点最少

参考：https://blog.csdn.net/lanchunhui/article/details/75905478


## B+树 R树
AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？
https://www.zhihu.com/question/30527705
从B树、B+树、B*树谈到R 树
http://blog.csdn.net/v_JULY_v/article/details/6530142/
B树、B-树、B+树、B*树 定义
https://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html

## 区间树

## 二叉堆
大根堆，小根堆

## Trie树
前缀树，后缀树
