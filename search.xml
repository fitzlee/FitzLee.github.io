<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jvm 内存结构]]></title>
    <url>%2Fposts%2Fjvm_art_mem_analysis.html</url>
    <content type="text"><![CDATA[JVM虚拟机内存结构-运行数据区域线程私有：栈区，本地方法栈，pc指针线程共有：方法区，堆区 程序计数器 当前线程所执行的字节码的行号指示器。 Java虚拟机栈 线程私有，与线程具有相同生命周期。用于存储局部变量表、操作数栈、动态链表、方法出口等信息。 局部变量表存放内容： 基本数据类型（boolean、byte、char、short、int、float、long、double） 对象引用（区别于符号引用，符号引用存放在常量池） returnAddress类型（指向一条字节码指令的地址） 64位长度的long和double类型数据占用2个局部变量空间（slot），其余占用1个slot。 两种异常： StackOverflowError：线程请求的栈深度&gt;虚拟机允许的深度 OutOfMemoryError: 动态扩展时无法申请到足够内存 本地方法栈（Native Method Stack） 与虚拟机栈类似，区别是Native Method Stack服务于Native方法，而虚拟机栈服务于Java方法。 Java堆（Java Heap） 所有线程共享，存放对象实例、数组。 垃圾收集器管理的主要区域，也称“GC堆（Garbage Collected Heap）” 包含新生代（Eden空间、From Survivor空间、To Survivor空间）、老生代。 可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。 物理上可以不连续，逻辑上连续。 可扩展：-Xmx和-Xms控制。-Xmx最大堆内存大小，-Xms初始堆内存大小。 当堆中没有可用内存完成实例分配，并且也无法再扩展时——OutOfMemoryError 方法区（别名Non-Heap） 也是所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 也称“永久代（Permanent Generation）”，但本质上并不等价。 永久代有-XX:MaxPermSize的上限。 运行时常量池（Runtime Constant Pool） 属于方法区的一部分。 直接内存（Direct Memory） JDK1.4新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可使用Native函数库直接分配堆外内存。不受Java堆大小（-Xmx）限制，从而可能造成各个内存区域总和大于物理内存限制而造成动态扩展时出现OutOfMemoryError。 小结： 1、2、3三种内存区域是各个线程私有的 4、5是所有线程共有的 6是5的一部分 7不是虚拟机运行时数据区的一部分，属于虚拟机的内存区域外的其他物理内存 Java内存结构 1.PC寄存器/程序计数器： 严格来说是一个数据结构，用于保存当前正在执行的程序的内存地址，由于Java是支持多线程执行的，所以程序执行的轨迹不可能一直都是线性执行。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存,这在某种程度上有点类似于“ThreadLocal”，是线程安全的。 2.Java栈 Java Stack： Java栈总是与线程关联在一起的，每当创建一个线程，JVM就会为该线程创建对应的Java栈，在这个Java栈中又会包含多个栈帧(Stack Frame)，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向该地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧被创建，这个新创建的栈帧被放到Java栈的栈顶，变为当前的活动栈。同样现在只有这个栈的本地变量才能被使用，当这个栈帧中所有指令都完成时，这个栈帧被移除Java栈，刚才的那个栈帧变为活动栈帧，前面栈帧的返回值变为这个栈帧的操作栈的一个操作数。 由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。在Hot Spot虚拟机中，可以使用-Xss参数来设置栈的大小。栈的大小直接决定了函数调用的可达深度。 3.堆 Heap: 堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。 4.方法区Method Area: 方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，不像Java堆中其他部分一样会频繁被GC回收，它存储的信息相对比较稳定，在一定条件下会被GC，当方法区要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation，大小可以通过参数来设置,可以通过-XX:PermSize指定初始值，-XX:MaxPermSize指定最大值。 5.常量池Constant Pool: 常量池本身是方法区中的一个数据结构。常量池中存储了如字符串、final变量值、类名和方法名常量。常量池在编译期间就被确定，并保存在已编译的.class文件中。一般分为两类：字面量和应用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定为到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。 6.本地方法栈Native Method Stack: 本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 参考：https://www.zhihu.com/question/29833675 7个区域内存溢出 程序计数器：看做当前线程所执行的字节码行号指示器。是线程私有的内存，且唯一一块不报OutOfMemoryError异常的内存区域。 Java虚拟机栈：用于描述java方法的内存模型：每个方法被执行时都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度就报StackOverflowError, 如果虚拟 机栈可以动态扩展，当拓展时无法申请到足够的内存会抛出OutOfMemoryError. 是线程私有的。 本地方法栈：与虚拟机栈相似，不同的在于它是为虚拟机使用到Native方法服务的。会抛出StackOverflowError和OutOfMemoryError。是线程私有的。 Java堆: 是所有线程共享的一块内存，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。如果堆上没有内存完成实例的分配就会报OutOfMemoryError. 方法区（永久代）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。是共享内存。 运行时常量池：用于存放编译器生成的各种字面量和符号引用，是方法区的一部分。无法申请内存时抛出OutOfMemoryError。 直接内存：不是虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的区域，是计算机直接的内存空间。这部分也被频繁使用，如JAVA NIO的引入基于通道和缓存区的I/O使用native函数直接分配堆外内存。如果内存不足会报OutOfMemoryError。 JMM模型JMM三性质 原子性（Atomicity）：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。 基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。 可见性：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。 Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。 无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。 除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。 使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。 使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。 final关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。 有序性：对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。 Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现， 在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。 happens-before原则1234567891011121314151、程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作。2、管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序，下同）对同一个锁的lock操作。3、volatile变量规则：对一个volatile变量的写操作happen—before后面对该变量的读操作。4、线程启动规则：Thread对象的start（）方法happen—before此线程的每一个动作。5、线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。6、线程中断规则：对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。7、对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。8、传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。 原则分析： https://blog.csdn.net/ns_code/article/details/17348313https://www.cnblogs.com/lewis0077/p/5143268.html JVM内存分配总的来说，JVM管理的内存包括堆内存和非堆内存。堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 因此这里所说的内存分配是指堆内存的分配，即我们程序中生成的对象的分配。以下所述针对的是HotSpot虚拟机。 1、Java堆结构以HotSpot为例，如下图： 1.1、年轻代年轻代（或称新生代，Young、New）通常用来放新生成的对象（但不绝对，如可以通过-XX:PretenureSizeThreadshold配置将大对象直接分配在老年代）。年轻代的目标就是尽可能快速地收集掉那些生命周期短的对象。 年轻代分3个区，1个Eden区，2个Survivor区（from 和 to），但每次只使用Eden和一个Survivor区，另一个Survivor区空着。空Survivor区用来放MinorGC时从Eden和在使用的Survivor区中复制来的活着的对象。 针对年轻代的GC为Minor GC或称Young GC，在Eden剩余空间不足以分配新对象时触发 1.2、老年代老年代（Old、Tenure）通常用来存放从年轻代复制过来的对象（也可直接在老年代分配对象）。老年代中存放的是一些生命周期较长的对象。 针对老年代的GC为Major GC或称Full GC，在老年代剩余空间不足以容纳新对象时触发。Major GC经常会伴随至少一次的Minor GC（但非绝对，如下面所说的HandlePromotionFailure策略，有可能直接进行Major GC；Parallel Scavenge收集器提供了直接进行Major GC的策略选择），Major GC一般比Minor GC慢10倍以上。 永久代 通常还可以听到永久代（PermGen space）的概念，其实它并不在Java堆。有时永久代又被称为元空间（Metaspace）或方法区，比较乱。它们的区别是：方法区为JVM的规范，永久代、元空间分别是方法区在HotSpot中的一种实现，对于其他类型的虚拟机实现，如 JRockit（BEA）、J9（IBM），其并没有这些概念。 2、堆内存分配过程 对象的内存分配，绝大部分都是在堆上分配（少数经过JIT编译后被拆散为标量类型并间接在栈上分配），这里介绍在堆上的分配。 生成对象（为对象分配内存）的过程如下： 首先看Eden剩余空间是否足够分配该对象，若够则直接在Eden分配； 否则进行MinorGC：将Eden和在使用的Survivor区中活着的对象复制到另一个Survivor区，并回收Eden和使用着的Survivor区。然后把对象分配到Eden，以后另一个Survivor成为使用的Survivor区； 若另一个Survivor区不能完全容纳复制过来的对象，则能放下的放入该Survivor，把放不下的放到老年代（即进行分配担保）； 若老年代剩余空间不够了则进行Full GC， 若Full GC后仍不够则抛出OOM异常。 具体可以分为： 分配过程（优先在Eden分配） 分配担保（垃圾回收时Survivor放不下的存活对象移到老年代） 提前移动的配置（大对象、对象年龄、动态年龄） 以下示例所用JDK为1.8.0_45。 2.1、对象优先在Eden区分配对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 示例代码： View Code GC日志： ;) 12345678910[GC (Allocation Failure) [DefNew: 7291K-&gt;508K(9216K), 0.0035043 secs] 7291K-&gt;6652K(19456K), 0.0035385 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4687K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000) from space 1024K, 49% used [0x00000000ff500000, 0x00000000ff57f390, 0x00000000ff600000) to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000) Metaspace used 2559K, capacity 4486K, committed 4864K, reserved 1056768K class space used 274K, capacity 386K, committed 512K, reserved 1048576K ;) 说明：新生代可用的空间为9M = 8M（Eden容量） + 1M（一个survivor容量），分配完allocation1、allocation2、allocation3之后，无法再分配allocation4，会发生分配失败，则需要进行一次Minor GC，survivor to区域的容量为1M，无法容纳总量为6M的三个对象，则会通过担保机制将allocation1、allocation2、allocation3转移到老年代，然后再将allocation4分配在Eden区。 2.2、空间分配担保空间分配担保（Handle Promotion，意译成对象存储位置晋升还差不多，分配担保…什么鬼）即让老年代空间来存放年轻代中的对象，其前提是老年代还有容纳的空间。 在发生Minor GC时，虚拟机会检查老年代连续的空闲区域是否大于新生代所有对象的总和，若成立，则说明Minor GC是安全的，否则，虚拟机需要查看HandlePromotionFailure的值，看是否允许担保失败，若允许，则虚拟机继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，将尝试进行一次Minor GC；若小于或者HandlePromotionFailure设置不运行冒险，那么此时将改成一次Full GC。 以上是JDK Update 24之前的策略，之后的策略改变了，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。 冒险是指经过一次Minor GC后有大量对象存活，而新生代的survivor区很小，放不下这些大量存活的对象，所以需要老年代进行分配担保，把survivor区无法容纳的对象直接进入老年代。 该策略的意义之一在于减少不必要的MinorGC。具体的流程图如下： 示例代码： View Code GC日志（没在老JDK上跑，可能与期望的有点出入）： ;) 1234567891011[GC (Allocation Failure) [DefNew: 7291K-&gt;508K(9216K), 0.0042361 secs] 7291K-&gt;4604K(19456K), 0.0042750 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [DefNew: 6811K-&gt;508K(9216K), 0.0007200 secs] 10907K-&gt;4604K(19456K), 0.0007436 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 2638K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 26% used [0x00000000fec00000, 0x00000000fee14930, 0x00000000ff400000) from space 1024K, 49% used [0x00000000ff400000, 0x00000000ff47f0e0, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 40% used [0x00000000ff600000, 0x00000000ffa00020, 0x00000000ffa00200, 0x0000000100000000) Metaspace used 2560K, capacity 4486K, committed 4864K, reserved 1056768K class space used 274K, capacity 386K, committed 512K, reserved 1048576K ;) 说明： 发生了两Minor次GC，第一次发生在给allocation4分配内存空间时，由于老年代的连续可用空间大于存活的对象总和，所以allocation2、allocation3将会进入老年代，allocation1的空间将被回收，allocation4分配在新生代；第二次发生在给allocation7分配内存空间时，此次GC将allocation4、allocation5、allocation6所占的内存全部回收。最后，allocation2、allocation3在老年代，allocation7在新生代。 2.3、大对象直接进入老年代需要大量连续内存空间的Java对象称为大对象，大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。虚拟机提供了-XX:PretenureSizeThreadshold（仅对Serial和ParNew收集器有效）参数来设置大对象的阈值，超过阈值的对象直接分配到老年代。这样做的目的是避免在Eden区和两个 Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 示例代码： View Code GC日志： ;) 123456789Heap def new generation total 9216K, used 1311K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 16% used [0x00000000fec00000, 0x00000000fed47f80, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000) Metaspace used 2559K, capacity 4486K, committed 4864K, reserved 1056768K class space used 274K, capacity 386K, committed 512K, reserved 1048576K ;) 说明：4MB对象超过PretenureSizeThreshold阈值（3MB），直接分配在了老年代。 2.4、长期存活的对象进入老年代每个对象有一个对象年龄计数器，与对象头标记字中的GC分代年龄对应。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一个阈值（默认15），下次触发Minor GC时就被移到老年代（即配置的是最多被在Survivor间移动几次，达到阈值后下一次GC时不移动而是直接晋升了）。虚拟机提供了-XX:MaxTenuringThreshold来进行设置。 示例代码： View Code GC日志： ;) 1234567891011[GC (Allocation Failure) [DefNew Desired survivor size 524288 bytes, new threshold 1 (max 1)- age 1: 783256 bytes, 783256 total: 5499K-&gt;764K(9216K), 0.0024536 secs] 5499K-&gt;4860K(19456K), 0.0024878 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [GC (Allocation Failure) [DefNew Desired survivor size 524288 bytes, new threshold 1 (max 1): 4860K-&gt;0K(9216K), 0.0006581 secs] 8956K-&gt;4860K(19456K), 0.0006864 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4178K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 4860K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 47% used [0x00000000ff600000, 0x00000000ffabf120, 0x00000000ffabf200, 0x0000000100000000) Metaspace used 2560K, capacity 4486K, committed 4864K, reserved 1056768K class space used 274K, capacity 386K, committed 512K, reserved 1048576K ;) 说明：发生了两次Minor GC，第一次是在给allocation3进行分配的时候会出现一次Minor GC，此时survivor区域不能容纳allocation2，但是可以容纳allocation1，所以allocation1将会进入survivor区域并且年龄为1，达到了阈值，将在下一次GC时晋升到老年代，而allocation2则会通过担保机制进入老年代。第二次发生GC是在第二次给allocation3分配空间时，这时，allocation1的晋升到老年代，此次GC也可以清理出原来allocation3占据的4MB空间，将allocation3分配在Eden区。所以，最后的结果是allocation1、allocation2在老年代，allocation3在Eden区。 2.5、动态判断对象年龄对象的年龄到达了MaxTenuringThreshold可以进入老年代，同时，如果在survivor区中相同年龄所有对象大小的总和大于survivor区的一半，年龄大于等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄。 示例代码： View Code GC日志： ;) 1234567891011[GC (Allocation Failure) [DefNew Desired survivor size 524288 bytes, new threshold 1 (max 15)- age 1: 1045416 bytes, 1045416 total: 5755K-&gt;1020K(9216K), 0.0027553 secs] 5755K-&gt;5116K(19456K), 0.0028017 secs] [Times: user=0.00 sys=0.02, real=0.00 secs] [GC (Allocation Failure) [DefNew Desired survivor size 524288 bytes, new threshold 15 (max 15): 5116K-&gt;0K(9216K), 0.0009216 secs] 9212K-&gt;5116K(19456K), 0.0009399 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4178K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 5116K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 49% used [0x00000000ff600000, 0x00000000ffaff130, 0x00000000ffaff200, 0x0000000100000000) Metaspace used 2559K, capacity 4486K, committed 4864K, reserved 1056768K class space used 274K, capacity 386K, committed 512K, reserved 1048576K ;) 说明：发生了两次Minor GC，第一次发生在给allocation4分配内存时，此时allocation1、allocation2将会进入survivor区，而allocation3通过担保机制将会进入老年代。第二次发生在第二次给allocation4分配内存时，此时，survivor区的allocation1、allocation2达到了survivor区容量的一半，将会进入老年代，此次GC可以清理出allocation4原来的4MB空间，并将allocation4分配在Eden区。最终，allocation1、allocation2、allocation3在老年代，allocation4在Eden区。、 3、堆内存分配参数设置见 HotSpot JVM各区域内存分配参数设置-MarchOn -Xmx3550m：等价于-XX:MaxHeapSize，设置JVM最大堆内存为3550M。 -Xms3550m：等价于-XX:InitialHeapSize，设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。 -XX:NewSize=1024m：设置年轻代初始值为1024M。 -XX:MaxNewSize=1024m：设置年轻代最大值为1024M。 -XX:SurvivorRatio=4：设置年轻代中Eden区与一个Survivor区的比值。表示Edgen为一个Survivor的4倍，即1个Survivor区占整个年轻代大小的1/6。默认为8。 -XX:NewRatio=4：设置老年代与年轻代（包括1个Eden和2个Survivor区）的比值。表示老年代是年轻代的4倍。 -XX:PretenureSizeThreadshold=1024：设置让大于此阈值的对象直接分配在老年代（只对Serial、ParNew收集器有效），单位为字节 -XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区移动了7次那下次MinorGC时就进入老年代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，可以在某种程度上提高服务稳定性 copy from ：http://www.cnblogs.com/z-sm/p/6252245.html JVM对象创建和内存布局1、对象创建的过程 1、类加载、解析、初始化：虚拟机遇到new时先检查此指令的参数是否能在常量池中找到类的符号引用，并检查符号引用代表的类是否被加载、解析、初始化，若没有则先进行类加载。 2、对象内存分配：类加载检查通过后，虚拟机为新生对象分配内存，对象所需内存大小在类加载完成后便可完全确定。分配内存的任务等同于从堆中分出一块确定大小的内存。（具体分配策略见：JVM内存分配策略-MarchOn） 根据内存是否规整（即用的放一边，空闲的放另一边，是否如此与所使用的垃圾收集器是否带有压缩整理Compact功能有关），分配方式分为指针碰撞（Serial、ParNe等收集器）和空闲列表（CMS收集器等）两种 并发控制：可能多个对象同时从堆中分配内存因此需要同步，两种解决方案：虚拟机用CAS配上失败重试保证原子操作；把内存分配动作按线程划分在不同空间中进行，即每个线程预先分配一块线程本地缓冲区TLAB，各线程在各自TLAB为各自对象分配内存。 3、对象的初始化：对象头和对象实例数据的初始化 2、对象的内存布局布局： 对象头：标记字（32位虚拟机4B，64位虚拟机8B） + 类型指针（32位虚拟机4B，64位虚拟机8B）+ [数组长（对于数组对象才需要此部分信息）] 实例数据 对齐填充：对于64位虚拟机来说，对象大小必须是8B的整数倍，不够的话需要占位填充 对象头用于存储对象的元数据信息： Mark Word 部分数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值等。Mark Word一般被设计为非固定的数据结构，以便存储更多的数据信息和复用自己的存储空间。 类型指针 指向它的类元数据的指针，用于判断对象属于哪个类的实例。 实例数据存储的是真正有效数据，如各种字段内容，各字段的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops(ordinary object pointers)，相同宽度的字段总是被分配到一起，便于之后取数据。父类定义的变量会出现在子类定义的变量的前面。 对齐填充部分仅仅起到占位符的作用，并非必须。 示例（以HashMap&lt;Long,Long&gt;为例）： 其只有Key和Value是有效数据，共28B=16B，包装成Long对象后分别具有了8B标记字和8B的类型指针，共24B2=48B；两个对象组成Map.Entry后多了16B对象头、一个8B的next字段、4B的int类型的hash字段，还必须添加4B的空白填充。共32B；最后还有对HashMap中对此Entry的8B的引用。所以空间利用率为 16B / (48B+32B+8B) ≈ 18% 32位虚拟机 VS 64位虚拟机： 由于指针膨胀和各种数据类型对齐补白的原因，运行于64位系统上的Java应用需要消耗更多的内存（通常比32位的增加10%~30%的内存开销） ；此外，64位虚拟机的运行速度比32位的大约有15%左右的性能差距。 不过，64位虚拟机也有它的优势：首先能管理更多的内存，32位最多4GB，实际上还受OS允许进程最大内存的限制（Windows下2GB）；其次，随着硬件技术的发展，计算机终究会完全过渡到64位，虚拟机也将过渡到64位。 3、对象的访问定位对象的访问定位也取决于具体的虚拟机实现。当我们在堆上创建一个对象实例后，就要通过虚拟机栈中的reference类型数据来操作堆上的对象。现在主流的访问方式有两种（HotSpot虚拟机采用的是第二种）： 使用句柄访问对象。即reference中存储的是对象句柄的地址，而句柄中包含了对象实例数据与类型数据的具体地址信息，相当于二级指针。 直接指针访问对象。即reference中存储的就是对象地址，相当于一级指针。 两种方式有各自的优缺点。当垃圾回收移动对象时，对于方式一而言，reference中存储的地址是稳定的地址，不需要修改，仅需要修改对象句柄的地址；而对于方式二，则需要修改reference中存储的地址。从访问效率上看，方式二优于方式一，因为方式二只进行了一次指针定位，节省了时间开销，而这也是HotSpot采用的实现方式。下图是句柄访问与指针访问的示意图。]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>oom</tag>
        <tag>mem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm 字节码执行引擎]]></title>
    <url>%2Fposts%2Fjvm_art_byte_code_execute.html</url>
    <content type="text"><![CDATA[JVM字节码执行引擎 虚拟机是相对于“物理机”而言的，这两种机器都有代码执行能力，其区别主要是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎是自己实现的。因此程序员可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。 在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型称为各种虚拟机执行引擎的统一外观。虚拟机实现中，可能会有两种的执行方式：解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码）。有些虚拟机值采用一种执行方式，但是有点采用了两种，甚至有可能包含几个不同级别的编译器执行引擎。 所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件、处理过程是等效字节码解析过程，输出的是执行结果。 运行时栈帧结构 栈帧（Stack Frame）是一种数据结构，它主要是用来支持虚拟机进行方法调用和方法执行。它是虚拟机运行时数据区的虚拟机栈的栈元素。 包含内容：栈帧包含了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息等。 执行过程：一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。在活动线程中，只有栈顶的栈帧才是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有的字节码指令都只针对当前栈帧进行操作。 执行意义：每个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 值得注意的是：在编译程序代码的时候，栈帧需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多大的内存，并不会受到运行期变量数据的影响，而仅仅取决于具体的虚拟机的实现。 局部变量表 一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了改方法所需分配的最大局部变量表的容器。 包含类型：boolean、byte、char、short、int、float、reference或returnAddress类型八种类型。 容量单位：变量槽（slot）。不过虚拟机中并没有明确确定每一个变量槽所占据的内存空间大小，只是有导向性地说明每个变量槽都应该存放的八种类型：boolean、byte、char、short、int、float、reference或returnAddress类型的数据。这种描述和明确指出“每个Slot占用32位长度的内存空间”有一些差别，它允许Slot的长度随着不同的处理器、操作系统或者虚拟机而发生改变。在64位系统上使用64位长度的内存空间来实现一个slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。 在Java中占32位以内的数据类型有boolean、byte、char、short、int、float、reference或returnAddress类型等，前六种不解释，而后面的reference是对象的引用。虚拟机规范并没有说明它的长度，也没有明确指出这个引用应有怎样的结构，但一般来说：虚拟机实现至少都应当能从此引用中直接或间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。而returnAddress是为字节码指令jsr、jsr_w和ret服务的，它指向一条字节码指令的地址。对于64为的数据类型，虚拟机会以高位在前的方式为其分配两个连续的Slot空间。即long和double两种类型。做法是将long和double类型速写分割为32位读写的做法。不过由于局部变量表建立在线程的堆栈上，是线程的私有数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题。 虚拟机索引方式：虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量。如果是32为数据类型的数据，索引n就表示使用第n个Slot，如果是64位数据类型的变量，则说明要使用第n和第n+1两个Slot。在方法执行过程中，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程。如果是实例方法（非static方法），那么局部变量表中的第0位索引的Slot默认是用来传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量相应的Slot就可以交给其他变量去使用。节省栈空间。但也有可能会影响到系统的垃圾收集行为。 还有一点要说明的是：局部变量不像前面介绍的类变量那样存在“准备阶段”。我们知道，类变量在加载过程中要经过两次赋初始值的过程：一次在准备阶段，赋予系统初始值，另外一次在初始化阶段，赋予程序员定义的初始值。但局部变量不一样，如果一个局部变量定义了但是没有赋初始值是不能使用的。所有不要认为Java中任何情况下都存在着诸如整型变量默认为0，布尔型变量默认为false之类的默认值。这一点要好好注意一下。 操作数栈 操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位所占的栈容量为2.在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。 另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数的虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。这样在进行方法调用时就可以共用一部分数据，而无须进行额外的参数复制传递。 Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中的栈就是指操作数栈。 动态连接 每个栈帧都包含着一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用的是为了支持方法调用过程中的动态连接。 在Class文件中存在着大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分在类加载阶段第一次使用阶段的时候转换为直接引用，这种转换称为静态解析。另外一部分将在每次的运行期间转化为直接引用，这部分称为动态转换。 方法返回地址 当一个方法被执行后，有两种方式可以退出这个方法。 第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口。 另外一种退出方式是：在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，无论是JVM内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。这种方式被称为异常退出出口。此方式不会给上层调用者产生任何返回值。 无论采用哪一种退出方式，在方法退出后，都会返回到方法被调用的位置，程序才能继续执行。方法返回时可能要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出之后，调用者的PC计数器的值就可以作为返回地址。栈帧中很可能会保存这个计数器值，而方法异常退出后，返回地址就要通过异常处理器表来确定，栈帧一般不保存这部分信息。 方法退出实际上就是把当前栈帧出栈的操作：因此退出时可能执行的操作：恢复上层方法局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向指令后面的一条指令。 附加信息 增加一些没有描述的信息到栈帧之中。一般将动态连接、方法返回地址和其他附加信息全部归为一类，称为栈帧信息。 方法调用 Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用都在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前所说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。 解析 所有的方法调用的目标方法在Class文件里面都只是一个常量池的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是L方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不会改变的。换句话说：调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析。在JVM中提供了5条方法调用字节码指令，分别是：invokestatic：调用静态方法involespecial：调用实例构造器方法、私有方法和父类方法。invokevirtual：调用所有的虚方法。invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。invokedynamic：先在运行时动态解析出调用限定符所引用的方法，然后再执行该方法。 只要能被invokestatic和invokeapecial指令调用的方法，都是可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，他们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法）。非虚方法除了上述的两种以外，还有一种就是被final修饰的方法，虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，所以可以把final方法看作是一种非虚方法。 解析调用一定是个静态的过程，在编译期间就可以确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派调用则可能是静态的或者是动态的，根据分派依据的总量数可以分为单分派和多分派，这两种分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派和动态多分派四种分派组合。 分派 –“重载”和“重写”的实现静态分派 JVM在重载时是通过参数的静态类型而不是实际类型做判定的，并且静态类型是编译期可知的，因此在编译阶段，Javac编译器会根据参数的静态类型决定使用那个重载版本，然后再把该方法的符号引号写到main（）方法的两条invokevritual指令的参数中。 所有依赖于静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型是方法的重载。 静态分派发生的时间：静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。 静态方法会在类加载期进行解析，而静态方法显然是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。 动态分派 运行期根据实际类型确定方法执行版本的分派过程称为动态分派。动态分派与方法重写有着密切的关系。 单分派和多分派 方法的接收者与方法的参数统称为方法的宗量。而根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种，单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。 JVM动态分派的实现 由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，为了避免频繁的搜索，最常用的“稳定优化”的手段就是为类在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。 虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实现入口，如果子类中重写了这个方法，子类方法表中的地址将会替换成指向子类实现版本的入口地址。 为了程序实现上的方便，具有相同的签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更在、查找的方法表，就可以从不同的虚方法表中按照索引转换出所需的入口地址。 基于栈的字节码解释执行引擎 Java程序在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树。对于一门具体语言的实现来说，词法分析、语法分析以及后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。当然也可以选择其中的一部分步骤实现一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装到一个封闭黑匣子中，如大多数的JS执行器。 基于栈的指令集与基于寄存器的指令集 Java编译器输出的指令流，基本上是一种基于栈指令集架构，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。 基于栈的指令集主要优点就是可移植。除此之外，还有其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译器实现更加简单等。 缺点是：执行速度相对较慢。 参考： https://github.com/Crab2died/jdepth/blob/master/src/main/java/com/github/jvm/execengine/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.md https://www.cnblogs.com/zhouyuqin/p/5220728.html https://blog.csdn.net/dd864140130/article/details/49515403 https://gavinzhang1.gitbooks.io/java-jvm-us/content/xu_ni_ji_zi_jie_ma_zhi_xing_yin_qing.html http://www.cnblogs.com/luyu1993/p/7171482.html]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>class</tag>
        <tag>byte code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm Params配置调优参数]]></title>
    <url>%2Fposts%2Fjvm_art_params_analysis.html</url>
    <content type="text"><![CDATA[JVM参数类型和调整所有线程共享的内存主要有两块：堆内存和方法区。 其中堆内存分为两块：新生代Young generation（Eden区、From Survivor区、To Survivor区）、老年代Tenured generation。 方法区有人也称之“永久代”，但是它们并不等同。方法区是JVM的规范，而永久代是该规范的一种实现方式。从jdk1.7开始已经逐步去除“永久代”，在JDK8中取而代之的是“元空间”（Metaspace）。 元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制 下面是JVM的一些主要参数： 1. 基本参数 参数 描述 -XX:+ 打开 -XX:- 关闭 2. 内存大小配置参数 参数 描述 -Xms 初始堆内存大小 -Xmx 最大堆内存大小 -Xmn 年轻代内存大小 -Xss 线程私有的虚拟机栈大小 -XX:MaxPermSize=64m 永久代最大值 -XX:PermSize 永久代初始值 -XX:MetaspaceSize 元空间初始大小 -XX:MaxMetaspaceSize 元空间最大值 -XX:MaxDirectMemorySize 直接内存大小，默认与Java堆最大值（-Xmx）一样 3. JVM调试参数 参数 描述 -verbose:gc 记录GC运行及运行时间 -XX:+PrintGCDetails 记录GC运行时的详细数据信息，以及在进程结束时打印当前的内存各区域分配情况。 -XX:+PrintGCTimeStamps 打印垃圾收集时间戳 -Xloggc:{gcLogPath} gc日志存放路径 -XX:+HeapDumpOnOutOfMemoryError 在内存溢出的时候生成Heap dump文件 -verbose:class、-XX:+TraceClassLoading 查看类加载信息(要求Product版虚拟机) -XX:+TraceClassUnLoading 查看类卸载信息(要求FastDebug版虚拟机) -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 用于远程调试 4. 垃圾收集器 参数 描述 -XX:+UseSerialG 使用Serial+Serial Old的收集器组合进行内存回收。 -XX:+UseParNewGC 使用ParNew+Serial Old的收集器组合进行内存回收。 -XX:+UseConcMarkSweepGC 使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old作为出现Concurrent Mode Failure失败后的后备收集器使用。 -XX:+UseParallelGC 使用Parallel Scavenge+Serial Old(PS Mark Sweep)收集器组合进行内存回收。 -XX:+UseParallelOldGC 使用Parallel Scavenge+Parallel Old收集器组合进行内存回收。 5. JVM调优参数 参数 描述 -XX:SurvivorRatio 新生代中Eden区域和Survivor区域（单个Survivor）的容量比值，默认为8 -XX:NewRatio 堆内存中老生代和年轻代的容量比值。例：NewRatio=2，表明old：new=2:1 -XX:PretenureSizeThreshold 直接晋升到老年代的对象大小，大于该值的对象直接在老年代分配。 -XX:MaxTenuringThreshold 对象在新生代中能存活的最大年龄。 -XX:+UseAdaptiveSizePolicy 动态调整Java堆中各个区域的大小以及进入老年代的年龄（限Parallel Scaverge收集器） -XX:+HandlePromotionFailure 允许老年代分配担保失败，开启后可以冒险YGC。 -XX:ParallelGCThreads 设置并行GC时进行内存回收的线程数 -XX:GCTimeRatio 默认为99，即允许1%的GC时间。GC时间占总时间的比例由公式1/(1+GCTimeRatio)得出（限Parallel Scaverge收集器） -XX:MaxGCPauseMillis 设置GC的最大停顿时间（限Parallel Scaverge收集器） -XX:+CMSInitialingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发Full GC。默认值是68，即68%。（限CMS收集器） -XX:+UseCMSCompactionAtFullCollection 设置CMS在完成垃圾收集后进行一次内存碎片整理。（限CMS收集器） -XX:+CMSFullGCsBeforeCompaction 设置CMS执行多少次GC后，下次GC时进行一次内存碎片整理，默认为0。即每次都整理。 -Xnoclassgc 不回收无用类 参考：http://www.cnblogs.com/z-sm/p/6253335.html]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>params</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 习题解析]]></title>
    <url>%2Fposts%2Falgo_leetcode.html</url>
    <content type="text"><![CDATA[1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,return [0, 1].Because nums[0] + nums[1] = 2 + 7 = 9, Tags: Array, Hash Table 思路 0 题意是让你从给定的数组中找到两个元素的和为指定值的两个索引，最容易的当然是循环两次，复杂度为 O(n^2)，首次提交居然是 2ms，打败了 100% 的提交，谜一样的结果，之后再次提交就再也没跑到过 2ms 了。 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = i + 1; j &lt; nums.length; ++j) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return null; &#125;&#125; 思路 1 利用 HashMap 作为存储，键为目标值减去当前元素值，索引为值，比如 i = 0 时，此时首先要判断 nums[0] = 2 是否在 map 中，如果不存在，那么插入键值对 key = 9 - 2 = 7, value = 0，之后当 i = 1 时，此时判断 nums[1] = 7 已存在于 map 中，那么取出该 value = 0 作为第一个返回值，当前 i 作为第二个返回值，具体代码如下所示。 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; ++i) &#123; if (map.containsKey(nums[i])) &#123; return new int[]&#123;map.get(nums[i]), i&#125;; &#125; map.put(target - nums[i], i); &#125; return null; &#125;&#125; 2. Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 1234567891011121314151617181920public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode node = new ListNode(0); ListNode n1 = l1, n2 = l2, t = node; int sum = 0; while (n1 != null || n2 != null) &#123; sum /= 10; if (n1 != null) &#123; sum += n1.val; n1 = n1.next; &#125; if (n2 != null) &#123; sum += n2.val; n2 = n2.next; &#125; t.next = new ListNode(sum % 10); t = t.next; &#125; if (sum / 10 != 0) t.next = new ListNode(1); return node.next; &#125; 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Tags: Hash Table, Two Pointers, String 思路题意是计算不带重复字符的最长子字符串的长度，开辟一个 hash 数组来存储该字符上次出现的位置，比如 hash[a] = 3 就是代表 a 字符前一次出现的索引在 3，遍历该字符串，获取到上次出现的最大索引（只能向前，不能退后），与当前的索引做差获取的就是本次所需长度，从中迭代出最大值就是最终答案。 1234567891011public int lengthOfLongestSubstring(String s) &#123; int[] m = new int[256]; Arrays.fill(m, -1); int res = 0, left = -1; for (int i = 0; i &lt; s.length(); ++i) &#123; left = Math.max(left, m[s.charAt(i)]); m[s.charAt(i)] = i; res = Math.max(res, i - left); &#125; return res;&#125; 123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len; if (s == null || (len = s.length()) == 0) return 0; int preP = 0, max = 0; int[] hash = new int[128]; for (int i = 0; i &lt; len; ++i) &#123; char c = s.charAt(i); if (hash[c] &gt; preP) &#123; preP = hash[c]; &#125; int l = i - preP + 1; hash[c] = i + 1; if (l &gt; max) max = l; &#125; return max; &#125;&#125; 4. Median of Two Sorted ArraysThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: 12nums1 = [1, 3]nums2 = [2] The median is 2.0 Example 2: 12nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 思路：归并计数法，时间O(n) 空间O(1) 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len1 = nums1.length; int len2 = nums2.length; int total = len1 + len2; if(total % 2==0)&#123; return (findKth(nums1,nums2,total/2)+findKth(nums1,nums2,total/2+1))/2.0; &#125; else &#123; return findKth(nums1,nums2,total/2+1); &#125; &#125; private int findKth(int[] nums1, int[] nums2, int k)&#123; int p = 0, q = 0; for(int i = 0; i &lt; k - 1; i++)&#123; if(p&gt;=nums1.length &amp;&amp; q&lt;nums2.length)&#123; q++; &#125; else if(q&gt;=nums2.length &amp;&amp; p&lt;nums1.length)&#123; p++; &#125; else if(nums1[p]&gt;nums2[q])&#123; q++; &#125; else &#123; p++; &#125; &#125; if(p&gt;=nums1.length) &#123; return nums2[q]; &#125; else if(q&gt;=nums2.length) &#123; return nums1[p]; &#125; else &#123; return Math.min(nums1[p],nums2[q]); &#125; &#125;&#125; 分治法 Divide and Conquer 二分 复杂度时间O(log(m+n)) 空间O(1) 思路，二分，每次删除一半的一半题目要求O(log(m+n))的时间复杂度，一般来说都是分治法或者二分搜索。首先我们先分析下题目，假设两个有序序列共有n个元素（根据中位数的定义我们要分两种情况考虑），当n为奇数时，搜寻第(n/2+1)个元素，当n为偶数时，搜寻第(n/2+1)和第(n/2)个元素，然后取他们的均值。进一步的，我们可以把这题抽象为“搜索两个有序序列的第k个元素”。如果我们解决了这个k元素问题，那中位数不过是k的取值不同罢了。 那如何搜索两个有序序列中第k个元素呢，这里又有个技巧。假设序列都是从小到大排列，对于第一个序列中前p个元素和第二个序列中前q个元素，我们想要的最终结果是：p+q等于k-1,且一序列第p个元素和二序列第q个元素都小于总序列第k个元素。因为总序列中，必然有k-1个元素小于等于第k个元素。这样第p+1个元素或者第q+1个元素就是我们要找的第k个元素。 所以，我们可以通过二分法将问题规模缩小，假设p=k/2-1，则q=k-p-1，且p+q=k-1。如果第一个序列第p个元素小于第二个序列第q个元素，我们不确定二序列第q个元素是大了还是小了，但一序列的前p个元素肯定都小于目标，所以我们将第一个序列前p个元素全部抛弃，形成一个较短的新序列。然后，用新序列替代原先的第一个序列，再找其中的第k-p个元素（因为我们已经排除了p个元素，k需要更新为k-p），依次递归。同理，如果第一个序列第p个元素大于第二个序列第q个元素，我们则抛弃第二个序列的前q个元素。递归的终止条件有如下几种： 较短序列所有元素都被抛弃，则返回较长序列的第k个元素（在数组中下标是k-1） 一序列第p个元素等于二序列第q个元素，此时总序列第p+q=k-1个元素的后一个元素，也就是总序列的第k个元素 注意每次递归不仅要更新数组起始位置（起始位置之前的元素被抛弃），也要更新k的大小（扣除被抛弃的元素） 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length, n = nums2.length; int k = (m + n) / 2; if((m+n)%2==0)&#123; return (findKth(nums1,nums2,0,0,m,n,k)+findKth(nums1,nums2,0,0,m,n,k+1))/2; &#125; else &#123; return findKth(nums1,nums2,0,0,m,n,k+1); &#125; &#125; private double findKth(int[] arr1, int[] arr2, int start1, int start2, int len1, int len2, int k)&#123; // 保证arr1是较短的数组 if(len1&gt;len2)&#123; return findKth(arr2,arr1,start2,start1,len2,len1,k); &#125; if(len1==0)&#123; return arr2[start2 + k - 1]; &#125; if(k==1)&#123; return Math.min(arr1[start1],arr2[start2]); &#125; int p1 = Math.min(k/2,len1) ; int p2 = k - p1; if(arr1[start1 + p1-1]&lt;arr2[start2 + p2-1])&#123; return findKth(arr1,arr2,start1 + p1,start2,len1-p1,len2,k-p1); &#125; else if(arr1[start1 + p1-1]&gt;arr2[start2 + p2-1])&#123; return findKth(arr1,arr2,start1,start2 + p2,len1,len2-p2,k-p2); &#125; else &#123; return arr1[start1 + p1-1]; &#125; &#125;&#125; 5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.12345678910Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 思路 中心扩散法 Spread From Center时间 O(n^2) 空间 O(1)动态规划虽然优化了时间，但也浪费了空间。实际上我们并不需要一直存储所有子字符串的回文情况，我们需要知道的只是中心对称的较小一层是否是回文。所以如果我们从小到大连续以某点为个中心的所有子字符串进行计算，就能省略这个空间。 这种解法中，外层循环遍历的是子字符串的中心点，内层循环则是从中心扩散，一旦不是回文就不再计算其他以此为中心的较大的字符串。由于中心对称有两种情况，一是奇数个字母以某个字母对称，而是偶数个字母以两个字母中间为对称，所以我们要分别计算这两种对称情况。 12345678910111213141516171819202122232425262728public class Solution &#123; String longest = ""; public String longestPalindrome(String s) &#123; for(int i = 0; i &lt; s.length(); i++)&#123; //计算奇数子字符串 helper(s, i, 0); //计算偶数子字符串 helper(s, i, 1); &#125; return longest; &#125; private void helper(String s, int idx, int offset)&#123; int left = idx; int right = idx + offset; while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left)==s.charAt(right))&#123; left--; right++; &#125; // 截出当前最长的子串 String currLongest = s.substring(left + 1, right); // 判断是否比全局最长还长 if(currLongest.length() &gt; longest.length())&#123; longest = currLongest; &#125; &#125;&#125; 更厉害的还有 马拉车算法 Manacher Algorithm https://segmentfault.com/a/1190000002991199#articleHeader14 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)12345678910111213141516171819202122P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows);Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 思路 0题意是让你把字符串按波浪形排好，然后返回横向读取的字符串。 听不懂的话，看下面的表示应该就明白了： 12345670 2n-2 4n-41 2n-3 2n-1 4n-5 4n-32 2n-4 2n 4n-6 .. . . . .. n+1 . 3n-1 .n-2 n 3n-4 3n-2 5n-6n-1 3n-3 5n-5 那么我们可以根据上面找规律，可以看到波峰和波谷是单顶点的，它们周期是 2 * (n - 1)，单独处理即可；中间的部分每个周期会出现两次，规律很好找，留给读者自己想象，不懂的可以结合以下代码。 1234567891011121314151617181920212223class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows &lt;= 1) return s; int len = s.length(); char[] chars = s.toCharArray(); int cycle = 2 * (numRows - 1); StringBuilder sb = new StringBuilder(); for (int j = 0; j &lt; len; j += cycle) &#123; sb.append(chars[j]); &#125; for (int i = 1; i &lt; numRows - 1; i++) &#123; int step = 2 * i; for (int j = i; j &lt; len; j += step) &#123; sb.append(chars[j]); step = cycle - step; &#125; &#125; for (int j = numRows - 1; j &lt; len; j += cycle) &#123; sb.append(chars[j]); &#125; return sb.toString(); &#125;&#125; 7. Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer.123456789101112Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21 题意是给你一个整型数，求它的逆序整型数，而且有个小坑点，当它的逆序整型数溢出的话，那么就返回 0，用我们代码表示的话可以求得结果保存在 long 中，最后把结果和整型的两个范围比较即可。12345678class Solution &#123; public int reverse(int x) &#123; long res = 0; for (; x != 0; x /= 10) res = res * 10 + x % 10; return res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE ? 0 : (int) res; &#125;&#125; 1234567891011public int reverse(int x) &#123; long rev = 0; while (x != 0) &#123; rev = rev * 10 + x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) &#123; return 0; &#125; &#125; return (int) rev; &#125; 8. String to Integer (atoi)Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.12345678910111213Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.Then take as many numerical digits as possible, which gets 42.Example 3:Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. 思路, 时间 O(n) 空间 O(1) 字符串题一般考查的都是边界条件、特殊情况的处理。所以遇到此题一定要问清楚各种条件下的输入输出应该是什么样的。这里已知的特殊情况有： 能够排除首部的空格，从第一个非空字符开始计算允许数字以正负号(+-)开头遇到非法字符便停止转换，返回当前已经转换的值，如果开头就是非法字符则返回0在转换结果溢出时返回特定值，这里是最大/最小整数注意检查溢出时最大整数要先减去即将加的最末位再除以10，来处理”2147483648”类似的情况可以参考glibc中stdlib/atoi.c的实现方法 1234567891011121314151617181920212223public class Solution &#123; public int myAtoi(String str) &#123; str = str.trim(); int result = 0; boolean isPos = true; for(int i = 0; i &lt; str.length(); i++)&#123; char c = str.charAt(i); if(i==0 &amp;&amp; (c=='-'||c=='+'))&#123; isPos = c=='+'?true:false; &#125; else if (c&gt;='0' &amp;&amp; c&lt;='9')&#123; // 检查溢出情况 if(result&gt;(Integer.MAX_VALUE - (c - '0'))/10)&#123; return isPos? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; result *= 10; result += c - '0'; &#125; else &#123; return isPos?result:-result; &#125; &#125; return isPos?result:-result; &#125;&#125; 9. Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.12345678910111213141516Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. 思路 0题意是判断一个有符号整型数是否是回文，也就是逆序过来的整数和原整数相同，首先负数肯定不是，接下来我们分析一下最普通的解法，就是直接算出他的回文数，然后和给定值比较即可。1234567891011class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int copyX = x, reverse = 0; while (copyX &gt; 0) &#123; reverse = reverse * 10 + copyX % 10; copyX /= 10; &#125; return x == reverse; &#125;&#125; 思路 1好好思考下是否需要计算整个长度，比如 1234321，其实不然，我们只需要计算一半的长度即可，就是在计算过程中的那个逆序数比不断除 10 的数大就结束计算即可，但是这也带来了另一个问题，比如 10 的倍数的数 10010，它也会返回 true，所以我们需要对 10 的倍数的数再加个判断即可，代码如下所示。 1234567891011class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return false; int halfReverseX = 0; while (x &gt; halfReverseX) &#123; halfReverseX = halfReverseX * 10 + x % 10; x /= 10; &#125; return halfReverseX == x || halfReverseX / 10 == x; &#125;&#125; 10. Regular Expression MatchingImplement regular expression matching with support for ‘.’ and’*’. ‘.’ Matches any single character. ‘*’ Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The function prototype should be: bool isMatch(const char s, const char p)Some examples:123456789101112131415161718192021222324252627isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → trueExample 3:Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.Example 4:Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.Example 5:Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 思路 1我们可以把上面的思路更简单化，如下： 如果 s 和 p 都为空，那么返回 true； 如果 p 的第二个字符为 ，由于 前面的字符个数可以为任意，那么我们先递归调用个数为 0 的情况；或者当 s 不为空，如果他们的首字母匹配，那么我们就递归调用去掉去掉首字母的 s 和完整的 p； 如果 p 的第二个字符不为 *，那么我们就老老实实判断第一个字符是否匹配并且递归调用他们去掉首位的子字符串。 12345678910111213class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) return s.isEmpty(); if (p.length() &gt; 1 &amp;&amp; p.charAt(1) == '*') &#123; return isMatch(s, p.substring(2)) || (!s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.') &amp;&amp; isMatch(s.substring(1), p)); &#125; return !s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.') &amp;&amp; isMatch(s.substring(1), p.substring(1)); &#125;&#125; 思路 2另一种思路就是动态规划了，我们定义 dp[i][j] 的真假来表示 s[0..i) 是否匹配 p[0..j)，通过思路 1，我们可以确定其状态转移方程如下所示： 如果 p[j - 1] == ‘*’, dp[i][j] = dp[i][j - 2] || (pc[j - 2] == sc[i - 1] || pc[j - 2] == ‘.’) &amp;&amp; dp[i - 1][j];； 如果 p[j - 1] != ‘*’，dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (pc[j - 1] == ‘.’ || pc[j - 1] == sc[i - 1]);。 123456789101112131415161718192021222324class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.length() == 0) return s.length() == 0; int sL = s.length(), pL = p.length(); boolean[][] dp = new boolean[sL + 1][pL + 1]; char[] sc = s.toCharArray(), pc = p.toCharArray(); dp[0][0] = true; for (int i = 2; i &lt;= pL; ++i) &#123; if (pc[i - 1] == '*' &amp;&amp; dp[0][i - 2]) &#123; dp[0][i] = true; &#125; &#125; for (int i = 1; i &lt;= sL; ++i) &#123; for (int j = 1; j &lt;= pL; ++j) &#123; if (pc[j - 1] == '*') &#123; dp[i][j] = dp[i][j - 2] || (pc[j - 2] == sc[i - 1] || pc[j - 2] == '.') &amp;&amp; dp[i - 1][j]; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (pc[j - 1] == '.' || pc[j - 1] == sc[i - 1]); &#125; &#125; &#125; return dp[sL][pL]; &#125;&#125; 11. Container With Most Waterhttps://github.com/Blankj/awesome-java-leetcode/blob/master/note/010/README.md Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Tags: Array, Two Pointers 思路 题意是给你 a1, a2, …, an 这 n 个数，代表 (i, ai) 坐标，让你从中找两个点与 x 轴围成的容器可以容纳最多的水。 不明白的话可以看数据为 1 8 6 2 5 4 8 3 7 所示的图。 如果用暴力法求每种情况的结果，其时间复杂度为 O(n^2)，相信肯定会超时，我们可以探索下是否有更巧妙的办法呢，题目的标签有双指针，是否就可以想到首尾各放一指针，然后根据条件来收缩。首先计算一次首尾构成的最大面积，然后分析下该移动哪个指针，如果移动大的那个指针的话，那样只会减小面积，所以我们要移动小的那个指针，小的那个指针移动到哪呢？当然是移动到大于之前的值的地方，否则面积不都比之前小么，然后继续更新最大值即可，借助如上分析写出如下代码应该不是什么难事了吧。 1234567891011121314151617181920212223242526class Solution &#123; public int maxArea(int[] height) &#123; int l = 0, r = height.length - 1; int max = 0, h = 0; while (l &lt; r) &#123; h = Math.min(height[l], height[r]); max = Math.max(max, (r - l) * h); while (height[l] &lt;= h &amp;&amp; l &lt; r) ++l; while (height[r] &lt;= h &amp;&amp; l &lt; r) --r; &#125; return max; &#125;&#125;public int maxArea(int[] height) &#123; int maxarea = 0, l = 0, r = height.length - 1; while (l &lt; r) &#123; maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l)); if (height[l] &lt; height[r]) l++; else r--; &#125; return maxarea; &#125; 12. Integer to RomanRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.123456789101112131415161718192021222324252627282930313233343536373839Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one&apos;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.Example 1:Input: 3Output: &quot;III&quot;Example 2:Input: 4Output: &quot;IV&quot;Example 3:Input: 9Output: &quot;IX&quot;Example 4:Input: 58Output: &quot;LVIII&quot;Explanation: C = 100, L = 50, XXX = 30 and III = 3.Example 5:Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 思路因为罗马数字都是由最大化的表示，比如10会表示成X而不是VV，所以我们可以从最大可能的表示向小的依次尝试。因为提示1-3999，所有的可能性不多，我们可以直接打表来帮助我们选择表示方法。在一个数量级中有四种可能的表示方法，以1-9为例，1-3是由I表示出来的，4是IV，5是V，6-8是V和若干个I，9是IX。 代码1234567891011121314151617public class Solution &#123; public String intToRoman(int num) &#123; String[] symbol = &#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; int[] value = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; StringBuilder res = new StringBuilder(); int i = 0; while(num&gt;0)&#123; if(num&gt;=value[i])&#123; res.append(symbol[i]); num -= value[i]; &#125; else &#123; i++; &#125; &#125; return res.toString(); &#125;&#125; 思路2：思路题意是整型数转罗马数字，范围从 1 到 3999，查看下百度百科的罗马数字介绍如下： 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9。 那么我们可以把整数的每一位分离出来，让其每一位都用相应的罗马数字位表示，最终拼接完成。比如 621 我们可以分离百、十、个分别为 6、2、1，那么 600 对应的罗马数字是 DC，20 对应的罗马数字是 XX，1 对应的罗马数字是 I，所以最终答案便是 DCXXI。 123456789class Solution &#123; public String intToRoman(int num) &#123; String M[] = &#123;"", "M", "MM", "MMM"&#125;; String C[] = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String X[] = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String I[] = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return M[num / 1000] + C[(num % 1000) / 100] + X[(num % 100) / 10] + I[num % 10]; &#125;&#125; 13. Roman to IntegerRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.12345678910111213141516171819202122232425262728293031323334353637383940Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one&apos;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.Example 1:Input: &quot;III&quot;Output: 3Example 2:Input: &quot;IV&quot;Output: 4Example 3:Input: &quot;IX&quot;Output: 9Example 4:Input: &quot;LVIII&quot;Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Example 5:Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.Tags: Math, String 思路:题意是罗马数字转整型数，范围从 1 到 3999，查看下百度百科的罗马数字介绍如下： 相同的数字连写，所表示的数等于这些数字相加得到的数，如 Ⅲ=3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数，如 Ⅷ=8、Ⅻ=12； 小的数字（限于 Ⅰ、X 和 C）在大的数字的左边，所表示的数等于大数减小数得到的数，如 Ⅳ=4、Ⅸ=9。 那么我们可以利用 map 来完成罗马数字的 7 个数字符号：I、V、X、L、C、D、M 和整数的映射关系，然后根据上面的解释来模拟完成即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int len = s.length(); int sum = map.get(s.charAt(len - 1)); for (int i = len - 2; i &gt;= 0; --i) &#123; if (map.get(s.charAt(i)) &lt; map.get(s.charAt(i + 1))) &#123; sum -= map.get(s.charAt(i)); &#125; else &#123; sum += map.get(s.charAt(i)); &#125; &#125; return sum; &#125;&#125; public static class Solution1 &#123; public int romanToInt(String s) &#123; Map&lt;Character, Integer&gt; map = new HashMap(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (i &gt; 0 &amp;&amp; map.get(s.charAt(i)) &gt; map.get(s.charAt(i - 1))) &#123; result += map.get(s.charAt(i)) - 2 * map.get(s.charAt(i - 1)); &#125; else &#123; result += map.get(s.charAt(i)); &#125; &#125; return result; &#125; &#125; 14. Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.12345678910Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2:Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 思路:题意是让你从字符串数组中找出公共前缀，我的想法是找出最短的那个字符串的长度 minLen，然后在 0…minLen 的范围比较所有字符串，如果比较到有不同的字符，那么直接返回当前索引长度的字符串即可，否则最后返回最短的字符串即可。 12345678910111213class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int len = strs.length; if (len == 0) return ""; int minLen = 0x7fffffff; for (String str : strs) minLen = Math.min(minLen, str.length()); for (int j = 0; j &lt; minLen; ++j) for (int i = 1; i &lt; len; ++i) if (strs[0].charAt(j) != strs[i].charAt(j)) return strs[0].substring(0, j); return strs[0].substring(0, minLen); &#125;&#125; 15. 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 思路： 时间 O(N^2) 空间 O(1)3Sum其实可以转化成一个2Sum的题，我们先从数组中选一个数，并将目标数减去这个数，得到一个新目标数。然后再在剩下的数中找一对和是这个新目标数的数，其实就转化为2Sum了。为了避免得到重复结果，我们不仅要跳过重复元素，而且要保证2Sum找的范围要是在我们最先选定的那个数之后的。 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; nums.length - 2; i++)&#123; // 跳过重复元素 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 计算2Sum ArrayList&lt;List&lt;Integer&gt;&gt; curr = twoSum(nums, i, 0 - nums[i]); res.addAll(curr); &#125; return res; &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int i, int target)&#123; int left = i + 1, right = nums.length - 1; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); curr.add(nums[i]); curr.add(nums[left]); curr.add(nums[right]); res.add(curr); do &#123; left++; &#125;while(left &lt; nums.length &amp;&amp; nums[left] == nums[left-1]); do &#123; right--; &#125; while(right &gt;= 0 &amp;&amp; nums[right] == nums[right+1]); &#125; else if (nums[left] + nums[right] &gt; target)&#123; right--; &#125; else &#123; left++; &#125; &#125; return res; &#125;&#125; 18. 4Sum基本思想： 时间 O(N^3) 空间 O(1) https://segmentfault.com/a/1190000003740669#articleHeader2和3Sum的思路一样，在计算4Sum时我们可以先选一个数，然后在剩下的数中计算3Sum。而计算3Sum则同样是先选一个数，然后再剩下的数中计算2Sum。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; nums.length - 3; i++)&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; List&lt;List&lt;Integer&gt;&gt; curr = threeSum(nums, i, target - nums[i]); res.addAll(curr); &#125; return res; &#125; private List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums, int i, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int j = i + 1; j &lt; nums.length - 2; j++)&#123; if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue; List&lt;List&lt;Integer&gt;&gt; curr = twoSum(nums, i, j, target - nums[j]); res.addAll(curr); &#125; return res; &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int i, int j, int target)&#123; int left = j + 1, right = nums.length - 1; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); curr.add(nums[i]); curr.add(nums[j]); curr.add(nums[left]); curr.add(nums[right]); res.add(curr); do &#123; left++; &#125;while(left &lt; nums.length &amp;&amp; nums[left] == nums[left-1]); do &#123; right--; &#125; while(right &gt;= 0 &amp;&amp; nums[right] == nums[right+1]); &#125; else if (nums[left] + nums[right] &gt; target)&#123; right--; &#125; else &#123; left++; &#125; &#125; return res; &#125;&#125; 16. 3Sum ClosetGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 思路题意是让你从数组中找出最接近 target 的三个数的和，该题和 3Sum 的思路基本一样，先对数组进行排序，然后遍历这个排序数组，用两个指针分别指向当前元素的下一个和数组尾部，判断三者的和与 target 的差值来移动两个指针，并更新其结果，当然，如果三者的和直接与 target 值相同，那么返回 target 结果即可。 12345678910111213141516171819202122public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int delta = 0x7fffffff, res = 0; Arrays.sort(nums); int len = nums.length - 2; for (int i = 0; i &lt; len; i++) &#123; int left = i + 1, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; int curDelta = Math.abs(sum - target); if (curDelta == 0) return sum; if (curDelta &lt; delta) &#123; delta = curDelta; res = sum; &#125; if (sum &gt; target) --right; else ++left; &#125; &#125; return res; &#125;&#125; 17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 12345Example:Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 思路：dfs题意是给你按键，让你组合出所有不同结果，首先想到的肯定是回溯了，对每个按键的所有情况进行回溯，回溯的终点就是结果字符串长度和按键长度相同。 123456789101112131415161718192021class Solution &#123; private static String[] map = new String[]&#123;"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() == 0) return Collections.emptyList(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); helper(list, digits, ""); return list; &#125; private void helper(List&lt;String&gt; list, String digits, String ans) &#123; if (ans.length() == digits.length()) &#123; list.add(ans); return; &#125; for (char c : map[digits.charAt(ans.length()) - '2'].toCharArray()) &#123; helper(list, digits, ans + c); &#125; &#125;&#125; 19. Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head.12345678Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid. Follow up: Could you do this in one pass? 典型的快慢指针。先用快指针向前走n步，这样快指针就领先慢指针n步了，然后快慢指针一起走，当快指针到尽头时，慢指针就是倒数第n个。不过如果要删除这个节点，我们要知道的是该节点的前面一个节点。另外，如果要删的是头节点，也比较难处理。这里使用一个dummy头节点，放在本来的head之前，这样我们的慢指针从dummy开始遍历，当快指针为空是，慢指针正好是倒数第n个的前一个节点。最后返回的时候，返回dummy的下一个。 1234567891011121314151617181920public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode fast = head; ListNode dummy = new ListNode(0); dummy.next = head; // 快指针先走n步 for(int i = 0; i &lt; n; i++)&#123; fast = fast.next; &#125; // 从dummy开始慢指针和快指针一起走 ListNode curr = dummy; while(fast != null)&#123; fast = fast.next; curr = curr.next; &#125; // 删除当前的下一个节点 curr.next = curr.next.next; return dummy.next; &#125;&#125; 20. Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.123456789101112131415161718192021222324Example 1:Input: &quot;()&quot;Output: trueExample 2:Input: &quot;()[]&#123;&#125;&quot;Output: trueExample 3:Input: &quot;(]&quot;Output: falseExample 4:Input: &quot;([)]&quot;Output: falseExample 5:Input: &quot;&#123;[]&#125;&quot;Output: true 思路: stack题意是判断括号匹配是否正确，很明显，我们可以用栈来解决这个问题，当出现左括号的时候入栈，当遇到右括号时，判断栈顶的左括号是否何其匹配，不匹配的话直接返回 false 即可，最终判断是否空栈即可，这里我们可以用数组模拟栈的操作使其操作更快，有个细节注意下 top = 1;，从而省去了之后判空的操作和 top - 1 导致数组越界的错误。 123456789101112131415161718class Solution &#123; public boolean isValid(String s) &#123; char[] stack = new char[s.length() + 1]; int top = 1; for (char c : s.toCharArray()) &#123; if (c == '(' || c == '[' || c == '&#123;') &#123; stack[top++] = c; &#125; else if (c == ')' &amp;&amp; stack[--top] != '(') &#123; return false; &#125; else if (c == ']' &amp;&amp; stack[--top] != '[') &#123; return false; &#125; else if (c == '&#125;' &amp;&amp; stack[--top] != '&#123;') &#123; return false; &#125; &#125; return top == 1; &#125;&#125; 21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.1234Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 1234567891011121314151617181920212223242526272829思路题意是用一个新链表来合并两个已排序的链表，那我们只需要从头开始比较已排序的两个链表，新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode temp = head; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; temp.next = l1; l1 = l1.next; &#125; else &#123; temp.next = l2; l2 = l2.next; &#125; temp = temp.next; &#125; temp.next = l1 != null ? l1 : l2; return head.next; &#125;&#125; 22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.123456789For example, given n = 3, a solution set is:[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路 0题意是给你 n 值，让你找到所有格式正确的圆括号匹配组，题目中已经给出了 n = 3 的所有结果。遇到这种问题，第一直觉就是用到递归或者堆栈，我们选取递归来解决，也就是 helper 函数的功能，从参数上来看肯定很好理解了，leftRest 代表还有几个左括号可以用，rightNeed 代表还需要几个右括号才能匹配，初始状态当然是 rightNeed = 0, leftRest = n，递归的终止状态就是 rightNeed == 0 &amp;&amp; leftRest == 0，也就是左右括号都已匹配完毕，然后把 str 加入到链表中即可。 12345678910111213141516class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); helper(list, "", 0, n); return list; &#125; private void helper(List&lt;String&gt; list, String str, int rightNeed, int leftRest) &#123; if (rightNeed == 0 &amp;&amp; leftRest == 0) &#123; list.add(str); return; &#125; if (rightNeed &gt; 0) helper(list, str + ")", rightNeed - 1, leftRest); if (leftRest &gt; 0) helper(list, str + "(", rightNeed + 1, leftRest - 1); &#125;&#125; 23. Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example:1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 思路 1还有另一种思路是利用优先队列，该数据结构用到的是堆排序，所以对总链表个数为 k 的复杂度为 logk，总元素为个数为 N 的话，其时间复杂度也为 O(Nlogk)。 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) return null; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(lists.length, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; if (o1.val &lt; o2.val) return -1; else if (o1.val == o2.val) return 0; else return 1; &#125; &#125;); ListNode node = new ListNode(0), tmp = node; for (ListNode l : lists) &#123; if (l != null) queue.add(l); &#125; while (!queue.isEmpty()) &#123; tmp.next = queue.poll(); tmp = tmp.next; if (tmp.next != null) queue.add(tmp.next); &#125; return node.next; &#125;&#125; 思路 2 分治策略题意是合并多个已排序的链表，分析并描述其复杂度，我们可以用分治法来两两合并他们，假设 k 为总链表个数，N 为总元素个数，那么其时间复杂度为 O(Nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) return null; return helper(lists, 0, lists.length - 1); &#125; private ListNode helper(ListNode[] lists, int left, int right) &#123; if (left &gt;= right) return lists[left]; int mid = left + right &gt;&gt;&gt; 1; ListNode l0 = helper(lists, left, mid); ListNode l1 = helper(lists, mid + 1, right); return merge2Lists(l0, l1); &#125; private ListNode merge2Lists(ListNode l0, ListNode l1) &#123; ListNode node = new ListNode(0), tmp = node; while (l0 != null &amp;&amp; l1 != null) &#123; if (l0.val &lt;= l1.val) &#123; tmp.next = new ListNode(l0.val); l0 = l0.next; &#125; else &#123; tmp.next = new ListNode(l1.val); l1 = l1.next; &#125; tmp = tmp.next; &#125; tmp.next = l0 != null ? l0 : l1; return node.next; &#125;&#125; 24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head.1234567Example:Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Note:Your algorithm should use only constant extra space.You may not modify the values in the list&apos;s nodes, only nodes itself may be changed. 思路 0题意是让你交换链表中相邻的两个节点，最终返回交换后链表的头，限定你空间复杂度为 O(1)。我们可以用递归来算出子集合的结果，递归的终点就是指针指到链表末少于两个元素时，如果不是终点，那么我们就对其两节点进行交换，这里我们需要一个临时节点来作为交换桥梁，就不多说了。 1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode node = head.next; head.next = swapPairs(node.next); node.next = head; return node; &#125;&#125; 思路 1另一种实现方式就是用循环来实现了，两两交换节点，也需要一个临时节点来作为交换桥梁，直到当前指针指到链表末少于两个元素时停止，代码很简单，如下所示。12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; vasl = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode preHead = new ListNode(0), cur = preHead; preHead.next = head; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; ListNode temp = cur.next.next; cur.next.next = temp.next; temp.next = cur.next; cur.next = temp; cur = cur.next.next; &#125; return preHead.next; &#125;&#125; 26. Remove Duplicates from Sorted Array IGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 思路：两个指针，快指针指向当前数组遍历到的位置，慢指针指向不重复序列下一个存放的位置，这样我们一旦遍历到一个不重复的元素，就把它复制到不重复序列的末尾。判断重复的方法是记录上一个遍历到的数字，看是否一样。 12345678910111213public int removeDuplicates(int[] nums) &#123; if(nums.length == 0) return 0; int dup = nums[0]; int end = 1; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i]!=dup)&#123; nums[end] = nums[i]; dup = nums[i]; end++; &#125; &#125; return end; &#125; 不同写法：题意是让你从一个有序的数组中移除重复的元素，并返回之后数组的长度。我的思路是判断长度小于等于 1 的话直接返回原长度即可，否则的话遍历一遍数组，用一个 tail 变量指向尾部，如果后面的元素和前面的元素不同，就让 tail 变量加一，最后返回 tail 即可。 123456789101112public int removeDuplicates(int[] nums) &#123; int len = nums.length; if (len &lt;= 1) return len; int tail = 1; for (int i = 1; i &lt; len; ++i) &#123; if (nums[i - 1] != nums[i]) &#123; nums[tail++] = nums[i]; &#125; &#125; return tail; &#125; ## 27. Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length.123456789101112131415161718192021222324252627282930313233Example 1:Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length.Example 2:Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.Internally you can think of this:// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 思路题意是移除数组中值等于 val 的元素，并返回之后数组的长度，并且题目中指定空间复杂度为 O(1)，我的思路是用 tail 标记尾部，遍历该数组时当索引元素不等于 val 时，tail 加一，尾部指向当前元素，最后返回 tail 即可。1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int tail = 0; for (int i = 0, len = nums.length; i &lt; len; ++i) &#123; if (nums[i] != val) &#123; nums[tail++] = nums[i]; &#125; &#125; return tail; &#125;&#125; 28. Implement strStr()Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.123456789Example 1:Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Example 2:Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). 思路题意是从主串中找到子串的索引，如果找不到则返回-1，当子串长度大于主串，直接返回-1，然后我们只需要遍历比较即可。 1234567891011121314class Solution &#123; public int strStr(String haystack, String needle) &#123; int l1 = haystack.length(), l2 = needle.length(); if (l1 &lt; l2) return -1; for (int i = 0; ; i++) &#123; if (i + l2 &gt; l1) return -1; for (int j = 0; ; j++) &#123; if (j == l2) return i; if (haystack.charAt(i + j) != needle.charAt(j)) break; &#125; &#125; &#125;&#125; KMP算法复杂度时间 O(N+M) 空间 O(M) 思路KMP算法是较为高级的算法。它使用一个next数组，这个数组记录了模式串needle自身的前缀和后缀的重复情况。同样是双指针进行匹配，当失配时可以根据这个数组找到应该将模式串向后位移多少位，避免一些重复的比较。具体的解法这里有两篇文章比较好，一篇是详细讲解KMP算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.length() == 0)&#123; return 0; &#125; int[] next = new int[needle.length()]; // 得到next数组 getNextArr(next, needle); // i是匹配串haystack的指针，j是模式串needle的指针 int i = 0, j = 0; // 双指针开始匹配 while(i &lt; haystack.length() &amp;&amp; j &lt; needle.length())&#123; // 如果j=-1意味着刚刚失配过，下标+1后，下一轮就可以开始匹配各自的第一个了 // 如果指向的字母相同，则下一轮匹配各自的下一个 if(j == -1 || haystack.charAt(i) == needle.charAt(j))&#123; i++; j++; // 如果失配，则将更新j为next[j] &#125; else &#123; j = next[j]; &#125; &#125; return j == needle.length() ? i - j : -1; &#125; private void getNextArr(int[] next, String needle)&#123; // k是前缀中相同部分的末尾，同时也是相同部分的长度，因为长度等于k-0。 // j是后缀的末尾，即后缀相同部分的末尾 int k = -1, j = 0; next[0] = -1; while(j &lt; needle.length() - 1)&#123; // 如果k=-1，说明刚刚失配了，则重新开始计算前缀和后缀相同的长度 // 如果两个字符相等，则在上次前缀和后缀相同的长度加1就行了 if (k == -1 || needle.charAt(j) == needle.charAt(k))&#123; k++; j++; next[j] = k; &#125; else &#123; // 否则，前缀长度缩短为next[k] k = next[k]; &#125; &#125; &#125;&#125; 29. Divide Two IntegersGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero.123456789Example 1:Input: dividend = 10, divisor = 3Output: 3Example 2:Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers.The divisor will never be 0.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows. 思路: 时间 O(N) 空间 O(1) 位操作 我们设想87 / 4，本来应该的得到21余3，那么如果我们把87忽略余数后分解一下，87 = 4 21 = 4 16 + 4 4 + 4 1，也就是87 = 4 (1 2^4 + 0 2^3 + 1 2^2 + 0 2^1 + 1 2^0)，也就是把商分解为27 = 1 2^4 + 0 2^3 + 1 2^2 + 0 2^1 + 1 * 2^0，所以商的二进制是10101。我们可以不断的将4乘2的一次方，二次方，等等，直到找到最大那个次方，在这里是2的四次方。然后，我们就从四次方到零次方，按位看商的这一位该是0还是1。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int divide(int dividend, int divisor) &#123; if(dividend == Integer.MIN_VALUE &amp;&amp; (divisor == 1 || divisor == -1))&#123; return divisor == 1 ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; return (int)divideLong(dividend, divisor); &#125; public long divideLong(long dd, long dv)&#123; boolean isPos = (dd &gt; 0 &amp;&amp; dv &gt; 0) || (dd &lt; 0 &amp;&amp; dv &lt; 0); dd = Math.abs(dd); dv = Math.abs(dv); int digits = 0; // 通过将除数乘2，乘4，乘8，一直乘下去，找到商的最高的次方 // 比如87/4=21，商的最高次方是4，即2^4=16，即4 * 16 &lt; 87 while(dv &lt;= dd)&#123; dv &lt;&lt;= 1; digits++; &#125; // 重置除数，把最高次方减1得到实际最高位，刚才循环中多加了一次 long res = 0; dv &gt;&gt;= digits; digits--; // 看商的每一位是否应该为1 while(digits &gt;= 0)&#123; if(dd &gt;= (dv &lt;&lt; digits))&#123; dd -= dv &lt;&lt; digits; res += 1 &lt;&lt; digits; &#125; digits--; System.out.println(res); &#125; return isPos ? res : - res; &#125;&#125; 30. Substring with Concatenation of All WordsYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.123456789101112131415Example 1:Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too.Example 2:Input: s = &quot;wordgoodstudentgoodword&quot;, words = [&quot;word&quot;,&quot;student&quot;]Output: [] 思路: 时间 O(NK) 空间 O(M)由于数组中所有单词的长度都是一样的，我们可以像Longest Substring with At Most Two Distinct Characters中一样，把每个词当作一个字母来看待，但是要遍历K次，K是单词的长度，因为我们要分别统计从下标0开头，从下标1开头。。。直到下标K-1开头的字符串。举例来说foobarfoo，给定数组是[foo, bar]，那我们要对foo|bar|foo搜索一次，对oob|arf|oo搜索一次，对oba|rfo|o搜索一次，我们不用再对bar|foo搜索，因为其已经包含在第一种里面了。每次搜索中，我们通过哈希表维护一个窗口，比如foo|bar|foo中，我们先拿出foo。如果foo都不在数组中，那说明根本不能拼进去，则哈希表全部清零，从下一个词开始重新匹配。但是foo是在数组中的，所以给当前搜索的哈希表计数器加上1，如果发现当前搜索中foo出现的次数已经比给定数组中foo出现的次数多了，我们就要把上一次出现foo之前的所有词都从窗口中去掉，如果没有更多，则看下一个词bar，不过在这之前，我们还要看看窗口中有多少个词了，如果词的个数等于数组中词的个数，说明我们找到了一个结果。 注意先判断输入是否为空，为空直接返回空结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;(); if(words == null || words.length == 0 || s == null || s.equals("")) return res; HashMap&lt;String, Integer&gt; freq = new HashMap&lt;String, Integer&gt;(); // 统计数组中每个词出现的次数，放入哈希表中待用 for(String word : words)&#123; freq.put(word, freq.containsKey(word) ? freq.get(word) + 1 : 1); &#125; // 得到每个词的长度 int len = words[0].length(); // 错开位来统计 for(int i = 0; i &lt; len; i++)&#123; // 建一个新的哈希表，记录本轮搜索中窗口内单词出现次数 HashMap&lt;String, Integer&gt; currFreq = new HashMap&lt;String, Integer&gt;(); // start是窗口的开始，count表明窗口内有多少词 int start = i, count = 0; for(int j = i; j &lt;= s.length() - len; j += len)&#123; String sub = s.substring(j, j + len); // 看下一个词是否是给定数组中的 if(freq.containsKey(sub))&#123; // 窗口中单词出现次数加1 currFreq.put(sub, currFreq.containsKey(sub) ? currFreq.get(sub) + 1 : 1); count++; // 如果该单词出现次数已经超过给定数组中的次数了，说明多来了一个该单词，所以要把窗口中该单词上次出现的位置及之前所有单词给去掉 while(currFreq.get(sub) &gt; freq.get(sub))&#123; String leftMost = s.substring(start, start + len); currFreq.put(leftMost, currFreq.get(leftMost) - 1); start = start + len; count--; &#125; // 如果窗口内单词数和总单词数一样，则找到结果 if(count == words.length)&#123; String leftMost = s.substring(start, start + len); currFreq.put(leftMost, currFreq.get(leftMost) - 1); res.add(start); start = start + len; count--; &#125; // 如果截出来的单词都不在数组中，前功尽弃，重新开始 &#125; else &#123; currFreq.clear(); start = j + len; count = 0; &#125; &#125; &#125; return res; &#125;&#125; 31. Next Permutation12345678910Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 ​ 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public void nextPermutation(int[] nums) &#123; if(nums.length &lt;= 1)&#123; return; &#125; int i = nums.length - 2; // 找到第一个下降点，我们要把这个下降点的值增加一点点 // 对于511这种情况，要把前面两个1都跳过，所以要包含等于 while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1])&#123; i--; &#125; // 如果这个下降点还在数组内，我们找到一个比它稍微大一点的数替换 // 如果在之外，说明整个数组是降序的，是全局最大了 if(i &gt;= 0)&#123; int j = nums.length - 1; // 对于151，这种情况，要把最后面那个1跳过，所以要包含等于 while(j &gt; i &amp;&amp; nums[j] &lt;= nums[i])&#123; j--; &#125; swap(nums, i, j); &#125; // 将下降点之前的部分倒序构成一个最小序列 reverse(nums, i + 1, nums.length - 1); &#125; private void swap(int[] nums, int i, int j)&#123; int tmp = nums[j]; nums[j] = nums[i]; nums[i] = tmp; &#125; private void reverse(int[] nums, int left, int right)&#123; while(left &lt; right)&#123; swap(nums, left, right); left++; right--; &#125; &#125;&#125; 32. Longest Valid ParenthesesGiven a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.1234567891011Example 1:Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot;Example 2:Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; 思路1: 栈这道求最长有效括号比之前那道 Valid Parentheses 验证括号难度要大一些，这里我们还是借助栈来求解，需要定义个start变量来记录合法括号串的起始位置，我们遍历字符串，如果遇到左括号，则将当前下标压入栈，如果遇到右括号，如果当前栈为空，则将下一个坐标位置记录到start，如果栈不为空，则将栈顶元素取出，此时若栈为空，则更新结果和i - start + 1中的较大值，否则更新结果和i - 栈顶元素中的较大值，代码如下： 123456789101112131415161718class Solution &#123;public: int longestValidParentheses(string s) &#123; int res = 0, start = 0; stack&lt;int&gt; m; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == '(') m.push(i); else if (s[i] == ')') &#123; if (m.empty()) start = i + 1; else &#123; m.pop(); res = m.empty() ? max(res, i - start + 1) : max(res, i - m.top()); &#125; &#125; &#125; return res; &#125;&#125;; 33. Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n).123456789Example 1:Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4Example 2:Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 思路：二分，判断左半边是否有序的条件是：nums[min] &lt;= nums[mid]，而判断是否在某一个有序区间，则要包含那个区间较远的那一头。判断是否在有序的那一方内，不再就循环继续找无序的一部分。 12345678910111213141516171819202122232425262728public class Solution &#123; public int search(int[] nums, int target) &#123; int min = 0, max = nums.length - 1, mid = 0; while(min &lt;= max)&#123; mid = (min + max) / 2; if(nums[mid] == target)&#123; return mid; &#125; // 如果左半部分是有序的 if(nums[min] &lt;= nums[mid])&#123; if(nums[min] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; max = mid - 1; &#125; else &#123; min = mid + 1; &#125; // 如果右半部份是有序的 &#125; else &#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[max])&#123; min = mid + 1; &#125; else &#123; max = mid - 1; &#125; &#125; &#125; // 不满足min &lt;= max条件时，返回-1 return -1; &#125;&#125; 34. Search for a RangeGiven a sorted array of integers, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4]. 思路1：二分找到该元素位置，然后由中间向两边扩散，最坏情况是o(n) 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int idx = search(nums, 0, nums.size() - 1, target); if (idx == -1) return &#123;-1, -1&#125;; int left = idx, right = idx; while (left &gt; 0 &amp;&amp; nums[left - 1] == nums[idx]) --left; while (right &lt; nums.size() - 1 &amp;&amp; nums[right + 1] == nums[idx]) ++right; return &#123;left, right&#125;; &#125; int search(vector&lt;int&gt;&amp; nums, int left, int right, int target) &#123; if (left &gt; right) return -1; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] &lt; target) return search(nums, mid + 1, right, target); else return search(nums, left, mid - 1, target); &#125;&#125;; 思路2：两次二分。时间 O(logN) 空间 O(1) 其实就是执行两次二分搜索，一次专门找左边边界，一次找右边边界。特别的，如果找左边边界时，要看mid左边一位的的数是否和当前mid相同，如果相同要继续在左半边二分搜索。如果找右边边界，则要判断右边一位的数是否相同。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; // 找到左边界 int front = search(nums, target, "front"); // 找到右边界 int rear = search(nums, target, "rear"); int[] res = &#123;front, rear&#125;; return res; &#125; public int search(int[] nums, int target, String type)&#123; int min = 0, max = nums.length - 1; while(min &lt;= max)&#123; int mid = min + (max - min) / 2; if(nums[mid] &gt; target)&#123; max = mid - 1; &#125; else if(nums[mid] &lt; target)&#123; min = mid + 1; &#125; else &#123; // 对于找左边的情况，要判断左边的数是否重复 if(type == "front")&#123; if(mid == 0) return 0; if(nums[mid] != nums[mid - 1]) return mid; max = mid - 1; &#125; else &#123; // 对于找右边的情况，要判断右边的数是否重复 if(mid == nums.length - 1) return nums.length - 1; if(nums[mid] != nums[mid + 1]) return mid; min = mid + 1; &#125; &#125; &#125; //没找到该数返回-1 return -1; &#125;&#125; 35. Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.12345678910111213141516171819Example 1:Input: [1,3,5,6], 5Output: 2Example 2:Input: [1,3,5,6], 2Output: 1Example 3:Input: [1,3,5,6], 7Output: 4Example 4:Input: [1,3,5,6], 0Output: 0 思路：二分查找123456789101112131415161718192021public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int min = 0, max = nums.length - 1; // 条件是min &lt;= max while(min &lt;= max)&#123; int mid = min + (max - min) / 2; // 找到了 if(nums[mid] == target)&#123; return mid; &#125; // 在左边 if(nums[mid] &gt; target)&#123; max = mid - 1; &#125; else &#123; // 在右边 min = mid + 1; &#125; &#125; return min; &#125;&#125; 36 Valid Sudoku123456* 36. Valid Sudoku** Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.* The Sudoku board could be partially filled, where empty cells are filled with the character &apos;.&apos;.** A partially filled sudoku which is valid. 求解数独当前状态是否正确思路是： 判断每行，每列，每个小方块是否有重复(数字1~9且不重复)。 双重循环搞定：HashSet或位图均可判断重复。https://blog.csdn.net/mine_song/article/details/702073261234567891011121314151617181920212223242526 public boolean isValidSudoku(char[][] board) &#123; for (int i = 0; i &lt; 9; i++) &#123; HashSet&lt;Character&gt; row = new HashSet&lt;&gt;(); HashSet&lt;Character&gt; column = new HashSet&lt;&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;&gt;(); for (int j = 0; j &lt; 9; j++) &#123; // 检查第i行，在横坐标位置 if (board[i][j] != '.' &amp;&amp; !row.add(board[i][j])) return false; // 检查第i列，在纵坐标位置 if (board[j][i] != '.' &amp;&amp; !column.add(board[j][i])) return false; // 行号+偏移量 int RowIndex = 3 * (i / 3) + j / 3; // 列号+偏移量 int ColIndex = 3 * (i % 3) + j % 3; //每个小九宫格，总共9个 if (board[RowIndex][ColIndex] != '.' &amp;&amp; !cube.add(board[RowIndex][ColIndex])) return false; &#125; &#125; return true; &#125;位图思路： bit_map_row[board[i][j] - '1'] == 1 37 Sudoku Solver12345* 37. Sudoku Solver** Write a program to solve a Sudoku puzzle by filling the empty cells.* Empty cells are indicated by the character &apos;.&apos;.* You may assume that there will be only one unique solution. 求解当前状态数独是否有解思路是：dfs，递归，尝试设置未填充位置上每一个数字，判断该数字，如果可行递归下一个位置，不可行换下一个数字。代码思路：https://blog.csdn.net/zdavb/article/details/481650591234567891011121314151617181920212223242526272829303132333435private boolean solve(char[][] board)&#123; for(int row = 0;row&lt;9;row++)&#123; for(int col = 0;col&lt;9;col++)&#123; if(board[row][col] == '.')&#123; for(char i = '1';i&lt;='9';i++)&#123; board[row][col] = i; if(isValid(board,row,col) &amp;&amp; solve(board)) return true; board[row][col] = '.'; &#125; return false; &#125; &#125; &#125; return true;&#125;private boolean isValid(char[][] board,int row,int col)&#123; for(int i = 0;i&lt;9;i++)&#123; if(i!=col &amp;&amp; board[row][i] == board[row][col]) return false; &#125; for(int i = 0;i&lt;9;i++)&#123; if(i!=row &amp;&amp; board[i][col] == board[row][col]) return false; &#125; int beginRow = 3*(row/3); int beginCol = 3*(col/3); for(int i = beginRow;i&lt;beginRow+3;i++)&#123; for(int j = beginCol;j&lt;beginCol+3;j++)&#123; if(i!=row &amp;&amp; j!=col &amp;&amp; board[i][j] == board[row][col]) return false; &#125; &#125; return true;&#125; 38 Count and SayThe count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11. 11 is read off as &quot;two 1s&quot; or 21. 21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer n, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; Tags: String 思路 题意是数和说，根据如下序列 1, 11, 21, 1211, 111221, ...，求第 n 个数，规则很简单,就是数和说，数就是数这个数数字有几个，说就是说这个数，所以 1 就是 1 个 1：11,11 就是有 2 个 1：21，21 就是 1 个 2、1 个 1：1211，可想而知后面就是 111221，思路的话就是按这个逻辑模拟出来即可。 123456789101112131415161718192021class Solution &#123; public String countAndSay(int n) &#123; String str = "1"; while (--n &gt; 0) &#123; int times = 1; StringBuilder sb = new StringBuilder(); char[] chars = str.toCharArray(); int len = chars.length; for (int j = 1; j &lt; len; j++) &#123; if (chars[j - 1] == chars[j]) &#123; times++; &#125; else &#123; sb.append(times).append(chars[j - 1]); times = 1; &#125; &#125; str = sb.append(times).append(chars[len - 1]).toString(); &#125; return str; &#125;&#125; 39. Combination SumCombination Sum： https://segmentfault.com/a/1190000003743112 12345678910111213141516171819202122232425Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.Example 1:Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]]Example 2:Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 思路： dfs， 递归+剪枝 Path Sum II 二叉树路径之和之二，Subsets II 子集合之二，Permutations 全排列，Permutations II 全排列之二，Combinations 组合项等等，如果仔细研究这些题目发现都是一个套路，都是需要另写一个递归函数，这里我们新加入三个变量，start记录当前的递归到的下标，out为一个解，res保存所有已经得到的解，每次调用新的递归函数时，此时的target要减去当前数组的的数。 123456789101112131415161718192021222324252627282930313233public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new LinkedList&lt;Integer&gt;(); // 先将数组排序避免重复搜素 Arrays.sort(candidates); helper(candidates, target, 0, tmp); return res; &#125; private void helper(int[] nums, int target, int index, List&lt;Integer&gt; tmp)&#123; // 如果当前和已经大于目标，说明该路径错误 if(target &lt; 0)&#123; return; // 如果当前和等于目标，说明这是一条正确路径，记录该路径 &#125; else if(target == 0)&#123; List&lt;Integer&gt; oneComb = new LinkedList&lt;Integer&gt;(tmp); res.add(oneComb); // 否则，对剩余所有可能性进行深度优先搜索 &#125; else &#123; // 选取之后的每个数字都是一种可能性 for(int i = index; i &lt; nums.length; i++)&#123; // 典型的先加入元素，再进行搜索，递归回来再移出元素的DFS解法 tmp.add(nums[i]); helper(nums, target - nums[i], i, tmp); tmp.remove(tmp.size() - 1); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (candidates == null || candidates.length &lt; 1) return res; Arrays.sort(candidates); backtrack(candidates, target, res, new ArrayList&lt;Integer&gt;(), 0); return res;&#125;// 如果不加参数start，会出现：input:[2,3,6,7]7// 结果：[[2,2,3],[2,3,2],[3,2,2],[7]]instead of [[2,2,3],[7]]的情况private void backtrack(int[] nums, int target, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list, int start) &#123; if (target &lt; 0) return; if (target == 0) &#123; res.add(list); return; &#125; //加上target &gt;= nums[i]：33ms to 23ms for (int i = start; i &lt; nums.length &amp;&amp; target &gt;= nums[i]; i++) &#123; list.add(nums[i]); backtrack(nums, target - nums[i], res, new ArrayList&lt;Integer&gt;(list), i); list.remove(list.size() - 1); &#125;&#125;或者，public class Solution &#123; private void solve(List&lt;List&lt;Integer&gt;&gt; res,int currentIndex,int count,List&lt;Integer&gt; tmp,int[] candidates,int target)&#123; if(count&gt;=target) &#123; if(count==target) res.add(new LinkedList&lt;&gt;(tmp)); return; &#125; for(int i = currentIndex;i&lt;candidates.length;i++)&#123; if(count+candidates[i]&gt;target)&#123; break; &#125; tmp.add(candidates[i]); solve(res,i,count+candidates[i],tmp,candidates,target); tmp.remove(tmp.size()-1); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(); Arrays.sort(candidates); solve(res,0,0,tmp,candidates,target); return res; &#125;&#125; 40. Combination Sum IIGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.123456789101112131415161718Example 1:Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]Example 2:Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] 思路： 只需要改动一点点即可，之前那道题给定数组中的数字可以重复使用，而这道题不能重复使用，只需要在之前的基础上修改两个地方即可，首先在递归的for循环里加上if (i &gt; start &amp;&amp; num[i] == num[i - 1]) continue; 这样可以防止res中出现重复项，然后就在递归调用combinationSum2DFS里面的参数换成i+1，这样就不会重复使用数组中的数字了 1234567891011121314151617181920212223242526272829303132public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new LinkedList&lt;Integer&gt;(); Arrays.sort(candidates); helper(candidates, target, 0, tmp); return res; &#125; private void helper(int[] nums, int target, int index, List&lt;Integer&gt; tmp)&#123; if(target &lt; 0)&#123; return; &#125; else if(target == 0)&#123; List&lt;Integer&gt; oneComb = new LinkedList&lt;Integer&gt;(tmp); res.add(oneComb); &#125; else &#123; for(int i = index; i &lt; nums.length; i++)&#123; tmp.add(nums[i]); // 递归时下标加1 helper(nums, target - nums[i], i+1, tmp); tmp.remove(tmp.size() - 1); // 跳过本轮剩余的重复元素 while(i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1])&#123; i++; &#125; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (candidates == null || candidates.length &lt; 1) return res; Arrays.sort(candidates); backtrack(candidates, target, res, new ArrayList&lt;Integer&gt;(), 0); return res;&#125;// 如果不加参数start，会出现：input:[2,3,6,7]7// 结果：[[2,2,3],[2,3,2],[3,2,2],[7]]instead of [[2,2,3],[7]]的情况private void backtrack(int[] nums, int target, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; list, int start) &#123; if (target == 0) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = start; i &lt; nums.length &amp;&amp; target &gt;= nums[i]; i++) &#123; if(i&gt;start&amp;&amp;nums[i]==nums[i-1]) continue; list.add(nums[i]); backtrack(nums, target - nums[i], res, list, i + 1); list.remove(list.size() - 1); &#125;&#125; 41. First Missing PositiveGiven an unsorted integer array, find the smallest missing positive integer.1234567891011Example 1:Input: [1,2,0]Output: 3Example 2:Input: [3,4,-1,1]Output: 2Example 3:Input: [7,8,9,11,12]Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. 思路：1、hashset12345678910111213141516class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int mx = 0; unordered_set&lt;int&gt; s; for (int num : nums) &#123; if (num &lt;= 0) continue; s.insert(num); mx = max(mx, num); &#125; for (int i = 1; i &lt;= mx; ++i) &#123; if (!s.count(i)) return i; &#125; return mx + 1; &#125;&#125;; 2、原地交换，A[i] = i + 1; 注意交换条件A[i] != (i+1) &amp;&amp; A[A[i]-1] != A[i] (防止重复)https://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html1234567891011121314151617class Solution &#123;public: int firstMissingPositive(int A[], int n) &#123; int i = 0; while (i &lt; n) &#123; if (A[i] != (i+1) &amp;&amp; A[i] &gt;= 1 &amp;&amp; A[i] &lt;= n &amp;&amp; A[A[i]-1] != A[i]) swap(A[i], A[A[i]-1]); else i++; &#125; for (i = 0; i &lt; n; ++i) if (A[i] != (i+1)) return i+1; return n+1; &#125;&#125;; 42. Trapping Rain WaterGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example:12Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 思路：1、dp，遍历两遍这种方法是基于动态规划Dynamic Programming的，我们维护一个一维的dp数组，这个DP算法需要遍历两遍数组，第一遍遍历dp[i]中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，然后跟当前值A[i]相比，如果大于当前值，则将差值存入结果，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public int trap(int[] height) &#123; int res = 0, mx = 0, n = height.length; int[] dp = new int[n]; for (int i = 0; i &lt; n; ++i) &#123; dp[i] = mx; mx = Math.max(mx, height[i]); &#125; mx = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; dp[i] = Math.min(dp[i], mx); mx = Math.max(mx, height[i]); if (dp[i] - height[i] &gt; 0) res += dp[i] - height[i]; &#125; return res; &#125;&#125;优化思路： public int trap(int[] height) &#123; if (height == null || height.length &lt; 2) return 0; int leftMax = height[0], rightMax = height[height.length - 1], left = 0, right = height.length - 1; int sum = 0; while (left &lt; right) &#123; leftMax = Math.max(height[left], leftMax); rightMax = Math.max(height[right], rightMax); if (leftMax &lt; rightMax) &#123; sum += leftMax - height[left]; left++; &#125; else &#123; sum += rightMax - height[right]; right--; &#125; &#125; return sum; &#125; 2 stack实现遍历高度，如果此时栈为空，或者当前高度小于等于栈顶高度，则把当前高度的坐标压入栈，注意我们不直接把高度压入栈，而是把坐标压入栈，这样方便我们在后来算水平距离。当我们遇到比栈顶高度大的时候，就说明有可能会有坑存在，可以装雨水。此时我们栈里至少有一个高度，如果只有一个的话，那么不能形成坑，我们直接跳过，如果多余一个的话，那么此时把栈顶元素取出来当作坑，新的栈顶元素就是左边界，当前高度是右边界，只要取二者较小的，减去坑的高度，长度就是右边界坐标减去左边界坐标再减1，二者相乘就是盛水量啦，参见代码如下12345678910111213141516class Solution &#123; public int trap(int[] height) &#123; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int i = 0, n = height.length, res = 0; while (i &lt; n) &#123; if (s.isEmpty() || height[i] &lt;= height[s.peek()]) &#123; s.push(i++); &#125; else &#123; int t = s.pop(); if (s.isEmpty()) continue; res += (Math.min(height[i], height[s.peek()]) - height[t]) * (i - s.peek() - 1); &#125; &#125; return res; &#125;&#125; 43 Multiply StringsGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.123456789Example 1:Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot;Example 2:Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Note: The length of both num1 and num2 is &lt; 110.Both num1 and num2 contain only digits 0-9.Both num1 and num2 do not contain any leading zero, except the number 0 itself.You must not use any built-in BigInteger library or convert the inputs to integer directly. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public String multiply(String num1, String num2) &#123; if (num1 == null || num2 == null || num1.length() == 0 || num2.length() == 0) return null; if(num1.equals("0")||num2.equals("0")) return "0"; int len1 = num1.length(), len2 = num2.length(); int[] arr1 = new int[len1], arr2 = new int[len2]; // 首尾交换，便于计算 for (int i = 0; i &lt; len1; i++) &#123; arr1[len1 - 1 - i] = num1.charAt(i) - '0'; &#125; for (int i = 0; i &lt; len2; i++) &#123; arr2[len2 - 1 - i] = num2.charAt(i) - '0'; &#125; // 两数相乘结果的长度介于len1*len2-1到len1*len2 int[] res = new int[len1 + len2]; for (int i = 0; i &lt; len1; i++) &#123; for (int j = 0; j &lt; len2; j++) &#123; res[i + j] += arr1[i] * arr2[j]; &#125; &#125; for (int i = 0; i &lt; len1 + len2; i++) &#123; while (res[i] &gt;9) &#123; res[i + 1] += res[i] / 10; res[i] = res[i] % 10; &#125; &#125; StringBuilder ans=new StringBuilder(); for (int i = len1 + len2-1; i &gt;=0; i--) &#123; ans.append(res[i]); &#125; //如果第一个元素是0，去除 return ans.charAt(0) == '0' &amp;&amp; ans.length() != 1 ? ans.substring(1) : ans.toString();&#125; public String multiply(String num1, String num2) &#123; if (isZero(num1) || isZero(num2)) &#123; return "0"; &#125; int[] a1 = new int[num1.length()]; int[] a2 = new int[num2.length()]; int[] product = new int[num1.length() + num2.length()]; for (int i = a1.length - 1; i &gt;= 0; i--) &#123; for (int j = a2.length - 1; j &gt;= 0; j--) &#123; int thisProduct = Character.getNumericValue(num1.charAt(i)) * Character.getNumericValue(num2.charAt(j)); product[i + j + 1] += thisProduct % 10; if (product[i + j + 1] &gt;= 10) &#123; product[i + j + 1] %= 10; product[i + j]++; &#125; product[i + j] += thisProduct / 10; if (product[i + j] &gt;= 10) &#123; product[i + j] %= 10; product[i + j - 1]++; &#125; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; product.length; i++) &#123; if (i == 0 &amp;&amp; product[i] == 0) &#123; continue; &#125; stringBuilder.append(product[i]); &#125; return stringBuilder.toString(); &#125; private boolean isZero(String num) &#123; for (char c : num.toCharArray()) &#123; if (c != '0') &#123; return false; &#125; &#125; return true; &#125; 44. Wildcard MatchingImplement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character.‘*’ Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). The function prototype should be:bool isMatch(const char s, const char p)12345678Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false 思路 0 题意是让让你从判断 s 字符串是否通配符匹配于 p，这道题和[Regular Expression Matching][010]很是相似，区别在于 *，正则匹配的 * 不能单独存在，前面必须具有一个字符，其意义是表明前面的这个字符个数可以是任意个数，包括 0 个；而通配符的 * 是可以随意出现的，跟前面字符没有任何关系，其作用是可以表示任意字符串。在此我们可以利用 贪心算法 来解决这个问题，需要两个额外指针 p 和 match 来分别记录最后一个 * 的位置和 * 匹配到 s 字符串的位置，其贪心体现在如果遇到 *，那就尽可能取匹配后方的内容，如果匹配失败，那就回到上一个遇到 * 的位置来继续贪心。 12345678910111213141516171819202122class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.length() == 0) return s.length() == 0; int si = 0, pi = 0, match = 0, star = -1; int sl = s.length(), pl = p.length(); char[] sc = s.toCharArray(), pc = p.toCharArray(); while (si &lt; sl) &#123; if (pi &lt; pl &amp;&amp; (pc[pi] == sc[si] || pc[pi] == '?')) &#123; si++; pi++; &#125; else if (pi &lt; pl &amp;&amp; pc[pi] == '*') &#123; star = pi++; match = si; &#125; else if (star != -1) &#123; si = ++match; pi = star + 1; &#125; else return false; &#125; while (pi &lt; pl &amp;&amp; pc[pi] == '*') pi++; return pi == pl; &#125;&#125; 思路 1 另一种思路就是动态规划了，我们定义 dp[i][j] 的真假来表示 s[0..i) 是否匹配 p[0..j)，其状态转移方程如下所示： 如果 p[j - 1] != &#39;*&#39;，P[i][j] = P[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &#39;?&#39;); 如果 p[j - 1] == &#39;*&#39;，P[i][j] = P[i][j - 1] || P[i - 1][j] 12345678910111213141516171819202122class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.length() == 0) return s.length() == 0; int sl = s.length(), pl = p.length(); boolean[][] dp = new boolean[sl + 1][pl + 1]; char[] sc = s.toCharArray(), pc = p.toCharArray(); dp[0][0] = true; for (int i = 1; i &lt;= pl; ++i) &#123; if (pc[i - 1] == '*') dp[0][i] = dp[0][i - 1]; &#125; for (int i = 1; i &lt;= sl; ++i) &#123; for (int j = 1; j &lt;= pl; ++j) &#123; if (pc[j - 1] != '*') &#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (sc[i - 1] == pc[j - 1] || pc[j - 1] == '?'); &#125; else &#123; dp[i][j] = dp[i][j - 1] || dp[i - 1][j]; &#125; &#125; &#125; return dp[sl][pl]; &#125;&#125; Jump Game II Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.Note: You can assume that you can always reach the last index. 思路：cur是当前能到达的最远位置，last是上一步能到达的最远位置，我们遍历数组，首先用i + nums[i]更新cur，这个在上面解法中讲过了，然后判断如果当前位置到达了last，即上一步能到达的最远位置，说明需要再跳一次了，我们将last赋值为cur，并且步数res自增1，这里我们小优化一下，判断如果cur到达末尾了，直接break掉即可，代码如下 123456789101112131415class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int res = 0, n = nums.size(), last = 0, cur = 0; for (int i = 0; i &lt; n - 1; ++i) &#123; cur = max(cur, i + nums[i]); if (i == last) &#123; last = cur; ++res; if (cur &gt;= n - 1) break; &#125; &#125; return res; &#125;&#125;; 46. Permutations全排列系列： https://blog.csdn.net/ll15311257617/article/details/79858510 Given a collection of numbers, return all possible permutations.123For example,[1,2,3] have the following permutations:[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1]. 思路： 1234567891011121314151617181920212223242526272829303132class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] used = null; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; res.clear(); if(nums.length==0) return res; used = new boolean[nums.length]; permuteAux(nums,0, new ArrayList&lt;&gt;()); return res; &#125; private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) &#123; if(index == nums.length)&#123; List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st); res.add(t); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; st.add(nums[i]); used[i] = true; permuteAux(nums,index+1,st); used[i] = false; st.remove(st.size()-1); &#125; return; &#125;&#125; 另一种交换思路12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; permuteDFS(num, 0, res); return res; &#125; void permuteDFS(vector&lt;int&gt; &amp;num, int start, vector&lt;vector&lt;int&gt; &gt; &amp;res) &#123; if (start &gt;= num.size()) res.push_back(num); for (int i = start; i &lt; num.size(); ++i) &#123; swap(num[start], num[i]); permuteDFS(num, start + 1, res); swap(num[start], num[i]); &#125; &#125;&#125;; 47. Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations.123456789Example:Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 思路：解题思路与46图题基本一致，但是却必须做出一些，改变，首先必须使得数组有序，在对数组中的每个元素进行全排列的时候，如果该元素与前一个元素相同，且前面一个元素已经完成了全排列，则跳过这个元素。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[] used = null; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; res.clear(); if(nums.length==0) return res; used = new boolean[nums.length]; Arrays.sort(nums); permuteAux(nums,0, new ArrayList&lt;&gt;()); return res; &#125; private void permuteAux(int[] nums,int index,List&lt;Integer&gt; st) &#123; if(index == nums.length)&#123; List&lt;Integer&gt; t = new ArrayList&lt;&gt;(st); res.add(t); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; st.add(nums[i]); used[i] = true; permuteAux(nums,index+1,st); used[i] = false; st.remove(st.size()-1); &#125; return; &#125;&#125; 或者直接使用46交换方法+set去重复即可。 48. Rotate ImageYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.123456789101112131415Example 1:Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] 1234567891011121314151617181920212223242526272829303132public static class Solution1 &#123; public void rotate(int[][] matrix) &#123; /**First swap the elements on the diagonal, then reverse each row: * 1, 2, 3 1, 4, 7 7, 4, 1 * 4, 5, 6 becomes 2, 5, 8 becomes 8, 5, 2 * 7, 8, 9 3, 6, 9 9, 6, 3 This is done in O(1) space! **/ int m = matrix.length; for (int i = 0; i &lt; m; i++) &#123; for (int j = i; j &lt; m; j++) &#123; /**ATTN: j starts from i, so that the diagonal changes with itself, results in no change.*/ int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125; /**then reverse*/ for (int i = 0; i &lt; m; i++) &#123; int left = 0; int right = m - 1; while (left &lt; right) &#123; int tmp = matrix[i][left]; matrix[i][left] = matrix[i][right]; matrix[i][right] = tmp; left++; right--; &#125; &#125; &#125;&#125; 49. Group AnagramsGiven an array of strings, group anagrams together. Example:1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase.The order of your output does not matter. 思路：错位词，所谓的错位词就是两个字符串中字母出现的次数都一样，只是位置不同，比如abc，bac, cba等它们就互为错位词，那么我们如何判断两者是否是错位词呢 123456789101112131415161718public class _49 &#123; public static class Solution1 &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String word : strs) &#123; char[] c = word.toCharArray(); Arrays.sort(c); String key = new String(c); if (!map.containsKey(key)) &#123; map.put(key, new ArrayList&lt;&gt;()); &#125; map.get(key).add(word); &#125; return new ArrayList&lt;&gt;(map.values()); &#125; &#125;&#125; 50. Pow(x, n)Implement pow(x, n), which calculates x raised to the power n (xn).123456789101112Example 1:Input: 2.00000, 10Output: 1024.00000Example 2:Input: 2.10000, 3Output: 9.26100Example 3:Input: 2.00000, -2Output: 0.25000Explanation: 2^-2 = 1/2^2 = 1/4 = 0.25 Note: -100.0 &lt; x &lt; 100.0n is a 32-bit signed integer, within the range [−2^31, 2^31 − 1] 思路：二分12345678910111213class Solution &#123;public: double myPow(double x, int n) &#123; if (n &lt; 0) return 1 / power(x, -n); return power(x, n); &#125; double power(double x, int n) &#123; if (n == 0) return 1; double half = power(x, n / 2); if (n % 2 == 0) return half * half; return x * half * half; &#125;&#125;; 1234567891011class Solution &#123;public: double myPow(double x, int n) &#123; double res = 1.0; for (int i = n; i != 0; i /= 2) &#123; if (i % 2 != 0) res *= x; x *= x; &#125; return n &lt; 0 ? 1 / res : res; &#125;&#125;; 51. N-Queenshttps://segmentfault.com/a/1190000003762668The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.123456789101112131415Example:Input: 4Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. 思路：dfs爆破123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Solution &#123; List&lt;List&lt;String&gt;&gt; res; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; res = new LinkedList&lt;List&lt;String&gt;&gt;(); int[] nqueens = new int[n]; helper(nqueens, n, 0); return res; &#125; public void helper(int[] nqueens, int n, int i)&#123; if(i == nqueens.length)&#123; List&lt;String&gt; one = new LinkedList&lt;String&gt;(); // 构成表示整个棋盘的字符串 for(int num : nqueens)&#123; // 构成一个形如....Q....的字符串 StringBuilder sb = new StringBuilder(); for(int j = 0; j &lt; num; j++)&#123; sb.append('.'); &#125; sb.append('Q'); for(int j = num + 1; j &lt; n; j++)&#123; sb.append('.'); &#125; one.add(sb.toString()); &#125; res.add(one); &#125; else &#123; //选择下一列的数字 // 比如之前已经选了13xxxxxx，下一列可以选6，形成136xxxxx for(int num = 0; num &lt; n; num++)&#123; nqueens[i] = num; // 如果是有效的，继续搜索 if(isValid(nqueens, i))&#123; helper(nqueens, n, i+1); &#125; &#125; &#125; &#125; private boolean isValid(int[] nqueens, int i)&#123; for(int idx = 0; idx &lt; i; idx++)&#123; // 检查对角线只要判断他们差的绝对值和坐标的差是否相等就行了 if(nqueens[idx] == nqueens[i] || Math.abs(nqueens[idx] - nqueens[i]) == i - idx)&#123; return false; &#125; &#125; return true; &#125;&#125; 52. N-Queens IIThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. 123456789101112131415161718192021222324252627282930313233public class Solution &#123; List&lt;List&lt;String&gt;&gt; res; int cnt = 0; public int totalNQueens(int n) &#123; int[] nqueens = new int[n]; helper(nqueens, n, 0); return cnt; &#125; public void helper(int[] nqueens, int n, int i)&#123; if(i == nqueens.length)&#123; cnt++; &#125; else &#123; for(int num = 0; num &lt; n; num++)&#123; nqueens[i] = num; if(isValid(nqueens, i))&#123; helper(nqueens, n, i+1); &#125; &#125; &#125; &#125; private boolean isValid(int[] nqueens, int i)&#123; for(int idx = 0; idx &lt; i; idx++)&#123; if(nqueens[idx] == nqueens[i] || Math.abs(nqueens[idx] - nqueens[i]) == i - idx)&#123; return false; &#125; &#125; return true; &#125;&#125; 53 Maximum SubarrayFind the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6. 思路：动态规划+空间优化这是一道非常典型的动态规划题，为了求整个字符串最大的子序列和，我们将先求较小的字符串的最大子序列和。这里我们从后向前、从前向后计算都是可以的。在从前向后计算的方法中，我们将第i个元素之前最大的子序列和存入一个一维数组dp中，对第i+1个元素来说，它的值取决于dp[i]，如果dp[i]是负数，那就没有必要加上它，因为这只会拖累子序列的最大和。如果是正数就加上它。最后我们再讲第i+1个元素自身加进去，就得到了第i+1个元素之前最大的子序列和。123456789101112public class Solution &#123; public int maxSubArray(int[] nums) &#123; int[] dp = new int[nums.length]; int max = nums[0]; dp[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++)&#123; dp[i] = dp[i-1]&gt;0? dp[i-1] + nums[i] : nums[i]; max = Math.max(dp[i],max); &#125; return max; &#125;&#125; 空间优化，dp[i]只与dp[i-1]有关1234567891011public class Solution &#123; public int maxSubArray(int[] nums) &#123; int max = nums[0]; int sum = nums[0]; for(int i = 1; i &lt; nums.length; i++)&#123; sum = sum &lt; 0 ? nums[i] : sum + nums[i]; max = Math.max(sum, max); &#125; return max; &#125;&#125; 54. Spiral Matrix螺旋矩阵Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.123456789101112131415161718Example 1:Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5]Example 2:Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] 思路：顺序打印即可，注意计算1、圈数是宽和高中较小的那个，加1再除以22、对应最后的行列计算int lastRow = m - i - 1; int lastCol = n - i - 1;1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;(); if(matrix.length == 0) return res; int m = matrix.length, n = matrix[0].length; // 计算圈数 int lvl = (Math.min(m, n) + 1) / 2; for(int i = 0; i &lt; lvl; i++)&#123; // 计算相对应的该圈最后一行 int lastRow = m - i - 1; // 计算相对应的该圈最后一列 int lastCol = n - i - 1; // 如果该圈第一行就是最后一行，说明只剩下一行 if(i == lastRow)&#123; for(int j = i; j &lt;= lastCol; j++)&#123; res.add(matrix[i][j]); &#125; // 如果该圈第一列就是最后一列，说明只剩下一列 &#125; else if(i == lastCol)&#123; for(int j = i; j &lt;= lastRow; j++)&#123; res.add(matrix[j][i]); &#125; &#125; else &#123; // 第一行 for(int j = i; j &lt; lastCol; j++)&#123; res.add(matrix[i][j]); &#125; // 最后一列 for(int j = i; j &lt; lastRow; j++)&#123; res.add(matrix[j][lastCol]); &#125; // 最后一行 for(int j = lastCol; j &gt; i; j--)&#123; res.add(matrix[lastRow][j]); &#125; // 第一列 for(int j = lastRow; j &gt; i; j--)&#123; res.add(matrix[j][i]); &#125; &#125; &#125; return res; &#125;&#125; 55. Jump GameGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.12345678910Example 1:Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 思路：我们只希望知道能否到达末尾，也就是说我们只对最远能到达的位置感兴趣，所以我们维护一个变量reach，表示最远能到达的位置，初始化为0。遍历数组中每一个数字，如果当前坐标大于reach或者reach已经抵达最后一个位置则跳出循环，否则就更新reach的值为其和i + nums[i]中的较大值，其中i + nums[i]表示当前位置能到达的最大位置，代码如下： 1234567891011class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), reach = 0; for (int i = 0; i &lt; n; ++i) &#123; if (i &gt; reach || reach &gt;= n - 1) break; reach = max(reach, i + nums[i]); &#125; return reach &gt;= n - 1; &#125;&#125;; 1234567891011121314public static class Solution1 &#123; public boolean canJump(int[] nums) &#123; int farthest = nums[0]; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &lt;= farthest &amp;&amp; nums[i] + i &gt; farthest) &#123; // i &lt;= farthest is to make sure that this current i is within the current range // i &gt; fathest 说明上一步最远也不能到达i这个位置 // nums[i]+i &gt; farthest is to make sure that it's necessary to update farthest with current nums[i]+i farthest = nums[i] + i; &#125; &#125; return farthest &gt;= nums.length - 1; &#125; &#125; 56. Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.123456789Example 1:Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2:Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considerred overlapping. 123456789/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */ 思路：首先根据Interval的起点，我们将其排序，这样能合并的Interval就一定是相邻的了：[1,3] [5,6] [2,3]—&gt; [1,3] [2,3] [5,6]然后我们就顺序遍历这个列表，并记录一个当前待合并的Interval，如果遍历到的Interval和当前待合并的Interval有重复部分，我们就将两个合并，如果没有重复部分，就将待合并的Interval加入结果中，并用新的Interval更新这个待合并的Interval。因为数组已经排过序，前面的Interval的起点肯定小于后面Interval的起点，所以在判断是否有重叠部分时，只要考虑待合并的Interval的终点和遍历到的Interval的起点的关系就行了。 123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res = new LinkedList&lt;Interval&gt;(); if(intervals.size() == 0)&#123; return res; &#125; // 按照起点排序 Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; public int compare(Interval i1, Interval i2)&#123; return i1.start - i2.start; &#125; &#125;); // 拿出第一个待合并的Interval Interval curr = intervals.get(0); for(Interval itv : intervals)&#123; // 如果有重叠部分，更新待合并的Interval的起点和终点 if(curr.end &gt;= itv.start)&#123; curr.start = Math.min(curr.start, itv.start); curr.end = Math.max(curr.end, itv.end); &#125; else &#123; // 否则将待合并的Interval加入结果中，并选取新的待合并Interval res.add(curr); curr = itv; &#125; &#125; // 将最后一个待合并的加进结果 res.add(curr); return res; &#125;&#125; 57. Insert IntervalGiven a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.123Example 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 1234567891011121314151617181920212223242526public class _57 &#123; public static class Solution1 &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); int i = 0; // add all the intervals ending before newInterval starts while (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start) &#123; result.add(intervals.get(i++)); &#125; // merge all overlapping intervals to one considering newInterval while (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123; newInterval = new Interval( // we could mutate newInterval here also Math.min(newInterval.start, intervals.get(i).start), Math.max(newInterval.end, intervals.get(i).end)); i++; &#125; result.add(newInterval); // add all the rest while (i &lt; intervals.size()) &#123; result.add(intervals.get(i++)); &#125; return result; &#125; &#125;&#125; 58. Length of Last WordGiven a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example:12Input: &quot;Hello World&quot;Output: 5 12345678910111213public static class Solution1 &#123; public int lengthOfLastWord(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; s = s.trim(); int n = s.length() - 1; while (n &gt;= 0 &amp;&amp; s.charAt(n) != ' ') &#123; n--; &#125; return s.length() - n - 1; &#125;&#125; 59. Spiral Matrix IIGiven a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3Output:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; int left = 0, right = n - 1, bottom = n - 1, top = 0, num = 1; while(left &lt; right &amp;&amp; top &lt; bottom)&#123; // 添加该圈第一行 for(int i = left; i &lt; right; i++)&#123; res[top][i] = num++; &#125; // 添加最后一列 for(int i = top; i &lt; bottom; i++)&#123; res[i][right] = num++; &#125; // 添加最后一行 for(int i = right; i &gt; left; i--)&#123; res[bottom][i] = num++; &#125; // 添加第一列 for(int i = bottom; i &gt; top; i--)&#123; res[i][left] = num++; &#125; top++; bottom--; left++; right--; &#125; // 如果是奇数，加上中间那个点 if(n % 2 == 1)&#123; res[n / 2][n / 2] = num; &#125; return res; &#125;&#125; 60. Permutation SequenceThe set [1,2,3,…,n] contains a total of n! unique permutations.123456789By listing and labeling all of the permutations in order, we get the following sequence for n = 3:&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive.Given k will be between 1 and n! inclusive.123456789Example 1:Input: n = 3, k = 3Output: &quot;213&quot;Example 2:Input: n = 4, k = 9Output: &quot;2314&quot; 思路：固定技巧 这道题是让求出n个数字的第k个排列组合，由于其特殊性，我们不用将所有的排列组合的情况都求出来，然后返回其第k个，我们可以只求出第k个排列组合即可，那么难点就在于如何知道数字的排列顺序，可参见网友喜刷刷的博客，首先我们要知道当n = 3时，其排列组合共有3! = 6种，当n = 4时，其排列组合共有4! = 24种，我们就以n = 4, k = 17的情况来分析，所有排列组合情况如下： 12341243132413421423143221342143231423412413243131243142321432413412 &lt;— k = 173421412341324213423143124321 我们可以发现，每一位上1,2,3,4分别都出现了6次，当第一位上的数字确定了，后面三位上每个数字都出现了2次，当第二位也确定了，后面的数字都只出现了1次，当第三位确定了，那么第四位上的数字也只能出现一次，那么下面我们来看k = 17这种情况的每位数字如何确定，由于k = 17是转化为数组下标为16：12345678910111213141516171819最高位可取1,2,3,4中的一个，每个数字出现3！= 6次，所以k = 16的第一位数字的下标为16 / 6 = 2，即3被取出第二位此时从1,2,4中取一个，k = 16是此时的k&apos; = 16 % (3!) = 4，而剩下的每个数字出现2！= 2次，所以第二数字的下标为4 / 2 = 2，即4被取出第三位此时从1,2中去一个，k&apos; = 4是此时的k&apos;&apos; = 4 % (2!) = 0，而剩下的每个数字出现1！= 1次，所以第三个数字的下标为 0 / 1 = 0，即1被取出第四位是从2中取一个，k&apos;&apos; = 0是此时的k&apos;&apos;&apos; = 0 % (1!) = 0，而剩下的每个数字出现0！= 1次，所以第四个数字的下标为0 / 1= 0，即2被取出那么我们就可以找出规律了a1 = k / (n - 1)!k1 = ka2 = k1 / (n - 2)!k2 = k1 % (n - 2)!...an-1 = kn-2 / 1!kn-1 = kn-2 / 1!an = kn-1 / 0!kn = kn-1 % 0! 1234567891011121314string getPermutation(int n, int k) &#123; string res; string num = "123456789"; vector&lt;int&gt; f(n, 1); for (int i = 1; i &lt; n; ++i) f[i] = f[i - 1] * i; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; res.push_back(num[j]); num.erase(j, 1); &#125; return res; &#125; 1234567891011121314151617181920212223public String getPermutation(int n, int k) &#123; int[] nums = new int[n + 1]; int permcount = 1; for (int i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; // put 1, 2, 3 ... n into nums[] permcount *= (i + 1); &#125; k--; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; permcount = permcount / (n - i); int idx = k / permcount;// the index that this position should // choose sb.append(nums[idx]); // left shift nums[] by one bit for (int j = idx; j &lt; n - i; j++) &#123; nums[j] = nums[j + 1]; &#125; k %= permcount; &#125; return sb.toString(); &#125; 61. Rotate ListGiven a linked list, rotate the list to the right by k places, where k is non-negative.123456789101112131415Example 1:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExample 2:Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 思路1：一个指针就够了，原理是先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走n - k % n个节点就到达新链表的头结点前一个点，这时断开链表即可，代码如下: 1234567891011121314151617ListNode *rotateRight(ListNode *head, int k) &#123; if (!head) return NULL; int n = 1; ListNode *cur = head; while (cur-&gt;next) &#123; ++n; cur = cur-&gt;next; &#125; cur-&gt;next = head; int m = n - k % n; for (int i = 0; i &lt; m; ++i) &#123; cur = cur-&gt;next; &#125; ListNode *newhead = cur-&gt;next; cur-&gt;next = NULL; return newhead; &#125; 思路2：快慢指针,旋转链表的本质，就是把链表的后半部分放到前面来，所以关键在于如何找链表后半部分的起始节点。实际上，我们用一个快指针先走k步，然后快慢指针同时走，这样当快指针到末尾时，慢指针就到链表后半部分的起始节点了。不过，由于k可能大于链表的长度，所以我们要先对k取链表长度的模。要计算链表长度只要遍历一遍链表就行了。 1234567891011121314151617181920212223242526272829public ListNode rotateRight(ListNode head, int k) &#123; ListNode fast = head; int length = 0; // 计算链表长度 while(fast != null)&#123; length++; fast = fast.next; &#125; // 如果不旋转或者原链表为空 则直接返回 if(head == null || k % length == 0)&#123; return head; &#125; fast = head; // 让快指针先走k步 for(int i = 0; i &lt; k % length; i++)&#123; fast = fast.next; &#125; // 找到新头节点的前一个节点 ListNode slow = head; while(fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; // 将后半部分放到前面来 ListNode newHead = slow.next; slow.next = null; fast.next = head; return newHead; &#125; 62. Unique PathsA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? 思路：动态规划+扫描空间优化动态规划Dynamic Programming来解，我们可以维护一个二维数组dp，其中dp[i][j]表示到当前位置不同的走法的个数，然后可以得到递推式为: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，这里为了节省空间，我们使用一维数组dp，一行一行的刷新也可以. 123456789101112131415public int uniquePaths(int m, int n) &#123; int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++)&#123; dp[i][0] = 1; &#125; for(int i = 0; i &lt; n; i++)&#123; dp[0][i] = 1; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125; 12345678910public int uniquePaths(int m, int n) &#123; int[] dp = new int[n]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; // 每一行的第一个数都是1 dp[j] = j == 0 ? 1 : dp[j - 1] + dp[j]; &#125; &#125; return dp[n - 1];&#125; 123456789101112class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(n, 1); for (int i = 1; i &lt; m; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125;; 63. Unique Paths IIA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100.1234567891011121314Example 1:Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right 思路：直接改造上一道题即可。 123456789public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int[] dp = new int[obstacleGrid[0].length]; for(int i = 0; i &lt; obstacleGrid.length; i++)&#123; for(int j = 0; j &lt; obstacleGrid[0].length; j++)&#123; dp[j] = obstacleGrid[i][j] == 1 ? 0 : (j == 0 ? (i == 0 ? 1 : dp[j]) : dp[j - 1] + dp[j]); &#125; &#125; return dp[obstacleGrid[0].length - 1]; &#125; 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123; if (obstacleGrid.empty() || obstacleGrid[0].empty()) return 0; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if (obstacleGrid[0][0] == 1) return 0; vector&lt;int&gt; dp(n, 0); dp[0] = 1; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (obstacleGrid[i][j] == 1) dp[j] = 0; else if (j &gt; 0) dp[j] += dp[j - 1]; &#125; &#125; return dp[n - 1]; &#125;&#125;; 64. Minimum Path SumGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example:12345678Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. 思路：动态规划12345678910111213141516171819202122public int minPathSum(int[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int height = grid.length; int width = grid[0].length; int[][] dp = new int[height][width]; dp[0][0] = grid[0][0]; for (int i = 1; i &lt; height; i++) &#123; dp[i][0] = dp[i - 1][0] + grid[i][0]; &#125; for (int j = 1; j &lt; width; j++) &#123; dp[0][j] = dp[0][j - 1] + grid[0][j]; &#125; for (int i = 1; i &lt; height; i++) &#123; for (int j = 1; j &lt; width; j++) &#123; dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; &#125; &#125; return dp[height - 1][width - 1];&#125; 65. Valid Number验证数字 http://www.cnblogs.com/grandyang/p/4084408.htmlValidate if a given string is numeric. Some examples:“0” =&gt; true“ 0.1 “ =&gt; true“abc” =&gt; false“1 a” =&gt; false“2e10” =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. 思路：首先，从题目中给的一些例子可以分析出来，我们所需要关注的除了数字以外的特殊字符有空格 ‘ ’， 小数点 ‘.’, 自然数 ‘e/E’, 还要加上正负号 ‘+/-“， 除了这些字符需要考虑意外，出现了任何其他的字符，可以马上判定不是数字。下面我们来一一分析这些出现了也可能是数字的特殊字符： 空格 ‘ ’： 空格分为两种情况需要考虑，一种是出现在开头和末尾的空格，一种是出现在中间的字符。出现在开头和末尾的空格不影响数字，而一旦中间出现了空格，则立马不是数字。解决方法：预处理时去掉字符的首位空格，中间再检测到空格，则判定不是数字。 小数点 ‘.’：小数点需要分的情况较多，首先的是小数点只能出现一次，但是小数点可以出现在任何位置，开头(“.3”), 中间(“1.e2”), 以及结尾(“1.” ), 而且需要注意的是，小数点不能出现在自然数 ‘e/E’ 之后，如 “1e.1” false, “1e1.1” false。还有，当小数点位于末尾时，前面必须是数字，如 “1.” true，” -.” false。解决方法：开头中间结尾三个位置分开讨论情况。 自然数 ‘e/E’：自然数的前后必须有数字，即自然数不能出现在开头和结尾，如 “e” false, “.e1” false, “3.e” false, “3.e1” true。而且小数点只能出现在自然数之前，还有就是自然数前面不能是符号，如 “+e1” false, “1+e” false. 解决方法：开头中间结尾三个位置分开讨论情况。 正负号 ‘+/-“，正负号可以再开头出现，可以再自然数e之后出现，但不能是最后一个字符，后面得有数字，如 “+1.e+5” true。解决方法：开头中间结尾三个位置分开讨论情况。 1234567891011121314151617181920212223242526class Solution &#123;public: bool isNumber(string s) &#123; bool num = false, numAfterE = true, dot = false, exp = false, sign = false; int n = s.size(); for (int i = 0; i &lt; n; ++i) &#123; if (s[i] == &apos; &apos;) &#123; if (i &lt; n - 1 &amp;&amp; s[i + 1] != &apos; &apos; &amp;&amp; (num || dot || exp || sign)) return false; &#125; else if (s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) &#123; if (i &gt; 0 &amp;&amp; s[i - 1] != &apos;e&apos; &amp;&amp; s[i - 1] != &apos; &apos;) return false; sign = true; &#125; else if (s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;) &#123; num = true; numAfterE = true; &#125; else if (s[i] == &apos;.&apos;) &#123; if (dot || exp) return false; dot = true; &#125; else if (s[i] == &apos;e&apos;) &#123; if (exp || !num) return false; exp = true; numAfterE = false; &#125; else return false; &#125; return num &amp;&amp; numAfterE; &#125;&#125;; 其他思路：利用有限自动机Finite Automata Machine的程序写的简洁优雅 (http://blog.csdn.net/kenden23/article/details/18696083), 还有利用正则表达式，更是写的丧心病狂的简洁 (http://blog.csdn.net/fightforyourdream/article/details/12900751) 1234567891011public boolean isNumber(String s) &#123; if(s.trim().isEmpty())&#123; return false; &#125; String regex = "[-+]?(\\d+\\.?|\\.\\d+)\\d*(e[-+]?\\d+)?"; if(s.trim().matches(regex))&#123; return true; &#125; else&#123; return false; &#125; &#125; 66. Plus OneGiven a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.123456789Example 1:Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2:Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 12345678910111213public int[] plusOne(int[] digits) &#123; int n = digits.length; for (int i = digits.length - 1; i &gt;= 0; --i) &#123; if (digits[i] &lt; 9) &#123; ++digits[i]; return digits; &#125; digits[i] = 0; &#125; int[] res = new int[n + 1]; res[0] = 1; return res; &#125; 进位法12345678910111213public int[] plusOne(int[] digits) &#123; if (digits.length == 0) return digits; int carry = 1, n = digits.length; for (int i = digits.length - 1; i &gt;= 0; --i) &#123; if (carry == 0) return digits; int sum = digits[i] + carry; digits[i] = sum % 10; carry = sum / 10; &#125; int[] res = new int[n + 1]; res[0] = 1; return carry == 0 ? digits : res; &#125; 67. Add BinaryGiven two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0.123456789Example 1:Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot;Example 2:Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; 思路：i &gt;=0 || j &gt;=0 循环，字符串长度不同，可以填0处理。 123456789101112131415public String addBinary(String a, String b) &#123; int i = a.length() - 1, j = b.length() - 1, carry = 0; StringBuilder sb = new StringBuilder(); while(i &gt;=0 || j &gt;=0)&#123; int m = i &gt;= 0 ? a.charAt(i) - '0' : 0; int n = j &gt;= 0 ? b.charAt(j) - '0' : 0; int sum = m + n + carry; carry = sum / 2; sb.insert(0, String.valueOf(sum % 2)); i--; j--; &#125; if(carry != 0) sb.insert(0, '1'); return sb.toString(); &#125; 68. Text JustificationGiven an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly Lcharacters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words.1234567891011For example,words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]L: 16.Return the formatted lines as:[ &quot;This is an&quot;, &quot;example of text&quot;, &quot;justification. &quot;] 文本对齐：http://www.cnblogs.com/grandyang/p/4350381.html 69. Sqrt(x)DescriptionImplement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2Example 2: Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. 二分123456789101112public int mySqrt(int x) &#123; long low = 0 , high = x / 2; while(low &lt;= high)&#123; int mid = low + (high - low) / 2; if(mid * mid &lt; x)&#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return (int)high; &#125; 牛顿其中x1是上次计算结果，x2是本次计算结果，当他的误差小于一定值时返回。初始x值可选n/2，或者神奇数0x5f37642f。 https://segmentfault.com/a/11900000036972041234567891011public int sqrt(int x) &#123; // 如果初始值取0x5f37642f，则会进一步加快计算速度 double x1 = x/2.0; double x2 = 0.0, err = x2 - x1; while(Math.abs(err)&gt;0.00000001)&#123; x2 = x1 - (x1 * x1 - x) / (2 * x1); err = x2 - x1; x1 = x2; &#125; return (int)x2; &#125; 70. Climbing StairsYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 题意是爬楼梯，每次你只能爬一步或者两步，问到顶层共有多少种方案。我们假设到顶层共有 f(n) 种，那么 f(n) = f(n - 1) + f(n - 2) 肯定是成立的. 12345678public int climbStairs(int n) &#123; int a = 1, b = 1; while (--n &gt; 0) &#123; b += a; a = b - a; &#125; return b; &#125; 71. Simplify PathGiven an absolute path for a file (Unix-style), simplify it.12345678910For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot;Corner Cases:Did you consider the case where path = &quot;/../&quot;?In this case, you should return &quot;/&quot;.Another corner case is the path might contain multiple slashes &apos;/&apos; together, such as &quot;/home//foo/&quot;.In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 123456789101112131415public class Solution &#123; public String simplifyPath(String path) &#123; Stack&lt;String&gt; s = new Stack&lt;&gt;(); String[] p = path.split("/"); for (String t : p) &#123; if (!s.isEmpty() &amp;&amp; t.equals("..")) &#123; s.pop(); &#125; else if (!t.equals(".") &amp;&amp; !t.equals("") &amp;&amp; !t.equals("..")) &#123; s.push(t); &#125; &#125; List&lt;String&gt; list = new ArrayList(s); return "/" + String.join("/", list); &#125;&#125; 72. Edit DistanceGiven two words word1 and word2, find the minimum number of operations required to convert word1 to word2.12345678910111213141516171819202122232425You have the following 3 operations permitted on a word:Insert a characterDelete a characterReplace a characterExample 1:Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)rorse -&gt; rose (remove &apos;r&apos;)rose -&gt; ros (remove &apos;e&apos;)Example 2:Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &apos;t&apos;)inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)exection -&gt; execution (insert &apos;u&apos;) 思路：dp[i-1][j-1]表示一个长为i-1的字符串str1变为长为j-1的字符串str2的最短距离 这道题让求从一个字符串转变到另一个字符串需要的变换步骤，共有三种变换方式，插入一个字符，删除一个字符，和替换一个字符。根据以往的经验，对于字符串相关的题目十有八九都是用动态规划Dynamic Programming来解，这道题也不例外。这道题我们需要维护一个二维的数组dp，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。跟以往的DP题目类似，难点还是在于找出递推式，我们可以举个例子来看，比如word1是“bbc”，word2是”abcd“，那么我们可以得到dp数组如下： 12345Ø a b c dØ 0 1 2 3 4b 1 1 1 2 3b 2 2 1 2 3c 3 3 2 1 2 我们通过观察可以发现，当word1[i] == word2[j]时，dp[i][j] = dp[i - 1][j - 1]，其他情况时，dp[i][j]是其左，左上，上的三个值中的最小值加1，那么可以得到递推式为：1234if word1[i - 1] == word2[j - 1] dp[i][j] = dp[i - 1][j - 1];else dp[i][j] =min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; 12345678910111213141516int minDistance(string word1, string word2) &#123; int n1 = word1.size(), n2 = word2.size(); int dp[n1 + 1][n2 + 1]; for (int i = 0; i &lt;= n1; ++i) dp[i][0] = i; for (int i = 0; i &lt;= n2; ++i) dp[0][i] = i; for (int i = 1; i &lt;= n1; ++i) &#123; for (int j = 1; j &lt;= n2; ++j) &#123; if (word1[i - 1] == word2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; else &#123; dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1; &#125; &#125; &#125; return dp[n1][n2]; &#125; 123456789101112131415161718192021222324public int minDistance(String word1, String word2) &#123; int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; // 初始化空字符串的情况 for(int i = 1; i &lt;= m; i++)&#123; dp[i][0] = i; &#125; for(int i = 1; i &lt;= n; i++)&#123; dp[0][i] = i; &#125; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; // 增加操作：str1a变成str2后再加上b，得到str2b int insertion = dp[i][j-1] + 1; // 删除操作：str1a删除a后，再由str1变为str2b int deletion = dp[i-1][j] + 1; // 替换操作：先由str1变为str2，然后str1a的a替换为b，得到str2b int replace = dp[i-1][j-1] + (word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1); // 三者取最小 dp[i][j] = Math.min(replace, Math.min(insertion, deletion)); &#125; &#125; return dp[m][n]; &#125; 73. Set Matrix ZeroesGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.1234567891011121314151617181920212223242526272829Example 1:Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]]Example 2:Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 思路：实际上，我们只需要直到哪些行，哪些列需要被置0就行了，最简单的方法就是建两个大小分别为M和N的数组，来记录哪些行哪些列应该被置0。那有没有可能不用额外空间呢？我们其实可以借用原矩阵的首行和首列来存储这个信息。这个方法的缺点在于，如果我们直接将0存入首行或首列来表示相应行和列要置0的话，我们很难判断首行或者首列自己是不是该置0。这里我们用两个boolean变量记录下首行和首列原本有没有0，然后在其他位置置完0后，再单独根据boolean变量来处理首行和首列，就避免了干扰的问题。 123456789101112131415161718192021222324252627282930313233public void setZeroes(int[][] matrix) &#123; if(matrix.length == 0) return; boolean firstRowZero = false, firstColZero = false; // 记录哪些行哪些列需要置0，并判断首行首列是否需要置0 for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; if(i != 0 &amp;&amp; j != 0 &amp;&amp; matrix[i][j] == 0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; else if (matrix[i][j] == 0)&#123; // 如果首行或首列出现0，则标记其需要置0，否则沿用上次值 firstRowZero = i == 0 ? true : firstRowZero; firstColZero = j == 0 ? true : firstColZero; &#125; &#125; &#125; // 将除首行首列的位置置0 for(int i = 1; i &lt; matrix.length; i++)&#123; for(int j = 1; j &lt; matrix[0].length; j++)&#123; if(matrix[0][j] == 0 || matrix[i][0] == 0)&#123; matrix[i][j] = 0; &#125; &#125; &#125; // 如果必要，将首列置0 for(int i = 0; firstColZero &amp;&amp; i &lt; matrix.length; i++)&#123; matrix[i][0] = 0; &#125; // 如果必要，将首行置0 for(int j = 0; firstRowZero &amp;&amp; j &lt; matrix[0].length; j++)&#123; matrix[0][j] = 0; &#125; &#125; 74. Search a 2D MatrixWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row.12345678910111213141516171819Example 1:Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: trueExample 2:Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13Output: false 思路：二分12345678910111213141516171819public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; if(m == 0) return false; int n = matrix[0].length; int min = 0, max = m * n - 1; while(min &lt;= max)&#123; int mid = min + (max - min) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target)&#123; return true; &#125; else if (matrix[row][col] &lt; target)&#123; min = mid + 1; &#125; else &#123; max = mid - 1; &#125; &#125; return false; &#125; 75. Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem.1234Example:Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.Could you come up with a one-pass algorithm using only constant space? 思路：我们先用两个指针，一个指向已经排好序的0的序列的后一个点，一个指向已经排好序的2的序列的前一个点。这样在一开始，两个指针是指向头和尾的，因为我们还没有开始排序。然后我们遍历数组，当遇到0时，将其和0序列后面一个数交换，然后将0序列的指针向后移。当遇到2时，将其和2序列前面一个数交换，然后将2序列的指针向前移。遇到1时，不做处理。这样，当我们遍历到2序列开头时，实际上我们已经排好序了，因为所有0都被交换到了前面，所有2都被交换到了后面。 12345678910111213141516171819202122232425262728public class Solution &#123; public void sortColors(int[] nums) &#123; int left = 0, right = nums.length - 1; int i = 0; while(i &lt;= right)&#123; // 遇到0交换到前面 if(nums[i] == 0)&#123; swap(nums, i, left); left++; // 因为左边必定有序，所以可以直接i++ i++; // 遇到2交换到后面 &#125; else if(nums[i] == 2)&#123; swap(nums, i, right); right--; &#125; else &#123; // 遇到1跳过 i++; &#125; &#125; &#125; private void swap(int[] nums, int i1, int i2)&#123; int tmp = nums[i1]; nums[i1] = nums[i2]; nums[i2] = tmp; &#125;&#125; 76. Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).1234Example:Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot; Note: If there is no such window in S that covers all characters in T, return the empty string “”.If there is such window, you are guaranteed that there will always be only one unique minimum window in S. 思路用一个哈希表记录目标字符串每个字母的个数，一个哈希表记录窗口中每个字母的个数。先找到第一个有效的窗口，用两个指针标出它的上界和下界。然后每次窗口右界向右移时，将左边尽可能的右缩，右缩的条件是窗口中字母的个数不小于目标字符串中字母的个数。 注意用一个数组来保存每个字符出现的次数，比哈希表容易 保存结果子串的起始点初值为-1，方便最后判断是否有正确结果 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public String minWindow(String S, String T) &#123; int[] srcHash = new int[255]; // 记录目标字符串每个字母出现次数 for(int i = 0; i &lt; T.length(); i++)&#123; srcHash[T.charAt(i)]++; &#125; int start = 0,i= 0; // 用于记录窗口内每个字母出现次数 int[] destHash = new int[255]; int found = 0; int begin = -1, end = S.length(), minLength = S.length(); for(start = i = 0; i &lt; S.length(); i++)&#123; // 每来一个字符给它的出现次数加1 destHash[S.charAt(i)]++; // 如果加1后这个字符的数量不超过目标串中该字符的数量，则找到了一个匹配字符 if(destHash[S.charAt(i)] &lt;= srcHash[S.charAt(i)]) found++; // 如果找到的匹配字符数等于目标串长度，说明找到了一个符合要求的子串 if(found == T.length())&#123; // 将开头没用的都跳过，没用是指该字符出现次数超过了目标串中出现的次数，并把它们出现次数都减1 while(start &lt; i &amp;&amp; destHash[S.charAt(start)] &gt; srcHash[S.charAt(start)])&#123; destHash[S.charAt(start)]--; start++; &#125; // 这时候start指向该子串开头的字母，判断该子串长度 if(i - start &lt; minLength)&#123; minLength = i - start; begin = start; end = i; &#125; // 把开头的这个匹配字符跳过，并将匹配字符数减1 destHash[S.charAt(start)]--; found--; // 子串起始位置加1，我们开始看下一个子串了 start++; &#125; &#125; // 如果begin没有修改过，返回空 return begin == -1 ? "" : S.substring(begin,end + 1); &#125;&#125; 77. CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. Example:12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 思路：通过深度优先搜索，回溯出所有可能性即可。时间 O(N) 空间 O(K) 12345678910111213141516171819202122232425262728293031public class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; dfs(1, k, n, new ArrayList&lt;Integer&gt;()); return res; &#125; private void dfs(int start, int k, int n, List&lt;Integer&gt; tmp)&#123; // 当已经选择足够数字时，将tmp加入结果 if(k == 0)&#123; res.add(new ArrayList&lt;Integer&gt;(tmp)); System.out.println(tmp); return; &#125; // 每一种选择数字的可能 for(int i = start; i &lt;= n; i++)&#123; tmp.add(i); dfs(i + 1, k - 1, n, tmp); tmp.remove(tmp.size() - 1); &#125; &#125;&#125;[1, 2][1, 3][1, 4][2, 3][2, 4][3, 4] 78. SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example:123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 思路：dfs即可，时间 O(NlogN) 空间 O(N) 递归栈空间https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_78.java12345678910111213141516public static class Solution2 &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); backtracking(result, new ArrayList(), nums, 0); return result; &#125; void backtracking(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list, int[] nums, int start) &#123; result.add(new ArrayList(list)); for (int i = start; i &lt; nums.length; i++) &#123; list.add(nums[i]); backtracking(result, list, nums, i + 1); list.remove(list.size() - 1); &#125; &#125;&#125; 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; Arrays.sort(S); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); //先加入空集 res.add(tmp); helper(S, 0, res, tmp); return res; &#125; private void helper(int[] S,int index,List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp)&#123; if(index&gt;=S.length) return; // 不加入当前元素产生的集合，然后继续递归 helper(S, index+1, res, tmp); List&lt;Integer&gt; tmp2 = new ArrayList&lt;Integer&gt;(tmp); tmp2.add(S[index]); res.add(tmp2); // 加入当前元素产生的集合，然后继续递归 helper(S, index+1, res, tmp2); &#125;&#125; 79. Word SearchGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example:12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 思路：dfs, 时间 O(N^2) 空间 O(N) 123456789101112131415161718192021222324public class Solution &#123; public boolean exist(char[][] board, String word) &#123; if(board.length == 0) return false; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; // 从i,j点作为起点开始搜索 boolean isExisted = search(board, i, j, word, 0); if(isExisted) return true; &#125; &#125; return false; &#125; private boolean search(char[][] board, int i, int j, String word, int idx)&#123; if(idx &gt;= word.length()) return true; if(i &lt; 0 || i &gt;= board.length || j &lt; 0 || j &gt;= board[0].length || board[i][j] != word.charAt(idx)) return false; // 将已经搜索过的字母标记一下，防止循环。只要变成另外一个字符，就不会再有循环了。 board[i][j] ^= 255; boolean res = search(board, i-1, j, word, idx+1) || search(board, i+1, j, word, idx+1) || search(board, i, j-1, word, idx+1) || search(board, i, j+1, word, idx+1); // 再次异或255就能恢复成原来的字母 board[i][j] ^= 255; return res; &#125;&#125; 80. Remove Duplicates from Sorted Array IIFollow up for “Remove Duplicates”: What if duplicates are allowed at most twice? For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length. 思路：双指针，记录前两个遍历到的数字来帮助我们判断是否出现了第三遍。如果当前数字和前一个数字的前一个一样的话，说明出现了第三次。 123456789101112131415public int removeDuplicates(int[] nums) &#123; if(nums.length &lt;= 2) return nums.length; int dup1 = nums[0]; int dup2 = nums[1]; int end = 2; for(int i = 2; i &lt; nums.length; i++)&#123; if(nums[i]!=dup1)&#123; nums[end] = nums[i]; dup1 = dup2; dup2 = nums[i]; end++; &#125; &#125; return end; &#125; Search in Rotated Sorted Array IIhttps://segmentfault.com/a/1190000003811864 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false.123456789Example 1:Input: nums = [2,5,6,0,0,1,2], target = 0Output: trueExample 2:Input: nums = [2,5,6,0,0,1,2], target = 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.Would this affect the run-time complexity? How and why? 思路如果可能有重复，那我们之前判断左右部分是否有序的方法就失效了，因为可能有这种13111情况，虽然起点小于等于中间，但不代表右边就不是有序的，因为中点也小于等于终点，所有右边也是有序的。所以，如果遇到这种中点和两边相同的情况，我们两边都要搜索。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean search(int[] nums, int target) &#123; return helper(nums, 0, nums.length - 1, target); &#125; public boolean helper(int[] nums, int min, int max, int target)&#123; int mid = min + (max - min) / 2; // 不符合min &lt;= max则返回假 if(min &gt; max)&#123; return false; &#125; if(nums[mid] == target)&#123; return true; &#125; boolean left = false, right = false; // 如果左边是有序的 if(nums[min] &lt;= nums[mid])&#123; // 看目标是否在左边有序数列中 if(nums[min] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; left = helper(nums, min, mid - 1, target); &#125; else &#123; left = helper(nums, mid + 1, max, target); &#125; &#125; // 如果右边也是有序的 if(nums[mid] &lt;= nums[max])&#123; // 看目标是否在右边有序数列中 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[max])&#123; right = helper(nums, mid + 1, max, target); &#125; else &#123; right = helper(nums, min, mid - 1, target); &#125; &#125; // 左右两边有一个包含目标就返回真 return left || right; &#125;&#125; 82. Remove Duplicates from Sorted List IIGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.123456789Example 1:Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5Example 2:Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 1234567891011121314151617181920212223public static class Solution1 &#123; public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; ListNode fakeHead = new ListNode(-1); fakeHead.next = head; ListNode pre = fakeHead; ListNode curr = head; while (curr != null) &#123; while (curr.next != null &amp;&amp; curr.val == curr.next.val) &#123; curr = curr.next; &#125; if (pre.next == curr) &#123; pre = pre.next; &#125; else &#123; pre.next = curr.next; &#125; curr = curr.next; &#125; return fakeHead.next; &#125; &#125; 83. Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once.123456789Example 1:Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2:Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 123456789101112131415161718192021222324252627public static class Solution1 &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode ret = new ListNode(-1); ret.next = head; while (head != null) &#123; while (head.next != null &amp;&amp; head.next.val == head.val) &#123; head.next = head.next.next; &#125; head = head.next; &#125; return ret.next; &#125;&#125;public static class Solution2 &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode curr = head; while (curr != null &amp;&amp; curr.next != null) &#123; if (curr.val == curr.next.val) &#123; curr.next = curr.next.next; &#125; else &#123; curr = curr.next; &#125; &#125; return head; &#125;&#125; 84. Largest Rectangle in Histogram同leetcode 11不同要区分清楚概念。https://leetcode.com/problems/largest-rectangle-in-histogram/description/Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 123Example:Input: [2,1,5,6,2,3]Output: 10 思路参考：http://www.cnblogs.com/grandyang/p/4322653.html 1、遍历数组，每找到一个局部峰值，然后向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值123456789101112131415161718class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; int res = 0; for (int i = 0; i &lt; height.size(); ++i) &#123; if (i + 1 &lt; height.size() &amp;&amp; height[i] &lt;= height[i + 1]) &#123; continue; &#125; int minH = height[i]; for (int j = i; j &gt;= 0; --j) &#123; minH = min(minH, height[j]); int area = minH * (i - j + 1); res = max(res, area); &#125; &#125; return res; &#125;&#125;; 2、stack 同1方法思想雷同123456789101112131415161718192021 /** * credit: https://leetcode.com/articles/largest-rectangle-histogram/#approach-5-using-stack-accepted * and https://discuss.leetcode.com/topic/7599/o-n-stack-based-java-solution */ public int largestRectangleArea(int[] heights) &#123; int len = heights.length; Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); int maxArea = 0; for (int i = 0; i &lt;= len; i++) &#123; int h = (i == len ? 0 : heights[i]); if (s.isEmpty() || h &gt;= heights[s.peek()]) &#123; s.push(i); &#125; else &#123; int tp = s.pop(); maxArea = Math.max(maxArea, heights[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea; &#125;&#125; 85. Maximal RectangleGiven a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.12345678910Example:Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6 解析1，https://www.cnblogs.com/lichen782/p/leetcode_maximal_rectangle.html复杂度：o(n^3)如上从上到下遍历，参考代码，然后对每一个坐标进行遍历寻找最大即可。123456789101112131415161718192021222324252627282930313233343536373839404142/** * 以给出的坐标作为左上角，计算其中的最大矩形面积 * @param matrix * @param row 给出坐标的行 * @param col 给出坐标的列 * @return 返回最大矩形的面积 */ private int maxRectangle(char[][] matrix, int row, int col) &#123; int minWidth = Integer.MAX_VALUE; int maxArea = 0; for (int i = row; i &lt; matrix.length &amp;&amp; matrix[i][col] == '1'; i++) &#123; int width = 0; while (col + width &lt; matrix[row].length &amp;&amp; matrix[i][col + width] == '1') &#123; width++; &#125; if (width &lt; minWidth) &#123;// 如果当前宽度小于了以前的最小宽度，更新它，为下面的矩形计算做准备 minWidth = width; &#125; int area = minWidth * (i - row + 1); if (area &gt; maxArea) maxArea = area; &#125; return maxArea; &#125; public int maximalRectangle(char[][] matrix) &#123; // Start typing your Java solution below // DO NOT write main() function int m = matrix.length; int n = m == 0 ? 0 : matrix[0].length; int maxArea = 0; for(int i = 0; i &lt; m; i++)&#123;//row for(int j = 0; j &lt; n; j++)&#123;//col if(matrix[i][j] == '1')&#123; int area = maxRectangle(matrix, i, j); if(area &gt; maxArea) maxArea = area; &#125; &#125; &#125; return maxArea; &#125; 思路：把每一行都计算上边的直方图，然后对每一行求解最大即可。这题的解法基于上题。要求最大的矩形，实际上可以将矩阵的每一行，转化为上一题的直方图，而直方图的每个竖条的数字，就是该行对应坐标正上方，向上方向有多少个连续的1。要转化为直方图，方法是每一行的数值都累加上一行计算出来的数值，而第一行的数值就是本身。如果原始矩阵中遇到0，则累加中断，重新置0。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; int max = 0; if(matrix.length == 0) return 0; int[][] dp = new int[matrix.length][matrix[0].length]; for(int i = 0; i &lt; matrix.length; i++)&#123; for(int j = 0; j &lt; matrix[0].length; j++)&#123; // 如果是第一行就是自身，如果遇到0则停止累加 dp[i][j] = i == 0 ? matrix[i][j] - '0' : matrix[i][j] == '1' ? dp[i-1][j] + matrix[i][j] - '0' : 0; &#125; &#125; for(int i = 0; i &lt; dp.length; i++)&#123; //找每行的最大矩形 int tmp = findRowMax(i, dp); max = Math.max(max, tmp); &#125; return max; &#125; private int findRowMax(int row, int[][] matrix)&#123; if(matrix[row].length== 0) return 0; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); int i = 1, max = matrix[row][0]; stk.push(0); while(i &lt; matrix[row].length || (i == matrix[row].length &amp;&amp; !stk.isEmpty()))&#123; if(i != matrix[row].length &amp;&amp; ( stk.isEmpty() || matrix[row][i] &gt;= matrix[row][stk.peek()] ))&#123; stk.push(i); i++; &#125; else &#123; int top = matrix[row][stk.pop()]; int currMax = !stk.isEmpty() ? top * (i - stk.peek() - 1) : top * i; max = Math.max(currMax, max); &#125; &#125; return max; &#125;&#125; 86. Partition ListGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.1234Example:Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 思路：就是将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可，代码如下：123456789101112131415161718192021222324public static class Solution1 &#123; public ListNode partition(ListNode head, int x) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode left = new ListNode(0); ListNode right = new ListNode(0); ListNode less = left; ListNode greater = right; while (head != null) &#123; if (head.val &lt; x) &#123; less.next = head; less = less.next; &#125; else &#123; greater.next = head; greater = greater.next; &#125; head = head.next; &#125; greater.next = null; less.next = right.next; return left.next; &#125;&#125; 另一种思路是把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可。 ## 87. Scramble String 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.Below is one possible representation of s1 = &quot;great&quot;: great / \ gr eat / \ / \g r e at / \ a tTo scramble the string, we may choose any non-leaf node and swap its two children.For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. rgeat / \ rg eat / \ / \r g e at / \ a tWe say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;.Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. rgtae / \ rg tae / \ / \r g ta e / \ t aWe say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;.Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.Example 1:Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;Output: trueExample 2:Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;Output: false 88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.1234567Example:Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 算法思想是：由于合并后A数组的大小必定是m+n，所以从最后面开始往前赋值，先比较A和B中最后一个元素的大小，把较大的那个插入到m+n-1的位置上，再依次向前推。如果A中所有的元素都比B小，那么前m个还是A原来的内容，没有改变。如果A中的数组比B大的，当A循环完了，B中还有元素没加入A，直接用个循环把B中所有的元素覆盖到A剩下的位置。代码如下: 123456789class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int count = m + n - 1; --m; --n; while (m &gt;= 0 &amp;&amp; n &gt;= 0) A[count--] = A[m] &gt; B[n] ? A[m--] : B[n--]; while (n &gt;= 0) A[count--] = B[n--]; &#125;&#125;; 89. Gray Code格雷码 The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. 12345678910111213141516171819202122232425Example 1:Input: 2Output: [0,1,3,2]Explanation:00 - 001 - 111 - 310 - 2For a given n, a gray code sequence may not be uniquely defined.For example, [0,2,3,1] is also a valid gray code sequence.00 - 010 - 211 - 301 - 1Example 2:Input: 0Output: [0]Explanation: We define the gray code sequence to begin with 0. A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1. Therefore, for n = 0 the gray code sequence is [0]. 格雷码相互转换：https://www.cnblogs.com/zhihongyu/archive/2012/08/14/2638781.html 123456789101112static int DecimaltoGray(int x)&#123; return x^(x&gt;&gt;1);&#125;static unsigned int GraytoDecimal(unsigned int x)&#123; unsigned int y = x; while(x&gt;&gt;=1) y ^= x; return y;&#125; 那么本题得解法直接利用int to gray num即可1234567891011// Binary to grey codeclass Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; pow(2,n); ++i) &#123; res.push_back((i &gt;&gt; 1) ^ i); &#125; return res; &#125;&#125;; 90. Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets.123456789101112Example:Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 1234567891011121314151617181920public static class Solution2 &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList(); Arrays.sort(nums); backtrack(nums, 0, new ArrayList(), result); return result; &#125; void backtrack(int[] nums, int start, List&lt;Integer&gt; curr, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList(curr)); for (int i = start; i &lt; nums.length; i++) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; curr.add(nums[i]); backtrack(nums, i + 1, curr, result); curr.remove(curr.size() - 1); &#125; &#125;&#125; 91. Decode WaysA message containing letters from A-Z is being encoded to numbers using the following mapping:1234567891011121314151617&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26Given a non-empty string containing only digits, determine the total number of ways to decode it.Example 1:Input: &quot;12&quot;Output: 2Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).Example 2:Input: &quot;226&quot;Output: 3Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). 思路：dp1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int numDecodings(String s) &#123; if(s.length() == 0) return s.length(); int[] dp = new int[s.length() + 1]; // 初始化第一种解码方式 dp[0] = 1; // 如果第一位是0，则无法解码 dp[1] = s.charAt(0) == '0' ? 0 : 1; for(int i = 2; i &lt;= s.length(); i++)&#123; // 如果字符串的第i-1位和第i位能组成一个10到26的数字，说明我们可以在第i-2位的解码方法上继续解码 if(Integer.parseInt(s.substring(i-2, i)) &lt;= 26 &amp;&amp; Integer.parseInt(s.substring(i-2, i)) &gt;= 10)&#123; dp[i] += dp[i - 2]; &#125; // 如果字符串的第i-1位和第i位不能组成有效二位数字，在第i-1位的解码方法上继续解码 if(Integer.parseInt(s.substring(i-1, i)) != 0)&#123; dp[i] += dp[i - 1]; &#125; &#125; return dp[s.length()]; &#125;&#125; public static class Solution1 &#123; public int numDecodings(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; int[] dp = new int[s.length() + 1]; dp[0] = 1; dp[1] = (s.charAt(0) != '0') ? 1 : 0; for (int i = 2; i &lt;= s.length(); i++) &#123; int first = Integer.valueOf(s.substring(i - 1, i)); int second = Integer.valueOf(s.substring(i - 2, i)); if (first &gt; 0 &amp;&amp; first &lt;= 9) &#123; dp[i] += dp[i - 1]; &#125; if (second &gt;= 10 &amp;&amp; second &lt;= 26) &#123; dp[i] += dp[i - 2]; &#125; &#125; return dp[s.length()]; &#125; &#125; 92. Reverse Linked List II94. Binary Tree Inorder Traversal12345678910111213Given a binary tree, return the inorder traversal of its nodes&apos; values.Example:Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2]Follow up: Recursive solution is trivial, could you do it iteratively? 1234567891011121314151617181920212223242526272829303132public static class Solution1 &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; return inorder(root, new ArrayList()); &#125; List&lt;Integer&gt; inorder(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) &#123; return result; &#125; inorder(root.left, result); result.add(root.val); return inorder(root.right, result); &#125;&#125;public static class Solution2 &#123; //iterative approach public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList(); Stack&lt;TreeNode&gt; stack = new Stack(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); result.add(root.val); root = root.right; &#125; return result; &#125;&#125; ##]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>algo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm GC 垃圾回收]]></title>
    <url>%2Fposts%2Fjvm_art_gc_analysis.html</url>
    <content type="text"><![CDATA[垃圾回收哪些内存JVM运行时数据区中，线程私有的程序计数器、虚拟机栈、本地方法栈随线程的创建和退出而自动产生和销毁，不需要垃圾回收。JVM垃圾回收的是共享区域的内存，主要是方法区和Java堆内存的回收。 1.1、方法区方法区的垃圾收集主要是回收废弃常量和无用的类（卸载类）。回收废弃常量与下面将介绍的回收Java堆中的对象很相似，而判定“无用的类”需同时满足三个条件： 1、该类所有实例已被回收，即Java堆中无该类的任何实例。（下层） 2、该类对应的java.lang.Class对象没有在任何地方被引用，无在任何地方通过反射访问该类的方法。（下层） 3、加载该类的ClassLoader已被回收。（上层） 1.2、堆Java堆里面存放着几乎所有的对象实例，垃圾收集器对堆进行回收前，首先要做的就是确定哪些对象可以作为垃圾回收。 JDK1.2后，Java对引用概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Soft Reference）、虚引用（Phantom Reference）。被强引用的对象（我们通常所用的对象就是强引用的）一定不会被回收，被其他引用的对象却可能被回收。 总的来说，回收的堆对象有两类： 1、有被引用的对象：即被软引用、弱引用、虚引用所引用的对象可能被当垃圾回收。 1、软引用：软引用对象在系统将要发生内存溢出前会被回收 2、弱引用：弱引用对象只能躲过一次垃圾回收，躲过一次后就被回收 3、虚引用：虚引用对象肯定会被回收，一个对象是否有虚引用完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，对象被设置成虚引用关联的唯一作用是在对象被垃圾收集时收到一个系统通知。 2、无被引用的对象：需要检查哪些对象已死（没被引用），主要有两种算法检测（3.1节详述具体实现）： 1、引用计数法：对象有个计数器记录被引用的个数，为0者可被回收。采用此法的有微软的COM技术、使用ActionScript3的FlashPlayer、Python等。此法存在对象间循环引用的问题导致对象不能被回收。 2、可达性分析法：主流Java虚拟机采用此法。选取一系列GC Roots对象作为起点分析引用链确定不可达对象。采用此法的有Java、C#、Lisp等。对于不可达的对象，如果其覆盖了finalize()方法并且没被执行过，则在JVM对之回收前其有一次逃过被回收的机会。如下：JVM将该对象放入F-Queue队列，并由虚拟机自动建立的、低优先级的Finalizer线程稍后去执行它。若finalize()里此对象又被成员变量（类变量或实例变量）引用，则此对象复活，不会被回收；否则被回收。 copyfrom：http://www.cnblogs.com/z-sm/p/6243378.html 判断对象是否存活？GC的两种判定方法：引用计数与根搜索算法 引用计数： 给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1，当引用失效时，计数器值减1,。任何时候计数器都为0的对象就是不可能再被使用的。它很难解决对象之间相互循环引用问题。 根搜索算法（GC Roots Traceing）: 通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。 1. 引用计数算法优势：实现简单，效率高。致命缺陷：无法解决对象相互引用的问题——会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。 2. 可达性分析算法对象到GC Roots没有引用链，则回收。 GC Roots包括： （1）Java虚拟机栈中引用的对象。 （2）方法区中类静态属性引用的对象。 （3）方法去中常量引用的对象。 （4）本地方法栈中Native方法（JNI）引用的对象。 如何确定不可达对象1、引用计数法：（采用此法的有微软的COM计数、使用ActionScript3的FlashPlayer、Python等） 思想： 堆中的每一个对象有一个引用计数，当一个对象被创建并把指向该对象的引用赋值给一个变量时，引用计数置为1，当再把这个引用赋值给其他变量时，引用计数加1，当一个对象的引用超过了生命周期或者被设置为新值时，对象的引用计数减1，任何引用计数为0的对象都可以被当成垃圾回收。当一个对象被回收时，它所引用的任何对象计数减1，这样，可能会导致其他对象也被当垃圾回收。 存在的问题：循环引用问题，示例如下。如果采用引用计数法，则两个实例没法被回收，但实际被回收了，说明JVM采用的不是引用计数法。 ;) 1234567891011121314151617181920212223242526272829 1 public class ReferenceCountingGC &#123; 2 public Object instance = null; 3 private static final int _1MB = 1024 * 1024; 4 /** 5 * 这个成员属性的唯一意义就是占点内存,以便能在GC日志中看清楚是否被回收过 6 */ 7 private byte[] bigSize = new byte[2 * _1MB]; 8 9 public static void testGC() &#123;10 // 定义两个对象11 ReferenceCountingGC objA = new ReferenceCountingGC();12 ReferenceCountingGC objB = new ReferenceCountingGC();13 14 // 给对象的成员赋值，即存在相互引用情况15 objA.instance = objB;16 objB.instance = objA;17 18 // 将引用设为空，即没有到堆对象的引用了19 objA = null;20 objB = null;21 22 // 进行垃圾回收23 System.gc(); 24 &#125;25 26 public static void main(String[] args) &#123;27 testGC(); 28 &#125;29 &#125; ;) 2、关于可达性分析法：（采用此法的有Java、C#、Lisp等） 思想：选取一系列GCRoots对象作为起点，开始向下遍历搜索其他相关的对象，搜索所走过的路径成为引用链，遍历完成后，若一个对象到GCRoots对象没有任何引用链，则证明此对象是不可用的，可以被当做垃圾进行回收。 可作为GC Roots的对象： 1、方法区中静态属性引用的对象、常量引用的对象 2、虚拟机栈（栈中的本地变量表）中引用的对象 3、本地方法栈中JNI（Native方法）引用的对象 具体实现（确定GC Roots节点），以HotSpot的为例： 问题——枚举寻找出可作为GC Roots的节点耗时：可作为GCRoots的结点主要在全局性的引用（如常量或类静态属性）与执行上下文（如栈帧中的局部变量表）中，很多应用仅方法区就数百兆，逐个检查变量看是否是GC Roots很耗时。 方法（寻找GC Roots节点）：采用一组称为OopMap的数据结构，在特定代码位置记录下哪些变量是引用，这样GC时利用该结构得知哪些是GC Roots从而避免逐个检查变量。 3. 关于引用JDK1.2之后，Java对引用进行了扩充。 （1）强引用：Object obj = new Object()，不会被jvm回收 （2）软引用：在内存溢出异常发生之前才被强制回收。 （3）弱引用：延迟到下次垃圾回收之前再被回收。 （4）虚引用：仅为了在被回收时收到一个系统通知。 Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。 强引用：程序代码中的普通引用。如Object obj = new Object(),只要强引用存在，垃圾回收器就不会回收。在不使用对象时应及时将引用设置为null，便于垃圾回收。 软引用：描述一些有用但并非必须的对象。对于软引用关联的对象在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。SoftRefence 弱引用：描述非必须对象，比软引用弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakRefence 虚引用：最弱的引用，不管是否有虚引用存在，完全不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的是希望能够在这个对象被垃圾回收器之前收到系统通知。PhantomReference 相关参考：Java 如何有效地避免OOM：善于利用软引用和弱引用 4. finalize方法：在对象被JVM回收之前，有一个低优先级的线程去执行。只有覆盖了finalize方法，才会执行，且只会执行一次。 5. 回收方法区：永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 垃圾收集算法垃圾回收算法（概述）： 标记-清除算法：时间效率低、空间碎片 复制算法：时间效率较高、空间利用率低。分配担保。适合于每次回收时大量对象死去只有少量存活的情况（年轻代）。 标记-整理算法。适合对象存活率高的情况（老年代）。 分代收集算法：就是上面几种用在堆的不同的分代区域中。年轻代：复制算法；老年代：标记-清除算法、标记-整理算法。 下面详述。 1. 标记-清除算法（Mark-Sweep）首先标记出所有需要回收的对象，使用可达性分析算法判断一个对象是否为可回收，在标记完成后统一回收所有被标记的对象。示例： 说明：1、效率问题，标记和清除两个阶段的效率都不高。2、空间问题，标记清除后会产生大量不连续的内存碎片，以后需要给大对象分配内存时，会提前触发一次垃圾回收动作。 2. 复制算法将内存分为两等块，每次使用其中一块。当这一块内存用完后，就将还存活的对象复制到另外一个块上，然后再把已使用过的内存空间一次清理掉。示例： 说明：适合于每次回收时大量对象死去只有少量存活的情况，如年轻代中。1、无内存碎片问题，实现简单，时间效率高。2、空间利用率低，可用内存缩小为原来的一半。 将内存分为两个半区，将区A中的存活对象全部复制到B区的连续空间，然后清理A中所有空间。 缺点：内存实际空间减半。在对象存活率较高时需要进行较多的复制操作。 实际应用：将堆内存分为新生代和老年代。由于新生代中的对象98%都是可回收的，故将新生代又划分为Eden空间和两块较小的Survivor空间，默认Eden:Survivor（单个）=8:1 这样每次垃圾收集时，将Eden和S1中的存活对象复制到S2，然后清空Eden和S1区。 为了防止S2中空间不足以存储Eden和S1的所有剩余存活对象，提供老年代作为保障（Handle Promotion：分配担保）。 3. 标记-整理算法（将存活对象移动到一起）标记过程与标记 - 清除算法一样，但之后让所有存活的对象移向一端，然后直接清理掉边界以外的内存。示例： 说明：适合对象存活率高的情况，如老年代中。无需考虑内存碎片问题。 4. 分代收集 新生代：存活率低，使用复制算法 老年代：存活率高，使用“标记-整理”或“标记-清除”算法 根据对象存活周期将堆分为新生代和老年代，然后根据各年代特点选择适当的回收算法。 新生代基本上对象都是朝生暮死的，生存时间很短暂，因此可采用复制算法，只需要复制少量的对象就可以完成收集。 老年代中的对象存活率高，也没有额外的空间进行分配担保，因此必须使用标记 - 整理或者标记 - 清除算法进行回收。 垃圾收集器概述：HotSpot目前共7种垃圾收集器，如下（图中存在连线表示可以搭配使用）： 总结： （1） 收集器 适用的代 采用的收集算法 适用的模式 串行、并行、并发 目标 Serial Young 复制 Client 用户线程停止，收集线程串行 GC时停顿时间少 ParNew（Parallel New Generation） Young 复制 Server 用户线程停止，收集线程并行 GC时停顿时间少 Parallel Scavenge Young 复制 用户线程停止、收集线程并行 吞吐量尽可能大 CMS Old 标记-清除 用户线程和收集线程均在执行，前者不用停止 GC时停顿时间少 Serial Old（MSC） Old 标记-整理 Client、Server 用户线程停止，收集线程串行 GC时停顿时间少 Parallel Old Old 标记-整理 用户线程停止，收集线程并行 吞吐量尽可能大 G1 Young、Old 标记-整理 Server 用户线程和收集线程均在执行，前者不用停止 GC时停顿时间少 （2） 注： 串行/并行是说垃圾收集线程是否能并行执行（此时用户线程得停止），并发则指垃圾收集时用户线程可以并发执行不用停下。 Parallel Scavenge和Parallel Old收集器以提高吞吐量为目标，其他收集器以减少停顿时间（单次GC所用时间）为目标。（吞吐量=运行用户代码时间 /（运行用户代码时间 + 垃圾回收时间）。停顿时间越短越适合与用户交互的程序以提高响应速度和用户体验；而高吞吐量可高效利用CPU以尽快完成程序运算任务，适合后台运算而不需要太多交互的任务。GC停顿时间缩短通常以牺牲吞吐量和新生代空间为代价换来。） 虚拟机运行在Client 模式下时默认用 Serial + Serial Old 收集器组合，两个分别用于年轻代、老年代。 虚拟机运行在Server模式下时默认用 Parallel Scavenge + Serial Old收 集器组合，两个分别用于年轻代、老年代。 如果机器只有一个核的话，采用并行回收器可能得不偿失，因为多个回收线程会争抢CPU资源，反而造成更大的消耗，这时，就最好采用串行回收器。 下面详述： 3.3.1、Serial收集器采用复制算法。 Serial收集器为单线程收集器，在进行垃圾收集时，必须要暂停其他所有的工作线程，直到它收集结束。运行过程如下图所示： 说明： 1、需要STW（Stop The World），停顿时间长。 2、简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。 3、虚拟机运行在Client模式下的默认年轻代收集器。 3.3.2、ParNew收集器采用复制算法。 ParNew是Serial的多线程版本，除了使用多线程进行垃圾收集外，其他行为与Serial完全一样，运行过程如下图所示： 说明：虚拟机运行在Server模式下的默认新生代收集器。 3.3.3、Parallel Scavenge收集器采用复制算法。 Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个精确控制吞吐量的参数： -XX:MaxGCPauseMillis：设置最大GC停顿毫秒数，收集器尽可能保证每次回收所用时间不超过该值。GC停顿时间缩短通常以牺牲吞吐量和新生代空间换来。 -XX:GCTimeRatio：设置用户代码运行时间与最大垃圾回收时间的比例，相当于吞吐量的倒数。 提供了自适应调整策略，-XX:+UseAdaptiveSizePolicy，这样虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数（新生代大小、Eden与Survivor比例、晋升老年代的对象大小阈值等）以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应调节策略。 Parallel Scavenge的运行过程与ParNew相似。 3.3.4、Serial Old收集器采用标记 - 整理算法。 老年代的单线程收集器，运行过程在之前的Serial收集器已经给出。不再赘述。 常作为下面介绍的CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。 3.3.5、Parallel Old收集器采用标记-整理算法。 老年代的多线程收集器，吞吐量优先，运行过程如下图所示： 3.3.6、CMS收集器采用标记-清除算法。 CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步： 初始标记，标记GCRoots能直接关联到的对象（找到GC Roots节点），时间很短。 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。 并发清除，回收内存空间，时间很长。 重置线程 其中，初始标记、重新标记仍需要GC停顿（Stop The World），并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。运行过程如下图所示： 缺点：1：内存碎片；2：由于并发故需要占用CPU、内存、且无法处理浮动垃圾 1、内存碎片。由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。 2、多线程并发，耗费CPU。对CPU资源非常敏感，并发阶段虽不会导致用户线程停顿但会占用一部分线程（CPU资源）从而导致应用程序变慢，总吞吐率下降。（不过总比让用户线程停顿好…） 3、因用户线程并发执行，故需要预留一部分老年代空间提供并发收集时程序运行使用，从而需要额外占用内存空间。预留内存无法满足程序需要时就会出现一次Concurrent Mode Failure，此时启动后备预案即Serial Old来收集老年代垃圾。提供了参数-XX:CMSInitialtingOccupancyFraction来设置内存占用阈值，达到阈值CMS就进行垃圾回收。 4、并发收集，无法处理浮动垃圾。因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾 3.3.7、G1收集器采用标记-整理算法。 G1（Garbage First）收集器具有如下特点： 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。 分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。 空间整合。基于标记 - 整理算法，无内存碎片产生，收集后能提供规整的可用内存。 可预测的停顿。能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 使用G1收集器时，Java堆会被划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但两者已经不是物理隔离了，都是一部分Region（不需要连续）的集合。G1收集器中，Region之间的对象引用以及其他收集器的新生代和老年代之间的对象引用，虚拟机都使用Remembered Set来避免全堆扫描的。每个Region对应一个Remembered Set,虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查老年代的对象是否引用了新生代的对象），如果是，则通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会遗漏。 如果不计算维护Remembered Set的操作，G1收集器的运作可以分为如下几步： 初始并发，标记GCRoots能直接关联到的对象；修改TAMS（Next Top At Mark Start）,使得下一阶段程序并发时，能够在可用的Region中创建新对象，需停顿线程，耗时很短。 并发标记，从GCRoots开始进行可达性分析，与用户程序并发执行，耗时很长。 最终标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，变动的记录将被记录在Remembered Set Logs中，此阶段会把其整合到Remembered Set中，需要停顿线程，与用户程序并行执行，耗时较短。 筛选回收，对各个Region的回收价值和成本进行排序，根据用户期望的GC时间进行回收，与用户程序并发执行，时间用户可控。 G1收集器运行过程的前3阶段与CMS的类似，具体示意图如下： 垃圾收集器组合及配置参数以下是虚拟机的一些非稳定运行参数，用来配置使用的收集器组合，通过 -XX:参数 配置。 （可以使用参数-XX:+PrintCommandLineFlags让JVM打印出那些已经被用户或者JVM设置过的详细的XX参数的名称和值） 参 数 描 述 UseSerialGC 虚拟机运行在Client 模式下的默认值，打开此开关后，使用Serial + Serial Old 收集器组合进行内存回收 UseParNewGC 打开此开关后，使用ParNew + Serial Old 收集器组合进行内存回收 UseConcMarkSweepGC 打开此开关后，使用ParNew + CMS + Serial Old 收集器组合进行内存回收。Serial Old 收集器将作为CMS 收集器出现Concurrent Mode Failure失败后的后备收集器使用 UseParallelGC 虚拟机运行在Server 模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收 UseParallelOldGC 打开此开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收 SurvivorRatio 新生代中Eden 区域与Survivor 区域的容量比值， 默认为8， 代表Eden ：Survivor=8∶1 PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 MaxTenuringThreshold 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC 之后，年龄就加1，当超过这个参数值时就进入老年代 UseAdaptiveSizePolicy 动态调整Java堆中各个区域的大小以及进入老年代的年龄 HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden 和Survivor 区的所有对象都存活的极端情况 ParallelGCThreads 设置并行GC 时进行内存回收的线程数 GCTimeRatio GC 时间占总时间的比率，默认值为99，即允许1% 的GC 时间。仅在使用Parallel Scavenge 收集器时生效 MaxGCPauseMillis 设置GC 的最大停顿时间。仅在使用Parallel Scavenge 收集器时生效 CMSInitiatingOccupancyFraction 设置CMS 收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS 收集器时生效 UseCMSCompactAtFullCollection 设置CMS 收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS 收集器时生效 CMSFullGCsBeforeCompaction 设置CMS 收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS 收集器时生效 垃圾收集GC触发的时机Minor GC = Young GcMajor GC = Full Gchttps://blog.csdn.net/yhyr_ycy/article/details/52566105https://blog.csdn.net/qq_33808060/article/details/60478794要准确理解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个方面来具体分析。 第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。（1）程序调用System.gc时可以触发；（2）系统自身来决定GC触发的时机。系统判断GC触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。 第二：“对什么东西”笼统的认为是Java对象并没有错。但是准确来讲，GC操作的对象分为：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。 第三：“做了什么”最浅显的理解为释放对象。但是从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。 具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。 GC将堆里的对象分为新生代，老年代，持久代。新生代有一个Eden区，两个survivor区。新生成的对象直接放在Eden区，Eden区满了就放进survivor1，当survivor1满了就会出发一次Minor GC：将存活的对象放入survivor2，然后清空Eden和survivor1，再将survivor区的交换，保证survivor2为空。当survivor2不足以存放Eden和survivor1的存活对象时，就会放入老年区。较大的对象和长期存活的对象直接进入老年区。当即将进入老年区的对象超过老年区剩余大小时，触发一次full GC。频率上说，Minor GC较频繁，full GC不频繁。持久代会存放一些静态值和方法。 Minor GC ，Full GC 触发条件Minor GC触发条件：当Eden区满时，触发Minor GC。Full GC触发条件：（1）调用System.gc时，系统建议执行Full GC，但是不必然执行（2）老年代空间不足（3）方法去空间不足（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 何时执行GC（GC停顿）（何时执行 即 考虑GC线程与用户线程间的协调） JVM采用一组称为OopMap的数据结构，在特定代码位置记录下哪些变量是引用，这样GC时利用该结构得知哪些是GC Roots从而避免逐个检查变量。 GC停顿：每条指令都可能使引用关系发生变化，但若为每条指令生成OopMap空间成本高，因此让在特定位置生成OopMap，程序执行到这些位置时才会停顿进行GC。此特定位置包括两种： 安全点（Safe Point），面向执行着的线程，线程响应GC中断请求到安全点时暂停，以让垃圾收集器进行GC。安全点太少会导致GC等待时间长，太多会增大运行时负荷；其选取以“具有让程序长时间执行的特征”为标准，如方法调用、循环跳转、异常跳转等指令会产生安全点。GC时让线程中断有抢先式（让所有线程中断，若有线程不在安全点则恢复之以让之执行到安全点后停下）和主动式（在安全点设置标志，线程执行到安全点时检查标志看是否要中断挂起）两种。 安全区域（Safe Region），面向未在执行（如Sleep或Blocked状态）的线程，未在执行的线程（没被分配CPU时间）不会响应线程中断。安全区域是指一段代码片段之中，引用关系不会发生变化，在这个区域的任何地方开始GC都是安全的，安全区域可以看成是对安全点的扩展。当线程执行到安全区域中的代码时，首先标识自己已进入安全区域，则在这段时间里JVM发起GC时就不用管标识自己为安全区域状态的线程；在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举（或者整个GC过程），若完成，线程继续执行，否则，它必须等待直到收到可以安全离开安全区域的信号。 GC类型MinorGC与MajorGC（FullGC）的区别： 新生代 GC（Minor GC）：指发生在新生代的垃圾收集动作，在Eden剩余空间不足以分配新对象时触发。因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。 老年代 GC（Major GC / Full GC）：指发生在老年代的 GC，在老年代剩余空间不足以容纳新对象时触发。出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里 就有直接进行 Major GC 的策略选择过程） 。MajorGC 的速度一般会比 Minor GC 慢 10 倍以上。 理解GC日志GC日志格式与所用JVM版本及收集器有关，但有一定的共性。这里以JDK1.8.0_45为例。 打印GC日志的参数： 12-XX:+PrintGCDetails-XX:+PrintGCTimeStamps 典型GC日志示例如下： ;) 12345678910110.080: [GC (System.gc()) [PSYoungGen: 1147K-&gt;616K(9216K)] 1147K-&gt;624K(19456K), 0.0006699 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 0.081: [Full GC (System.gc()) [PSYoungGen: 616K-&gt;0K(9216K)] [ParOldGen: 8K-&gt;508K(10240K)] 624K-&gt;508K(19456K), [Metaspace: 2555K-&gt;2555K(1056768K)], 0.0034445 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap PSYoungGen total 9216K, used 410K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 5% used [0x00000000ff600000,0x00000000ff666800,0x00000000ffe00000) from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 508K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 4% used [0x00000000fec00000,0x00000000fec7f1c0,0x00000000ff600000) Metaspace used 2562K, capacity 4486K, committed 4864K, reserved 1056768K class space used 275K, capacity 386K, committed 512K, reserved 1048576K ;) 由PSYoungGen和ParOldGen得知JVM的垃圾收集器组合为Parallel Scavenge(新生代) + Parallel Old(老年代)。 最前面的数字0.080、0.081表示GC发生的时间，为JVM启动以来经过的秒数。 [GC (System.gc())]与[Full GC (System.gc())]，表示此次垃圾收集的停顿类型，而不是用来区分新生代GC和老年代GC的，如果有Full，则表示此次GC发生了Stop The World。 PSYoungGen: 1147K-&gt;616K(9216K)，表示，“新生代区域：该内存区域GC前已使用容量 -&gt; 该内存区域GC后已使用容量（该内存区域总容量）”。区域名称与所用收集器名称有关：若为Serial收集器则名为DefNew，Default New Generation；若为ParNew收集器则名为ParNew，Parallel New Generation；若为Parallel Scavenge收集器则名为PSYoungGenn。老年代和元空间与此类似。 1147K-&gt;624K(19456K)，, 0.0006699 secs，表示，“GC前Java堆已使用的容量 -&gt; GC后Java堆已使用的容量（Java堆总容量），GC所用秒数”。 [Times: user=0.00 sys=0.00, real=0.00 secs]，表示GC的更具体的时间，user代表用户态消耗的CPU时间，sys代表内核态消耗的CPU时间，real代表操作从开始到结束所经过的墙钟时间。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，如等待磁盘IO，等待线程阻塞，CPU时间则不包含这些耗时。当系统有多CPU或者多核时，多线程操作会叠加这些CPU时间，所以读者看到user或者sys时间超过real时间也是很正常的。 4.3、Java程序的总运行时间 = 运行用户代码时间 + 非用户代码时间（即时编译时间 + 类加载验证时间 + 垃圾回收时间）。其中，非用户代码时间里的加载验证和即时编译一般集中在程序运行开始的一阶段，而垃圾回收则是伴随着程序运行的整个过程。 JDK提供的Visual VM工具里Visual GC中展示的即包括该三部分非用户代码时间（Compile Time、Class Loader Time、GC Time）； 前面说的吞吐量即这里的 运行用户代码时间/（运行用户代码时间 + 垃圾回收时间）。 此外： 类验证可以通过 -XVerify:none 禁用； 即时编译可以通过 -Xint 禁用，从而纯以解释执行的方式执行代码。 内存分配与回收策略1. 优先在Eden区分配（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次Minor GC(也称Young GC) -XX:+PrintGCDetails 在JVM发生垃圾收集时打印内存回收日志 在进程退出时输出当前各区域的内存分配情况 在JDK8中，PermGen（永久代）被Metaspace（元空间）取代了。 2. 大对象直接进入老年代-XX:PretenureSizeThreshold：直接进入老年代的对象大小 3. 长期存活的对象将进入老年代-XX:MaxTenuringThreshold：设置对象在新生代中能存活的最大年龄，默认15 -XX:+PrintTenuringDistribution：打印老年代内的各年龄对象内存分配情况 4. 动态对象年龄判定若Survivor中相同年龄的所有对象大小总和超过Survivor的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代。 5. 空间分配担保 （1）YGC发生前先检查“老年代最大可用的连续空间”是否大于新生代所有对象总空间。如果是，则触发YGC,无风险；如果否，进入（2） （2）再次判断“老年代最大可用的连续空间”是否大于历次平均晋升到老年代的对象大小总和。如果否，则直接执行FullGC；如果是，进入（3） （3）执行YGC，有风险。 （4）如果3中的YGC失败，则再执行FullGC。 五、垃圾回收和GC实战1. YGC测试代码：12345678910111213141516171819202122/** * @author zni.feng */import java.lang.management.ManagementFactory;public class YGCTest &#123; /** * VM参数： -verbose:gc -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 */ private static final int _1MB= 1024 * 1024; public static void main(String[] args) &#123; System.out.println(ManagementFactory.getRuntimeMXBean().getInputArguments());//打印JVM参数 byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2*_1MB]; allocation2 = new byte[2*_1MB]; allocation3 = new byte[2*_1MB]; allocation4 = new byte[4*_1MB]; //出现一次YGC System.out.println(&quot;exit&quot;); &#125;&#125; 测试结果： 123456789101112[-verbose:gc, -XX:+UseSerialGC, -Xms20M, -Xmx20M, -Xmn10M, -XX:+PrintGCDetails, -XX:SurvivorRatio=8, -Dfile.encoding=UTF-8][GC (Allocation Failure) [DefNew: 6815K-&gt;282K(9216K), 0.0077121 secs] 6815K-&gt;6426K(19456K), 0.0077785 secs] [Times: user=0.01 sys=0.01, real=0.01 secs] exitHeap def new generation total 9216K, used 4620K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf03c8d8, 0x00000007bf400000) from space 1024K, 27% used [0x00000007bf500000, 0x00000007bf546800, 0x00000007bf600000) to space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) tenured generation total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 60% used [0x00000007bf600000, 0x00000007bfc00030, 0x00000007bfc00200, 0x00000007c0000000) Metaspace used 2695K, capacity 4486K, committed 4864K, reserved 1056768K class space used 294K, capacity 386K, committed 512K, reserved 1048576K 测试结果分析： 从结果可以看到，发生了一次YGC，GC后新生代（DefNew：Default New Generaion）从6815K降到了282K，即基本上全部回收，而整个堆内存的大小并没有显著减小（从6815K降到了6426K），这是因为allocation1、allocation2、allocation3对象仍存在（强引用），并没有被真正回收，只是从新生代进入了老年代（Survivor区不足以容纳6M的对象）。并且，从程序结束时的各区域内存分配情况可以看到，老年代占用了约6M（tenured generation total 10240K,used 6144K）；新生代Eden区占用了52%，约4M（total 8192K，即8M），是用来存放allocation4的对象。 2. 大对象直接进入老年代123456789101112131415161718/** * @author zni.feng */public class PretenureSizeThresholdTest &#123; /** * VM参数: -verbose:gc -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 * -XX:PretenureSizeThreshold=3145728 * (3145728=3*1024*1024=3MB) */ private static final int _1MB=1024*1024; public static void main(String[] args) &#123; byte[] allocation; allocation = new byte[4*_1MB]; &#125;&#125; 测试结果： 123456789Heap def new generation total 9216K, used 835K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 10% used [0x00000007bec00000, 0x00000007becd0f90, 0x00000007bf400000) from space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000) tenured generation total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000) Metaspace used 2621K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K 测试结果分析：可以看到，allocation对象直接进入了老年代。 copy from : https://www.cnblogs.com/znicy/p/6918767.html GC区域Eden Survivor(from,to), Old Gen和Perm GenVM区域总体分两类，heap区和非heap区。heap区又分为： Eden Space（伊甸园）、 Survivor Space(幸存者区)、 Old Gen（老年代）。 非heap区又分： Code Cache(代码缓存区)； Perm Gen（永久代）； Jvm Stack(java虚拟机栈)； Local Method Statck(本地方法栈)； 下面我们对每一个内存区域做详细介绍。Eden Space字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的survivor区域。 Survivor Space幸存者区，用于保存在eden space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两个，分别为To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候Eden区域不能被回收的对象被放入到空的survivor（也就是To Survivor，同时Eden区域的内存会在垃圾回收的过程中全部释放），另一个survivor（即From Survivor）里不能被回收的对象也会被放入这个survivor（即To Survivor），然后To Survivor 和 From Survivor的标记会互换，始终保证一个survivor是空的。 Eden Space和Survivor Space都属于新生代，新生代中执行的垃圾回收被称之为Minor GC（因为是对新生代进行垃圾回收，所以又被称为Young GC），每一次Young GC后留下来的对象age加1。 注：GC为Garbage Collection，垃圾回收。 Old Gen老年代，用于存放新生代中经过多次垃圾回收仍然存活的对象，也有可能是新生代分配不了内存的大对象会直接进入老年代。经过多次垃圾回收都没有被回收的对象，这些对象的年代已经足够old了，就会放入到老年代。 当老年代被放满的之后，虚拟机会进行垃圾回收，称之为Major GC。由于Major GC除并发GC外均需对整个堆进行扫描和回收，因此又称为Full GC。 heap区即堆内存，整个堆大小=年轻代大小 + 老年代大小。堆内存默认为物理内存的1/64(&lt;1GB)；默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制，可以通过MinHeapFreeRatio参数进行调整；默认空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制，可以通过MaxHeapFreeRatio参数进行调整。 下面我们来认识下非堆内存（非heap区）Code Cache代码缓存区，它主要用于存放JIT所编译的代码。CodeCache代码缓冲区的大小在client模式下默认最大是32m，在server模式下默认是48m，这个值也是可以设置的，它所对应的JVM参数为ReservedCodeCacheSize 和 InitialCodeCacheSize，可以通过如下的方式来为Java程序设置。 1-XX:ReservedCodeCacheSize=128m CodeCache缓存区是可能被充满的，当CodeCache满时，后台会收到CodeCache is full的警告信息，如下所示：“CompilerThread0” java.lang.OutOfMemoryError: requested 2854248 bytes for Chunk::new. Out of swap space? 注：JIT编译器是在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。 Perm Gen全称是Permanent Generation space，是指内存的永久保存区域，因而称之为永久代。这个内存区域用于存放Class和Meta的信息，Class在被 Load的时候被放入这个区域。因为Perm里存储的东西永远不会被JVM垃圾回收的，所以如果你的应用程序LOAD很多CLASS的话，就很可能出现PermGen space错误。默认大小为物理内存的1/64。 https://blog.csdn.net/shiyong1949/article/details/52585256/ Java最大线程数https://www.cnblogs.com/princessd8251/articles/3914434.htmlJVM中可以生成的最大数量由JVM的堆内存大小、Thread的Stack内存大小、系统最大可创建的线程数量（Java线程的实现是基于底层系统的线程机制来实现的，Windows下_beginthreadex，Linux下pthread_create）三个方面影响。具体数量可以根据Java进程可以访问的最大内存（32位系统上一般2G）、堆内存、Thread的Stack内存来估算。ThreadStackSize JVMMemory 能创建的线程数默认的325K -Xms1024m -Xmx1024m i = 2655默认的325K -Xms1224m -Xmx1224m i = 2072默认的325K -Xms1324m -Xmx1324m i = 1753默认的325K -Xms1424m -Xmx1424m i = 1435-Xss1024k -Xms1424m -Xmx1424m i = 452增大堆内存（-Xms，-Xmx）会减少可创建的线程数量，增大线程栈内存（-Xss，32位系统中此参数值最小为60K）也会减少可创建的线程数量 JVM参数调优https://blog.csdn.net/rickyit/article/details/53895060 堆大小设置 JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。我在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。典型设置： java **-Xmx3550m -Xms3550m -Xmn2g -Xss128k Xmx3550m ：设置JVM最大可用内存为3550M。 -Xms3550m ：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g ：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k** ：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0-XX:NewRatio=4 :设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5-XX:SurvivorRatio=4 ：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6-XX:MaxPermSize=16m :设置持久代大小为16m。-XX:MaxTenuringThreshold=0 ：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代 。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间 ，增加在年轻代即被回收的概论。 回收器选择 JVM给了三种选择：串行收集器、并行收集器、并发收集器 ，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置 进行判断。 吞吐量优先 的并行收集器如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。典型配置 ： java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20-XX:+UseParallelGC ：选择垃圾收集器为并行收集器。 此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。-XX:ParallelGCThreads=20 ：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC-XX:+UseParallelOldGC ：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100-XX:MaxGCPauseMillis=100 : 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy-XX:+UseAdaptiveSizePolicy ：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 响应时间优先 的并发收集器如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。典型配置 ： java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC-XX:+UseConcMarkSweepGC ：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。-XX:+UseParNewGC :设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection-XX:CMSFullGCsBeforeCompaction ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。-XX:+UseCMSCompactAtFullCollection ：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 堆栈溢出和内存泄露 永久方法区溢出因此持久带溢出有可能是运行时常量池溢出，也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。当持久带溢出的时候抛出java.lang.OutOfMemoryError: PermGen space 12345678List&lt;String&gt; list = new ArrayList&lt;String&gt;(); while(true)&#123; list.add(UUID.randomUUID().toString().intern()); &#125; &#125;作者：GhostStories链接：https://www.jianshu.com/p/cd705f88cf2a 堆溢出 12345static class OOMError&#123;&#125; public static void main(String[] args) &#123; List&lt;OOMError&gt; list = new ArrayList&lt;OOMError&gt;(); while (true) &#123; list.add(new OOMError()); &#125; &#125; 如何解决发生在Java堆内存的OutOfMemoryError异常呢？ 首先我们要分清楚产生OutOfMemoryError异常的原因是内存泄露还是内存溢出，如果内存中的对象确实都必须存活着而不像上面那样不断地创建对象实例却不使用该对象，则是内存溢出，而像上面代码中的情况则是内存泄露。 如果是内存泄露，我们可以通过一些内存查看工具来查看泄露对象到GC Roots的引用链，找到泄露对象是通过怎样的路径与GC Roots相关联并导致GC无法自动回收这些泄露对象，掌握了这些信息，我们就能比较准确地定位出泄露代码的位置。 如果不是内存泄露，也就是说内存中的对象确实都还必须存活，那么应该检查虚拟机的堆参数，看看是否还可以将机器物理内存调大，同时在代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况。 链接：http://www.imooc.com/article/18073 线程栈溢出栈（JVM Stack）存放主要是栈帧( 局部变量表, 操作数栈 , 动态链接 , 方法出口信息 )的地方。注意区分栈和栈帧：栈里包含栈帧。与线程栈相关的内存异常有两个：a）、StackOverflowError(方法调用层次太深，内存不够新建栈帧)b）、OutOfMemoryError（线程太多，内存不够新建线程）123public void stackOverFlowMethod()&#123; stackOverFlowMethod();&#125; http://www.imooc.com/article/18073https://blog.csdn.net/hu1991die/article/details/43052281 OOM你遇到过哪些情况 java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。 java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。 java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>gc</tag>
        <tag>oom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime的理解]]></title>
    <url>%2Fposts%2Fjava_jdk_base_runtime.html</url>
    <content type="text"><![CDATA[https://www.jianshu.com/p/b78fef2102eb https://blog.csdn.net/tomcmd/article/details/48971051 Java Runtime Area的分类 从线程的角度理解Java Runtime Area 从存储内容理解Java Runtime Area 方法区中究竟存储了哪些信息？ 基本数据类型的成员变量放在jvm的哪块内存区域里？ Java Runtime Area的分类Java Runtime Area主要可以分为六部分 ： Program Counter (PC) Register 程序计数器 Java Virtual Machine Stacks Java虚拟机栈 Heap Memory Java堆 Method Area 方法区 Run-time Constant Pool 运行时常量池 Native Method Stacks 本地方法栈 具体的每个区域的内容和特点可以参考《深入理解Java虚拟机》,此书已经讲的很详细了。下面我们对这几个数据区域进行分类，分别从不同的视角来分析，加深我们的理解 从线程的角度理解Java Runtime Area首先，我们从区域是否是线程私有的还是所有线程共享的来分类： image.png 程序计数器 Java虚拟机栈 本地方法栈都是线程私有的而Java堆**方法区**运行时常量池都是所有线程共享的 进一步理解： 对于线程私有的数据区域程序计数器 Java虚拟机栈 本地方法栈，他们的生存周期都是一致的，都是随着线程开始，而进行初始化随着线程结束而销毁 而对于线程共享的数据区域Java堆**方法区**运行时常量池，他们的生存周期都是一致的随着JVM的启动而分配内存随着JVM的关闭而销毁 从存储内容理解Java Runtime Area下面我们再根据不同区域所存储的数据类型进行分类：可以分为三类 方法区和常量池存储类的信息 堆内存存储对象信息 程序计数器，Java虚拟机栈，本地方法栈存储线程的信息 下图很清楚的说明 image.png The heap space holds object data, the method area holds class code, and the native area holds references to the code and object data.堆存储object的data，方法区存储class的信息和code，native区域存储指向class信息和code的引用和指向对象的data的引用 下面这个图更详细的指出了三个区域存储的内容： image.png 下面我们通过一个实际代码的例子，来说明; 看下面这段代码： image.png 这段代码编译之后，就存储成如下这个样子： image.png 易混淆的Java Runtime Area 的问题下面我们会对关于Java 运行时数据区易混淆的问题进行释疑 方法区中究竟存储了哪些信息？栈中存放了局部变量表等与方法有关的信息，但方法中还有指令代码这一重要内容，它既没有放在栈(Stack)中也没放在堆(Heap)中，那它放在哪呢？其实，方法区中除了包括你所说的“已加载的类的基本信息、常量、静态变量等”外，还包括编译器编译后的代码，而且这应该是方法区中主要的一部分，毕竟类中主要是方法和属性，而类中的属性，如果是实例域的话则新建对象后存储在堆(Heap)中，静态的话就如你所说存储在方法区中，因此该区域中方法占主要部分，这应该是此运行时数据区称为方法区的原因吧。 基本数据类型的成员变量放在jvm的哪块内存区域里？比如 123class&#123;private int i;&#125; 有的朋友可能因为基本数据类型，就认为存储在栈中。但其实是存储在堆中的，因为这是属于对象的信息，每个对象都拥有不同的实例变量，这些实例变量都存储在堆中，不管是基本数据类型还是引用数据类型ava虚拟机栈是线程私有的，生命周期跟线程相同，每个方法调用的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每个方法调用的过程，就代表了一个栈帧在虚拟机栈中入栈到出栈的过程，当进入一个方法时，这个方法在栈中需要分配多大的内存都是完全确定的，方法运行时不会改变局部变量表的大小——《深入理解java虚拟机第二版》很多java程序员一开始就被网上的一些教程所误导：基本数据类型放在栈中，数组和类的实例放在堆中。 这个说法不准确，事实上，如上面的实例变量i，他是存放在java堆中。因为它不是静态的变量，不会独立于类的实例而存在，而该类实例化之后，放在堆中，当然也包含了它的属性i。如果在方法中定义了int i = 0;则在局部变量表创建了两个对象：引用i和0。 这两个对象都是线程私有（安全）的。 比如定义了int[] is = new int[10]. 定义了两个对象，一个是is引用，放在局部变量表中，一个是长度为10的数组，放在堆中，这个数组，只能通过is来访问，方法结束后出栈，is被销毁，根据java的根搜索算法，判断数组不可达，就将它销毁了。]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[queue队列等结构源码原理]]></title>
    <url>%2Fposts%2Fjava_jdk_base_queue.html</url>
    <content type="text"><![CDATA[ConcurrentSkipListMap到目前为止，我们在Java世界里看到了两种实现key-value的数据结构：Hash、TreeMap，这两种数据结构各自都有着优缺点。 Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。 红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。 然而，这次介绍第三种实现key-value的数据结构：SkipList。SkipList有着不低于红黑树的效率，但是其原理和实现的复杂度要比红黑树简单多了。 SkipList什么是SkipList？Skip List ，称之为跳表，它是一种可以替代平衡树的数据结构，其数据元素默认按照key值升序，天然有序。Skip list让已排序的数据分布在多层链表中，以0-1随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。 我们先看一个简单的链表，如下： 如果我们需要查询9、21、30，则需要比较次数为3 + 6 + 8 = 17 次，那么有没有优化方案呢？有！我们将该链表中的某些元素提炼出来作为一个比较“索引”，如下： 我们先与这些索引进行比较来决定下一个元素是往右还是下走，由于存在“索引”的缘故，导致在检索的时候会大大减少比较的次数。当然元素不是很多，很难体现出优势，当元素足够多的时候，这种索引结构就会大显身手。 SkipList的特性SkipList具备如下特性： 由很多层结构组成，level是通过一定的概率随机产生的 每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法 最底层(Level 1)的链表包含所有元素 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素 我们将上图再做一些扩展就可以变成一个典型的SkipList结构了 SkipList的查找SkipListd的查找算法较为简单，对于上面我们我们要查找元素21，其过程如下： 比较3，大于，往后找（9）， 比9大，继续往后找（25），但是比25小，则从9的下一层开始找（16） 16的后面节点依然为25，则继续从16的下一层找 找到21 如图 红色虚线代表路径。 SkipList的插入SkipList的插入操作主要包括： 查找合适的位置。这里需要明确一点就是在确认新节点要占据的层次K时，采用丢硬币的方式，完全随机。如果占据的层次K大于链表的层次，则重新申请新的层，否则插入指定层次 申请新的节点 调整指针 假定我们要插入的元素为23，经过查找可以确认她是位于25后，9、16、21前。当然需要考虑申请的层次K。 如果层次K &gt; 3 需要申请新层次（Level 4） 如果层次 K = 2 直接在Level 2 层插入即可 这里会涉及到以个算法：通过丢硬币决定层次K，该算法我们通过后面ConcurrentSkipListMap源码来分析。还有一个需要注意的地方就是，在K层插入元素后，需要确保所有小于K层的层次都应该出现新节点。 SkipList的删除删除节点和插入节点思路基本一致：找到节点，删除节点，调整指针。 比如删除节点9，如下： ConcurrentSkipListMap通过上面我们知道SkipList采用空间换时间的算法，其插入和查找的效率O(logn)，其效率不低于红黑树，但是其原理和实现的复杂度要比红黑树简单多了。一般来说会操作链表List，就会对SkipList毫无压力。 ConcurrentSkipListMap其内部采用SkipLis数据结构实现。为了实现SkipList，ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中Node表示最底层的单链表有序节点、Index表示为基于Node的索引层，HeadIndex用来维护索引层次。到这里我们可以这样说ConcurrentSkipListMap是通过HeadIndex维护索引层次，通过Index从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层Node时，就只需要比较很小一部分数据了。在JDK中的关系如下图： Node 1234567static final class Node&lt;K,V&gt; &#123; final K key; volatile Object value; volatile ConcurrentSkipListMap.Node&lt;K, V&gt; next; /** 省略些许代码 */&#125; Node的结构和一般的单链表毫无区别，key-value和一个指向下一个节点的next。 Index 1234567static class Index&lt;K,V&gt; &#123; final ConcurrentSkipListMap.Node&lt;K,V&gt; node; final ConcurrentSkipListMap.Index&lt;K,V&gt; down; volatile ConcurrentSkipListMap.Index&lt;K,V&gt; right; /** 省略些许代码 */&#125; Index提供了一个基于Node节点的索引Node，一个指向下一个Index的right，一个指向下层的down节点。 HeadIndex 1234567static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; //索引层，从1开始，Node单链表层为0 HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125; HeadIndex内部就一个level来定义层级。 ConcurrentSkipListMap提供了四个构造函数，每个构造函数都会调用initialize()方法进行初始化工作。 123456789final void initialize() &#123; keySet = null; entrySet = null; values = null; descendingMap = null; randomSeed = seedGenerator.nextInt() | 0x0100; // ensure nonzero head = new ConcurrentSkipListMap.HeadIndex&lt;K,V&gt;(new ConcurrentSkipListMap.Node&lt;K,V&gt;(null, BASE_HEADER, null), null, null, 1);&#125; 注意，initialize()方法不仅仅只在构造函数中被调用，如clone，clear、readObject时都会调用该方法进行初始化步骤。这里需要注意randomSeed的初始化。 12private transient int randomSeed;randomSeed = seedGenerator.nextInt() | 0x0100; // ensure nonzero randomSeed一个简单的随机数生成器（在后面介绍）。 put操作CoucurrentSkipListMap提供了put()方法用于将指定值与此映射中的指定键关联。源码如下： 12345public V put(K key, V value) &#123; if (value == null) throw new NullPointerException(); return doPut(key, value, false);&#125; 首先判断value如果为null，则抛出NullPointerException，否则调用doPut方法，其实如果各位看过JDK的源码的话，应该对这样的操作很熟悉了，JDK源码里面很多方法都是先做一些必要性的验证后，然后通过调用do**()方法进行真正的操作。 doPut()方法内容较多，我们分步分析。 12345678910private V doPut(K key, V value, boolean onlyIfAbsent) &#123; Node&lt;K,V&gt; z; // added node if (key == null) throw new NullPointerException(); // 比较器 Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (Node&lt;K, V&gt; b = findPredecessor(key, cmp), n = b.next; ; ) &#123; /** 省略代码 */ doPut()方法有三个参数，除了key,value外还有一个boolean类型的onlyIfAbsent，该参数作用与如果存在当前key时，该做何动作。当onlyIfAbsent为false时，替换value，为true时，则返回该value。用代码解释为： 1234 if (!map.containsKey(key)) return map.put(key, value);else return map.get(key); 首先判断key是否为null，如果为null，则抛出NullPointerException，从这里我们可以确认ConcurrentSkipList是不支持key或者value为null的。然后调用findPredecessor()方法，传入key来确认位置。findPredecessor()方法其实就是确认key要插入的位置。 1234567891011121314151617181920212223242526272829303132333435363738private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123; if (key == null) throw new NullPointerException(); // don&apos;t postpone errors for (;;) &#123; // 从head节点开始，head是level最高级别的headIndex for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123; // r != null，表示该节点右边还有节点，需要比较 if (r != null) &#123; Node&lt;K,V&gt; n = r.node; K k = n.key; // value == null，表示该节点已经被删除了 // 通过unlink()方法过滤掉该节点 if (n.value == null) &#123; //删掉r节点 if (!q.unlink(r)) break; // restart r = q.right; // reread r continue; &#125; // value != null，节点存在 // 如果key 大于r节点的key 则往前进一步 if (cpr(cmp, key, k) &gt; 0) &#123; q = r; r = r.right; continue; &#125; &#125; // 到达最右边，如果dowm == null，表示指针已经达到最下层了，直接返回该节点 if ((d = q.down) == null) return q.node; q = d; r = d.right; &#125; &#125; &#125; findPredecessor()方法意思非常明确：寻找前辈。从最高层的headIndex开始向右一步一步比较，直到right为null或者右边节点的Node的key大于当前key为止，然后再向下寻找，依次重复该过程，直到down为null为止，即找到了前辈，看返回的结果注意是Node，不是Item，所以插入的位置应该是最底层的Node链表。 在这个过程中ConcurrentSkipListMap赋予了该方法一个其他的功能，就是通过判断节点的value是否为null，如果为null，表示该节点已经被删除了，通过调用unlink()方法删除该节点。 123final boolean unlink(Index&lt;K,V&gt; succ) &#123; return node.value != null &amp;&amp; casRight(succ, succ.right);&#125; 删除节点过程非常简单，更改下right指针即可。 通过findPredecessor()找到前辈节点后，做什么呢？看下面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; // 前辈节点的next != null if (n != null) &#123; Object v; int c; Node&lt;K,V&gt; f = n.next; // 不一致读，主要原因是并发，有节点捷足先登 if (n != b.next) // inconsistent read break; // n.value == null，该节点已经被删除了 if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // 前辈节点b已经被删除 if (b.value == null || v == n) // b is deleted break; // 节点大于，往前移 if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123; b = n; n = f; continue; &#125; // c == 0 表示，找到一个key相等的节点，根据onlyIfAbsent参数来做判断 // onlyIfAbsent ==false，则通过casValue，替换value // onlyIfAbsent == true，返回该value if (c == 0) &#123; if (onlyIfAbsent || n.casValue(v, value)) &#123; @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v; return vv; &#125; break; // restart if lost race to replace value &#125; // else c &lt; 0; fall through &#125; // 将key-value包装成一个node，插入 z = new Node&lt;K,V&gt;(key, value, n); if (!b.casNext(n, z)) break; // restart if lost race to append to b break outer; &#125; 找到合适的位置后，就是在该位置插入节点咯。插入节点的过程比较简单，就是将key-value包装成一个Node，然后通过casNext()方法加入到链表当中。当然是插入之前需要进行一系列的校验工作。 在最下层插入节点后，下一步工作是什么？新建索引。前面博主提过，在插入节点的时候，会根据采用抛硬币的方式来决定新节点所插入的层次，由于存在并发的可能，ConcurrentSkipListMap采用ThreadLocalRandom来生成随机数。如下： 1int rnd = ThreadLocalRandom.nextSecondarySeed(); 抛硬币决定层次的思想很简单，就是通过抛硬币如果硬币为正面则层次level + 1 ，否则停止，如下： 123// 抛硬币决定层次while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0) ++level; 在阐述SkipList插入节点的时候说明了，决定的层次level会分为两种情况进行处理，一是如果层次level大于最大的层次话则需要新增一层，否则就在相应层次以及小于该level的层次进行节点新增处理。 level &lt;= headIndex.level 123456// 如果决定的层次level比最高层次head.level小，直接生成最高层次的index// 由于需要确认每一层次的down，所以需要从最下层依次往上生成if (level &lt;= (max = h.level)) &#123; for (int i = 1; i &lt;= level; ++i) idx = new ConcurrentSkipListMap.Index&lt;K,V&gt;(z, idx, null);&#125; 从底层开始，小于level的每一层都初始化一个index，每次的node都指向新加入的node，down指向下一层的item，右侧next全部为null。整个处理过程非常简单：为小于level的每一层初始化一个index，然后加入到原来的index链条中去。 level &gt; headIndex.level 123456789101112131415161718192021222324252627282930313233// leve &gt; head.level 则新增一层 else &#123; // try to grow by one level // 新增一层 level = max + 1; // 初始化 level个item节点 @SuppressWarnings(&quot;unchecked&quot;) ConcurrentSkipListMap.Index&lt;K,V&gt;[] idxs = (ConcurrentSkipListMap.Index&lt;K,V&gt;[])new ConcurrentSkipListMap.Index&lt;?,?&gt;[level+1]; for (int i = 1; i &lt;= level; ++i) idxs[i] = idx = new ConcurrentSkipListMap.Index&lt;K,V&gt;(z, idx, null); // for (;;) &#123; h = head; int oldLevel = h.level; // 层次扩大了，需要重新开始（有新线程节点加入） if (level &lt;= oldLevel) // lost race to add level break; // 新的头结点HeadIndex ConcurrentSkipListMap.HeadIndex&lt;K,V&gt; newh = h; ConcurrentSkipListMap.Node&lt;K,V&gt; oldbase = h.node; // 生成新的HeadIndex节点，该HeadIndex指向新增层次 for (int j = oldLevel+1; j &lt;= level; ++j) newh = new ConcurrentSkipListMap.HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j); // HeadIndex CAS替换 if (casHead(h, newh)) &#123; h = newh; idx = idxs[level = oldLevel]; break; &#125; &#125; 当抛硬币决定的level大于最大层次level时，需要新增一层进行处理。处理逻辑如下： 初始化一个对应的index数组，大小为level + 1，然后为每个单位都创建一个index，个中参数为：Node为新增的Z，down为下一层index，right为null 通过for循环来进行扩容操作。从最高层进行处理，新增一个HeadIndex，个中参数：节点Node，down都为最高层的Node和HeadIndex，right为刚刚创建的对应层次的index，level为相对应的层次level。最后通过CAS把当前的head与新加入层的head进行替换。 通过上面步骤我们发现，尽管已经找到了前辈节点，也将node插入了，也确定确定了层次并生成了相应的Index，但是并没有将这些Index插入到相应的层次当中，所以下面的代码就是将index插入到相对应的层当中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 从插入的层次level开始 splice: for (int insertionLevel = level;;) &#123; int j = h.level; // 从headIndex开始 for (ConcurrentSkipListMap.Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123; if (q == null || t == null) break splice; // r != null；这里是找到相应层次的插入节点位置，注意这里只横向找 if (r != null) &#123; ConcurrentSkipListMap.Node&lt;K,V&gt; n = r.node; int c = cpr(cmp, key, n.key); // n.value == null ，解除关系，r右移 if (n.value == null) &#123; if (!q.unlink(r)) break; r = q.right; continue; &#125; // key &gt; n.key 右移 if (c &gt; 0) &#123; q = r; r = r.right; continue; &#125; &#125; // 上面找到节点要插入的位置，这里就插入 // 当前层是最顶层 if (j == insertionLevel) &#123; // 建立联系 if (!q.link(r, t)) break; // restart if (t.node.value == null) &#123; findNode(key); break splice; &#125; // 标志的插入层 -- ，如果== 0 ，表示已经到底了，插入完毕，退出循环 if (--insertionLevel == 0) break splice; &#125; // 上面节点已经插入完毕了，插入下一个节点 if (--j &gt;= insertionLevel &amp;&amp; j &lt; level) t = t.down; q = q.down; r = q.right; &#125; &#125; 这段代码分为两部分看，一部分是找到相应层次的该节点插入的位置，第二部分在该位置插入，然后下移。 至此，ConcurrentSkipListMap的put操作到此就结束了。代码量有点儿多，这里总结下： 首先通过findPredecessor()方法找到前辈节点Node 根据返回的前辈节点以及key-value，新建Node节点，同时通过CAS设置next 设置节点Node，再设置索引节点。采取抛硬币方式决定层次，如果所决定的层次大于现存的最大层次，则新增一层，然后新建一个Item链表。 最后，将新建的Item链表插入到SkipList结构中。 get操作相比于put操作 ，get操作会简单很多，其过程其实就只相当于put操作的第一步： 123456789101112131415161718192021222324252627282930private V doGet(Object key) &#123; if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (ConcurrentSkipListMap.Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; Object v; int c; if (n == null) break outer; ConcurrentSkipListMap.Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) == 0) &#123; @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v; return vv; &#125; if (c &lt; 0) break outer; b = n; n = f; &#125; &#125; return null; &#125; 与put操作第一步相似，首先调用findPredecessor()方法找到前辈节点，然后顺着right一直往右找即可，同时在这个过程中同样承担了一个删除value为null的节点的职责。 remove操作remove操作为删除指定key节点，如下： 123public V remove(Object key) &#123; return doRemove(key, null);&#125; 直接调用doRemove()方法，这里remove有两个参数，一个是key，另外一个是value，所以doRemove方法即提供remove key，也提供同时满足key-value。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162final V doRemove(Object key, Object value) &#123; if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (ConcurrentSkipListMap.Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; Object v; int c; if (n == null) break outer; ConcurrentSkipListMap.Node&lt;K,V&gt; f = n.next; // 不一致读，重新开始 if (n != b.next) // inconsistent read break; // n节点已删除 if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // b节点已删除 if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) &lt; 0) break outer; // 右移 if (c &gt; 0) &#123; b = n; n = f; continue; &#125; /* * 找到节点 */ // value != null 表示需要同时校验key-value值 if (value != null &amp;&amp; !value.equals(v)) break outer; // CAS替换value if (!n.casValue(v, null)) break; if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // retry via findNode else &#123; // 清理节点 findPredecessor(key, cmp); // clean index // head.right == null表示该层已经没有节点，删掉该层 if (head.right == null) tryReduceLevel(); &#125; @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v; return vv; &#125; &#125; return null; &#125; 调用findPredecessor()方法找到前辈节点，然后通过右移，然后比较，找到后利用CAS把value替换为null，然后判断该节点是不是这层唯一的index，如果是的话，调用tryReduceLevel()方法把这层干掉，完成删除。 其实从这里可以看出，remove方法仅仅是把Node的value设置null，并没有真正删除该节点Node，其实从上面的put操作、get操作我们可以看出，他们在寻找节点的时候都会判断节点的value是否为null，如果为null，则调用unLink()方法取消关联关系，如下： 123456if (n.value == null) &#123; if (!q.unlink(r)) break; // restart r = q.right; // reread r continue;&#125; size操作ConcurrentSkipListMap的size()操作和ConcurrentHashMap不同，它并没有维护一个全局变量来统计元素的个数，所以每次调用该方法的时候都需要去遍历。 12345678public int size() &#123; long count = 0; for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) &#123; if (n.getValidValue() != null) ++count; &#125; return (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;&#125; 调用findFirst()方法找到第一个Node，然后利用node的next去统计。最后返回统计数据，最多能返回Integer.MAX_VALUE。注意这里在线程并发下是安全的。 ConcurrentSkipListMap过程其实不复杂，相比于ConcurrentHashMap而言，是简单的不能再简单了。对跳表SkipList熟悉的话，ConcurrentSkipListMap 应该是盘中餐了。 我们知道线程Thread可以调用setPriority(int newPriority)来设置优先级的，线程优先级高的线程先执行，优先级低的后执行。而前面介绍的ArrayBlockingQueue、LinkedBlockingQueue都是采用FIFO原则来确定线程执行的先后顺序，那么有没有一个队列可以支持优先级呢？ PriorityBlockingQueue 。 PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。 PriorityBlockingQueue二叉堆由于PriorityBlockingQueue底层采用二叉堆来实现的，所以有必要先介绍下二叉堆。 二叉堆是一种特殊的堆，就结构性而言就是完全二叉树或者是近似完全二叉树，满足树结构性和堆序性。树机构特性就是完全二叉树应该有的结构，堆序性则是：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。它有两种表现形式：最大堆、最小堆。 最大堆：父节点的键值总是大于或等于任何一个子节点的键值（下右图） 最小堆：父节点的键值总是小于或等于任何一个子节点的键值（下走图） 二叉堆一般用数组表示，如果父节点的节点位置在n处，那么其左孩子节点为：2 n + 1 ，其右孩子节点为2 (n + 1)，其父节点为（n - 1） / 2 处。上左图的数组表现形式为： 二叉堆的基本结构了解了，下面来看看二叉堆的添加和删除节点。二叉堆的添加和删除相对于二叉树来说会简单很多。 添加元素首先将要添加的元素N插添加到堆的末尾位置（在二叉堆中我们称之为空穴）。如果元素N放入空穴中而不破坏堆的序（其值大于跟父节点值（最大堆是小于父节点）），那么插入完成。否则，我们则将该元素N的节点与其父节点进行交换，然后与其新父节点进行比较直到它的父节点不在比它小（最大堆是大）或者到达根节点。 假如有如下一个二叉堆 这是一个最小堆，其父节点总是小于等于任一一个子节点。现在我们添加一个元素2。 第一步：在末尾添加一个元素2，如下： 第二步：元素2比其父节点6小，进行替换，如下： 第三步：继续与其父节点5比较，小于，替换： 第四步：继续比较其跟节点1，发现跟节点比自己小，则完成，到这里元素2插入完毕。所以整个添加元素过程可以概括为：在元素末尾插入元素，然后不断比较替换直到不能移动为止。 复杂度：Ο(logn) 删除元素删除元素与增加元素一样，需要维护整个二叉堆的序。删除位置1的元素（数组下标0），则把最后一个元素空出来移到最前边，然后和它的两个子节点比较，如果两个子节点中较小的节点小于该节点，就将他们交换，知道两个子节点都比该元素大为止。 就上面二叉堆而言，删除的元素为元素1。 第一步：删掉元素1，元素6空出来，如下： 第二步：与其两个子节点（元素2、元素3）比较，都小，将其中较小的元素（元素2）放入到该空穴中： 第三步：继续比较两个子节点（元素5、元素7），还是都小，则将较小的元素（元素5）放入到该空穴中： 第四步：比较其子节点（元素8），比该节点小，则元素6放入该空穴位置不会影响二叉堆的树结构，放入： 到这里整个删除操作就已经完成了。 二叉堆的添加、删除操作还是比较简单的，很容易就理解了。下面我们就参考该内容来开启PriorityBlockingQueue的源代码研究。 PriorityBlockingQueuePriorityBlockingQueue继承AbstractQueue，实现BlockingQueue接口。 12public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable 定义了一些属性 12345678910111213141516171819202122232425// 默认容量 private static final int DEFAULT_INITIAL_CAPACITY = 11; // 最大容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 二叉堆数组 private transient Object[] queue; // 队列元素的个数 private transient int size; // 比较器，如果为空，则为自然顺序 private transient Comparator&lt;? super E&gt; comparator; // 内部锁 private final ReentrantLock lock; private final Condition notEmpty; // private transient volatile int allocationSpinLock; // 优先队列：主要用于序列化，这是为了兼容之前的版本。只有在序列化和反序列化才非空 private PriorityQueue&lt;E&gt; q; 内部仍然采用可重入锁ReentrantLock来实现同步机制，但是这里只有一个notEmpty的Condition，了解了ArrayBlockingQueue我们知道它定义了两个Condition，之类为何只有一个呢？原因就在于PriorityBlockingQueue是一个无界队列，插入总是会成功，除非消耗尽了资源导致服务器挂。 入列PriorityBlockingQueue提供put()、add()、offer()方法向队列中加入元素。我们这里从put()入手：put(E e) ：将指定元素插入此优先级队列。 123public void put(E e) &#123; offer(e); // never need to block&#125; PriorityBlockingQueue是无界的，所以不可能会阻塞。内部调用offer(E e)： 123456789101112131415161718192021222324252627public boolean offer(E e) &#123; // 不能为null if (e == null) throw new NullPointerException(); // 获取锁 final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 扩容 while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; // 根据比较器是否为null，做不同的处理 if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; // 唤醒正在等待的消费者线程 notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true; &#125; siftUpComparable当比较器comparator为null时，采用自然排序，调用siftUpComparable方法： 1234567891011121314151617private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; // “上冒”过程 while (k &gt; 0) &#123; // 父级节点 （n - ） / 2 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; // key &gt;= parent 完成（最大堆） if (key.compareTo((T) e) &gt;= 0) break; // key &lt; parant 替换 array[k] = e; k = parent; &#125; array[k] = key; &#125; 这段代码所表示的意思：将元素X插入到数组中，然后进行调整以保持二叉堆的特性。 siftUpUsingComparator当比较器不为null时，采用所指定的比较器，调用siftUpUsingComparator方法： 123456789101112private static &lt;T&gt; void siftUpUsingComparator(int k, T x, Object[] array, Comparator&lt;? super T&gt; cmp) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (cmp.compare(x, (T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = x; &#125; 扩容：tryGrow 12345678910111213141516171819202122232425262728293031323334private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // 扩容操作使用自旋，不需要锁主锁，释放 Object[] newArray = null; // CAS 占用 if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; // 新容量 最小翻倍 int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : (oldCap &gt;&gt; 1)); // 超过 if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; // 最大容量 &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; // 扩容后allocationSpinLock = 0 代表释放了自旋锁 &#125; &#125; // 到这里如果是本线程扩容newArray肯定是不为null，为null就是其他线程在处理扩容，那就让给别的线程处理 if (newArray == null) Thread.yield(); // 主锁获取锁 lock.lock(); // 数组复制 if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; 整个添加元素的过程和上面二叉堆一模一样：先将元素添加到数组末尾，然后采用“上冒”的方式将该元素尽量往上冒。 出列PriorityBlockingQueue提供poll()、remove()方法来执行出对操作。出对的永远都是第一个元素：array[0]。 123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return dequeue(); &#125; finally &#123; lock.unlock(); &#125; &#125; 先获取锁，然后调用dequeue()方法： 12345678910111213141516171819202122private E dequeue() &#123; // 没有元素 返回null int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; // 出对元素 E result = (E) array[0]; // 最后一个元素（也就是插入到空穴中的元素） E x = (E) array[n]; array[n] = null; // 根据比较器释放为null，来执行不同的处理 Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125; &#125; siftDownComparable 如果比较器为null，则调用siftDownComparable来进行自然排序处理： 1234567891011121314151617181920212223242526private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array, int n) &#123; if (n &gt; 0) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x; // 最后一个叶子节点的父节点位置 int half = n &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // 待调整位置左节点位置 Object c = array[child]; //左节点 int right = child + 1; //右节点 //左右节点比较，取较小的 if (right &lt; n &amp;&amp; ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0) c = array[child = right]; //如果待调整key最小，那就退出，直接赋值 if (key.compareTo((T) c) &lt;= 0) break; //如果key不是最小，那就取左右节点小的那个放到调整位置，然后小的那个节点位置开始再继续调整 array[k] = c; k = child; &#125; array[k] = key; &#125; &#125; 处理思路和二叉堆删除节点的逻辑一样：就第一个元素定义为空穴，然后把最后一个元素取出来，尝试插入到空穴位置，并与两个子节点值进行比较，如果不符合，则与其中较小的子节点进行替换，然后继续比较调整。 siftDownUsingComparator 如果指定了比较器，则采用比较器来进行调整： 12345678910111213141516171819private static &lt;T&gt; void siftDownUsingComparator(int k, T x, Object[] array, int n, Comparator&lt;? super T&gt; cmp) &#123; if (n &gt; 0) &#123; int half = n &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = array[child]; int right = child + 1; if (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; 0) c = array[child = right]; if (cmp.compare(x, (T) c) &lt;= 0) break; array[k] = c; k = child; &#125; array[k] = x; &#125;&#125; PriorityBlockingQueue采用二叉堆来维护，所以整个处理过程不是很复杂，添加操作则是不断“上冒”，而删除操作则是不断“下掉”。掌握二叉堆就掌握了PriorityBlockingQueue，无论怎么变还是不离其宗。对于PriorityBlockingQueue需要注意的是他是一个无界队列，所以添加操作是不会失败的，除非资源耗尽。 前面的BlockingQueue都是单向的FIFO队列，而LinkedBlockingDeque则是一个由链表组成的双向阻塞队列，双向队列就意味着可以从对头、对尾两端插入和移除元素，同样意味着LinkedBlockingDeque支持FIFO、FILO两种操作方式。 LinkedBlockingDeque是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。 DelayQueue是一个支持延时获取元素的无界阻塞队列。里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行。也就是说只有在延迟期到时才能够从队列中取元素。 DelayQueue主要用于两个方面：- 缓存：清掉缓存中超时的缓存数据- 任务超时处理 DelayQueueDelayQueue实现的关键主要有如下几个： 可重入锁ReentrantLock 用于阻塞和通知的Condition对象 根据Delay时间排序的优先级队列：PriorityQueue 用于优化阻塞通知的线程元素leader ReentrantLock、Condition这两个对象就不需要阐述了，他是实现整个BlockingQueue的核心。PriorityQueue是一个支持优先级线程排序的队列（参考【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue），leader后面阐述。这里我们先来了解Delay，他是实现延时操作的关键。 DelayedDelayed接口是用来标记那些应该在给定延迟时间之后执行的对象，它定义了一个long getDelay(TimeUnit unit)方法，该方法返回与此对象相关的的剩余时间。同时实现该接口的对象必须定义一个compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125; 如何使用该接口呢？上面说的非常清楚了，实现该接口的getDelay()方法，同时定义compareTo()方法即可。 内部结构先看DelayQueue的定义： 123456789101112131415public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; /** 可重入锁 */ private final transient ReentrantLock lock = new ReentrantLock(); /** 支持优先级的BlockingQueue */ private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); /** 用于优化阻塞 */ private Thread leader = null; /** Condition */ private final Condition available = lock.newCondition(); /** * 省略很多代码 */&#125; 看了DelayQueue的内部结构就对上面几个关键点一目了然了，但是这里有一点需要注意，DelayQueue的元素都必须继承Delayed接口。同时也可以从这里初步理清楚DelayQueue内部实现的机制了：以支持优先级无界队列的PriorityQueue作为一个容器，容器里面的元素都应该实现Delayed接口，在每次往优先级队列中添加元素时以元素的过期时间作为排序条件，最先过期的元素放在优先级最高。 offer()1234567891011121314151617public boolean offer(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 向 PriorityQueue中插入元素 q.offer(e); // 如果当前元素的对首元素（优先级最高），leader设置为空，唤醒所有等待线程 if (q.peek() == e) &#123; leader = null; available.signal(); &#125; // 无界队列，永远返回true return true; &#125; finally &#123; lock.unlock(); &#125;&#125; offer(E e)就是往PriorityQueue中添加元素，具体可以参考（【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue）。整个过程还是比较简单，但是在判断当前元素是否为对首元素，如果是的话则设置leader=null，这是非常关键的一个步骤，后面阐述。 take()123456789101112131415161718192021222324252627282930313233343536373839404142public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; // 对首元素 E first = q.peek(); // 对首为空，阻塞，等待off()操作唤醒 if (first == null) available.await(); else &#123; // 获取对首元素的超时时间 long delay = first.getDelay(NANOSECONDS); // &lt;=0 表示已过期，出对，return if (delay &lt;= 0) return q.poll(); first = null; // don&apos;t retain ref while waiting // leader != null 证明有其他线程在操作，阻塞 if (leader != null) available.await(); else &#123; // 否则将leader 设置为当前线程，独占 Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; // 超时阻塞 available.awaitNanos(delay); &#125; finally &#123; // 释放leader if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; // 唤醒阻塞线程 if (leader == null &amp;&amp; q.peek() != null) available.signal(); lock.unlock(); &#125;&#125; 首先是获取对首元素，如果对首元素的延时时间 delay &lt;= 0 ，则可以出对了，直接return即可。否则设置first = null，这里设置为null的主要目的是为了避免内存泄漏。如果 leader != null 则表示当前有线程占用，则阻塞，否则设置leader为当前线程，然后调用awaitNanos()方法超时等待。 first = null 这里为什么如果不设置first = null，则会引起内存泄漏呢？线程A到达，列首元素没有到期，设置leader = 线程A，这是线程B来了因为leader != null，则会阻塞，线程C一样。假如线程阻塞完毕了，获取列首元素成功，出列。这个时候列首元素应该会被回收掉，但是问题是它还被线程B、线程C持有着，所以不会回收，这里只有两个线程，如果有线程D、线程E…呢？这样会无限期的不能回收，就会造成内存泄漏。 这个入队、出对过程和其他的阻塞队列没有很大区别，无非是在出对的时候增加了一个到期时间的判断。同时通过leader来减少不必要阻塞。 LinkedBlockingDequeLinkedBlockingDeque 继承AbstractQueue，实现接口BlockingDeque，而BlockingDeque又继承接口BlockingQueue，BlockingDeque是支持两个附加操作的 Queue，这两个操作是：获取元素时等待双端队列变为非空；存储元素时等待双端队列中的空间变得可用。这两类操作就为LinkedBlockingDeque 的双向操作Queue提供了可能。BlockingDeque接口提供了一系列的以First和Last结尾的方法，如addFirst、addLast、peekFirst、peekLast。 1234567891011121314151617181920212223public class LinkedBlockingDeque&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingDeque&lt;E&gt;, java.io.Serializable &#123; // 双向链表的表头 transient Node&lt;E&gt; first; // 双向链表的表尾 transient Node&lt;E&gt; last; // 大小，双向链表中当前节点个数 private transient int count; // 容量，在创建LinkedBlockingDeque时指定的 private final int capacity; final ReentrantLock lock = new ReentrantLock(); private final Condition notEmpty = lock.newCondition(); private final Condition notFull = lock.newCondition();&#125; 通过上面的Lock可以看出，LinkedBlockingDeque底层实现机制与LinkedBlockingQueue一样，依然是通过互斥锁ReentrantLock 来实现，notEmpty 、notFull 两个Condition做协调生产者、消费者问题。 与其他BlockingQueue一样，节点还是使用内部类Node： 1234567891011static final class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; prev; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125;&#125; 双向嘛，节点肯定得要有前驱prev、后继next咯。 基础方法LinkedBlockingDeque 的add、put、offer、take、peek、poll系列方法都是通过调用XXXFirst，XXXLast方法。所以这里就仅以putFirst、putLast、pollFirst、pollLast分析下。 putFirstputFirst(E e) :将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。 12345678910111213141516public void putFirst(E e) throws InterruptedException &#123; // check null if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); // 获取锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; while (!linkFirst(node)) // 在notFull条件上等待，直到被唤醒或中断 notFull.await(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 先获取锁，然后调用linkFirst方法入列，最后释放锁。如果队列是满的则在notFull上面等待。linkFirst设置Node为对头： 1234567891011121314151617181920212223private boolean linkFirst(Node&lt;E&gt; node) &#123; // 超出容量 if (count &gt;= capacity) return false; // 首节点 Node&lt;E&gt; f = first; // 新节点的next指向原first node.next = f; // 设置node为新的first first = node; // 没有尾节点，设置node为尾节点 if (last == null) last = node; // 有尾节点，那就将之前first的pre指向新增node else f.prev = node; ++count; // 唤醒notEmpty notEmpty.signal(); return true;&#125; linkFirst主要是设置node节点队列的列头节点，成功返回true，如果队列满了返回false。整个过程还是比较简单的。 putLastputLast(E e) :将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。 123456789101112public void putLast(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; while (!linkLast(node)) notFull.await(); &#125; finally &#123; lock.unlock(); &#125;&#125; 调用linkLast将节点Node链接到队列尾部： 123456789101112131415161718192021private boolean linkLast(Node&lt;E&gt; node) &#123; if (count &gt;= capacity) return false; // 尾节点 Node&lt;E&gt; l = last; // 将Node的前驱指向原本的last node.prev = l; // 将node设置为last last = node; // 首节点为null，则设置node为first if (first == null) first = node; else //非null，说明之前的last有值，就将之前的last的next指向node l.next = node; ++count; notEmpty.signal(); return true;&#125; pollFirstpollFirst()：获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。 123456789public E pollFirst() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return unlinkFirst(); &#125; finally &#123; lock.unlock(); &#125;&#125; 调用unlinkFirst移除队列首元素： 1234567891011121314151617181920212223242526272829private E unlinkFirst() &#123; // 首节点 Node&lt;E&gt; f = first; // 空队列，直接返回null if (f == null) return null; // first.next Node&lt;E&gt; n = f.next; // 节点item E item = f.item; // 移除掉first ==&gt; first = first.next f.item = null; f.next = f; // help GC first = n; // 移除后为空队列，仅有一个节点 if (n == null) last = null; else // n的pre原来指向之前的first，现在n变为first了，pre指向null n.prev = null; --count; notFull.signal(); return item;&#125; pollLastpollLast():获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。 123456789public E pollLast() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return unlinkLast(); &#125; finally &#123; lock.unlock(); &#125;&#125; 调用unlinkLast移除尾结点，链表空返回null ： 123456789101112131415161718private E unlinkLast() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; l = last; if (l == null) return null; Node&lt;E&gt; p = l.prev; E item = l.item; l.item = null; l.prev = l; // help GC last = p; if (p == null) first = null; else p.next = null; --count; notFull.signal(); return item;&#125; LinkedBlockingDeque大部分方法都是通过linkFirst、linkLast、unlinkFirst、unlinkLast这四个方法来实现的，因为是双向队列，所以他们都是针对first、last的操作，看懂这个整个LinkedBlockingDeque就不难了。 掌握了双向队列的插入、删除操作，LinkedBlockingDeque就没有任何难度可言了，数据结构的重要性啊！！！！ SynchronousQueue数据结构 由于SynchronousQueue的支持公平策略和非公平策略，所以底层可能两种数据结构：队列（实现公平策略）和栈（实现非公平策略），队列与栈都是通过链表来实现的。具体的数据结构如下 说明：数据结构有两种类型，栈和队列；栈有一个头结点，队列有一个头结点和尾结点；栈用于实现非公平策略，队列用于实现公平策略。 SynchronousQueue源码分析 3.1 类的继承关系 12public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;&#125; 说明：SynchronousQueue继承了AbstractQueue抽象类，AbstractQueue定义了对队列的基本操作；同时实现了BlockingQueue接口，BlockingQueue表示阻塞型的队列，其对队列的操作可能会抛出异常；同时也实现了Searializable接口，表示可以被序列化。 3.2 类的内部类 SynchronousQueue的内部类框架图如下 说明：其中比较重要的类是左侧的三个类，Transferer是TransferStack栈和TransferQueue队列的公共类，定义了转移数据的公共操作，由TransferStack和TransferQueue具体实现，WaitQueue、LifoWaitQueue、FifoWaitQueue表示为了兼容JDK1.5版本中的SynchronousQueue的序列化策略所遗留的，这里不做具体的讲解。下面着重看左侧的三个类。 ① Transferer ;) 1234567891011121314151617abstract static class Transferer&lt;E&gt; &#123; /** * Performs a put or take. * * @param e if non-null, the item to be handed to a consumer; * if null, requests that transfer return an item * offered by producer. * @param timed if this operation should timeout * @param nanos the timeout, in nanoseconds * @return if non-null, the item provided or received; if null, * the operation failed due to timeout or interrupt -- * the caller can distinguish which of these occurred * by checking Thread.interrupted. */ // 转移数据，put或者take操作 abstract E transfer(E e, boolean timed, long nanos);&#125; ;) 说明：Transferer定义了transfer操作，用于take或者put数据。transfer方法由子类实现。 ② TransfererStack 1. 类的继承关系 1static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123;&#125; http://www.cnblogs.com/leesf456/p/5560362.html 作为BlockingQueue中的一员，SynchronousQueue与其他BlockingQueue有着不同特性： SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。 因为没有容量，所以对应 peek, contains, clear, isEmpty … 等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false,peek始终返回null。 SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。 若使用 TransferQueue, 则队列中永远会存在一个 dummy node（这点后面详细阐述）。 SynchronousQueue非常适合做交换工作，生产者的线程和消费者的线程同步以传递某些信息、事件或者任务。 与其他BlockingQueue一样，SynchronousQueue同样继承AbstractQueue和实现BlockingQueue接口： 12public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable SynchronousQueue提供了两个构造函数： 123456789public SynchronousQueue() &#123; this(false);&#125;public SynchronousQueue(boolean fair) &#123; // 通过 fair 值来决定公平性和非公平性 // 公平性使用TransferQueue，非公平性采用TransferStack transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125; TransferQueue、TransferStack继承Transferer，Transferer为SynchronousQueue的内部类，它提供了一个方法transfer()，该方法定义了转移数据的规范，如下： 123abstract static class Transferer&lt;E&gt; &#123; abstract E transfer(E e, boolean timed, long nanos);&#125; transfer()方法主要用来完成转移数据的，如果e != null，相当于将一个数据交给消费者，如果e == null，则相当于从一个生产者接收一个消费者交出的数据。 SynchronousQueue采用队列TransferQueue来实现公平性策略，采用堆栈TransferStack来实现非公平性策略，他们两种都是通过链表实现的，其节点分别为QNode，SNode。TransferQueue和TransferStack在SynchronousQueue中扮演着非常重要的作用，SynchronousQueue的put、take操作都是委托这两个类来实现的。 TransferQueueTransferQueue是实现公平性策略的核心类，其节点为QNode，其定义如下： 12345678910111213static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; &#123; /** 头节点 */ transient volatile QNode head; /** 尾节点 */ transient volatile QNode tail; // 指向一个取消的结点 //当一个节点中最后一个插入时，它被取消了但是可能还没有离开队列 transient volatile QNode cleanMe; /** * 省略很多代码O(∩_∩)O */&#125; 在TransferQueue中除了头、尾节点外还存在一个cleanMe节点。该节点主要用于标记，当删除的节点是尾节点时则需要使用该节点。 同时，对于TransferQueue需要注意的是，其队列永远都存在一个dummy node，在构造时创建： 12345TransferQueue() &#123; QNode h = new QNode(null, false); // initialize to dummy node. head = h; tail = h;&#125; 在TransferQueue中定义了QNode类来表示队列中的节点，QNode节点定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static final class QNode &#123; // next 域 volatile QNode next; // item数据项 volatile Object item; // 等待线程，用于park/unpark volatile Thread waiter; // to control park/unpark //模式，表示当前是数据还是请求，只有当匹配的模式相匹配时才会交换 final boolean isData; QNode(Object item, boolean isData) &#123; this.item = item; this.isData = isData; &#125; /** * CAS next域，在TransferQueue中用于向next推进 */ boolean casNext(QNode cmp, QNode val) &#123; return next == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; /** * CAS itme数据项 */ boolean casItem(Object cmp, Object val) &#123; return item == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; /** * 取消本结点，将item域设置为自身 */ void tryCancel(Object cmp) &#123; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this); &#125; /** * 是否被取消 * 与tryCancel相照应只需要判断item释放等于自身即可 */ boolean isCancelled() &#123; return item == this; &#125; boolean isOffList() &#123; return next == this; &#125; private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = QNode.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 上面代码没啥好看的，需要注意的一点就是isData，该属性在进行数据交换起到关键性作用，两个线程进行数据交换的时候，必须要两者的模式保持一致。 TransferStackTransferStack用于实现非公平性，定义如下： 123456789101112131415static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123; static final int REQUEST = 0; static final int DATA = 1; static final int FULFILLING = 2; volatile SNode head; /** * 省略一堆代码 O(∩_∩)O~ */&#125; TransferStack中定义了三个状态：REQUEST表示消费数据的消费者，DATA表示生产数据的生产者，FULFILLING，表示匹配另一个生产者或消费者。任何线程对TransferStack的操作都属于上述3种状态中的一种（对应着SNode节点的mode）。同时还包含一个head域，表示头结点。 内部节点SNode定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static final class SNode &#123; // next 域 volatile SNode next; // 相匹配的节点 volatile SNode match; // 等待的线程 volatile Thread waiter; // item 域 Object item; // data; or null for REQUESTs // 模型 int mode; /** * item域和mode域不需要使用volatile修饰，因为它们在volatile/atomic操作之前写，之后读 */ SNode(Object item) &#123; this.item = item; &#125; boolean casNext(SNode cmp, SNode val) &#123; return cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; /** * 将s结点与本结点进行匹配，匹配成功，则unpark等待线程 */ boolean tryMatch(SNode s) &#123; if (match == null &amp;&amp; UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123; Thread w = waiter; if (w != null) &#123; // waiters need at most one unpark waiter = null; LockSupport.unpark(w); &#125; return true; &#125; return match == s; &#125; void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this); &#125; boolean isCancelled() &#123; return match == this; &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long matchOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = SNode.class; matchOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;match&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 上面简单介绍了TransferQueue、TransferStack，由于SynchronousQueue的put、take操作都是调用Transfer的transfer()方法，只不过是传递的参数不同而已，put传递的是e参数，所以模式为数据（公平isData = true，非公平mode= DATA），而take操作传递的是null，所以模式为请求（公平isData = false，非公平mode = REQUEST），如下： 1234567891011121314151617// put操作public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); if (transferer.transfer(e, false, 0) == null) &#123; Thread.interrupted(); throw new InterruptedException(); &#125;&#125;// take操作public E take() throws InterruptedException &#123; E e = transferer.transfer(null, false, 0); if (e != null) return e; Thread.interrupted(); throw new InterruptedException();&#125; 公平模式公平性调用TransferQueue的transfer方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798E transfer(E e, boolean timed, long nanos) &#123; QNode s = null; // 当前节点模式 boolean isData = (e != null); for (;;) &#123; QNode t = tail; QNode h = head; // 头、尾节点 为null，没有初始化 if (t == null || h == null) continue; // 头尾节点相等（队列为null） 或者当前节点和队列节点模式一样 if (h == t || t.isData == isData) &#123; // tn = t.next QNode tn = t.next; // t != tail表示已有其他线程操作了，修改了tail，重新再来 if (t != tail) continue; // tn != null，表示已经有其他线程添加了节点，tn 推进，重新处理 if (tn != null) &#123; // 当前线程帮忙推进尾节点，就是尝试将tn设置为尾节点 advanceTail(t, tn); continue; &#125; // 调用的方法的 wait 类型的, 并且 超时了, 直接返回 null // timed 在take操作阐述 if (timed &amp;&amp; nanos &lt;= 0) return null; // s == null，构建一个新节点Node if (s == null) s = new QNode(e, isData); // 将新建的节点加入到队列中，如果不成功，继续处理 if (!t.casNext(null, s)) continue; // 替换尾节点 advanceTail(t, s); // 调用awaitFulfill, 若节点是 head.next, 则进行自旋 // 若不是的话, 直接 block, 直到有其他线程 与之匹配, 或它自己进行线程的中断 Object x = awaitFulfill(s, e, timed, nanos); // 若返回的x == s表示，当前线程已经超时或者中断，不然的话s == null或者是匹配的节点 if (x == s) &#123; // 清理节点S clean(t, s); return null; &#125; // isOffList：用于判断节点是否已经从队列中离开了 if (!s.isOffList()) &#123; // 尝试将S节点设置为head，移出t advanceHead(t, s); if (x != null) s.item = s; // 释放线程 ref s.waiter = null; &#125; // 返回 return (x != null) ? (E)x : e; &#125; // 这里是从head.next开始，因为TransferQueue总是会存在一个dummy node节点 else &#123; // 节点 QNode m = h.next; // 不一致读，重新开始 // 有其他线程更改了线程结构 if (t != tail || m == null || h != head) continue; /** * 生产者producer和消费者consumer匹配操作 */ Object x = m.item; // isData == (x != null)：判断isData与x的模式是否相同，相同表示已经匹配了 // x == m ：m节点被取消了 // !m.casItem(x, e)：如果尝试将数据e设置到m上失败 if (isData == (x != null) || x == m || !m.casItem(x, e)) &#123; // 将m设置为头结点，h出列，然后重试 advanceHead(h, m); continue; &#125; // 成功匹配了，m设置为头结点h出列，向前推进 advanceHead(h, m); // 唤醒m上的等待线程 LockSupport.unpark(m.waiter); return (x != null) ? (E)x : e; &#125; &#125;&#125; 整个transfer的算法如下：\1. 如果队列为null或者尾节点模式与当前节点模式一致，则尝试将节点加入到等待队列中（采用自旋的方式），直到被匹配或、超时或者取消。匹配成功的话要么返回null（producer返回的）要么返回真正传递的值（consumer返回的），如果返回的是node节点本身则表示当前线程超时或者取消了。\2. 如果队列不为null，且队列的节点是当前节点匹配的节点，则进行数据的传递匹配并返回匹配节点的数据\3. 在整个过程中都会检测并帮助其他线程推进 当队列为空时，节点入列然后通过调用awaitFulfill()方法自旋，该方法主要用于自旋/阻塞节点，直到节点被匹配返回或者取消、中断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Object awaitFulfill(QNode s, E e, boolean timed, long nanos) &#123; // 超时控制 final long deadline = timed ? System.nanoTime() + nanos : 0L; Thread w = Thread.currentThread(); // 自旋次数 // 如果节点Node恰好是head节点，则自旋一段时间，这里主要是为了效率问题，如果里面阻塞，会存在唤醒、线程上下文切换的问题 // 如果生产者、消费者者里面到来的话，就避免了这个阻塞的过程 int spins = ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0); // 自旋 for (;;) &#123; // 线程中断了，剔除当前节点 if (w.isInterrupted()) s.tryCancel(e); // 如果线程进行了阻塞 -&gt; 唤醒或者中断了，那么x != e 肯定成立，直接返回当前节点即可 Object x = s.item; if (x != e) return x; // 超时判断 if (timed) &#123; nanos = deadline - System.nanoTime(); // 如果超时了，取消节点,continue，在if(x != e)肯定会成立，直接返回x if (nanos &lt;= 0L) &#123; s.tryCancel(e); continue; &#125; &#125; // 自旋- 1 if (spins &gt; 0) --spins; // 等待线程 else if (s.waiter == null) s.waiter = w; // 进行没有超时的 park else if (!timed) LockSupport.park(this); // 自旋次数过了, 直接 + timeout 方式 park else if (nanos &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanos); &#125;&#125; 在自旋/阻塞过程中做了一点优化，就是判断当前节点是否为对头元素，如果是的则先自旋，如果自旋次数过了，则才阻塞，这样做的主要目的就在如果生产者、消费者立马来匹配了则不需要阻塞，因为阻塞、唤醒会消耗资源。在整个自旋的过程中会不断判断是否超时或者中断了，如果中断或者超时了则调用tryCancel()取消该节点。 tryCancel 123void tryCancel(Object cmp) &#123; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);&#125; 取消过程就是将节点的item设置为自身（itemOffset是item的偏移量）。所以在调用awaitFulfill()方法时，如果当前线程被取消、中断、超时了那么返回的值肯定时S，否则返回的则是匹配的节点。如果返回值是节点S，那么if(x == s)必定成立，如下： 12345Object x = awaitFulfill(s, e, timed, nanos);if (x == s) &#123; // wait was cancelled clean(t, s); return null;&#125; 如果返回的x == s成立，则调用clean()方法清理节点S： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void clean(QNode pred, QNode s) &#123; // s.waiter = null; while (pred.next == s) &#123; QNode h = head; QNode hn = h.next; // hn节点被取消了，向前推进 if (hn != null &amp;&amp; hn.isCancelled()) &#123; advanceHead(h, hn); continue; &#125; // 队列为空，直接return null QNode t = tail; if (t == h) return; QNode tn = t.next; // 不一致，说明有其他线程改变了tail节点，重新开始 if (t != tail) continue; // tn != null 推进tail节点，重新开始 if (tn != null) &#123; advanceTail(t, tn); continue; &#125; // s 不是尾节点 移出 if (s != t) &#123; QNode sn = s.next; // 如果s已经被移除退出循环，否则尝试断开s if (sn == s || pred.casNext(s, sn)) return; &#125; // s是尾节点，则有可能会有其他线程在添加新节点，则cleanMe出场 QNode dp = cleanMe; // 如果dp不为null，说明是前一个被取消节点，将其移除 if (dp != null) &#123; QNode d = dp.next; QNode dn; if (d == null || // 节点d已经删除 d == dp || // 原来的节点 cleanMe 已经通过 advanceHead 进行删除 !d.isCancelled() || // 原来的节点 s已经删除 (d != t &amp;&amp; // d 不是tail节点 (dn = d.next) != null &amp;&amp; // dn != d &amp;&amp; // that is on list dp.casNext(d, dn))) // d unspliced // 清除 cleanMe 节点, 这里的 dp == pred 若成立, 说明清除节点s，成功, 直接return, 不然的话要再次循环 casCleanMe(dp, null); if (dp == pred) return; &#125; else if (casCleanMe(null, pred)) // 原来的 cleanMe 是 null, 则将 pred 标记为 cleamMe 为下次 清除 s 节点做标识 return; &#125;&#125; 这个clean()方法感觉有点儿难度，我也看得不是很懂。这里是引用http://www.jianshu.com/p/95cb570c8187 删除的节点不是queue尾节点, 这时 直接 pred.casNext(s, s.next) 方式来进行删除(和ConcurrentLikedQueue中差不多) 删除的节点是队尾节点 此时 cleanMe == null, 则 前继节点pred标记为 cleanMe, 为下次删除做准备 此时 cleanMe != null, 先删除上次需要删除的节点, 然后将 cleanMe至null, 让后再将 pred 赋值给 cleanMe 非公平模式非公平模式transfer方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394E transfer(E e, boolean timed, long nanos) &#123; SNode s = null; // constructed/reused as needed int mode = (e == null) ? REQUEST : DATA; for (;;) &#123; SNode h = head; // 栈为空或者当前节点模式与头节点模式一样，将节点压入栈内，等待匹配 if (h == null || h.mode == mode) &#123; // 超时 if (timed &amp;&amp; nanos &lt;= 0) &#123; // 节点被取消了，向前推进 if (h != null &amp;&amp; h.isCancelled()) // 重新设置头结点（弹出之前的头结点） casHead(h, h.next); else return null; &#125; // 不超时 // 生成一个SNode节点，并尝试替换掉头节点head (head -&gt; s) else if (casHead(h, s = snode(s, e, h, mode))) &#123; // 自旋，等待线程匹配 SNode m = awaitFulfill(s, timed, nanos); // 返回的m == s 表示该节点被取消了或者超时、中断了 if (m == s) &#123; // 清理节点S，return null clean(s); return null; &#125; // 因为通过前面一步将S替换成了head，如果h.next == s ，则表示有其他节点插入到S前面了,变成了head // 且该节点就是与节点S匹配的节点 if ((h = head) != null &amp;&amp; h.next == s) // 将s.next节点设置为head，相当于取消节点h、s casHead(h, s.next); // 如果是请求则返回匹配的域，否则返回节点S的域 return (E) ((mode == REQUEST) ? m.item : s.item); &#125; &#125; // 如果栈不为null，且两者模式不匹配（h != null &amp;&amp; h.mode != mode） // 说明他们是一队对等匹配的节点，尝试用当前节点s来满足h节点 else if (!isFulfilling(h.mode)) &#123; // head 节点已经取消了，向前推进 if (h.isCancelled()) casHead(h, h.next); // 尝试将当前节点打上&quot;正在匹配&quot;的标记，并设置为head else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123; // 循环loop for (;;) &#123; // s为当前节点，m是s的next节点， // m节点是s节点的匹配节点 SNode m = s.next; // m == null，其他节点把m节点匹配走了 if (m == null) &#123; // 将s弹出 casHead(s, null); // 将s置空，下轮循环的时候还会新建 s = null; // 退出该循环，继续主循环 break; &#125; // 获取m的next节点 SNode mn = m.next; // 尝试匹配 if (m.tryMatch(s)) &#123; // 匹配成功，将s 、 m弹出 casHead(s, mn); // pop both s and m return (E) ((mode == REQUEST) ? m.item : s.item); &#125; else // 如果没有匹配成功，说明有其他线程已经匹配了，把m移出 s.casNext(m, mn); &#125; &#125; &#125; // 到这最后一步说明节点正在匹配阶段 else &#123; // head 的next的节点，是正在匹配的节点，m 和 h配对 SNode m = h.next; // m == null 其他线程把m节点抢走了，弹出h节点 if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); else h.casNext(m, mn); &#125; &#125; &#125;&#125; 整个处理过程分为三种情况，具体如下：\1. 如果当前栈为空获取节点模式与栈顶模式一样，则尝试将节点加入栈内，同时通过自旋方式等待节点匹配，最后返回匹配的节点或者null（被取消）\2. 如果栈不为空且节点的模式与首节点模式匹配，则尝试将该节点打上FULFILLING标记，然后加入栈中，与相应的节点匹配，成功后将这两个节点弹出栈并返回匹配节点的数据\3. 如果有节点在匹配，那么帮助这个节点完成匹配和出栈操作，然后在主循环中继续执行 当节点加入栈内后，通过调用awaitFulfill()方法自旋等待节点匹配： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123; // 超时 final long deadline = timed ? System.nanoTime() + nanos : 0L; // 当前线程 Thread w = Thread.currentThread(); // 自旋次数 // shouldSpin 用于检测当前节点是否需要自旋 // 如果栈为空、该节点是首节点或者该节点是匹配节点，则先采用自旋，否则阻塞 int spins = (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0); for (;;) &#123; // 线程中断了，取消该节点 if (w.isInterrupted()) s.tryCancel(); // 匹配节点 SNode m = s.match; // 如果匹配节点m不为空，则表示匹配成功，直接返回 if (m != null) return m; // 超时 if (timed) &#123; nanos = deadline - System.nanoTime(); // 节点超时，取消 if (nanos &lt;= 0L) &#123; s.tryCancel(); continue; &#125; &#125; // 自旋;每次自旋的时候都需要检查自身是否满足自旋条件，满足就 - 1，否则为0 if (spins &gt; 0) spins = shouldSpin(s) ? (spins-1) : 0; // 第一次阻塞时，会将当前线程设置到s上 else if (s.waiter == null) s.waiter = w; // 阻塞 当前线程 else if (!timed) LockSupport.park(this); // 超时 else if (nanos &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanos); &#125;&#125; awaitFulfill()方法会一直自旋/阻塞直到匹配节点。在S节点阻塞之前会先调用shouldSpin()方法判断是否采用自旋方式，为的就是如果有生产者或者消费者马上到来，就不需要阻塞了，在多核条件下这种优化是有必要的。同时在调用park()阻塞之前会将当前线程设置到S节点的waiter上。匹配成功，返回匹配节点m。 shouldSpin()方法如下： 1234boolean shouldSpin(SNode s) &#123; SNode h = head; return (h == s || h == null || isFulfilling(h.mode));&#125; 同时在阻塞过程中会一直检测当前线程是否中断了，如果中断了，则调用tryCancel()方法取消该节点，取消过程就是将当前节点的math设置为当前节点。所以如果线程中断了，那么在返回m时一定是S节点自身。 123void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this);&#125; awaitFullfill()方法如果返回的m == s，则表示当前节点已经中断取消了，则需要调用clean()方法，清理节点S： 123456789101112131415161718192021222324252627void clean(SNode s) &#123; // 清理item域 s.item = null; // 清理waiter域 s.waiter = null; // past节点 SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; // 从栈顶head节点，取消从栈顶head到past节点之间所有已经取消的节点 // 注意：这里如果遇到一个节点没有取消，则会退出while SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // 如果p节点已经取消了，则剔除该节点 // 如果经历上面while p节点还没有取消，则再次循环取消掉所有p 到past之间的取消节点 while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125; clean()方法就是将head节点到S节点之间所有已经取消的节点全部移出。【不清楚为何要用两个while，一个不行么】 ArrayBlockingQueueArrayBlockingQueue，一个由数组实现的有界阻塞队列。该队列采用FIFO的原则对元素进行排序添加的。 ArrayBlockingQueue为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了。ArrayBlockingQueue支持对等待的生产者线程和使用者线程进行排序的可选公平策略，但是在默认情况下不保证线程公平的访问，在构造时可以选择公平策略（fair = true）。公平性通常会降低吞吐量，但是减少了可变性和避免了“不平衡性”。 ArrayBlockingQueue先看ArrayBlockingQueue的定义： 1234567891011121314public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable &#123; private static final long serialVersionUID = -817911632652898426L; final Object[] items; int takeIndex; int putIndex; int count; // 重入锁 final ReentrantLock lock; // notEmpty condition private final Condition notEmpty; // notFull condition private final Condition notFull; transient ArrayBlockingQueue.Itrs itrs;&#125; 可以清楚地看到ArrayBlockingQueue继承AbstractQueue，实现BlockingQueue接口。看过java.util包源码的同学应该都认识AbstractQueue，改类在Queue接口中扮演着非常重要的作用，该类提供了对queue操作的骨干实现（具体内容移驾其源码）。BlockingQueue继承java.util.Queue为阻塞队列的核心接口，提供了在多线程环境下的出列、入列操作，作为使用者，则不需要关心队列在什么时候阻塞线程，什么时候唤醒线程，所有一切均由BlockingQueue来完成。 ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。 items，一个定长数组，维护ArrayBlockingQueue的元素 takeIndex，int，为ArrayBlockingQueue对首位置 putIndex，int，ArrayBlockingQueue对尾位置 count，元素个数 lock，锁，ArrayBlockingQueue出列入列都必须获取该锁，两个步骤公用一个锁 notEmpty，出列条件 notFull，入列条件 入队ArrayBlockingQueue提供了诸多方法，可以将元素加入队列尾部。 add(E e) ：将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException offer(E e) :将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false offer(E e, long timeout, TimeUnit unit) :将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间 put(E e) :将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间 方法较多，我们就分析一个方法：add(E e)： 12345678910public boolean add(E e) &#123; return super.add(e);&#125; public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException(&quot;Queue full&quot;);&#125; add方法调用offer(E e)，如果返回false，则直接抛出IllegalStateException异常。offer(E e)为ArrayBlockingQueue实现： 123456789101112131415public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 方法首先检查是否为null，然后获取lock锁。获取锁成功后，如果队列已满则直接返回false，否则调用enqueue(E e)，enqueue(E e)为入列的核心方法，所有入列的方法最终都将调用该方法在队列尾部插入元素： 12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 该方法就是在putIndex（对尾）为知处添加元素，最后使用notEmpty的signal()方法通知阻塞在出列的线程（如果队列为空，则进行出列操作是会阻塞）。 出队ArrayBlockingQueue提供的出队方法如下： poll() :获取并移除此队列的头，如果此队列为空，则返回 null poll(long timeout, TimeUnit unit) :获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要） remove(Object o) :从此队列中移除指定元素的单个实例（如果存在） take() :获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要） poll() 123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; 如果队列为空返回null，否则调用dequeue()获取列头元素： 123456789101112private E dequeue() &#123; final Object[] items = this.items; E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return x; &#125; 该方法主要是从列头（takeIndex 位置）取出元素，同时如果迭代器itrs不为null，则需要维护下该迭代器。最后调用notFull.signal()唤醒入列线程。 take() 1234567891011public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; take()与poll()存在一个区别就是count == 0 时的处理，poll()直接返回null，而take()则是在notEmpty上面等待直到被入列的线程唤醒。 ConcurrentLinkedQueueConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。上一篇文章介绍了JDK java.util.concurrent包下很重要的一个类：ConcurrentHashMap，今天来看下另一个重要的类——ConcurrentLinkedQueue。在多线程编程环境下并发安全队列是不可或缺的一个重要工具类，为了实现并发安全可以有两种方式：一种是阻塞式的，例如：LinkedBlockingQueue；另一种即是我们将要探讨的非阻塞式，例如：ConcurrentLinkedQueue。相比较于阻塞式，非阻塞的最显著的优点就是性能，非阻塞式算法使用CAS来原子性的更新数据，避免了加锁的时间，同时也保证了数据的一致性。 简单介绍ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。 结构预览首先看看结构图： 图1：ConcurrentLinkedQueue结构图：从图中可以看到ConcurrentLinkedQueue中包含两个内部类：Node和Itr。Node用来表示ConcurrentLinkedQueue链表中的一个节点，通过Node的next字段指向下一个节点，从而形成一个链表结构；Itr实现Iterator接口，用来遍历ConcurrentLinkedQueue。ConcurrentLinkedQueue中的方法不多，其中最主要的两个方法是：offer(E)和poll()，分别实现队列的两个重要的操作：入队和出队。 方法 含义 offer(E) 插入一个元素到队列尾部 poll() 从队列头部取出一个元素 add(E) 同offer(E) peek() 获取头部元素，但不删除 isEmpty() 判断队列是否为空 size() 获取队列长度(元素个数) contains(Object) 判断队列是否包含指定元素 remove(Object) 删除队列中指定元素 toArray(T[]) 将队列的元素复制到一个数组 iterator() 返回一个可遍历该队列的迭代器 下面会着重分析offer(E)和poll()两个方法，同时会讲解remove(Object)和iterator()方法。 常用方法解读入队——offer首先看看入队操作，由于是无阻塞的队列，所以整个入队操作是在无锁模式下进行的，下面来分析下JDK到底是如何实现无锁并保证安全性的。 123456789101112131415161718192021222324/** * Inserts the specified element at the tail of this queue. * * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Queue#offer&#125;) * @throws NullPointerException if the specified element is null */public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; n = new Node&lt;E&gt;(e, null); for (;;) &#123;//① Node&lt;E&gt; t = tail;//② Node&lt;E&gt; s = t.getNext();//② if (t == tail) &#123;//③ if (s == null) &#123;//④ if (t.casNext(s, n)) &#123;//⑥ casTail(t, n);//⑦ return true; &#125; &#125; else &#123; casTail(t, s);//⑤ &#125; &#125; &#125;&#125; 代码不长，但是思路还是很巧妙的，下面我们逐句深入分析每一行代码。if (e == null) throw new NullPointerException(); Node n = new Node(e, null);检查NULL，避免NullPointerException，然后创建一个Node，该Node的item为传入的参数e，next为NULL。for (;;) {}接着是一个死循环，死循环保证该入队操作能够一直重试直至入队成功。Node t = tail; Node s = t.getNext();使用局部变量t引用tail节点，同时获取tail节点的next节点，赋予变量s。if (t == tail) {}只有在t==tail的情况下才会执行入队操作，否则进行下一轮循环，直到t==tail，因为是无锁模式，所以如果同时有多个线程在执行入队操作，那么在一个线程读取了tail之后，很可能会有其他线程已经修改了tail（此处的修改是指将tail指向另一个节点，所以t还引用着原来的节点，导致t!=tail，而并非是修改了tail所指向的节点的值），此处的判断避免了一开始的错误，但是并不能保证后续的执行过程中不会插入其他线程的操作，其实ConcurrentLinkedQueue的设计使得if内的代码即使在有其他线程插入的情况下依旧能够很好地执行，下面我们接着分析。 if (s == null) {} else { casTail(t, s); }这里判断s（tail的next是否为NULL），如果不为NULL，则直接将tail指向s。这里需要说明一下：由于tail指向的是队列的尾部，所以tail的next应该始终是NULL，那么当发生tail的next不为NULL，则说明当前队列处于不一致状态，这时当前线程需要帮助队列进入一致性状态，这就是ConcurrentLinkedQueue设计的巧妙之处！那么如果帮助队列进入一致性状态呢？这个问题我们先留着，继续看什么情况下会导致队列进入不一致状态！ 1234if (t.casNext(s, n)) &#123; casTail(t, n); return true;&#125; 这几句代码完成了入队的操作，第一步CAS的设置t（指向tail）的next为n（新创建的节点），该更新操作能够完成的前提是t的next值==s，即tail的next值在该线程首次读取期间并未发生变化。此处的CAS操作保证了tail的next值更新的原子性，所以不会出现不一致情况。当成功更新了tail的next节点之后，接下来就是原子性的更新tail为n，此处如果更新成功，则入队顺利完成完成，但是奇怪的是如果此处更新失败，入队依旧是成功的！为什么呢？看下文。 我们试想如果一个线程成功的原子性更新了tail的next值为新创建的节点，由于Node的next是volatile修饰的，所以会立即被之后的所有线程可见，那么就会出现tail未变化但是tail的next已经不是NULL了，此时就会出现上面提到的tail的next不为NULL的情况了，现在我们再来看看上面是如何处理这种情况的，casTail(t, s);，从这句可以看出当一个线程看到tail的next不为NULL时就会直接将tail更新成s（tail的next所指向的节点），即将tail指向其next节点，当然这里的更新也是CAS保证的原子性更新。为什么敢这么大胆，正是因为如果当前线程（T1）看到tail的next不为NULL，那么必然是有一个线程（T2）处于入队操作中，且成功执行了t.casNext(s, n)（将新创建的节点赋到tail的next上），正准备执行casTail(t, n);（将tail执行其next指向的节点），那么T1直接将T2准备做的工作完成，然后再进入循环重新进行入队操作，而T2也不在乎自己这一步是否顺利完成，反正只要有人完成了就行，所以T2就直接返回入队成功，最终T1帮助T2顺利完成了入队操作，并且全程无锁，此设计真的是巧妙啊~~~ 下面我们使用流程图形象的描绘下入队过程，整个入队方法被划分成7步（见上面的代码中的注释）。说明：虽然入队是在无锁模式下进行，但是由于使用CAS进行原子性更新，所以很多地方其实还是实现了线程安全的，除了⑥-&gt;⑦，下面的图描绘的也正是⑥-&gt;⑦这一步可能出现的冲突情况。 图2：ConcurrentLinkedQueue入队流程图： 上面介绍了ConcurrentLinkedQueue是如何实现无锁入队的，但是我们只说明了多个线程同时入队操作是线程安全的，但是如果多个线程同时进行入队和出队，以及删除操作呢？这个问题在下面分析另外两个方法时会提到，同时最后也会进行一个总结，下面我们先看看删除操作是如何实现的。 删除——remove先介绍删除，是因为出队操作有个地方需要在这里提前介绍下。 1234567891011public boolean remove(Object o) &#123; if (o == null) return false;// ① for (Node&lt;E&gt; p = first(); p != null; p = p.getNext()) &#123;// ② E item = p.getItem();// ③ if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null))// ④ return true; &#125; return false;&#125; 源码中的注释申明了remove方法会使用equals()判断两个节点的值与待删除的值是否相同，同时如果队列有多个与待删除值相同的节点则只删除最前面的一个节点。 同样remove()方法也是无锁模式，①判断是否为NULL，②从队列头部开始查找，③获取每个节点的item值，用于跟o进行equals比较，前面三步都很平常，重点在④，if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null))这里首先判断item不为NULL，然后判断item与o相等，前面两个都满足的话，那说明已经查找到一个节点的值与待删除的值一样，后面就是删除该节点，这里删除其实并非真的删除，而只是原子性的将节点的item值设置为NULL。从上面的分析可以看出ConcurrentLinkedQueue的删除只是将队列中的某个节点值置为NULL，由于Node的item是volatile的，所以不存在线程安全问题，同时由于remove并未修改队列的结构，所以多个线程同时进行remove，或者同其他方法一起进行也不会发生线程安全性问题。 出队——poll出队从逻辑上来说就是从队列的头部往外取出数据并删除，下面看看ConcurrentLinkedQueue是如何实现无锁出队的。 12345678910111213141516171819202122public E poll() &#123; for (;;) &#123;// ① Node&lt;E&gt; h = head;// ② Node&lt;E&gt; t = tail;// ② Node&lt;E&gt; first = h.getNext();// ② if (h == head) &#123;// ③ if (h == t) &#123;// ④ if (first == null)// ⑤ return null; else casTail(t, first);// ⑥ &#125; else if (casHead(h, first)) &#123;// ⑦ E item = first.getItem();// ⑧ if (item != null) &#123;// ⑨ first.setItem(null);// ⑩ return item; &#125; // else skip over deleted item, continue loop, &#125; &#125; &#125;&#125; 出队的步骤略多些，不过理解了也就很简单了。首先①是一个死循环；②的三步分别是获取head/tail/head.next三个节点；③判断h==head，避免操作过程中已有其他线程移动了head；④判断head是否等于tail，即队列是否为NULL，说到这里我们先来看看head和tail在队列中到底处于什么位置。我们用一个队列入队出队的时序图来描绘下在入队和出队过程中head和tail到底是如何变化的。 图3：ConcurrentLinkedQueue队列时序图：从图中我们可以看出head的next指向的是队列的第一个元素，我们出队也是将head的next指向的元素出队，同时head==tail说明队列已经没有元素了。明白了这两点我们再接着④分析，如果④这里为真，说明队列已经为NULL，接着⑤判断f（head的next指向的节点）是否为NULL，不为NULL则执行⑥将tail指向f，到这里如果理解了上面入队操作，那么应该是可以理解这一步的用意的——帮助其他线程执行入队操作，跟入队时的⑤是一样的，因为head==tail，head的next不为NULL，则说明tail的next不为NULL，所以要将tail重新指向他的next，帮助正在执行入队的线程完成入队工作。理解了这一步那么出队操作就已经理解了一大半了，下面继续看⑦⑧⑨⑩。 如果head!=tail，则队列不为NULL，那么直接将head指向下一个节点，将当前节点踢出队列即可，当然需要CAS保证原子性更新，然后将踢出队列的节点的item取出返回，并置为NULL即完成了出队操作。这里需要注意的是如果被踢出队列的节点的item是NULL，说明该节点已经被删除了（因为remove()方法只是将节点的item设置为NULL，而不将节点踢出队列），那就只能再次循环了。再提一点，为什么⑦⑧⑨⑩能够被线程安全的执行，因为在⑦这一步是原子更新的，而且更新之后这个节点就立即不会被其他任何线程访问到了，所以后面⑧⑨⑩想怎么处理都是安全的。 到这里出队操作应该很清楚了，下面就来综合分析下为什么针对ConcurrentLinkedQueue的整个入队/出队/删除都是不需要锁的。 上面已经分析了如果多个线程同时访问其中任一个方法（offer/poll/remove）都是无需加锁而且线程安全的 由于remove方法不修改ConcurrentLinkedQueue的结构，所以跟其他两个方法都不会有冲突 如果同时两个线程，一个入队，一个出队，在队列不为NULL的情况下是不是有任何问题的，因为一个操作tail，一个操作head，完全不相关。但是如果队列为NULL时还是会发生冲突的，因为tail==head。这里我们在分析出队时也提到了，如果出队线程发现tail的next不为NULL，那么就会感知到当前有一个线程在执行入队操作，所以出队线程就会帮助入队线程完成入队操作，而且每个操作都是通过CAS保证原子性更新，所以就算同时两个线程，一个入队，一个出队也不会发生冲突。 综上，ConcurrentLinkedQueue最终实现了无锁队列。 使用场景ConcurrentLinkedQueue适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。下面我们来简单对比下ConcurrentLinkedQueue与我们常用的阻塞队列LinkedBlockingQueue的性能。表1：入队性能对比 线程数 ConcurrentLinkedQueue耗时(ms) LinkedBlockingQueue耗时(ms) 5 22 29 10 50 59 20 99 112 30 139 171 测试数据：N个线程，每个线程入队10000个元素。 参考： http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/ http://cmsblogs.com/?p=2611]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>并发</tag>
        <tag>queue</tag>
        <tag>跳表</tag>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 线程原理及锁同步分析]]></title>
    <url>%2Fposts%2Fjava_jdk_base_thread_lock.html</url>
    <content type="text"><![CDATA[Java内存模型内存模型：在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。 Java虚拟机规范定义了Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果（C/C++等则直接使用物理机和OS的内存模型，使得程序须针对特定平台编写），它在多线程的情况下尤其重要。 JMM的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量是指共享变量，存在竞争问题的变量，如实例字段、静态字段、数组对象元素等，不包括线程私有的局部变量、方法参数等，因为私有变量不存在竞争问题。可以JMM认为包括内存划分、变量访问操作与规则两部分。 内存划分物理机中的内存模型： Java内存划分如下所示（可与上述物理机中的内存模型作类比）： 分为主内存和工作内存，每个线程都有自己的工作内存，它们共享主内存。 主内存（Main Memory）存储所有共享变量的值。 工作内存（Working Memory）存储该线程使用到的共享变量在主内存的的值的副本拷贝。 线程对共享变量的所有读写操作都在自己的工作内存中进行，不能直接读写主内存中的变量（volatile变量也不例外，虽然它看起来如同直接访问主内存一般）。 不同线程间也无法直接访问对方工作内存中的变量，线程间变量值的传递必须通过主内存完成。 注：这种划分与Java内存区域中堆、栈、方法区等的划分是不同层次的划分，两者基本没有关系。硬要联系的话，大致上主内存对应Java堆中对象的实例数据部分、工作内存对应栈的部分区域；从更低层次上说，主内存对应物理硬件内存、工作内存对应寄存器和高速缓存。 内存间交互的操作和规则（这里介绍的访问操作及规则完全确定了Java程序中哪些内存访问在并发下是安全的，1.3节介绍与此等效的判断原则——先行发生原则） 1.2.1、8个原子操作和执行规则 8个原子操作：JMM定义了8个原子操作来完成工作内存和主内存间的交互： 1、lock（锁定）：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。2、unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。3、read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的load动作使用。4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。5、use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。6、assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。7、store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的write操作使用。8、write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。 8个原子操作的执行规则：JMM还规定了执行上述8中基本操作时需满足如下规则： 1、不允许read和load、store和write操作之一单独出现，即不允许一变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况。即要求read、load成对顺序出现，但不要求连续出现（中间可以插入其他指令），store、write亦然。2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。3、不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。4、一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。5、一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。6、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。7、如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。 从上面可以看出，把变量从工作内存复制到主内存需要顺序执行read、load，从工作内存同步回主内存则需要顺序执行store、write。总结： read、load必须成对顺序出现，但不要去连续出现。assign、store、write同之； 变量诞生和初始化：变量只能从主内存“诞生”，且须先初始化后才能使用，即在use/store前须先load/assign； lock一个变量后会清空工作内存中该变量的值，使用前须先初始化；unlock前须将变量同步回主内存； 一个变量同一时刻只能被一线程lock，lock几次就须unlock几次；未被lock的变量不允许被执行unlock，一个线程不能去unlock其他线程lock的变量。 1.2.2、volatile变量访问规则 volatile变量是JVM提供的最轻量级的同步机制。Java内存模型对volatile专门定义了一些特殊的访问规则，被volatile修饰的变量可以保证可见性、有序性，但不保证原子性。 1、保证可见性：即一个线程修改了一变量的值，其他线程立即可见该变量的新值。 原理：一个线程对变量修改后立即同步回主内存，即 assign、store、write须连续执行、其他线程对变量读取前立即从主内存刷新新值到工作内存即 read、load、use须连续执行。 2、保证有序性：禁止指令重排序。 原理：确保指令重排序时不会把后面指令排列到内存屏障（Memory Barrier，也称内存栅栏：在volatile变量上加lock前缀指令）之前的位置，并且不会把变量之前的指令排到内存屏障之后的位置，即在执行内存屏障这句话时，这前面的操作已全部完成。 3、不保证原子性 输出值不等于threadNum*countRange，说明volatile变量并没保证原子性。原因也很明了：race++不是原子操作，虽然线程拿到race值时是最新的，但执行完加一操作写回时可能race值已经被其他线程更新了，导致更新被覆盖。 指令重排序： 含义：只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致。如java语言规范就是规定JVM线程内部维持顺序化语义。 类型：计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种： 编译器优化的重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令并行的重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序 内存系统的重排：由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。 其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题 指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。 1.2.3、long和double型变量的特殊规则（非原子性协定） Java内存模型要求前述8个操作具有原子性，但对于64位的数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。即未被volatile修饰时线程对其的读取不是原子操作，可能只读到“半个变量”值。虽然如此，商用虚拟机几乎都把64位数据的读写实现为原子操作，因此我们可以忽略这个问题。 先行发生原则先行发生（happens-before）原则用来确定一个访问在并发环境下是否安全、数据是否存在竞争。其与1.2节介绍的访问操作及规则等效。 Java内存模型具备一些先天的“有序性”，即不需要通过任何同步手段（volatile、synchronized等）就能够得到保证的有序性，这个通常也称为happens-before原则。如果两个操作的执行次序不符合先行原则且无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 这些规则包括： 1、程序次序规则（Program Order Rule）：一个线程内，按照代码顺序（虑到分支、循环等结构，准确地说应该是控制流顺序），书写在前面的操作先行发生于书写在后面的操作。2、锁定规则（Monitor Lock Rule）：一个unLock操作先行发生于后面对同一个锁的lock操作。“后面”指时间上的先后顺序。3、volatile变量规则（Volatile Variable Rule）：对一个变量的写操作先行发生于后面对这个变量的读操作。“后面”指时间上的先后顺序。4、传递规则（Transitivity）：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。5、线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每个一个动作。6、线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生（通过Thread.interrupted()检测）。7、线程终止规则（Thread Termination Rule）：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。8、对象终结规则（Finaizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于他的finalize()方法的开始。 注：先行发生与时间先后顺序之间没有必然联系，衡量并发安全问题必须以先行发生原则为准。如对于一个普通变量的不带同步的get、set方法，让时间上线程1、2先后调用get、set方法，线程2并不一定得到线程1设置的值。因为它们不符合先行原则也不能由之导出。 参考：http://www.cnblogs.com/z-sm/p/7196347.html Java内存结构 1.PC寄存器/程序计数器： 严格来说是一个数据结构，用于保存当前正在执行的程序的内存地址，由于Java是支持多线程执行的，所以程序执行的轨迹不可能一直都是线性执行。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存,这在某种程度上有点类似于“ThreadLocal”，是线程安全的。 2.Java栈 Java Stack： Java栈总是与线程关联在一起的，每当创建一个线程，JVM就会为该线程创建对应的Java栈，在这个Java栈中又会包含多个栈帧(Stack Frame)，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会含有一些局部变量、操作栈和方法返回值等信息。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向该地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另外一个方法时，与之对应的一个新的栈帧被创建，这个新创建的栈帧被放到Java栈的栈顶，变为当前的活动栈。同样现在只有这个栈的本地变量才能被使用，当这个栈帧中所有指令都完成时，这个栈帧被移除Java栈，刚才的那个栈帧变为活动栈帧，前面栈帧的返回值变为这个栈帧的操作栈的一个操作数。 由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。 在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。在Hot Spot虚拟机中，可以使用-Xss参数来设置栈的大小。栈的大小直接决定了函数调用的可达深度。 3.堆 Heap: 堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。 4.方法区Method Area: 方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，不像Java堆中其他部分一样会频繁被GC回收，它存储的信息相对比较稳定，在一定条件下会被GC，当方法区要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation，大小可以通过参数来设置,可以通过-XX:PermSize指定初始值，-XX:MaxPermSize指定最大值。 5.常量池Constant Pool: 常量池本身是方法区中的一个数据结构。常量池中存储了如字符串、final变量值、类名和方法名常量。常量池在编译期间就被确定，并保存在已编译的.class文件中。一般分为两类：字面量和应用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定为到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。 6.本地方法栈Native Method Stack: 本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 工作内存和主存 JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下 主内存 主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。 工作内存 主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。 弄清楚主内存和工作内存后，接了解一下主内存与工作内存的数据存储类型以及操作方式，根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，简单示意图如下所示： JMM的最初目的，就是为了能够支持多线程程序设计的，每个线程可以认为是和其他线程不同的CPU上运行，或者对于多处理器的机器而言，该模型需要实现的就是使得每一个线程就像运行在不同的机器、不同的CPU或者本身就不同的线程上一样，这种情况实际上在项目开发中是常见的。对于CPU本身而言，不能直接访问其他CPU的寄存器，模型必须通过某种定义规则来使得线程和线程在工作内存中进行相互调用而实现CPU本身对其他CPU、或者说线程对其他线程的内存中资源的访问，而表现这种规则的运行环境一般为运行该程序的运行宿主环境（操作系统、服务器、分布式系统等），而程序本身表现就依赖于编写该程序的语言特性，这里也就是说用Java编写的应用程序在内存管理中的实现就是遵循其部分原则，也就是前边提及到的JMM定义了Java语言针对内存的一些的相关规则。然而，虽然设计之初是为了能够更好支持多线程，但是该模型的应用和实现当然不局限于多处理器，而在JVM编译器编译Java编写的程序的时候以及运行期执行该程序的时候，对于单CPU的系统而言，这种规则也是有效的，这就是是上边提到的线程和线程之间的内存策略。JMM本身在描述过程没有提过具体的内存地址以及在实现该策略中的实现方法是由JVM的哪一个环节（编译器、处理器、缓存控制器、其他）提供的机制来实现的，甚至针对一个开发非常熟悉的程序员，也不一定能够了解它内部对于类、对象、方法以及相关内容的一些具体可见的物理结构。相反，JMM定义了一个线程与主存之间的抽象关系，其实从上边的图可以知道，每一个线程可以抽象成为一个工作内存（抽象的高速缓存和寄存器），其中存储了Java的一些值，该模型保证了Java里面的属性、方法、字段存在一定的数学特性，按照该特性，该模型存储了对应的一些内容，并且针对这些内容进行了一定的序列化以及存储排序操作，这样使得Java对象在工作内存里面被JVM顺利调用，（当然这是比较抽象的一种解释）既然如此，大多数JMM的规则在实现的时候，必须使得主存和工作内存之间的通信能够得以保证，而且不能违反内存模型本身的结构，这是语言在设计之处必须考虑到的针对内存的一种设计方法。这里需要知道的一点是，这一切的操作在Java语言里面都是依靠Java语言自身来操作的，因为Java针对开发人员而言，内存的管理在不需要手动操作的情况下本身存在内存的管理策略，这也是Java自己进行内存管理的一种优势。 其他硬件原理：https://blog.csdn.net/javazejian/article/details/72772461 JMM 原子性、可见性、有序性JMM是围绕着在并发过程中（多线程环境下）如何处理原子性、可见性、有序性这3个特征来建立的。 总结： JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。 原子性含义：是指一个操作在同一时刻只能被一个线程执行，只有该线程执行完了其他线程才能执行该操作。该操作可以只有一个步骤也可以有多个步骤，后者可以称为组合操作。 JMM实现： 由JMM直接保证的原子性变量操作包括read、load、use、assign、store、write；基本数据类型的读写也是原子性的（long、double也可以当做原子性）。 由JMM的lock、unlock可实现更大范围的原子性保证，虽用户没法直接用之，但可用synchronized关键字来保证原子性。synchronized关键字编译后在同步块前后形成字节码指令monitorenter、monitorexit，这两个指令最终即利用了lock、unlock操作保证其间组合操作的原子性。 可见性含义：是指当一个线程修改了共享变量的值，其他线程立即得知该修改。 JMM实现： （volatile）变量值被一个线程修改后会立即同步回主内存、变量值被其他线程读取前立即从主内存刷新值到工作内存。即read、load、use三者连续顺序执行，assign、store、write连续顺序执行。 （synchronized）1.2.1节中原子操作执行规则8——“对一个变量执行unlock操作之前，必须先把此变量同步回主内存，即执行store、write”。 （final）final修饰的字段在构造器中一旦初始化完成，且构造器没有把“this”的引用传递出去，则其他线程可立即看到final字段的值。 有序性含义：在一个线程内所有的操作都是有序的，表现为串行化语义（在一个线程观察另一个则操作不一定有序，是因为有“指令重排序”现象和“工作内存与主内存同步延迟”现象）。 JMM实现： （volatile）禁止指令重排序 （synchronized）1.2.1节中原子操作执行规则5——“一个变量在同一个时刻只允许一条线程对其执行lock操作”，此规则决定了持有同一个锁的两个同步块只能串行进入。 原子性（Atomicity）：一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。 基本类型数据的访问大都是原子操作，long 和double类型的变量是64位，但是在32位JVM中，32位的JVM会将64位数据的读写操作分为2次32位的读写操作来进行，这就导致了long、double类型的变量在32位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。 可见性：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。 Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。 无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。 除了volatile关键字能实现可见性之外，还有synchronized,Lock，final也是可以的。 使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。 使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。 final关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。 有序性：对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。 Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现， 在单线程程序中，不会发生“指令重排”和“工作内存和主内存同步延迟”现象，只在多线程程序中出现。 happens-before原则1、程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作。 2、管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序，下同）对同一个锁的lock操作。 3、volatile变量规则：对一个volatile变量的写操作happen—before后面对该变量的读操作。 4、线程启动规则：Thread对象的start（）方法happen—before此线程的每一个动作。 5、线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。 6、线程中断规则：对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。 7、对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。 8、传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。 原则分析：https://blog.csdn.net/ns_code/article/details/17348313https://www.cnblogs.com/lewis0077/p/5143268.html volatile原理volatile保证线程可见性，禁止指令重排，但不保证原子性。 volatile关键字的两层语义 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 Mesi缓存一致性如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 1）通过在总线加LOCK#锁的方式 2）通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 以上内容参考自：https://blog.csdn.net/javazejian/article/details/72772461#t16https://blog.csdn.net/jjavaboy/article/details/77164474https://www.cnblogs.com/lewis0077/p/5143268.htmlhttps://blog.csdn.net/longfulong/article/details/78790955 锁的种类http://ifeve.com/java_lock_see2/ 可重入锁可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁.可重入锁最大的作用是避免死锁123456789101112131415161718192021222324252627public class SpinLock1 &#123; private AtomicReference&lt;Thread&gt; owner =new AtomicReference&lt;&gt;(); private int count =0; public void lock()&#123; Thread current = Thread.currentThread(); if(current==owner.get()) &#123; count++; return ; &#125; while(!owner.compareAndSet(null, current))&#123; &#125; &#125; public void unlock ()&#123; Thread current = Thread.currentThread(); if(current==owner.get())&#123; if(count!=0)&#123; count--; &#125;else&#123; owner.compareAndSet(current, null); &#125; &#125; &#125;&#125; 公平锁/非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。 可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。 12345678synchronized void setA() throws Exception&#123; Thread.sleep(1000); setB();&#125;synchronized void setB() throws Exception&#123; Thread.sleep(1000);&#125; 上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。 独享锁/共享锁共享锁独享锁是指该锁一次只能被一个线程所持有。共享锁是指该锁可被多个线程所持有。 对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。 互斥锁/读写锁上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。互斥锁在Java中的具体实现就是ReentrantLock读写锁在Java中的具体实现就是ReadWriteLock 乐观锁/悲观锁乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。 从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。 偏向锁/轻量级锁/重量级锁这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。 自旋锁在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。典型的自旋锁实现的例子，可以参考自旋锁的实现 在自旋锁中 另有三种常见的锁形式:TicketLock ，CLHlock 和MCSlock.https://github.com/Essviv/spring/tree/master/src/main/java/com/cmcc/syw/concurrency/lock/spinlock 12345678910111213141516171819202122public class SpinLock implements Operator &#123; private AtomicReference&lt;Thread&gt; current = new AtomicReference&lt;&gt;(); public static void main(String[] args) &#123; SpinLock spinLock = new SpinLock(); final int COUNT = 200; for (int i = 0; i &lt; COUNT; i++) &#123; new CustomThread(spinLock).start(); &#125; &#125; public void lock() &#123; Thread currentThread = Thread.currentThread(); while (!current.compareAndSet(null, currentThread)) &#123; //获取锁失败,则开始轮询,直到成功 &#125; &#125; public void unlock() &#123; current.compareAndSet(Thread.currentThread(), null); &#125;&#125; 123456789101112131415161718192021222324252627282930public class TicketLock implements Operator &#123; private AtomicInteger serviceNum = new AtomicInteger(); private AtomicInteger currentNum = new AtomicInteger(); private ThreadLocal&lt;Integer&gt; ticketNum = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; TicketLock ticketLock = new TicketLock(); final int COUNT = 200; for (int i = 0; i &lt; COUNT; i++) &#123; new CustomThread(ticketLock).start(); &#125; &#125; public void lock() &#123; //每个线程在进入这个之前,先拿到唯一的一个号 ticketNum.set(currentNum.getAndIncrement()); //服务号每次只会让拥有当前号码的线程进入 while (ticketNum.get() != serviceNum.get()) &#123; &#125; &#125; public void unlock() &#123; //解锁的过程类似于叫号的过程 serviceNum.getAndIncrement(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ClhSpinLock implements Operator &#123; //前驱节点 private ThreadLocal&lt;Node&gt; prev = new ThreadLocal&lt;&gt;(); //当前节点 private ThreadLocal&lt;Node&gt; current = new ThreadLocal&lt;&gt;(); //末尾节点 private AtomicReference&lt;Node&gt; tail = new AtomicReference&lt;&gt;(); public static void main(String[] args) &#123; ClhSpinLock clhLock = new ClhSpinLock(); final int COUNT = 50; for (int i = 0; i &lt; COUNT; i++) &#123; new CustomThread(clhLock).start(); &#125; &#125; public void lock() &#123; //创建当前的节点 Node currentNode = new Node(); current.set(currentNode); //加入队列 Node prevNode = tail.getAndSet(currentNode); prev.set(prevNode); //等待获取锁， 如果失败，则自旋等待 while (prevNode != null &amp;&amp; prevNode.isLocked()) &#123; &#125; //help GC prev.set(null); &#125; public void unlock() &#123; current.get().setLocked(false); &#125; private class Node &#123; //标识当前线程是否正在获取锁或已经获取到锁 private volatile boolean isLocked; public Node() &#123; this.isLocked = true; &#125; public boolean isLocked() &#123; return isLocked; &#125; public void setLocked(boolean locked) &#123; isLocked = locked; &#125; &#125;&#125; 12 3、阻塞锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * clh锁实践代码: 当获取锁失败时，使用阻塞方式 * &lt;p&gt; * Created by sunyiwei on 2016/12/7. */public class ClhBlockLock implements Operator &#123; //前驱节点 private ThreadLocal&lt;Node&gt; prev = new ThreadLocal&lt;&gt;(); //当前节点 private ThreadLocal&lt;Node&gt; current = new ThreadLocal&lt;&gt;(); //末尾节点 private AtomicReference&lt;Node&gt; tail = new AtomicReference&lt;&gt;(); public static void main(String[] args) &#123; ClhBlockLock clhLock = new ClhBlockLock(); final int COUNT = 50; for (int i = 0; i &lt; COUNT; i++) &#123; new CustomThread(clhLock).start(); &#125; &#125; public void lock() &#123; //创建当前的节点 Node currentNode = new Node(); current.set(currentNode); //加入队列 Node prevNode = tail.getAndSet(currentNode); prev.set(prevNode); if (prevNode != null) &#123; prevNode.setNext(currentNode); &#125; //等待获取锁， 当获取失败时，阻塞等待 while (prevNode != null &amp;&amp; prevNode.isLocked()) &#123; LockSupport.park(this); &#125; //help GC prev.set(null); &#125; public void unlock() &#123; Node currentNode = current.get(); currentNode.setLocked(false); Node nextNode = currentNode.getNext(); if (nextNode != null) &#123; LockSupport.unpark(nextNode.getThread()); &#125; &#125; private class Node &#123; private final Thread thread; //标识当前线程是否正在获取锁或已经获取到锁 private volatile boolean isLocked; private Node next; public Node() &#123; this.isLocked = true; this.next = null; this.thread = Thread.currentThread(); &#125; public boolean isLocked() &#123; return isLocked; &#125; public void setLocked(boolean locked) &#123; isLocked = locked; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; public Thread getThread() &#123; return thread; &#125; &#125;&#125; 12、对象锁13、线程锁14、锁粗化16、锁消除17、锁膨胀18、信号量 CAS和Unsafe操作上边我们介绍了volatile和JMM机制，那么从下图可以看出，Java并发的关键还有一个CAS的操作。 Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）。同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式： 首先，声明共享变量为volatile； 然后，使用CAS的原子条件更新来实现线程之间的同步； 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。 AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下： Unsafe 简单讲一下这个类。Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。 这个类尽管里面的方法都是public的，但是并没有办法使用它们，JDK API文档也没有提供任何关于这个类的方法的解释。总而言之，对于Unsafe类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然JDK库里面的类是可以随意使用的。 从第一行的描述可以了解到Unsafe提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过Java本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。 举两个例子，比方说： 1public native long staticFieldOffset(Field paramField); 这个方法可以用来获取给定的paramField的内存地址偏移量，这个值对于给定的field是唯一的且是固定不变的。再比如说： 12public native int arrayBaseOffset(Class paramClass);public native int arrayIndexScale(Class paramClass); 前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。最后看三个方法： 123public native long allocateMemory(long paramLong);public native long reallocateMemory(long paramLong1, long paramLong2);public native void freeMemory(long paramLong); 分别用来分配内存，扩充内存和释放内存的。 当然这需要有一定的C/C++基础，对内存分配有一定的了解，这也是为什么我一直认为C/C++开发者转行做Java会有优势的原因。 CAS CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。 当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。 CAS也是通过Unsafe实现的，看下Unsafe下的三个方法： 12345public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3); 由CAS分析AtomicInteger原理 java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的，下面拿AtomicInteger分析一下，首先是AtomicInteger类变量的定义： 1234567891011private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125;private volatile int value; 关于这段代码中出现的几个成员属性： 1、Unsafe是CAS的核心类，前面已经讲过了 2、valueOffset表示的是变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的原值的 3、value是用volatile修饰的，这是非常关键的 下面找一个方法getAndIncrement来研究一下AtomicInteger是如何实现的，比如我们常用的addAndGet方法： 12345678public final int addAndGet(int delta) &#123; for (;;) &#123; int current = get(); int next = current + delta; if (compareAndSet(current, next)) return next; &#125;&#125; 123public final int get() &#123; return value;&#125; 这段代码如何在不加锁的情况下通过CAS实现线程安全，我们不妨考虑一下方法的执行： 1、AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据Java内存模型，线程1和线程2各自持有一份value的副本，值为3 2、线程1运行到第三行获取到当前的value为3，线程切换 3、线程2开始运行，获取到value为3，利用CAS对比内存中的值也为3，比较成功，修改内存，此时内存中的value改变比方说是4，线程切换 4、线程1恢复运行，利用CAS比较发现自己的value为3，内存中的value为4，得到一个重要的结论–&gt;此时value正在被另外一个线程修改，所以我不能去修改它 5、线程1的compareAndSet失败，循环判断，因为value是volatile修饰的，所以它具备可见性的特性，线程2对于value的改变能被线程1看到，只要线程1发现当前获取的value是4，内存中的value也是4，说明线程2对于value的修改已经完毕并且线程1可以尝试去修改它 6、最后说一点，比如说此时线程3也准备修改value了，没关系，因为比较-交换是一个原子操作不可被打断，线程3修改了value，线程1进行compareAndSet的时候必然返回的false，这样线程1会继续循环去获取最新的value并进行compareAndSet，直至获取的value和内存中的value一致为止 整个过程中，利用CAS机制保证了对于value的修改的线程安全性。 CAS的缺点 CAS看起来很美，但这种操作显然无法涵盖并发下的所有场景，并且CAS从语义上来说也不是完美的，存在这样一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个漏洞称为CAS操作的”ABA”问题。java.util.concurrent包为了解决这个问题，提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较”鸡肋”，大部分情况下ABA问题并不会影响程序并发的正确性，如果需要解决ABA问题，使用传统的互斥同步可能回避原子类更加高效。 CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作 \1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 关于ABA问题参考文档: http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html \2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 \3. 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。 来源： https://blog.csdn.net/liu88010988/article/details/50799978 https://www.cnblogs.com/xrq730/p/4976007.html AQS框架源码解析Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类–AbstractQueuedSynchronizer,简称AQS。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。 本章我们就一起探究下这个神奇的东东，并对其实现原理进行剖析理解 基本实现原理 AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。 1private volatile int state;//共享变量，使用volatile修饰保证线程可见性 状态信息通过procted类型的getState，setState，compareAndSetState进行操作 AQS支持两种同步方式： 1.独占式 2.共享式 这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。 同步器的设计是基于模板方法模式的，一般的使用方式是这样： 1.使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放） 2.将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。 这其实是模板方法模式的一个很经典的应用。 我们来看看AQS定义的这些可重写的方法： protected boolean tryAcquire(int arg) : 独占式获取同步状态，试着获取，成功返回true，反之为false protected boolean tryRelease(int arg) ：独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态； protected int tryAcquireShared(int arg) ：共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败； protected boolean tryReleaseShared(int arg) ：共享式释放同步状态，成功为true，失败为false protected boolean isHeldExclusively() ： 是否在独占模式下被线程占用。 关于AQS的使用，我们来简单总结一下： 如何使用 首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了。 设计思想 对于使用者来讲，我们无需关心获取资源失败，线程排队，线程阻塞/唤醒等一系列复杂的实现，这些都在AQS中为我们处理好了。我们只需要负责好自己的那个环节就好，也就是获取/释放共享资源state的姿势T_T。很经典的模板方法设计模式的应用，AQS为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可。 自定义同步器 同步器代码实现 上面大概讲了一些关于AQS如何使用的理论性的东西，接下来，我们就来看下实际如何使用，直接采用JDK官方文档中的小例子来说明问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 1 package juc; 2 3 import java.util.concurrent.locks.AbstractQueuedSynchronizer; 4 5 /** 6 * Created by chengxiao on 2017/3/28. 7 */ 8 public class Mutex implements java.io.Serializable &#123; 9 //静态内部类，继承AQS10 private static class Sync extends AbstractQueuedSynchronizer &#123;11 //是否处于占用状态12 protected boolean isHeldExclusively() &#123;13 return getState() == 1;14 &#125;15 //当状态为0的时候获取锁，CAS操作成功，则state状态为1，16 public boolean tryAcquire(int acquires) &#123;17 if (compareAndSetState(0, 1)) &#123;18 setExclusiveOwnerThread(Thread.currentThread());19 return true;20 &#125;21 return false;22 &#125;23 //释放锁，将同步状态置为024 protected boolean tryRelease(int releases) &#123;25 if (getState() == 0) throw new IllegalMonitorStateException();26 setExclusiveOwnerThread(null);27 setState(0);28 return true;29 &#125;30 &#125;31 //同步对象完成一系列复杂的操作，我们仅需指向它即可32 private final Sync sync = new Sync();33 //加锁操作，代理到acquire（模板方法）上就行，acquire会调用我们重写的tryAcquire方法34 public void lock() &#123;35 sync.acquire(1);36 &#125;37 public boolean tryLock() &#123;38 return sync.tryAcquire(1);39 &#125;40 //释放锁，代理到release（模板方法）上就行，release会调用我们重写的tryRelease方法。41 public void unlock() &#123;42 sync.release(1);43 &#125;44 public boolean isLocked() &#123;45 return sync.isHeldExclusively();46 &#125;47 &#125; 源码分析 我们先来简单描述下AQS的基本实现，前面我们提到过，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。（这个内置的同步队列称为”CLH”队列）。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部head和尾部tail。 其实就是个双端双向链表。 当线程获取资源失败（比如tryAcquire时试图设置state状态失败），会被构造成一个结点加入CLH队列中，同时当前线程会被阻塞在队列中（通过LockSupport.park实现，其实是等待态）。当持有同步状态的线程释放同步状态时，会唤醒后继结点，然后此结点线程继续加入到对同步状态的争夺中。 Node结点 Node结点是AbstractQueuedSynchronizer中的一个静态内部类，我们捡Node的几个重要属性来说一下 1234567891011121314151617181920 1 static final class Node &#123; 2 /** waitStatus值，表示线程已被取消（等待超时或者被中断）*/ 3 static final int CANCELLED = 1; 4 /** waitStatus值，表示后继线程需要被唤醒（unpaking）*/ 5 static final int SIGNAL = -1; 6 /**waitStatus值，表示结点线程等待在condition上，当被signal后，会从等待队列转移到同步到队列中 */ 7 /** waitStatus value to indicate thread is waiting on condition */ 8 static final int CONDITION = -2; 9 /** waitStatus值，表示下一次共享式同步状态会被无条件地传播下去10 static final int PROPAGATE = -3;11 /** 等待状态，初始为0 */12 volatile int waitStatus;13 /**当前结点的前驱结点 */14 volatile Node prev;15 /** 当前结点的后继结点 */16 volatile Node next;17 /** 与当前结点关联的排队中的线程 */18 volatile Thread thread;19 /** ...... */20 &#125; 独占式 获取同步状态–acquire() 来看看acquire方法，lock方法一般会直接代理到acquire上 123451 public final void acquire(int arg) &#123;2 if (!tryAcquire(arg) &amp;&amp;3 acquireQueued(addWaiter(Node.EXCLUSIVE), arg))4 selfInterrupt();5 &#125; 我们来简单理一下代码逻辑： a.首先，调用使用者重写的tryAcquire方法，若返回true，意味着获取同步状态成功，后面的逻辑不再执行；若返回false，也就是获取同步状态失败，进入b步骤； b.此时，获取同步状态失败，构造独占式同步结点，通过addWatiter将此结点添加到同步队列的尾部（此时可能会有多个线程结点试图加入同步队列尾部，需要以线程安全的方 式添加）； c.该结点以在队列中尝试获取同步状态，若获取不到，则阻塞结点线程，直到被前驱结点唤醒或者被中断。 addWaiter 为获取同步状态失败的线程，构造成一个Node结点，添加到同步队列尾 123456789101112131415private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode);//构造结点 //指向尾结点tail Node pred = tail; //如果尾结点不为空，CAS快速尝试在尾部添加，若CAS设置成功，返回；否则，eng。 if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node; &#125; 先cas快速设置，若失败，进入enq方法 将结点添加到同步队列尾部这个操作，同时可能会有多个线程尝试添加到尾部，是非线程安全的操作。 以上代码可以看出，使用了compareAndSetTail这个cas操作保证安全添加尾结点。 enq方法 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; //如果队列为空，创建结点，同时被head和tail引用 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123;//cas设置尾结点，不成功就一直重试 t.next = node; return t; &#125; &#125; &#125; &#125; enq内部是个死循环，通过CAS设置尾结点，不成功就一直重试。很经典的CAS自旋的用法，我们在之前关于原子类的源码分析中也提到过。这是一种乐观的并发策略。 最后，看下acquireQueued方法 acquireQueued 12345678910111213141516171819202122final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123;//死循环 final Node p = node.predecessor();//找到当前结点的前驱结点 if (p == head &amp;&amp; tryAcquire(arg)) &#123;//如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。 setHead(node);//获取同步状态成功，将当前结点设置为头结点。 p.next = null; // 方便GC failed = false; return interrupted; &#125; // 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; acquireQueued内部也是一个死循环，只有前驱结点是头结点的结点，也就是老二结点，才有机会去tryAcquire；若tryAcquire成功，表示获取同步状态成功，将此结点设置为头结点；若是非老二结点，或者tryAcquire失败，则进入shouldParkAfterFailedAcquire去判断判断当前线程是否应该阻塞，若可以，调用parkAndCheckInterrupt阻塞当前线程，直到被中断或者被前驱结点唤醒。若还不能休息，继续循环。 shouldParkAfterFailedAcquire 1shouldParkAfterFailedAcquire用来判断当前结点线程是否能休息 1234567891011121314151617private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前驱结点的wait值 int ws = pred.waitStatus; if (ws == Node.SIGNAL)//若前驱结点的状态是SIGNAL，意味着当前结点可以被安全地park return true; if (ws &gt; 0) &#123; // ws&gt;0，只有CANCEL状态ws才大于0。若前驱结点处于CANCEL状态，也就是此结点线程已经无效，从后往前遍历，找到一个非CANCEL状态的结点，将自己设置为它的后继结点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 若前驱结点为其他状态，将其设置为SIGNAL状态 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; 若shouldParkAfterFailedAcquire返回true，也就是当前结点的前驱结点为SIGNAL状态，则意味着当前结点可以放心休息，进入parking状态了。parkAncCheckInterrupt阻塞线程并处理中断。 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this);//使用LockSupport使线程进入阻塞状态 return Thread.interrupted();// 线程是否被中断过 &#125; 至此，关于acquire的方法源码已经分析完毕，我们来简单总结下 a.首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节； b.线程获取同步状态失败，就构造一个结点，加入同步队列中，这个过程要保证线程安全； c.加入队列中的结点线程进入自旋状态，若是老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态；否则，当其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒。 释放同步状态–release() 当前线程执行完自己的逻辑之后，需要释放同步状态，来看看release方法的逻辑 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123;//调用使用者重写的tryRelease方法，若成功，唤醒其后继结点，失败则返回false Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);//唤醒后继结点 return true; &#125; return false; &#125; 1 unparkSuccessor:唤醒后继结点 123456789101112131415 1 private void unparkSuccessor(Node node) &#123; 2 //获取wait状态 3 int ws = node.waitStatus; 4 if (ws &lt; 0) 5 compareAndSetWaitStatus(node, ws, 0);// 将等待状态waitStatus设置为初始值0 6 Node s = node.next;//后继结点 7 if (s == null || s.waitStatus &gt; 0) &#123;//若后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到一个处于正常阻塞状态的结点 进行唤醒 8 s = null; 9 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)10 if (t.waitStatus &lt;= 0)11 s = t;12 &#125;13 if (s != null)14 LockSupport.unpark(s.thread);//使用LockSupprot唤醒结点对应的线程15 &#125; release的同步状态相对简单，需要找到头结点的后继结点进行唤醒，若后继结点为空或处于CANCEL状态，从后向前遍历找寻一个正常的结点，唤醒其对应线程。 共享式 共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法tryAcquire返回值为boolean，这很容易理解；对于共享式同步组件来讲，同一时刻可以有多个线程同时获取到同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法tryAcquireShared返回值为int。 123protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException(); &#125; 1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取； 2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了； 3.当返回值小于0时，表示获取同步状态失败。 获取同步状态–acquireShared 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0)//返回值小于0，获取同步状态失败，排队去；获取同步状态成功，直接返回去干自己的事儿。 doAcquireShared(arg); &#125; doAcquireShared 123456789101112131415161718192021222324252627 1 private void doAcquireShared(int arg) &#123; 2 final Node node = addWaiter(Node.SHARED);//构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。 3 boolean failed = true;//是否获取成功 4 try &#123; 5 boolean interrupted = false;//线程parking过程中是否被中断过 6 for (;;) &#123;//死循环 7 final Node p = node.predecessor();//找到前驱结点 8 if (p == head) &#123;//头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态 9 int r = tryAcquireShared(arg);//尝试获取同步装填10 if (r &gt;= 0) &#123;//r&gt;=0,获取成功11 setHeadAndPropagate(node, r);//获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结点12 p.next = null; // 方便GC13 if (interrupted)14 selfInterrupt();15 failed = false;16 return;17 &#125;18 &#125;19 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;//是否能安心进入parking状态20 parkAndCheckInterrupt())//阻塞线程21 interrupted = true;22 &#125;23 &#125; finally &#123;24 if (failed)25 cancelAcquire(node);26 &#125;27 &#125; 大体逻辑与独占式的acquireQueued差距不大，只不过由于是共享式，会有多个线程同时获取到线程，也可能同时释放线程，空出很多同步状态，所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去。 setHeadAndPropagate 123456789private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125; &#125; 释放同步状态–releaseShared 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared();//释放同步状态 return true; &#125; return false; &#125; doReleaseShared 123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123;//死循环，共享模式，持有同步状态的线程可能有多个，采用循环CAS保证线程安全 Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; unparkSuccessor(h);//唤醒后继结点 &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; &#125; if (h == head) break; &#125; &#125; 代码逻辑比较容易理解，需要注意的是，共享模式，释放同步状态也是多线程的，此处采用了CAS自旋来保证。 总结 关于AQS的介绍及源码分析到此为止了。 AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。 AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。 参考： https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html https://github.com/Essviv/blogs/blob/master/source/_posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc/AQS%E6%A1%86%E6%9E%B6/AQS%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md LockSupport与wait-notify的使用.LockSupport，Java之初就有Object对象的wait和notify方法可以实现线程的阻塞和唤醒。那么它们的区别 是什么呢？ wait notify必须要获取sychronized锁(对象锁，类锁等)，且需要先执行wait，否则notify没有作用，也会造成wait一直没有唤醒。 LockSupport，park和unpark使用上没有要求(作用于线程)，直接阻塞线程，且没有顺序之分。 这个类的作用有点类似于Semaphore，通过许可证(permit)来联系使用它的线程。如果许可证可用，调用park方法会立即返回并在这个过程中消费这个许可，不然线程会阻塞。调用unpark会使许可证可用。(和Semaphores有些许区别,许可证不会累加，最多只有一张。相当于一个信号量(0,1),默认是0 。 LockSupport并不需要获取对象的监视器。LockSupport机制是每次unpark给线程1个“许可”——最多只能是1，而park则相反，如果当前 线程有许可，那么park方法会消耗1个并返回，否则会阻塞线程直到线程重新获得许可，在线程启动之前调用park/unpark方法没有任何效果。 12345678// 1次unpark给线程1个许可LockSupport.unpark(Thread.currentThread());// 如果线程非阻塞重复调用没有任何效果LockSupport.unpark(Thread.currentThread());// 消耗1个许可LockSupport.park(Thread.currentThread());// 阻塞LockSupport.park(Thread.currentThread()); LockSupport.park()也能响应中断信号，但是跟Thread.sleep()不同的是它不会抛出InterruptedException Object.wait()方法的Javadoc的话会发现官方也是建议下面这样的用法： 123456synchronized (obj) &#123; while (&lt;condition does not hold&gt;) …… obj.wait(); ……&#125; StackOverflow上有一个问题里一个叫xagyg的回答解释的比较清楚，有兴趣的可以看下。 简单来说因为： wait前会释放监视器，被唤醒后又要重新获取，这瞬间可能有其他线程刚好先获取到了监视器，从而导致状态发生了变化， 这时候用while循环来再判断一下条件（比如队列是否为空）来避免不必要或有问题的操作。 这种机制还可以用来处理伪唤醒（spurious wakeup），所谓伪唤醒就是no reason wakeup，对于LockSupport.park()来说就是除了unpark和interrupt之外的原因。 LockSupport的实现 学习要知其然，还要知其所以然。接下来不妨看看LockSupport的实现。 进入LockSupport的park方法，可以发现它是调用了Unsafe的park方法，这是一个本地native方法，只能通过openjdk的源码看看其本地实现了。 它调用了线程的Parker类型对象的park方法，如下是Parker类的定义： 类中定义了一个int类型的_counter变量，咱们上文中讲灵活性的那一节说，可以先执行unpark后执行park，就是通过这个变量实现，看park方法的实现代码(由于方法比较长就不整体截图了)： park方法会调用Atomic::xchg方法，这个方法会原子性的将_counter赋值为0，并返回赋值前的值。如果调用park方法前，_counter大于0，则说明之前调用过unpark方法，所以park方法直接返回。 接着往下看： 实际上Parker类用Posix的mutex，condition来实现的阻塞唤醒。如果对mutex和condition不熟，可以简单理解为mutex就是Java里的synchronized，condition就是Object里的wait/notify操作。 park方法里调用pthread_mutex_trylock方法，就相当于Java线程进入Java的同步代码块，然后再次判断_counter是否大于零，如果大于零则将_counter设置为零。最后调用pthread_mutex_unlock解锁，相当于Java执行完退出同步代码块。如果_counter不大于零，则继续往下执行pthread_cond_wait方法，实现当前线程的阻塞。 最后再看看unpark方法的实现吧，这块就简单多了，直接上代码： 图中的1和4就相当于Java的进入synchronized和退出synchronized的加锁解锁操作，代码2将_counter设置为1，同时判断先前_counter的值是否小于1，即这段代码：if(s&lt;1)。如果不小于1，则就不会有线程被park，所以方法直接执行完毕，否则就会执行代码3，来唤醒被阻塞的线程。 通过阅读LockSupport的本地实现，我们不难发现这么个问题：多次调用unpark方法和调用一次unpark方法效果一样，因为都是直接将_counter赋值为1，而不是加1。简单说就是：线程A连续调用两次LockSupport.unpark(B)方法唤醒线程B，然后线程B调用两次LockSupport.park()方法， 线程B依旧会被阻塞。因为两次unpark调用效果跟一次调用一样，只能让线程B的第一次调用park方法不被阻塞，第二次调用依旧会阻塞。 到这里,自己实现一把“锁”用到的技术点都已经介绍完了，甚至本节还介绍了锁的具体实现，相信即使没有最后一篇介绍怎么实现“锁”，大家也能动手写个锁了。 参考： https://www.cnblogs.com/qingquanzi/p/8228422.html https://blog.csdn.net/secsf/article/details/78560013 https://www.cnblogs.com/fairjm/p/locksuport.html ReentrantLock实现原理及源码分析 ReentrantLock是Java并发包中提供的一个可重入的互斥锁。ReentrantLock和synchronized在基本用法，行为语义上都是类似的，同样都具有可重入性。只不过相比原生的Synchronized，ReentrantLock增加了一些高级的扩展功能，比如它可以实现公平锁，同时也可以绑定多个Conditon。 可重入性/公平锁/非公平锁 可重入性 所谓的可重入性，就是可以支持一个线程对锁的重复获取，原生的synchronized就具有可重入性，一个用synchronized修饰的递归方法，当线程在执行期间，它是可以反复获取到锁的，而不会出现自己把自己锁死的情况。ReentrantLock也是如此，在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。那么有可重入锁，就有不可重入锁，我们在之前文章中自定义的一个Mutex锁就是个不可重入锁，不过使用场景极少而已。 公平锁/非公平锁 所谓公平锁,顾名思义，意指锁的获取策略相对公平，当多个线程在获取同一个锁时，必须按照锁的申请时间来依次获得锁，排排队，不能插队；非公平锁则不同，当锁被释放时，等待中的线程均有机会获得锁。synchronized是非公平锁，ReentrantLock默认也是非公平的，但是可以通过带boolean参数的构造方法指定使用公平锁，但非公平锁的性能一般要优于公平锁。 synchronized是Java原生的互斥同步锁，使用方便，对于synchronized修饰的方法或同步块，无需再显式释放锁。synchronized底层是通过monitorenter和monitorexit两个字节码指令来实现加锁解锁操作的。而ReentrantLock做为API层面的互斥锁，需要显式地去加锁解锁。 12345678910111213class X &#123; private final ReentrantLock lock = new ReentrantLock(); // ... public void m() &#123; lock.lock(); // 加锁 try &#123; // ... 函数主题 &#125; finally &#123; lock.unlock() //解锁 &#125; &#125; &#125; 源码分析 接下来我们从源码角度来看看ReentrantLock的实现原理，它是如何保证可重入性，又是如何实现公平锁的。 ReentrantLock是基于AQS的，AQS是Java并发包中众多同步组件的构建基础，它通过一个int类型的状态变量state和一个FIFO队列来完成共享资源的获取，线程的排队等待等。AQS是个底层框架，采用模板方法模式，它定义了通用的较为复杂的逻辑骨架，比如线程的排队，阻塞，唤醒等，将这些复杂但实质通用的部分抽取出来，这些都是需要构建同步组件的使用者无需关心的，使用者仅需重写一些简单的指定的方法即可（其实就是对于共享变量state的一些简单的获取释放的操作）。 上面简单介绍了下AQS，详细内容可参考本人的另一篇文章《Java并发包基石-AQS详解》，此处就不再赘述了。先来看常用的几个方法，我们从上往下推。 无参构造器（默认为公平锁） 123public ReentrantLock() &#123; sync = new NonfairSync();//默认是非公平的 &#125; sync是ReentrantLock内部实现的一个同步组件，它是Reentrantlock的一个静态内部类，继承于AQS，后面我们再分析。 带布尔值的构造器（是否公平） 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();//fair为true，公平锁；反之，非公平锁 &#125; 看到了吧，此处可以指定是否采用公平锁，FailSync和NonFailSync亦为Reentrantlock的静态内部类，都继承于Sync。 再来看看几个我们常用到的方法 lock() 123public void lock() &#123; sync.lock();//代理到Sync的lock方法上 &#125; Sync的lock方法是抽象的，实际的lock会代理到FairSync或是NonFairSync上（根据用户的选择来决定，公平锁还是非公平锁） lockInterruptibly() 123public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);//代理到sync的相应方法上，同lock方法的区别是此方法响应中断 &#125; 此方法响应中断，当线程在阻塞中的时候，若被中断，会抛出InterruptedException异常 tryLock() 123public boolean tryLock() &#123; return sync.nonfairTryAcquire(1);//代理到sync的相应方法上 &#125; tryLock，尝试获取锁，成功则直接返回true，不成功也不耽搁时间，立即返回false。 unlock() 123public void unlock() &#123; sync.release(1);//释放锁 &#125; 释放锁，调用sync的release方法，其实是AQS的release逻辑。 newCondition() 获取一个conditon，ReentrantLock支持多个Condition 123public Condition newCondition() &#123; return sync.newCondition(); &#125; 其他方法就不再赘述了，若想继续了解可去API中查看。 小结 其实从上面这写方法的介绍，我们都能大概梳理出ReentrantLock的处理逻辑，其内部定义了三个重要的静态内部类，Sync，NonFairSync，FairSync。Sync作为ReentrantLock中公用的同步组件，继承了AQS（要利用AQS复杂的顶层逻辑嘛，线程排队，阻塞，唤醒等等）；NonFairSync和FairSync则都继承Sync，调用Sync的公用逻辑，然后再在各自内部完成自己特定的逻辑（公平或非公平）。 接下来，关于如何实现重入性，如何实现公平性，就得去看这几个静态内部类了 NonFairSync（非公平可重入锁） 12345678910111213static final class NonfairSync extends Sync &#123;//继承Sync private static final long serialVersionUID = 7316153563782823691L; /** 获取锁 */ final void lock() &#123; if (compareAndSetState(0, 1))//CAS设置state状态，若原值是0，将其置为1 setExclusiveOwnerThread(Thread.currentThread());//将当前线程标记为已持有锁 else acquire(1);//若设置失败，调用AQS的acquire方法，acquire又会调用我们下面重写的tryAcquire方法。这里说的调用失败有两种情况：1当前没有线程获取到资源，state为0，但是将state由0设置为1的时候，其他线程抢占资源，将state修改了，导致了CAS失败；2 state原本就不为0，也就是已经有线程获取到资源了，有可能是别的线程获取到资源，也有可能是当前线程获取的，这时线程又重复去获取，所以去tryAcquire中的nonfairTryAcquire我们应该就能看到可重入的实现逻辑了。 &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);//调用Sync中的方法 &#125; &#125; nonfairTryAcquire() 简单总结下流程： 1.先获取state值，若为0，意味着此时没有线程获取到资源，CAS将其设置为1，设置成功则代表获取到排他锁了； 2.若state大于0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己抢占的，是的话，state累加，返回true，重入成功，state的值即是线程重入的次数； 3.其他情况，则获取锁失败。 来看看可重入公平锁的处理逻辑 FairSync 123456789101112131415161718192021222324252627static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1);//直接调用AQS的模板方法acquire，acquire会调用下面我们重写的这个tryAcquire &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread();//获取当前线程 int c = getState();//获取state值 if (c == 0) &#123;//若state为0，意味着当前没有线程获取到资源，那就可以直接获取资源了吗？NO!这不就跟之前的非公平锁的逻辑一样了嘛。看下面的逻辑 if (!hasQueuedPredecessors() &amp;&amp;//判断在时间顺序上，是否有申请锁排在自己之前的线程，若没有，才能去获取，CAS设置state，并标记当前线程为持有排他锁的线程；反之，不能获取！这即是公平的处理方式。 compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123;//重入的处理逻辑，与上文一致，不再赘述 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; &#125; 可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于有了!hasQueuedPredecessors()这个判断逻辑，即便state为0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回false，获取失败。 看看这个判断是否有排队中线程的逻辑 **hasQueuedPredecessors() 1234567public final boolean hasQueuedPredecessors() &#123; Node t = tail; // 尾结点 Node h = head;//头结点 Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());//判断是否有排在自己之前的线程&#125; 需要注意的是，这个判断是否有排在自己之前的线程的逻辑稍微有些绕，我们来梳理下，由代码得知，有两种情况会返回true，我们将此逻辑分解一下（注意：返回true意味着有其他线程申请锁比自己早，需要放弃抢占） 1. h !=t &amp;&amp; (s = h.next) == null，这个逻辑成立的一种可能是head指向头结点，tail此时还为null。考虑这种情况：当其他某个线程去获取锁失败，需构造一个结点加入同步队列中（假设此时同步队列为空），在添加的时候，需要先创建一个无意义傀儡头结点（在AQS的enq方法中，这是个自旋CAS操作），有可能在将head指向此傀儡结点完毕之后，还未将tail指向此结点。很明显，此线程时间上优于当前线程，所以，返回true，表示有等待中的线程且比自己来的还早。 2.h != t &amp;&amp; (s = h.next) != null &amp;&amp; s.thread != Thread.currentThread()。同步队列中已经有若干排队线程且当前线程不是队列的老二结点，此种情况会返回true。假如没有s.thread !=Thread.currentThread()这个判断的话，会怎么样呢？若当前线程已经在同步队列中是老二结点（头结点此时是个无意义的傀儡结点),此时持有锁的线程释放了资源，唤醒老二结点线程，老二结点线程重新tryAcquire（此逻辑在AQS中的acquireQueued方法中），又会调用到hasQueuedPredecessors，不加s.thread !=Thread.currentThread()这个判断的话，返回值就为true，导致tryAcquire失败。 最后，来看看ReentrantLock的tryRelease，定义在Sync中 12345678910111213protected final boolean tryRelease(int releases) &#123; int c = getState() - releases;//减去1个资源 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //若state值为0，表示当前线程已完全释放干净，返回true，上层的AQS会意识到资源已空出。若不为0，则表示线程还占有资源，只不过将此次重入的资源的释放了而已，返回false。 if (c == 0) &#123; free = true;// setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; 总结 ReentrantLock是一种可重入的，可实现公平性的互斥锁，它的设计基于AQS框架，可重入和公平性的实现逻辑都不难理解，每重入一次，state就加1，当然在释放的时候，也得一层一层释放。至于公平性，在尝试获取锁的时候多了一个判断：是否有比自己申请早的线程在同步队列中等待，若有，去等待；若没有，才允许去抢占。 http://www.cnblogs.com/chengxiao/p/7255941.html CountDownLatch 含义 CountDownLatch可以理解为一个计数器在初始化时设置初始值，当一个线程需要等待某些操作先完成时，需要调用await()方法。这个方法让线程进入休眠状态直到等待的所有线程都执行完成。每调用一次countDown()方法内部计数器减1,直到计数器为0时唤醒。这个可以理解为特殊的CyclicBarrier。线程同步点比较特殊，为内部计数器值为0时开始。 方法 核心方法两个：countDown()和await() countDown():使CountDownLatch维护的内部计数器减1,每个被等待的线程完成的时候调用 await():线程在执行到CountDownLatch的时候会将此线程置于休眠 CountDownLatch初始构造函数传入count，countDown()函数每次调用-1， await等待为0时返回。 实现基于AQS共享锁，覆写tryAcquireShared和tryReleaseShared方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class CountDownLatch &#123; private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; private final Sync sync; //初始化一个同步器 public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; //调用同步器的acquireSharedInterruptibly方法 //并且是响应中断的 public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; //调用同步器的releaseShared方法去让state减1 public void countDown() &#123; sync.releaseShared(1); &#125; //获取剩余的count public long getCount() &#123; return sync.getCount(); &#125; public String toString() &#123; return super.toString() + "[Count = " + sync.getCount() + "]"; &#125;&#125; 案例： https://blog.csdn.net/ErixHao/article/details/52747955 CyclicBarrier 可以理解为循环栅栏,栅栏就是一种障碍物.假如我们将计数器设置为10,那么凑齐第一批10个线程后,计数器就会归零,然后接着凑齐下一批10个线程,这就是循环栅栏的含义. 构造器: 1public CyclicBarrier(int parties, Runnable barrierAction) ​ parties:计数总数,也就是参与的线程总数. barrierAction 当计数器一次完成计数后,系统会执行的动作 ​ 方法 ​ await()：使线程置入休眠直到最后一个线程的到来之后唤醒所有休眠的线程 没有显示调用CountDown()方法 CountDownLatch一般只能使用一次，CyclicBarrier可以多次使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class CyclicBarrierDemo &#123; public static class Soldier implements Runnable &#123; private String soldier; private final CyclicBarrier cyclic; public Soldier(CyclicBarrier cyclic, String soldier) &#123; this.soldier = soldier; this.cyclic = cyclic; &#125; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see Thread#run() */ @Override public void run() &#123; try &#123; //等待所有士兵到齐 cyclic.await(); doWork(); //等待所有士兵完成工作 cyclic.await(); &#125; catch (InterruptedException e) &#123;//在等待过程中,线程被中断 e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123;//表示当前CyclicBarrier已经损坏.系统无法等到所有线程到齐了. e.printStackTrace(); &#125; &#125; void doWork() &#123; try &#123; Thread.sleep(Math.abs(new Random().nextInt() % 10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(soldier + ":任务完成"); &#125; &#125; public static class BarrierRun implements Runnable &#123; boolean flag; int N; public BarrierRun(boolean flag, int N) &#123; this.flag = flag; this.N = N; &#125; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see Thread#run() */ @Override public void run() &#123; if (flag) &#123; System.out.println("司令:[士兵" + N + "个,任务完成!]"); &#125; else &#123; System.out.println("司令:[士兵" + N + "个,集合完毕!]"); flag = true; &#125; &#125; &#125; public static void main(String[] args) &#123; final int N = 10; Thread[] allSoldier = new Thread[N]; boolean flag = false; CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag, N)); //设置屏障点,主要为了执行这个方法 System.out.println("集合队伍! "); for (int i = 0; i &lt; N; i++) &#123; System.out.println("士兵" + i + "报道! "); allSoldier[i] = new Thread(new Soldier(cyclic, "士兵" + i)); allSoldier[i].start(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.CyclicBarrier;import java.util.concurrent.BrokenBarrierException;public class CyclicBarrierTest1 &#123; private static int SIZE = 5; private static CyclicBarrier cb; public static void main(String[] args) &#123; cb = new CyclicBarrier(SIZE); // 新建5个任务 for(int i=0; i&lt;SIZE; i++) new InnerThread().start(); &#125; static class InnerThread extends Thread&#123; public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + " wait for CyclicBarrier."); // 将cb的参与者数量加1 cb.await(); // cb的参与者数量等于5时，才继续往后执行 System.out.println(Thread.currentThread().getName() + " continued."); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 比较CountDownLatch和CyclicBarrier： (01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 参考： https://www.cnblogs.com/skywang12345/p/3533995.html https://www.cnblogs.com/ten951/p/6212160.html https://www.cnblogs.com/uodut/p/6830939.html#_label2 CopyOnWriteList和CopyOnWriteSet Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 什么是CopyOnWrite容器 CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差，但是读操作因为操作的对象和写操作不是同一个对象，读之间也不需要加锁，读和写之间的同步处理只是在写完后通过一个简单的“=”将引用指向新的数组对象上来，这个几乎不需要时间，这样读操作就很快很安全，适合在多线程里使用，绝对不会发生ConcurrentModificationException，所以最后得出结论：CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。 COWSet的底层是通过COWList实现的， 在写操作的时候，有选择性的选择addIfAbsent版本的操作. COWList的底层实现是通过ReentrantLock来实现的，所有的写操作执行前都必须先获取到相应的RL锁，然后再进行操作. https://www.cnblogs.com/dolphin0520/p/3938914.html 在线程对其进行些操作的时候，会拷贝一个新的数组以存放新的字段。 private volatile transient Object[] array;//保证了线程的可见性，所有操作直接操作主存。 写操作加锁，读操作不加锁，相对来说读的效率更高 可变操作（add()、set() 和 remove() 等等）的开销很大, 因为通常需要复制整个基础数组。 写操作Object[] newElements = Arrays.copyOf(elements, len + 1);直接加锁，复制，新建一个数组，写回主存，get操作不加锁直接操作 123456789101112131415161718192021222324 /** The lock protecting all mutators */ transient final ReentrantLock lock = new ReentrantLock(); /** The array, accessed only via getArray/setArray. */ private volatile transient Object[] array;//保证了线程的可见性public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//ReentrantLock 保证了线程的可见性和顺序性，即保证了多线程安全。 lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//在原先数组基础之上新建长度＋1的数组，并将原先数组当中的内容拷贝到新数组当中。 newElements[len] = e;//设值 setArray(newElements);//对新数组进行赋值 return true; &#125; finally &#123; lock.unlock(); &#125; &#125; public E get(int index) &#123; return (E)(getArray()[index]); &#125; 迭代不会出现ConcurrentModificationException, 因为迭代器会保存一个快照private final Object[] snapshot;, 而不是直接操作原来的Object[] array，不可变，不会发生同步问题。 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作, 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;public ListIterator&lt;E&gt; listIterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;public ListIterator&lt;E&gt; listIterator(final int index) &#123; Object[] elements = getArray(); int len = elements.length; if (index&lt;0 || index&gt;len) throw new IndexOutOfBoundsException("Index: "+index); return new COWIterator&lt;E&gt;(elements, index);&#125; private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; // 保存数组的快照，是一个不可变的对象 private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; @SuppressWarnings("unchecked") public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; @SuppressWarnings("unchecked") public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125;&#125; 参考：https://blog.csdn.net/mazhimazh/article/details/19210547 Synchronized原理记得刚刚开始学习Java的时候，一遇到多线程情况就是synchronized，相对于当时的我们来说synchronized是这么的神奇而又强大，那个时候我们赋予它一个名字“同步”，也成为了我们解决多线程情况的百试不爽的良药。但是，随着我们学习的进行我们知道synchronized是一个重量级锁，相对于Lock，它会显得那么笨重，以至于我们认为它不是那么的高效而慢慢摒弃它。诚然，随着Javs SE 1.6对synchronized进行的各种优化后，synchronized并不会显得那么重了。下面跟随LZ一起来探索synchronized的实现机制、Java是如何对它进行了优化、锁优化机制、锁的存储结构和升级过程； 实现原理 synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码： 利用javap工具查看生成的class文件信息来分析Synchronize的实现从上面可以看出，同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。(摘自：http://www.cnblogs.com/javaminer/p/3889023.html) 下面我们来继续分析，但是在深入之前我们需要了解两个重要的概念：Java对象头，Monitor。 Java对象头、monitorJava对象头和monitor是实现synchronized的基础！下面就这两个概念来做详细介绍。 Java对象头synchronized用的锁是存在Java对象头里的，那么什么是Java对象头呢？Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键，所以下面将重点阐述 Mark Word。Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。下图是Java对象头的存储结构（32位虚拟机）：对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说，Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）： 简单介绍了Java对象头，我们下面再看Monitor。 Monitor什么是Monitor？我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。Nest:用来实现重入锁的计数。HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。摘自：Java中synchronized的实现原理与应用）我们知道synchronized是重量级锁，效率不怎么滴，同时这个观念也一直存在我们脑海里，不过在jdk 1.6中对synchronize的实现进行了各种优化，使得它显得不是那么重了，那么JVM采用了那些优化手段呢？ 锁优化jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 自旋锁线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。何谓自旋锁？所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。 适应自旋锁JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。 锁消除为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法： 在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。 锁粗化我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。 偏向锁-&gt;轻量级锁-&gt;重量级锁 偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。 ​ 一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个 线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将 对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。 ​ 轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。 轻量级锁引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：获取锁 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）； JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）； 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态； 释放锁轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： 取出在获取轻量级锁保存在Displaced Mark Word中的数据； 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）； 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。 对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢； 下图是轻量级锁的获取和释放过程 偏向锁引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可，处理流程如下：获取锁 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01； 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）； 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）； 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块； 执行同步代码块 释放锁偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下： 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态； 撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态； 下图是偏向锁的获取和释放流程 重量级锁重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。 参考： http://www.importnew.com/23511.html https://www.cnblogs.com/charlesblc/p/5994162.html https://blog.csdn.net/choukekai/article/details/63688332 https://www.jianshu.com/p/e674ee68fd3f 线程安全集合类copy from： http://colobu.com/2014/11/27/java-collections-overview/ ArraysArray是Java唯一内建的集合类型。在你预先知道所要处理数据元素个数的情况下特别有用。java.util.Arrays 包含了许多处理数据的实用方法： Arrays.asList - 可以把 Array 转换成 List。将转换结果作为其他集合类型构造函数的参数。 Arrays.binarySearch - 在一个已排序的数组中或者其中一段快速查找。 Arrays.copyOf - 如果你想扩大数组容量又想保留它的内容的时候可以使用这个方法。 Arrays.copyOfRange - 可以复制整个数组或其中的一段。 Arrays.deepEquals、Arrays.deepHashCode - Arrays.equals/hashCode的高级版本，支持嵌套的子数组。 Arrays.equals - 如果你想要比较两个数组是否相等，应该调用这个方法而不是数组对象的 equals方法。 加入两个数组包含相同数量的元素， 并且对应的元素的equals是true, 这个方法才返回true。 换句话说， 只有相同(equals=true)的元素并且顺序一样的两个数组才相等。 Arrays.fill - 用一个给定的值填充整个数组或其中的一段。 Arrays.hashCode - 用来根据数组的内容计算其哈希值（数组对象的hashCode()不可用）。这个方法集合了Java 5的自动装箱和变长参数的特性，来实现一个简单的hashcode方法。 Arrays.sort - 对整个数组或者数组的一段进行排序。也可以使用此方法用给定的比较器Comparator对对象数组进行排序。 Arrays.toString - 打印数组的内容。 如果想要复制整个数组或其中一部分到另一个数组，可以调用 System.arraycopy方法。此方法从源数组中指定的位置复制指定个数的元素到目标数组的指定位置。通常这是最快的复制数组方法。（有时候用 ByteBuffer bulk复制会更快。可以参考这篇文章）. 最后一点，所有的集合都可以用T[] Collection.toArray( T[] a ) 这个方法复制到数组中。通常会用这样的方式调用： 1return coll.toArray( new T[ coll.size() ] ); 这个方法会分配足够大的数组来储存所有的集合元素，这样 toArray 方法本身不必为返回值再分配空间了。 非线程安全集合这一部分介绍的是非线程安全的集合。这些集合都在java.util包里。其中一些在Java 1.o的时候就有了（现在已经弃用），其中大多数在Java 1.4中发布。枚举集合在Java 1.5中发布，并且从这个版本之后所有的集合都支持泛型。PriorityQueue也在Java 1.5中加入。非线程安全的集合架构的最后一个发布的类是ArrayDeque ，在Java 1.6中发布。 List ArrayList - 最有用的List接口实现。由一个整数（数组中第一个还未被使用的元素的位置）和数组作为后台实现。像所有的List一样，ArrayList可以在必要的时候扩展它的大小。ArrayList访问元素的时间开销固定。在尾部添加元素成本低（为常数复杂度），而在头部添加元素成本很高（线性复杂度）。这是由ArrayList的实现原理——所有的元素的从角标为0开始一个接着一个排列造成的。也就是说，从要插入的元素位置往后，每个元素都要向后移动一个位置。它是一个CPU缓存友好的集合， 因为它是基于数组的。（其实也不是非常友好，因为有时数组会包含对象，这样存储的只是指向实际对象的指针）。 LinkedList - Deque实现：每一个节点都保存着上一个节点和下一个节点的指针。这就意味着数据的存取和更新具有线性复杂度（这也是一个最佳化的实现，每次操作都不会遍历数组一半以上，操作成本最高的元素就是数组中间的那个）。如果想写出高效的LinkedList代码可以使用 ListIterators 。如果你想用一个Queue/Deque实现的话（你只需读取第一个和最后一个元素就行了）——考虑用ArrayDeque代替。 Vector - 一个带有线程同步方法的ArrayList版本。现在直接用ArrayList代替了。 Queues/deques ArrayDeque - Deque（双向队列）是基于有首尾指针的数组（环形缓冲区）实现的。和LinkedList不同，这个类没有实现List接口。因此，如果没有首尾元素的话就不能取出任何元素。这个类比LinkedList要好一些，因为它产生的垃圾数量较少（在扩容的时候旧的数组会被丢弃）。 Stack - 栈，一种后进先出的队列。不要在生产代码中使用，使用别的Deque来代替（ArrayDeque比较好）。 PriorityQueue - 一个基于优先级的队列。使用自然顺序或者制定的比较器来排序。他的主要属性——poll/peek/remove/element会返回一个队列的最小值。不仅如此，PriorityQueue还实现了Iterable接口，队列迭代时不进行排序（或者其他顺序）。在需要排序的集合中，使用这个队列会比TreeSet等其他队列要方便。 Maps HashMap：最常用的Map实现。只是将一个键和值相对应，并没有其他的功能。对于复杂的hashCode method，get/put方法有固定的复杂度。 EnumMap：枚举类型作为键值的Map。因为键的数量相对固定，所以在内部用一个数组储存对应值。通常来说，效率要高于HashMap。 HashTable：旧HashMap的同步版本，新的代码中也使用了HashMap。 IdentityHashMap：这是一个特殊的Map版本，它违背了一般Map的规则：它使用 “==” 来比较引用而不是调用Object.equals来判断相等。这个特性使得此集合在遍历图表的算法中非常实用——可以方便地在IdentityHashMap中存储处理过的节点以及相关的数据。 LinkedHashMap ：HashMap和LinkedList的结合，所有元素的插入顺序存储在LinkedList中。这就是为什么迭代LinkedHashMap的条目（entry）、键和值的时候总是遵循插入的顺序。在JDK中，这是每元素消耗内存最大的集合。 TreeMap：一种基于已排序且带导向信息Map的红黑树。每次插入都会按照自然顺序或者给定的比较器排序。这个Map需要实现equals方法和Comparable/Comparator。compareTo需要前后一致。这个类实现了一个NavigableMap接口：可以带有与键数量不同的入口，可以得到键的上一个或者下一个入口，可以得到另一Map某一范围的键（大致和SQL的BETWEEN运算符相同），以及其他的一些方法。 WeakHashMap：这种Map通常用在数据缓存中。它将键存储在WeakReference中，就是说，如果没有强引用指向键对象的话，这些键就可以被垃圾回收线程回收。值被保存在强引用中。因此，你要确保没有引用从值指向键或者将值也保存在弱引用中m.put(key, new WeakReference(value))。 Sets HashSet：一个基于HashMap的Set实现。其中，所有的值为“假值”（同一个Object对象具备和HashMap同样的性能。基于这个特性，这个数据结构会消耗更多不必要的内存。 EnumSet：值为枚举类型的Set。Java的每一个enum都映射成一个不同的int。这就允许使用BitSet——一个类似的集合结构，其中每一比特都映射成不同的enum。EnumSet有两种实现，RegularEnumSet——由一个单独的long存储（能够存储64个枚举值，99.9%的情况下是够用的），JumboEnumSet——由long[]存储。 BitSet：一个比特Set。需要时常考虑用BitSet处理一组密集的整数Set（比如从一个预先知道的数字开始的id集合）。这个类用 long[]来存储bit。 LinkedHashMap：与HashSet一样，这个类基于LinkedHashMap实现。这是唯一一个保持了插入顺序的Set。 TreeSet：与HashSet类似。这个类是基于一个TreeMap实例的。这是在单线程部分唯一一个排序的Set。 java.util.Collections就像有专门的java.util.Arrays来处理数组，Java中对集合也有java.util.Collections来处理。第一组方法主要返回集合的各种数据： Collections.checkedCollection / checkedList / checkedMap / checkedSet / checkedSortedMap / checkedSortedSet：检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个ClassCastException异常。这个功能可以防止在运行的时候出错。//fixme Collections.emptyList / emptyMap / emptySet ：返回一个固定的空集合，不能添加任何元素。 Collections.singleton / singletonList / singletonMap：返回一个只有一个入口的 set/list/map 集合。 Collections.synchronizedCollection / synchronizedList / synchronizedMap / synchronizedSet / synchronizedSortedMap / synchronizedSortedSet：获得集合的线程安全版本（多线程操作时开销低但不高效，而且不支持类似put或update这样的复合操作） Collections.unmodifiableCollection / unmodifiableList / unmodifiableMap / unmodifiableSet / unmodifiableSortedMap / unmodifiableSortedSet：返回一个不可变的集合。当一个不可变对象中包含集合的时候，可以使用此方法。 第二组方法中，其中有一些方法因为某些原因没有加入到集合中： Collections.addAll：添加一些元素或者一个数组的内容到集合中。 Collections.binarySearch：和数组的Arrays.binarySearch功能相同。 Collections.disjoint：检查两个集合是不是没有相同的元素。 Collections.fill：用一个指定的值代替集合中的所有元素。 Collections.frequency：集合中有多少元素是和给定元素相同的。 Collections.indexOfSubList / lastIndexOfSubList：和String.indexOf(String) / lastIndexOf(String)方法类似——找出给定的List中第一个出现或者最后一个出现的子表。 Collections.max / min：找出基于自然顺序或者比较器排序的集合中，最大的或者最小的元素。 Collections.replaceAll：将集合中的某一元素替换成另一个元素。 Collections.reverse：颠倒排列元素在集合中的顺序。如果你要在排序之后使用这个方法的话，在列表排序时，最好使用Collections.reverseOrder比较器。 Collections.rotate：根据给定的距离旋转元素。 Collections.shuffle：随机排放List集合中的节点，可以给定你自己的生成器——例如 java.util.Random / java.util.ThreadLocalRandom or java.security.SecureRandom。 Collections.sort：将集合按照自然顺序或者给定的顺序排序。 Collections.swap：交换集合中两个元素的位置（多数开发者都是自己实现这个操作的）。 并发集合这一部分将介绍java.util.concurrent包中线程安全的集合。这些集合的一个主要特性就是保证方法的原子执行。因为并发的操作，例如add或update或者check再update，都有一次以上的调用，必须同步。因为第一步从集合中组合操作查询到的信息在开始第二步操作时可能变为无效数据。 大部分的并发集合是在Java 1.5引入的。ConcurrentSkipListMap / ConcurrentSkipListSet 和 LinkedBlockingDeque是在Java 1.6新加入的。最后加入到Java 1.7是 ConcurrentLinkedDeque 和 LinkedTransferQueue。 Lists CopyOnWriteArrayList：list的实现每一次更新都会产生一个新的隐含数组副本，所以这个操作成本很高。通常用在遍历操作比更新操作多的集合，比如listeners/observers集合。 Queues/deques ArrayBlockingQueue：基于数组实现的一个有界阻塞队，大小不能重新定义。所以当你试图向一个满的队列添加元素的时候，就会受到阻塞，直到另一个方法从队列中取出元素。 ConcurrentLinkedDeque / ConcurrentLinkedQueue：基于链表实现的无界队列，添加元素不会堵塞。但是这就要求这个集合的消费者工作速度至少要和生产这一样快，不然内存就会耗尽。严重依赖于CAS(compare-and-set)操作。 DelayQueue：无界的保存Delayed元素的集合。元素只有在延时已经过期的时候才能被取出。队列的第一个元素延期最小（包含负值——延时已经过期）。当你要实现一个延期任务的队列的时候使用（不要自己手动实现——使用ScheduledThreadPoolExecutor）。 LinkedBlockingDeque / LinkedBlockingQueue：可选择有界或者无界基于链表的实现。在队列为空或者满的情况下使用ReentrantLock-s。 LinkedTransferQueue：基于链表的无界队列。除了通常的队列操作，它还有一系列的transfer方法，可以让生产者直接给等待的消费者传递信息，这样就不用将元素存储到队列中了。这是一个基于CAS操作的无锁集合。 PriorityBlockingQueue：PriorityQueue的无界的版本。 SynchronousQueue：一个有界队列，其中没有任何内存容量。这就意味着任何插入操作必须等到响应的取出操作才能执行，反之亦反。如果不需要Queue接口的话，通过Exchanger类也能完成响应的功能。 Maps ConcurrentHashMap：get操作全并发访问，put操作可配置并发操作的哈希表。并发的级别可以通过构造函数中concurrencyLevel参数设置（默认级别16）。该参数会在Map内部划分一些分区。在put操作的时候只有只有更新的分区是锁住的。这种Map不是代替HashMap的线程安全版本——任何 get-then-put的操作都需要在外部进行同步。 ConcurrentSkipListMap：基于跳跃列表（Skip List）的ConcurrentNavigableMap实现。本质上这种集合可以当做一种TreeMap的线程安全版本来使用。 Sets ConcurrentSkipListSet：使用 ConcurrentSkipListMap来存储的线程安全的Set。 CopyOnWriteArraySet：使用CopyOnWriteArrayList来存储的线程安全的Set。 相关阅读 Java 基本类型集合库：Trove：Trove库概述——存储Java基本类型数据的集合库（与大多数JDK中的Objects类不同）。 Java常见数据类型内存占用（1）：各种类的内存占用会所名，包括enums、EnumMap、EnumSet、BitSet、ArrayList、LinkedList和ArrayDeque。 Java常见数据类型内存占用（2）：HashMap、HashSet、LinkedHashMap、LinkedHashSet、TreeMap、TreeSet和JDK 7 PriorityQueue内存占用，以及对应的Trove替代类说明。 推荐阅读如果想要了解更多关于Java集合的知识，推荐阅读以下书籍： Cay S. Horstmann. Core Java Volume I–Fundamentals (9th Edition) (Core Series) ：第13章描述了Java集合. Naftalin, Wadler. Java Generics and Collections：书的第2部分（第10章至第17章）专门讨论了Java集合。 Goetz, Peierls, Bloch, Bowbeer, Holmes, Lea. Java Concurrency in Practice：最好的Java并发书籍。第5章讨论了Java 1.5引入的并发集合。 总结 单线程 并发 Lists ArrayList——基于泛型数组LinkedList——不推荐使用Vector——已废弃（deprecated） CopyOnWriteArrayList——几乎不更新，常用来遍历 Queues / deques ArrayDeque——基于泛型数组Stack——已废弃（deprecated）PriorityQueue——读取操作的内容已排序 ArrayBlockingQueue——有界的阻塞式队列ConcurrentLinkedDeque / ConcurrentLinkedQueue——无界的链表队列（CAS）DelayQueue——元素带有延迟功能的队列LinkedBlockingDeque / LinkedBlockingQueue——链表阻塞队列，可设定是否带边界LinkedTransferQueue——可将元素transfer进行w/o存储PriorityBlockingQueue——并发PriorityQueue`SynchronousQueue——使用Queue接口进行Exchanger` Maps HashMap——通用MapEnumMap——键使用enum`Hashtable——已废弃（deprecated）IdentityHashMap——键使用==进行比较LinkedHashMap——保持插入顺序TreeMap——键已排序WeakHashMap`——适用于缓存（cache） ConcurrentHashMap——通用并发MapConcurrentSkipListMap——已排序的并发Map Sets HashSet——通用setEnumSet——enum SetBitSet——比特或密集的整数SetLinkedHashSet——保持插入顺序TreeSet——排序Set 线程创建一般来讲线程创建有四种方式: 继承Thread 实现Runnable接口 实现Callable接口，结合 FutureTask使用 利用该线程池ExecutorService、Callable、Future来实现 参考 https://my.oschina.net/u/566591/blog/1576410 https://cloud.tencent.com/developer/article/1038547 线程状态 参考： https://www.jianshu.com/p/d7c87eca472a 2.3.1、线程状态Java语言定义了5种线程状态，如下（同色块属于同一种状态）： 1、新建（New） ：创建后尚未通过start()启动的线程处于此状态。 2、可运行（Runable）：Runable包括了OS线程状态中的Running和Ready，即处于Runable状态的线程可能正在执行，也可能处于就绪状态等待分配CPU。 3、等待：此状态的线程不会被分配CPU执行时间，等待被唤醒或等待倒计时到了后自动唤醒。分为无限等待和限时等待（wait和sleep的一个区别是前者会释放对象锁后者不会）： 无限等待（Waiting）：此状态的线程不会被分配CPU执行时间，需要等待被其他线程显示唤醒。 以下方法让线程进入此状态：无时间参数的方法 obj.wait()、threadObj.join()、threadObj.join(0)、LockSupport.park() 。 限时等待（Timed Waiting）：此状态的线程也不会被分配CPU执行时间，但过一定时间后由系统自动唤醒而不用经由其他线程显示唤醒。 以下方法让线程进入此状态：有时间参数的方法 obj.wait(long timeout)、threadObj.join(long timeout)、LockSupport.parkNanos(long nanos)、LockSupport.parkUntil(long deadline)、threadObj.sleep(long timeout) 。 LockSupport的park、unpark用于挂起或恢复线程，其底层最终是调用了Unsafe类的park、unpark native方法。 4、阻塞（Blocking）：此状态的线程不会被分配CPU执行时间，在等待获取一个排它锁，在占有此锁的另一个线程释放该锁时此线程将结束阻塞。如程序等待进入同步区域时（如synchronized块）线程将进入此状态。 5、结束（tTerminated）：线程执行结束已终止，处于此状态。 2.3.2、线程状态转换详细的状态转换如下：（wait是Object的实例方法，调用时会释放持有的对象锁，其他则不会。各方法的区别可见 join、sleep、wait、notify等的区别-MarchOn） copy from：http://www.cnblogs.com/z-sm/p/7201822.html 线程优先级Java 线程优先级使用 1 ~ 10 的整数表示： 最低优先级 1：Thread.MIN_PRIORITY 最高优先级 10：Thread.MAX_PRIORITY 普通优先级 5：Thread.NORM_PRIORITY 获取设置优先级： ​ System.out.println(Thread.currentThread().getPriority()); ​ Thread.currentThread().setPriority(Thread.MIN_PRIORITY); 默认优先级： Java 默认的线程优先级是父线程的优先级，而非普通优先级Thread.NORM_PRIORITY，因为主线程默认优先级是普通优先级Thread.NORM_PRIORITY，所以如果不主动设置线程优先级，则新创建的线程的优先级就是普通优先级Thread.NORM_PRIORITY. 优先级调度： 高优先级的线程比低优先级的线程有更高的几率得到执行，实际上这和操作系统及虚拟机版本相关，有可能即使设置了线程的优先级也不会产生任何作用。 最大优先级： 我们可以设定线程组的最大优先级，当创建属于该线程组的线程时，新线程的优先级不能超过这个最大优先级 系统线程组的最大优先级默认为 Thread.MAX_PRIORITY 创建线程组时最大优先级默认为父线程组（如果未指定父线程组，则其父线程组默认为当前线程所属线程组）的最大优先级 可以通过 setPriority 更改最大优先级，但无法超过父线程组的最大优先级 copy from :https://blog.csdn.net/silent_paladin/article/details/54561496 线程InterruptException异常 当一个方法后面声明可能会抛出InterruptedException 异常时，说明该方法是可能会花一点时间，但是可以取消的方法。 抛InterruptedException的代表方法有： \1. java.lang.Object 类的 wait 方法 \2. java.lang.Thread 类的 sleep 方法 \3. java.lang.Thread 类的 join 方法 – 需要花点时间的方法 执行wait方法的线程，会进入等待区等待被notify/notify All。在等待期间，线程不会活动。 执行sleep方法的线程，会暂停执行参数内所设置的时间。 执行join方法的线程，会等待到指定的线程结束为止。 因此，上面的方法都是需要花点时间的方法。 – 可以取消的方法 因为需要花时间的操作会降低程序的响应性，所以可能会取消/中途放弃执行这个方法。 这里主要是通过interrupt方法来取消。 \1. sleep方法与interrupt方法 interrupt方法是Thread类的实例方法，在执行的时候并不需要获取Thread实例的锁定，任何线程在任何时刻，都可以通过线程实例来调用其他线程的interrupt方法。 当在sleep中的线程被调用interrupt方法时，就会放弃暂停的状态，并抛出InterruptedException异常，这样一来，线程的控制权就交给了捕捉这个异常的catch块了。 \2. wait方法和interrupt方法 当线程调用wait方法后，线程在进入等待区时，会把锁定接触。当对wait中的线程调用interrupt方法时，会先重新获取锁定，再抛出InterruptedException异常，获取锁定之前，无法抛出InterruptedException异常。 \3. join方法和interrupt方法 当线程以join方法等待其他线程结束时，一样可以使用interrupt方法取消。因为join方法不需要获取锁定，故而与sleep一样，会马上跳到catch程序块 – interrupt方法干了什么？ interrupt方法其实只是改变了中断状态而已。 而sleep、wait和join这些方法的内部会不断的检查中断状态的值，从而自己抛出InterruptEdException。 所以，如果在线程进行其他处理时，调用了它的interrupt方法，线程也不会抛出InterruptedException的，所以如果要使用该方法终止线程，那么需要while(true)来检测线程中断状态，只有当线程走到了sleep, wait, join这些方法的时候，才会抛出InterruptedException。若是没有调用sleep, wait, join这些方法，或者没有在线程里自己检查中断状态，自己抛出InterruptedException，那InterruptedException是不会抛出来的。 isInterrupted方法，可以用来检查中断状态 Thread.interrupted方法，可以用来检查并清除中断状态。 copyfrom： https://blog.csdn.net/derekjiang/article/details/4845757 https://www.ibm.com/developerworks/cn/java/j-jtp05236.html 线程取消或终止 方法一：设置某个“已请求取消”标志，任务定期检查该标志。 1234567private volatile boolean cancelled;public void run() &#123; while(!cancelled) &#123; &#125;&#125; 方法二： 中断Interrupt 123456789101112131415@overidepublic void run() &#123; try &#123; BigInteger p = BigInteger.ONE; while (!Thread.currentThread().isInterrupted()) &#123; queue.put(p = p.nextProbablePrime()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; void cancel() &#123; Thread.currentThread().interrupt();&#125; 方法三：通过Future来实现取消 方法四： 线程池关闭。 shutdown: 调用之后不允许继续往线程池内继续添加线程; 线程池的状态变为SHUTDOWN状态; 所有在调用shutdown()方法之前提交到ExecutorSrvice的任务都会执行; 一旦所有线程结束执行当前任务，ExecutorService才会真正关闭。 shutdownNow(): 该方法返回尚未执行的 task 的 List; 线程池的状态变为STOP状态; 阻止所有正在等待启动的任务, 并且停止当前正在执行的任务; awaitTermination： 调用awaitTermination设置定时任务，代码内的意思为 2s 后检测线程池内的线程是否均执行完毕（就像老师告诉学生，“最后给你 2s 钟时间把作业写完”），若没有执行完毕，则调用shutdownNow()方法。 简单点来说，就是:shutdown()调用后，不可以再 submit 新的 task，已经 submit 的将继续执行shutdownNow()调用后，试图停止当前正在执行的 task，并返回尚未执行的 task 的 list 参考：https://hacpai.com/article/1488023925829 线程间通信wait/notify join, threadlocal, inheritableThreadLocal(主线程和子线程) 管道通信就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信 https://blog.csdn.net/justloveyou_/article/details/54929949https://www.cnblogs.com/hapjin/p/5492619.htmlhttps://blog.csdn.net/u011514810/article/details/77131296 Thread Pool线程池 既然Android中线程池来自于Java，那么研究Android线程池其实也可以说是研究Java中的线程池 在Java中，线程池的概念是Executor这个接口，具体实现为ThreadPoolExecutor类，学习Java中的线程池，就可以直接学习他了 对线程池的配置，就是对ThreadPoolExecutor构造函数的参数的配置，既然这些参数这么重要，就来看看构造函数的各个参数吧。 ThreadPoolExecutor提供了四个构造函数12345678910111213141516171819202122232425262728293031//五个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)//六个参数的构造函数-1public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)//六个参数的构造函数-2public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)//七个参数的构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 我知道你看到这些构造函数和我一样也是吓呆了，但其实一共就7种类型，理解起来简直和理解一周有7天一样简单，而且一周有两天是周末，其实也就只有5天需要了解！相信我，毕竟扯皮，我比较擅长 int corePoolSize =&gt; 该线程池中核心线程数最大值 核心线程： 线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程 核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。 如果指定ThreadPoolExecutor的allowCoreThreadTimeOut这个属性为true，那么核心线程如果不干活(闲置状态)的话，超过一定时间(时长下面参数决定)，就会被销毁掉 很好理解吧，正常情况下你不干活我也养你，因为我总有用到你的时候，但有时候特殊情况(比如我自己都养不起了)，那你不干活我就要把你干掉了 int maximumPoolSize 该线程池中线程总数最大值 线程总数 = 核心线程数 + 非核心线程数。核心线程在上面解释过了，这里说下非核心线程： 不是核心线程的线程(别激动，把刀放下…)，其实在上面解释过了 long keepAliveTime 该线程池中非核心线程闲置超时时长 一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉 如果设置allowCoreThreadTimeOut = true，则会作用于核心线程 TimeUnit unit keepAliveTime的单位，TimeUnit是一个枚举类型，其包括： NANOSECONDS ： 1微毫秒 = 1微秒 / 1000 MICROSECONDS ： 1微秒 = 1毫秒 / 1000 MILLISECONDS ： 1毫秒 = 1秒 /1000 SECONDS ： 秒 MINUTES ： 分 HOURS ： 小时 DAYS ： 天 BlockingQueue workQueue 该线程池中的任务队列：维护着等待执行的Runnable对象 当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务 常用的workQueue类型： SynchronousQueue：这个队列接收到任务的时候，会直接提交给线程处理，而不保留它，如果所有线程都在工作怎么办？那就新建一个线程来处理这个任务！所以为了保证不出现&lt;线程数达到了maximumPoolSize而不能新建线程&gt;的错误，使用这个类型队列的时候，maximumPoolSize一般指定成Integer.MAX_VALUE，即无限大 LinkedBlockingQueue：这个队列接收到任务的时候，如果当前线程数小于核心线程数，则新建线程(核心线程)处理任务；如果当前线程数等于核心线程数，则进入队列等待。由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize ArrayBlockingQueue：可以限定队列的长度，接收到任务的时候，如果没有达到corePoolSize的值，则新建线程(核心线程)执行任务，如果达到了，则入队等候，如果队列已满，则新建线程(非核心线程)执行任务，又如果总线程数到了maximumPoolSize，并且队列也满了，则发生错误 DelayQueue：队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务 ThreadFactory threadFactory 创建线程的方式，这是一个接口，你new他的时候需要实现他的Thread newThread(Runnable r)方法，一般用不上，这是星期六，休息 但我还是说一句吧(把枪放下…) 小伙伴应该知道AsyncTask是对线程池的封装吧？那就直接放一个AsyncTask新建线程池的threadFactory参数源码吧： 12345678&gt; new ThreadFactory() &#123;&gt; private final AtomicInteger mCount = new AtomicInteger(1);&gt; &gt; public Thread new Thread(Runnable r) &#123;&gt; return new Thread(r,&quot;AsyncTask #&quot; + mCount.getAndIncrement());&gt; &#125;&gt; &#125;&gt; 这么简单？就给线程起了个名？！对啊，所以说这是星期六啊，别管他了，虽然我已经强迫你们看完了… RejectedExecutionHandler handler 这玩意儿就是抛出异常专用的，比如上面提到的两个错误发生了，就会由这个handler抛出异常，你不指定他也有个默认的 抛异常能抛出什么花样来？所以这个星期天不管了，一边去，根本用不上 新建一个线程池的时候，一般只用5个参数的构造函数。 向ThreadPoolExecutor添加任务那说了这么多，你可能有疑惑，我知道new一个ThreadPoolExecutor，大概知道各个参数是干嘛的，可是我new完了，怎么向线程池提交一个要执行的任务啊？ 通过ThreadPoolExecutor.execute(Runnable command)方法即可向线程池内添加一个任务 ThreadPoolExecutor的策略上面介绍参数的时候其实已经说到了ThreadPoolExecutor执行的策略，这里给总结一下，当一个任务被添加进线程池时： 线程数量未达到corePoolSize，则新建一个线程(核心线程)执行任务 线程数量达到了corePools，则将任务移入队列等待 队列已满，新建线程(非核心线程)执行任务 队列已满，总线程数又达到了maximumPoolSize，就会由上面那位星期天(RejectedExecutionHandler)抛出异常 常见四种线程池如果你不想自己写一个线程池，那么你可以从下面看看有没有符合你要求的(一般都够用了)，如果有，那么很好你直接用就行了，如果没有，那你就老老实实自己去写一个吧 Java通过Executors提供了四种线程池，这四种线程池都是直接或间接配置ThreadPoolExecutor的参数实现的，下面我都会贴出这四种线程池构造函数的源码，各位大佬们一看便知！ 来，走起： CachedThreadPool()可缓存线程池： 线程数无限制 有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销 创建方法： ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); 源码： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 通过我上面行云流水谈笑风生天马行空滔滔不绝的对各种参数的说明，这个源码你肯定一眼就看懂了，想都不用想(下面三种一样啦) FixedThreadPool()定长线程池： 可控制线程最大并发数（同时执行的线程数） 超出的线程会在队列中等待 创建方法： 12345//nThreads =&gt; 最大线程数即maximumPoolSizeExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads);//threadFactory =&gt; 创建线程的方法，这就是我叫你别理他的那个星期六！你还看！ExecutorService fixedThreadPool = Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory); 源码： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 2个参数的构造方法源码，不用我贴你也知道他把星期六放在了哪个位置！所以我就不贴了，省下篇幅给我扯皮 ScheduledThreadPool()定长线程池： 支持定时及周期性任务执行。 创建方法： 12//nThreads =&gt; 最大线程数即maximumPoolSizeExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(int corePoolSize); 源码： 12345678910public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;//ScheduledThreadPoolExecutor():public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue());&#125; SingleThreadExecutor()单线程化的线程池： 有且仅有一个工作线程执行任务 所有任务按照指定顺序执行，即遵循队列的入队出队规则 创建方法： ExecutorService singleThreadPool = Executors.newSingleThreadPool(); 源码： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 还有一个Executors.newSingleThreadScheduledExecutor()结合了3和4，就不介绍了，基本不用。 copy from : https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/ 并发控制策略（Concurrency Strategies）以对tree的并发读写为例： 1、lock-free solution copy-on-write：确定要write的node后copy该node并对copied node做write操作，然后以原子更新方式替换原node。最多允许一个write和多个read同时access a tree，因为多个write同时写同一node时最后一个write操作会覆盖其他write操作。 test-and-set、compare-and-swap等原子操作，由硬件指令提供原子保证。 2、lock-based solution coarse-grained lock：以tree为粒度进行加锁 mutex lock：排它锁，如synchronized。write和read都加锁，最多允许一个write或一个read access a tree。 read-write lock：读写锁，如ReentrantReadWrite lock。write和read都加锁，最多允许一个write或多个read access a tree。 fine-grained lock：以tree node为粒度进行加锁。可采用排它锁或读写锁。write和read都加锁，最多允许一个write access a node，此时该node能否被read access视采用的锁而定。 hand-over-hand lock：必须先锁住父节点才能锁住子节点，然后释放父节点锁并获取子节点的子节点的锁，以此方式从上到下直到锁住要write的节点。被锁节点的子树无法被其他write access，即使write的是a different node。 optimistic lock：先找到要write的node，然后对node的父node加锁，再对该node加锁。允许其他write access被锁节点的子树。 hybrid solution：综合copy-on-write和fine-grained-lock，write加锁（对被加锁加点采用copy-on-write方式进行write）、read不加锁，最多允许多个write和多个read access a node。 总结： Java的线程安全实现Java中的并发正确性保障手段主要有以下几类。 1、阻塞同步（互斥同步）：悲观并发策略、重量级锁。认为共享数据一定存在访问竞争而总进行加锁。 同步和互斥的区别：同步是指多线程并发访问共享数据时，保证共享数据同一时刻只被一个（或一些，使用信号量时）线程使用 。互斥是实现同步的手段，实现方式包括临界区、互斥量、信号量等。 Java中的互斥同步手段：有synchronized、java.util.concurrent.locks.ReentrantLock（重入锁）等。都是互斥锁，区别：前者是Java语言本身提供的；后者则不是，而是类库实现。后者增加了 等待可中断、可实现公平锁、锁可绑定多个条件 3个功能。JDK1.6后两者性能持平，优先使用synchronized。 优缺点：使用范围广。总进行加锁、线程阻塞唤醒需要用户态核心态转换、维护锁计数器等操作，特别是阻塞增加了性能消耗。互斥同步对性能最大的影响是阻塞的实现，挂起和恢复线程的操作都需要转内内核完成，频繁切换影响OS并发性能。 2、非阻塞同步：乐观并发策略、轻量级锁。先操作，检测到冲突时再补偿，硬件指令保证 操作和检测 两组合步骤的原子性。不是为了替代重量级锁，而是在没有多线程竞争时减少传统的重量级锁使用OS互斥量带来的性能消耗。 基于冲突检测：先进行操作，若没有其他线程争用共享数据则操作成功，否则进行冲突补偿措施如重试。有Test-and-Set、Fetch-and-Increment、Swqp、Compare-and-Swap、Load-Linked/Store-Conditional等。以Test-and-Set为例： Java中的非阻塞同步手段：JDK1.5起提供的CAS操作——sun.misc.Unsafe类的compareAndSwapInt()、compareAndSwapLong()等方法。借助之，可以原子更新基本数据类型、原子更新引用类型、原子更新数组元素、原子更新属性值（详见Java并发包中的原子操作类）。CAS操作可以认为就是一种自旋锁。 优缺点：性能较高，不用挂起线程。存在ABA问题（可改用互斥同步解决、也可加时间戳解决）、不可重入。 3、非同步方案：保证线程安全并不一定要同步，不涉及共享数据的方法本身就是线程安全的，有很多，如： 可重入代码：不依赖存储在堆上的数据和共用的系统资源、用到的状态量都由参数传入、不调用field可重入方法等的代码。判断可重入的原则：若一个方法的返回结果是可预测的，只要输入相同数据就能返回相同结果，则是可重入的。 线程本地存储：把共享数据的可见范围限定在本线程内达到线程安全。如java.lang.ThreadLocal类，原理：每个线程都有一个Map，类型为ThreadLocalMap，Map的key为ThreadLocal变量的hash值，Value为本线程设置的该ThreadLocal变量的值。 thread local每个线程维护一个ThreadLocal.ThreadLocalMap threadLocals = null;线程私有变量来实现，当调用set方法如下： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;复制代码 set(T value) 方法中，首先获取当前线程，然后在获取到当前线程的 ThreadLocalMap，如果 ThreadLocalMap 不为 null，则将 value 保存到 ThreadLocalMap 中，并用当前 ThreadLocal 作为 key；否则创建一个 ThreadLocalMap 并给到当前线程，然后保存 value。 ThreadLocalMap 相当于一个 HashMap，是真正保存值的地方。 https://juejin.im/post/5965ef1ff265da6c40737292 lock和lockInterruptlylock方法会忽略中断请求，继续获取锁直到成功；而lockInterruptibly则直接抛出中断异常来立即响应中断，由上层调用者处理中断https://blog.csdn.net/wojiushiwo945you/article/details/42387091 thread.join = object.wait() = condition.await()均会释放锁。均需要一个锁互斥变量控制。join默认thread对象锁，object对象锁，condition归属的lock锁。thead.sleep()不释放锁最好使用循环判断条件包围wait操作。wait/await操作均会被打断 Timer的操作TimerTask进入Timer后是需要排队执行的。new Timer(true)那么当附属线程结束后，这个timer也会被销毁。 readResolve方法和序列化https://blog.csdn.net/haydenwang8287/article/details/5964130]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>thread</tag>
        <tag>lock</tag>
        <tag>synchronize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jvm class结构和加载原理]]></title>
    <url>%2Fposts%2Fjvm_art_class_load.html</url>
    <content type="text"><![CDATA[Class类文件结构ClassFile结构一个Class类文件是由一个ClassFile结构组成： 123456789101112131415161718ClassFile &#123; u4 magic; //魔数，固定值0xCAFEBABE u2 minor_version; //次版本号 u2 major_version; //主版本号 u2 constant_pool_count; //常量的个数 cp_info constant_pool[constant_pool_count-1]; //具体的常量池内容 u2 access_flags; //访问标识 u2 this_class; //当前类索引 u2 super_class; //父类索引 u2 interfaces_count; //接口的个数 u2 interfaces[interfaces_count]; //具体的接口内容 u2 fields_count; //字段的个数 field_info fields[fields_count]; //具体的字段内容 u2 methods_count; //方法的个数 method_info methods[methods_count]; //具体的方法内容 u2 attributes_count; //属性的个数 attribute_info attributes[attributes_count]; //具体的属性内容&#125; 一个Class文件的大小：26 + cp_info[] + u2[] + field_info[] + method_info[] + attribute_info[] ClassFile文件组成3.1 魔数每个Class文件头4个字节称为魔数(Magic Number),作用是用于确定这个Class文件是否能被虚拟机所接受，魔数固定值0xCAFEBABE。这是身份识别，比如jpeg等图片文件头也会有魔数。 3.2 版本号紧跟魔数，也占用4个字节。从第5字节到第8字节存储的分别是 次版本号，主版本号。 3.3 常量池常量池是Class文件空间最大的数据项之一，长度不固定。 a. 常量池长度 用u2类型代表常量池容量计数值，u2紧跟版本号。u2的大小等于常量池的常量个数+1。对于u2=0的特殊情况，代表没有使用常量池。 b. 常量池内容,格式如下： 1234cp_info &#123; u1 tag; u1 info[];&#125; 包括两个类常量，字面量和符号引用： 字面量：与Java语言层面的常量概念相近，包含文本字符串、声明为final的常量值等。 符号引用：编译语言层面的概念，包括以下3类： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 常量池中每一项常量都是一个表结构，每个表的开始第一位是u1类型的标志位tag, 代表当前这个常量的类型。在JDK 1.7.中共有14种不同的表结构的类型，如下： Class文件都是二进制格式，可通过Jdk/bin/javap.exe工具，分析Class文件字节码。关于javap用法，可通过javap --help来查看。 3.4访问标识2个字节代表，标示用于识别一些类或者接口层次的访问信息. 标识名 标识值 解释 ACC_PUBLIC 0x0001 声明为public;可以从包外部访问 ACC_FINAL 0x0010 被声明为final;不允许子类修改 ACC_SUPER 0x0020 当被invokespecial指令调用时，将特殊对待父类的方法 ACC_INTERFACE 0x0200 接口标识符 ACC_ABSTRACT 0x0400 声明为abstract;不能被实例化 ACC_SYNTHETIC 0x1000 声明为synthetic;不存在于源代码，由编译器生成 ACC_ANNOTATION 0x2000 声明为注释类型 ACC_ENUM 0x4000 声明为枚举类型 3.5 类/父类索引当前类索引和父类索引占用大小都为u2类型，由于一个类智能继承一个父类，故父类索引只有一个。除了java.lang.Object对象的父类索引为0，其他所有类都有父类。 3.6 接口索引一个类可以实现多个接口，故利用interfaces_count来记录该类所实现的接口个数，interfaces[interfaces_count]来记录所有实现的接口内容。 3.7 字段表字段表用于描述类或接口中声明的变量，格式如下： 1234567field_info &#123; u2 access_flags; //访问标识 u2 name_index; //名称索引 u2 descriptor_index; //描述符索引 u2 attributes_count; //属性个数 attribute_info attributes[attributes_count]; //属性表的具体内容&#125; 字段访问标识如下：(表中加粗项是字段独有的) 标识名 标识值 解释 ACC_PUBLIC 0x0001 声明为 public; 可以从包外部访问 ACC_PRIVATE 0x0002 声明为 private; 只有定义的类可以访问 ACC_PROTECTED 0x0004 声明为 protected;只有子类和相同package的类可访问 ACC_STATIC 0x0008 声明为 static；属于类变量 ACC_FINAL 0x0010 声明为 final; 对象构造后无法直接修改值 ACC_VOLATILE 0x0040 声明为 volatile; 不会被缓存,直接刷新到主屏幕 ACC_TRANSIENT 0x0080 声明为 transient; 不能被序列化 ACC_SYNTHETIC 0x1000 声明为 synthetic; 不存在于源代码，由编译器生成 ACC_ENUM 0x4000 声明为enum Java语法中，接口中的字段默认包含ACC_PUBLIC, ACC_STATIC, ACC_FINAL标识。ACC_FINAL，ACC_VOLATILE不能同时选择等规则。 紧跟其后的name_index和descriptor_index是对常量池的引用，分别代表着字段的简单名和方法的描述符。 3.8方法表方法表用于描述类或接口中声明的方法，格式如下： 1234567method_info &#123; u2 access_flags; //访问标识 u2 name_index; //名称索引 u2 descriptor_index; //描述符索引 u2 attributes_count; //属性个数 attribute_info attributes[attributes_count]; //属性表的具体内容&#125; 方法访问标识如下：(表中加粗项是方法独有的) 标识名 标识值 解释 ACC_PUBLIC 0x0001 声明为 public; 可以从包外部访问 ACC_PRIVATE 0x0002 声明为 private; 只有定义的类可以访问 ACC_PROTECTED 0x0004 声明为 protected;只有子类和相同package的类可访问 ACC_STATIC 0x0008 声明为 static；属于类变量 ACC_FINAL 0x0010 声明为 final; 不能被覆写 ACC_SYNCHRONIZED 0x0020 声明为 synchronized; 同步锁包裹 ACC_BRIDGE 0x0040 桥接方法, 由编译器生成 ACC_VARARGS 0x0080 声明为 接收不定长参数 ACC_NATIVE 0x0100 声明为 native; 由非Java语言来实现 ACC_ABSTRACT 0x0400 声明为 abstract; 没有提供实现 ACC_STRICT 0x0800 声明为 strictfp; 浮点模式是FP-strict ACC_SYNTHETIC 0x1000 声明为 synthetic; 不存在于源代码，由编译器生成 对于方法里的Java代码，进过编译器编译成字节码指令后，存放在方法属性表集合中“code”的属性内。 当子类没有覆写父类方法，则方法集合中不会出现父类的方法信息。 Java语言中重载方法，必须与原方法同名，且特征签名不同。特征签名是指方法中各个参数在常量池的字段符号引用的集合，不包括返回值。当时Class文件格式中，特征签名范围更广，允许方法名和特征签名都相同，但返回值不同的方法，合法地共存子啊同一个Class文件中。 3.9 属性表属性表格式： 12345attribute_info &#123; u2 attribute_name_index; //属性名索引 u4 attribute_length; //属性长度 u1 info[attribute_length]; //属性的具体内容&#125; 属性表的限制相对宽松，不需要各个属性表有严格的顺序，只有不与已有的属性名重复，任何自定义的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机运行时会忽略掉无法识别的属性。 关于虚拟机规范中预定义的属性，这里不展开讲了，列举几个常用的。 属性名 使用位置 解释 Code 方法表 方法体的内容 ConstantValue 字段表 final关键字定义的常量值 Deprecated 类、方法表、字段表 声明为deprecated InnerClasses 类文件 内部类的列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 Signature 类、方法表、字段表 用于支持泛型的方法签名，由于Java的泛型采用擦除法，避免类型信息被擦除后导致签名混乱，Signature记录相关信息 Code属性 java程序方法体中的代码，经编译后得到的字节码指令存储在Code属性内，Code属性位于方法表的属性集合中。但与native或者abstract的方法则不会存在Code属性中。 Code属性的格式如下： 12345678910111213141516Code_attribute &#123; u2 attribute_name_index; //常量池中的uft8类型的索引，值固定为”Code“ u4 attribute_length; //属性值长度，为整个属性表长度-6 u2 max_stack; //操作数栈的最大深度值，jvm运行时根据该值佩服栈帧 u2 max_locals; //局部变量表最大存储空间，单位是slot u4 code_length; // 字节码指令的个数 u1 code[code_length]; // 具体的字节码指令 u2 exception_table_length; //异常的个数 &#123; u2 start_pc; u2 end_pc; u2 handler_pc; //当字节码在[start_pc, end_pc)区间出现catch_type或子类，则转到handler_pc行继续处理。 u2 catch_type; //当catch_type=0，则任意异常都需转到handler_pc处理 &#125; exception_table[exception_table_length]; //具体的异常内容 u2 attributes_count; //属性的个数 attribute_info attributes[attributes_count]; //具体的属性内容&#125; slot是虚拟机未局部变量分配内存使用的最小单位。对于byte/char/float/int/short/boolean/returnAddress等长度不超过32位的局部变量，每个占用1个Slot；对于long和double这两种64位的数据类型则需要2个Slot来存放。 实例方法中有隐藏参数this, 显式异常处理器的参数，方法体定义的局部变量都使用局部变量表来存放。 max_locals，不是所有局部变量所占Slot之和，因为Slot可以重用，javac编译器会根据变量的作用域来分配Slot给各个变量使用，从而计算出max_locals大小。 虚拟机规范限制严格方法不允许超过65535个字节码，否则拒绝编译。 Code属性是Class文件中最重要的属性，Java程序的幸福课分为代码(方法体中的Java代码)和元数据(包含类、接口、字段、方法定义以及其他信息)两部分。 ConstantValue属性 ConstantValue属性是指被static关键字修饰的变量（也称为类变量）。 类变量: 在类构造器方法或者使用ConstantValue属性来赋值 实例变量：在实例构造器方法进行赋值 参考: http://gityuan.com/2015/10/17/jvm-class-instruction/ https://www.cnblogs.com/avivahe/p/5747113.html 类加载时机 类从加载到虚拟机内存~卸载出内存的生命周期(这些阶段通常是交叉混合进行的): 加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化 –&gt; 使用 –&gt; 卸载 主动引用五种必须立即对类进行初始化的情况: 遇到new(new实例化对象),getstatic,putstatic(读取/修改类属性,final除外)或invokestatic(调用静态方法)这4条字节码指令时 使用java.lang.reflect包的方法对类进行反射调用时 初始化某个类,发现其父类未初始化时(对父类立即初始化) 虚拟机启动时用户指定的执行主类(包含main()的) JDK1.7动态语言支持的情况(略) 除上述五种场景外所有的方式都不会触发初始化,称为被动引用: 通过子类引用父类的类属性,不会触发子类初始化: 对于静态字段,只有直接定义这个字段的类才会被初始化.通过子类引用父类中定义的类属性,只会触发父类的初始化. 通过类数组定义来引用类,不会触发此类的初始化(SuperClass[] a=new SuperClass[10]): 类数组是由虚拟机自动生成,直接继承于Object的子类,只会触发[SuperClass的初始化. 使用某一类的常量不会触发该定义类的初始化: 在编译阶段已经将该定义类(定义该常量的类)的常量存储到了调用类(调用此常量的类)的常量池中,以后的每一次引用实际上都转化为调用类对自身常量池的引用. 一个接口在初始化时,并不要求父接口也全初始化,只有真正使用父接口(如引用接口常量)才会初始化. 类加载过程加载、验证、准备、解析、初始化。 加载: 根据全限定名来获取定义类的二进制字节流,然后将该字节流所代表的静态结构转化为方法区的运行时数据结构,最后在生成一个代表该类的Class对象,作为方法区这些数据的访问入口. 验证:主要时为了确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.包含四个阶段的验证过程: 文件格式验证:保证输入的字节流能够正确地解析并存储在方法区之内,格式上符合描述一个java类型信息的要求 元数据验证:字节码语义信息的验证,以保证描述的信息符合java语言规范.验证点有:这个类是否有父类等. 字节码验证:主要是进行数据流和控制流分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为. 符号引用验证:对符号引用转化为直接引用过程的验证. 准备:为类变量分配内存并设置变量的初始值, 这些内存在方法区进行分配. 解析:将虚拟机常量池中的符号引用转化为直接引用的过程.解析主要是针对类或接口、字段、类方法、类接口方法四类. 初始化:执行静态变量的赋值操作以及静态代码块,完成初识化.初始化过程保证了父类中定义的初始化优先于子类的初始化.但接口不需要执行父类的初始化. 加载: 加载过程: 通过类的权限定名获取类的二进制字节流. 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构. 在内存中生成代表这个类的Class对象,作为这个类在方法区的各种数据的访问入口. 数组类本身不通过类加载器创建,而是由Java虚拟机直接创建的. 一个数组类的创建遵循以下规则: 若数组的组件类型是引用类型,则遵循上述加载过程加载这个类型.这个数组将在加载该组件类型的加载器的类名称空间上被标识. 若数组的组件类型为基本类型,则虚拟机把数组标记为与启动类加载器关联. 数组可见性与组件类型可见性一致,基本类型默认为public. 加载与连接交叉进行(开始时间固定先后). 验证:目的:确保Class文件的字节流中的信息符合当前虚拟机要求,不会危害虚拟机安全. 验证的四个阶段: 文件格式验证: 12345678验证字节流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理: a.是否以魔数0xCAFEBABY开头. b.主次版本号是否在当前虚拟机处理范围之内. c.是否支持常量池中的常量类型(检查常量tag标志). d.指向常量的各种索引值是否存在且符合类型. e.CONSTANT_Utf8_info型的常量中是否符合UTF8编码. f.Class文件中各个部分及文件本身是否有被删除或附加的信息. ... 元数据验证: 123456对字节码描述的信息进行语义分析,保证其描述的信息符合Java语言规范的要求: a.是否有父类(除Object外都须有父类). b.是否继承了不允许被继承的类(final). c.如果不是抽象类,是否实现了父类或接口中的所有方法. d.类中字段,方法是否与父类产生矛盾 ... 字节码验证: 12345通过数据流和控制流分析,确定程序语义是合法符合逻辑的(最复杂的部分): a.保证操作数栈的数据类型与指令代码序列都能配合工作. b.保证跳转指令不会跳到方法体之外的字节码. c.保证方法体中的类型转换是有效的. .... 符号引用验证: 12345对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验.发生在虚拟机将符号引用转化为直接引用的时候(在解析阶段发生): a.符号引用中通过字符串描述的权限定名是否能够找到对应类. b.指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段. c.符号引用中的类,字段,方法的访问性是否可被当前类访问. ... 通过-Xverify:none参数可关闭大部分类的验证措施,缩短加载时间. 准备:正式为类分配内存并设置类变量初始值(数据类型的零值)的阶段,这些变量所使用的内存都将在方法区中进行分配.这时候进行内存分配的仅包括类变量(static修饰的静态变量),而不包括实例变量(实例变量将在对象实例化时随着对象一起分配在Java堆上). 特殊情况: 如果是被final修饰,则一开始就初始化为其指定的值. 解析:虚拟机将常量池内的符号引用替换为直接引用的过程. 符号引用: 以一组符号来描述所引用的目标,符号可以是任何形式的字面量,能无歧义地定位到目标(未必在内存中).(与虚拟机实现的内存布局无关) 直接引用: 可以是直接指向目标的指针,相对偏移量或是一个能间接定位到目标的句柄.(和虚拟机实现的内存布局相关) 解析动作: 类或接口解析: 字段解析 类方法解析 接口方法解析 (下面三种与动态语言相关) 方法类型解析 方法句柄解析 调用点限定符解析 初始化:初始化阶段是根据程序员在程序中制定的主观计划区初始化类变量和其他资源,即执行类构造器()方法的过程. 执行过程的特点和细节: ()是由编译器自动收集类中所有类变量的赋值动作和静态语句块(static{})中的语句合并并而成的. 编译器收集的顺序是由语句在源文件中出现的顺序所决定的 注:静态语句块只能访问到定义静态语句块之前的变量;无法访问在它之后的变量,但却可以赋值. 1234567public class Test&#123; static&#123; i = 0; //赋值语句正常编译通过 System.out.println(i); //编译器会提示非法向前引用 &#125; static int i = 1;&#125; 虚拟机会保证在子类()方法执行之前,父类的()方法已经执行完毕. 由于父类的()先执行,则意味着父类的静态语句块要优先于子类的变量赋值操作. ()对于类或接口来说并不是必需的,若没有静态语句块,也没有类变量赋值操作,则可以不生成 ()方法. 接口与类不同,执行接口的方法不需要先执行父接口的()方法.只有使用到父接口中的 类变量时,父接口才会初始化(接口实现类初始化也不会执行接口的()方法). 虚拟机会保证一个类的()方法在多线程的情况下能被正确的加锁,同步(如果()中有 耗时很长的操作,可能导致多个线程阻塞). 类加载器 通过一个类的权限定名来获取描述此类的二进制字节流. 类与类加载器: 类与加载它的类加载器一起确立这个类在虚拟机中的唯一性. (来源于同一个class文件的两个类,被同一个虚拟机加载,只要加载的类加载器不同,那这两个类必定不相等) 双亲委派模型: Java虚拟机的角度存在两种类加载器: 启动类加载器Bootstrap ClassLoader(C++实现,虚拟机的一部分). 其他类加载器(Java语言实现,继承抽象类ClassLoader) 开发人员角度存在四种类加载器: 启动类加载器Bootstrap ClassLoader: 加载&lt;JAVA_HOME&gt;\lib目录下,或者被-Xbootclasspath参数指定的路径下的能被虚拟机识别的类库. 扩展类加载器Extension CLassLoader: 加载&lt;JAVA_HOME&gt;\lib\ext目录下,或者被java.ext.dirs变量指定的路径下的类库. 应用程序类加载器Application ClassLoader(默认类加载器): 一般也称为系统类加载器.加载用户类路径(ClassPath)上所指定的类库. 自定义类加载器 双亲委派模型工作流程: 一个类加载器收到类加载请求,先把请求委派给父类加载器,因此所有的请求都会传递到顶层的启动类加载器中. 当父类加载器反馈自己无法完成这个加载请求(它的搜索范围内找不到这个类)时,子加载器才会尝试自己去加载. 优点: Java类随着类加载器一起具备了一中带有优先级的层次关系.保证了Java类型体系中的基础行为(唯一性). 打破双亲委派模型: Tomcat 自定义了一套双亲委派模型,当应用使用Spring管理对象时,必然会打破双亲委派模型: Spring使用线程上下文下载器委托下层加载器加载对象。 为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。 Dubbo的SPI也是采用这种机制实现。 参考： https://github.com/wususu/Notes/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md https://blog.csdn.net/ns_code/article/details/17881581 双亲委派模型除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器.顺序依次是: Bootstrap ClassLoader: 启动类加载器,加载java_home/lib中的类 Extension ClassLoader: 扩展类加载器,加载java_home/lib/ext目录下的类库 Application ClassLoader: 应用程序类加载器,加载用户类路径上指定类库. 双亲委派模型的工作原理是:如果一个类加载器受到了类加载请求,它首先不会自己去尝试加载这个类,而把这个请求委派给父类加载器去完成,每一层次的类加载器都是如此,因此所有的加载请求最终都应该传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成加载请求时,加载器才尝试自己加载.这种方式保证了Oject类(JDK 核心类)在各个加载器加载环境中都是同一个类. 双亲委派破坏https://blog.csdn.net/zhangcanyan/article/details/78993959 双亲委派模型的式作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完全这个加载请求时，子加载器才会尝试自己去加载。 双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前————即 JDK 1.2 发布之前。 JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。 双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的。如果基础类又要调用回用户的代码，那该怎么办？ 为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认是应用类加载器。 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（ OSGi 中称为 Bundle） 都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。 在 Java 程序员中基本有一个共识： OSGi 中对类加载器的使用是很值得学习的，弄懂了 OSGi 的实现，就可以算是掌握了类加载器的精髓。 编译期优化javac对代码的运行效率几乎没有任何优化措施（JDK1.3之后-O优化参数没有意义了），性能优化主要集中在运行期（后端的即时编译期），javac主要进行了一些针对Java语言编码过程的优化，如语法糖。 编译过程编译过程大概分为3个过程：javac中的代码是这样的： 解析与填充符号表过程：首先进行词法、语法分析，将源代码的字符流转换为Token集合，然后根据Token序列构造抽象语法树AST，对应parseFiles()方法；然后填充符号表（记录符号地址和符号信息映射关系），符号表中记录的信息在编译的不同阶段都会用到，对应enterTress()方法； 插入式注解处理器的注解处理过程：处理代码中的注解，这个过程中可能影响到语法树的元素，如果影响到了，则要重新回到解析及填充符号表的过程，这样一个循环称作一个Round，直到注解处理器没有对语法树进行修改； 分析与字节码生成过程：具体又分为标注检查（检查变量使用前是否已生命、变量与赋值之间类型是否匹配等问题，以及常量折叠，如”1”+”2”优化为”12”）、数据及控制流分析（检查局部变量使用前是否赋值、每条路径是否都有返回值、异常是否都处理了等问题）、解语法糖（由desugar()方法完成）、字节码生成（收敛生成()方法he ()方法，将所有生成的信息转换成字节码写入磁盘）等子过程。 语法糖泛型Java的泛型是伪泛型，只在源码中存在，编译时进行类型擦除变成原生类型（Raw Type），并在调用的地方加上强转类型代码，这是为了兼容旧版本。对于重载方法，如果泛型参数的泛型类型不同而其他参数以及返回类型相同，是不允许重载的，比如以下方法1和方法2不能重载；而如果泛型参数的泛型类型不同，且返回类型不同，则可以重载，比如方法1和方法3（JVM本来就允许）。 1//方法1和方法2不能重载，方法1和方法3可以重载//方法1public String test(List&lt;Integer&gt;);//方法2public String test(List&lt;String&gt;);//方法3public int test(List&lt;String&gt;); 自动装箱/拆箱、遍历循环、变长参数遍历循环（增强for）的实现是编译时还原为迭代其的实现，因此需要实现Iterable接口。 条件编译java的条件编译通过条件为常量的if语句实现。如下面代码中，编译后的字节码不会包含调用B()方法的指令。 1if(true)&#123; A();&#125; else &#123; B();&#125; 运行期优化解释器与编译器许多主流商用JVM包括HotSpot采用解释器与编译器并存的结构，启动的时候使用解释器，保证启动速度，随着运行时间推移，编译器发挥作用，编译为本地代码，提高执行效率。在JVM中这种模式被称为混合模式，可以用-Xint强制JVM运行于解释模式，或用-Xcomp强制JVM运行于编译模式。HotSpot包含两个及时编译器Client Compiler和Server Compiler，一般简称为C1和C2。 热点探测运行过程中被即时编译器编译的热点代码包括被多次调用的方法或#循环体，对于后者编译器还是会以整个方法作为编译对象。判断方法或循环体是否热点代码的行为被称为热点探测，目前主要的热点探测方法有两种： 基于采样的热点探测。JVM周期性的检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那么就是热点方法。缺点是容易收到线程阻塞或其他外界因素影响，优点是简单高效； 基于计数器的热点探测。为每个方法甚至代码块建立计数器，统计执行次数，超过一定阈值就认为是热点方法。缺点是不能获取导方法的调用关系，优点是精确且严谨。 HotSpot使用第二种，准备了方法调用计数器和回边计数器。前者统计方法被调用的次数，默认的阈值：Client模式1500次，Server模式10000次，可以通过-XX:CompileThreshold来设定；后者统计循环体被执行的次数，字节码遇到控制流向后跳转的指令称为回边(Back Edge)，通过-XX:BackEdgeThreshold来手动设置阈值。对于方法调用计数器，一个方法执行时先判断存不存在JIT编译过的版本，存在的话执行编译后版本，不存在的话计数器加一，再判断是否超过阈值，超过的话向即时编译器提交编译申请。其统计的并不是方法被调用的绝对次数，而是一段时间内的调用次数，如果超过一定时间计数器仍不足阈值，则计数值会减少一半，这被成为热度衰减(Counter Decay)，这段时间被称为半衰期。热度衰减的动作时在GC时顺便进行的。回边计数器没有计数热度衰减的过程，记录循环体被调用的绝对次数。默认配置下，编译是在后台的编译线程进行的，除非用-XX:-BackgroundCompilation来禁止后台编译，这样提交编译请求的线程会一直等待编译完成。 编译优化技术JVM几乎所有的优化措施都集中在及时编译器中。 方法内联方法内联（Method Inlining）指的是将调用的方法代码替换掉调用者的调用语句。目的： 取出调用方法的成本，如建立栈帧； 为其他优化建立良好基础，比如内联可以发现更多的无用代码。 考虑到多态，方法内联的实现并不简单，在编译器无法得出调用的方法是哪个版本的结论（父类还是子类），需要在运行期确定。JVM引入了类型继承关系分析（Class Hierarchy Analysis，CHA）技术，用于确定目前加载的类中某个接口是否有多于一种的实现、某类是否存在子类、子类是否抽象等信息。进行内联时： 如果目标方法是非虚方法（私有方法、实力构造器、父类方法、静态方法等），那么直接进行内联； 对于虚方法，向CHA查询该方法是否有多个版本可选，如果只有一个版本，则直接进行内联，此时属于激进优化，需要预留逃生门（守护内联），此后如果JVM没有加载到改变方法接受者的继承关系的类，则可以继续使用内联优化的版本，否则抛弃已编译的代码、退回到解释状态进行或重新编译； 如果虚方法有多个版本，则尝试内联缓存（Inline Cache）。发生方法调用前，内联缓存状态为空；第一次调用后，缓存记录下方法接受者的版本信息，每次进行方法调用的时候都比较接受者版本，如果方法接受者版本一样，则继续调用内联缓存进行内联，否则取消内联。 冗余访问消除冗余访问消除（Redundant Loads Elimination）指的是如果能保证一个方法的两次调用之间的代码不会引起其返回值的更改，那么这第二次调用的结果可以直接用第一次调用结果去赋值，比如一下代码： 1public void foo1()&#123; y=b.value; //其他调用，不会影响b.value的返回值 z=b.value();&#125; 以上代码可以优化为： 1public void foo1()&#123; y=b.value; //其他调用，不会影响b.value的返回值 z=y;&#125; 复写传播复写传播（Copy Propagation）指的是去掉重复的变量。 无用代码消除无用代码消除（Dead Code Elimination），无用代码指的是永远不会izhixing的代码，或者完全没有意义的代码。 公共子表达式消除Common Subexpression Elimination定义：一个表达式E已经计算过，且计算后到现在E的变量全部没有变化，那么E这次出现成为了公共子表达式，无需重复计算，直接用前面计算结果替换即可。如果消除优化仅限于程序基本块内，则成为局部公共子表达式消除，如果覆盖范围涵盖多个基本块，则成为全局公共子表达式消除。 数组边界检查消除Java访问数组元素时，会对下标进行上下界范围检查，不满足上下界时会抛出ArrayIndexOutOfBoundsException异常。编译器根据数据流分析确定数组长度，并判断小表有无月结；在循环中进行数组访问时，也是可以通过数据流分析判定循环变量的取值是否越界，如果能保证循环体中不越界的话循环体中访问数组的语句可以消除边界检查。还有一种思路时隐式异常处理，将空指针检查和除数为零检查消除，注册一个Segment Fault信号的异常处理器，放在异常处理里面，在这个异常处理器里面再转换为对应的异常并抛出。还有一些其他的消除操作，比如自动装箱消除、安全点消除、消除反射等等。 逃逸分析逃逸分析不能直接优化代码，而是为其他优化手段提供优化的依据。逃逸分析指的是分析对象动态作用域：一个对象在方法中被定义后，被外部方法引用，则称为方法逃逸，被外部线程引用访问到的话，被称为线程逃逸。如果能证明一个对象不会逃逸到方法或线程外，则可以进行以下优化： 栈上分配（Stack Allocation）：若确认对象没有方法逃逸，可以将其在栈上分配内存，则其占用内存会随着栈帧出栈而被销毁，减少GC压力，而一般应用中不逃逸的局部对象占很大比例； 同步消除（Synchronization Elimination）：若确认对象没有线程逃逸，可以对该变量实时的同步措施消除； 标量替换（Scalar Replacement）：标量指一个数据无法再分解为更小的数据来表示，如基础数据类型，反之称之为聚合量（Aggregate），如对象。若确认一个对象没有逃逸，则可以不创建对象，改为直接创建它会被使用到的成员变量来代替，同时可以保存在栈上，提高读写效率，并为进一步优化创造条件。 参考：https://leibnizhu.gitlab.io/2017/06/09/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B/index.html 类变量初始化顺序 父类静态属性/父类静态代码块-&gt;子类静态代码块/子类静态属性-&gt;父类普通属性-&gt;父类构造方法-&gt;子类普通属性-&gt;子类构造方法 https://blog.csdn.net/jianggujin/article/details/52228983 多态原理]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>class</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kotlin简明教程]]></title>
    <url>%2Fposts%2Fjava_jdk_base_kotlin_learn.html</url>
    <content type="text"><![CDATA[第一周Day 1：可见性 在 Kotlin 中一切都是默认 public 的。并且 Kotlin 还有一套丰富的可见性修饰符，例如：private, protected, internal。它们每个都以不同的方式降低了可见性。 Day 2：Elvis 操作符 需要处理代码中的空值？可以使用 elvis 操作符，避免您的 “空情况” (null-erplate)。这只是替换空作为值或者返回事件情况的一个小语法。 Day 3：String 模板 格式化字符串？将$放在变量名的前面去表达字符串中的变量和表达式。使用 ${expression} 求表达式的值。 Day 4：When 表达式 强大的 switch！Kotlin 的 When 表达几乎可以匹配任何东西。字面值，枚举，数字范围。您甚至可以调用任意函数！ Day 5：循环，范围表达式与解构 for 循环在与其他两种 Kotlin 特性一起使用时可以获得超级能力：范围表达式和解构。 Day 6：属性 在 Kotlin 中，类可以具有可变和只读属性，默认情况下生成 getter 和 setter。如果需要，您也可以实现自定义的。 Day 7：解构声明 Android KTX 使用解构来分配颜色的组件值。您可以在您的类中使用解构，或者扩展现有的类来添加解构。 第一周学习小结： 本周以基本知识为主：处理空错误，简化循环和条件，属性，解构架。下一周我们将会深入探索 Kotlin 的更多功能。 第二周Day 8：简单的 bundle 准备去通过简洁的方式去创建 bundle，不调用 putString，putInt，或它们的 20 个方法中的任何一个。一个调用让您生成一个新的 bundle，它甚至可以处理 Arrays。 Day 9：Parcelize 喜欢 Parcelable 的速度，但不喜欢写所有的代码？和 @Parcelize 打个招呼。 Day 10：Data 类和 equality 可以创建具有一个具有处理数据的类吗？将它们标记为 “Data” 类。并默认实现生成 equals() 方法 - 相当于 hashCode()，toString() 和copy()，并检查结构是否相等。 Day 11：简化 postDelay Lambda 非常贴心，使用最后一个参数调用语法您可以取消回调，Callable 和 Runnable，例如 Android KTX 贴心的用一个小包装来处理 postDelayed。 Day 12：默认参数 方法参数的数量是否太多？在函数中指定默认参数值。使用命名参数使代码更具可读性。 Day 13：从 Java 编程语言调用 Kotlin 在同一个项目中使用 Kotlin 和 Java？您有没有顶级功能或属性的课程？默认情况下，编译器将生成类名称 YourFileKt。通过使用 @file：JvmName 注释文件来更改它。 Day 14：在没有迭代器的情况下迭代类型 迭代器用在了有趣的地方！Android KTX 将迭代器添加到 viewGroup 和 sparseArray。要定义迭代器扩展请使用 operator 关键字。 Foreach 循环将使用扩展名！ 第二周学习小结 这周我们更深入学了 Kotlin 的特性：简洁 bundle，迭代，Data，postDelay，默认参数，序列化。下一周我们会了解更多的 Kotlin 特性并且开始探索 Android KTX。 第三周Day 15：sealed 类 Kotlin 的 sealed 类可以让您轻松的处理错误数据，当结合 LiveData 您可以用一个 LiveData 同时代表成功和失败的路径，这比用两个不变量要好。 Day 16：懒加载 懒加载是个好东西！通过使用懒加载，可以省去昂贵的属性初始化的成本直到它们真正需要。计算值然后保存并为了未来的任何时候的调用。 Day 17：Lateinit Android 中，在 onCreate 或者其它的回调初始化对象，但在 Kotlin 中不为空的对象必须初始化。那么怎么办呢？可以输入 lateinit。来承诺最终将会初始化。 Day 18：要求 (require) 和检查 (check) 您方法的参数是有效的吗？用 require 在使用前可以检查它们，如果它们是无效的将会抛出 IllegalArgumentException。 您的封闭类的状态是否正确？可以使用 check 来验证。如果检查的值为 false，它将抛出 IllegalStateException。 Day 19：内联 (InLine) 等不及要使用 lambdas 来生成一个新的接口？kotlin 可以使您制定一个 inline 的方法 – 这意味着调用将替换方法体，用很非常简单的方法来生成 lambda 的接口。 Day 20：运算符重载 用操作符重载快更快速写 Kotlin。像 Path，Range或 SpannableStrings 这样的对象允许像加法或减法这样的操作。通过 Kotlin，您可以实现自己的操作符。 Day 21：顶级方法和参数 类的实用方法？将它们添加到源文件的顶层。在 Java 中，它们被编译为该类的静态方法。 第三周学习小结： 本周主要讨论一些基本的 Kotlin 特性，如运算符重载，内联，运算符重载，懒加载，以及非常强大的 inLine,并展示了使用 Android KTX 处理内容值，捆绑包和回调时如何编写更简洁的代码。 第四周Day 22：简单的内容值 将 ContentValues 的强大功能与 Kotlin 的简洁性相结合。使用 Android KTX 只传递一个 Pair &lt;StringKey，Value&gt; 创建 ContentValues。 Day 23：DSLs 特定于域的语言可以通过使用类型安全的构建器来完成。它们为简化 API 做出贡献；您也可以自己借助扩展 lambdas 和类型安全构建器等功能构建它们。 Day 24：具体化 具体化的概念例子：Android KTX 中的 Context.systemService() 使用泛化来通过泛型传递 “真实” 类型。没有通过 getSystemService。 Android KTX：Context.systemService() Day 25：Delegates 通过 by 用您的工作委托给另一个类。通过类继承，并将属性访问器逻辑与委托者属性重用。 Day 26：延期方法 没有更多的 Util 类。通过使用扩展功能扩展类的功能。把您要扩展的类的名字放在您添加的方法的名字前面。 扩展功能的一些特性： 不是成员函数 不要以任何方式修改原始类 通过静态类型信息解决编译时间 会被编译为静态函数 不要多态性 例如：String.toUri() Day 27：Drawable.toBitmap() 轻松转换 如果您曾经将 Drawable 转换为 Bitmap，那么您知道需要多少样？Android KTX 具有一系列功能，可以使您的代码在使用图形包中的类时更加简洁。 Day 28：Sequences, lazy 和 generators 序列是从未存在的列表。序列是迭代器的表亲，一次只能懒散地产生一个值。这在使用 map 和 fifter 时非常重要 - 它们将创建序列，而不是为每一步都复制列表！ Day 29：更简单的 Spans 功能强大但很难使用 - 这就是 Spans API 感觉的文本样式。 Android KTX 为一些最常见的 span 添加了扩展功能，并使 API 更易于使用。Android KTX: 可跨越字符串的构建器 Day 30：updatePadding 扩展 通过默认参数扩展现有的 API 通常会让每个人都高兴。 Android KTX 允许您使用默认参数在视图的一侧设置填充。一行代码可以节省很多代码！Android KTX: View.updatePadding Day 31：范围外 run，let，with，apply 让我们运行一些标准的 Kotlin 函数！简短而强大，run，let，with 和 appy 都有一个接收器 (this)，可能有一个参数 (it) 并可能有一个返回值。差异如下： run let with apply 第四周学习小结： 本周我们涵盖了更多语言特性，如 interop,refied 和 sequence，并且在 Android KTX，展示了它帮助您编写简洁易读的代码的一些方法。我们也讨论了高级特性：领域特定语言 (DSL)。 参考： https://juejin.im/post/5b0e1a6ef265da092a2b773f#heading-1]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>kotlin</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScheduledThreadPoolExecutor解析]]></title>
    <url>%2Fposts%2Fjava_jdk_base_scheduler_thread.html</url>
    <content type="text"><![CDATA[ScheduledThreadPoolExecutor解析我们知道Timer与TimerTask虽然可以实现线程的周期和延迟调度，但是Timer与TimerTask存在一些缺陷，所以对于这种定期、周期执行任务的调度策略，我们一般都是推荐ScheduledThreadPoolExecutor来实现。下面就深入分析ScheduledThreadPoolExecutor是如何来实现线程的周期、延迟调度的。 ScheduledThreadPoolExecutor，继承ThreadPoolExecutor且实现了ScheduledExecutorService接口，它就相当于提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。在JDK API中是这样定义它的：ThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。 它提供了四个构造方法： public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); } ​ public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory); } ​ public ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), handler); } ​ ​ public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory, handler); } 当然我们一般都不会直接通过其构造函数来生成一个ScheduledThreadPoolExecutor对象（例如new ScheduledThreadPoolExecutor(10)之类的），而是通过Executors类（例如Executors.newScheduledThreadPool(int);） 在ScheduledThreadPoolExecutor的构造函数中，我们发现它都是利用ThreadLocalExecutor来构造的，唯一变动的地方就在于它所使用的阻塞队列变成了DelayedWorkQueue，而不是ThreadLocalhExecutor的LinkedBlockingQueue（通过Executors产生ThreadLocalhExecutor对象）。DelayedWorkQueue为ScheduledThreadPoolExecutor中的内部类，它其实和阻塞队列DelayQueue有点儿类似。DelayQueue是可以提供延迟的阻塞队列，它只有在延迟期满时才能从中提取元素，其列头是延迟期满后保存时间最长的Delayed元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。有关于DelayQueue的更多介绍请参考这篇博客【死磕Java并发】—–J.U.C之阻塞队列：DelayQueue。所以DelayedWorkQueue中的任务必然是按照延迟时间从短到长来进行排序的。下面我们再深入分析DelayedWorkQueue，这里留一个引子。 ScheduledThreadPoolExecutor提供了如下四个方法，也就是四个调度器： schedule(Callable callable, long delay, TimeUnit unit) :创建并执行在给定延迟后启用的 ScheduledFuture。 schedule(Runnable command, long delay, TimeUnit unit) :创建并执行在给定延迟后启用的一次性操作。 scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) :创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推。 scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) :创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。 第一、二个方法差不多，都是一次性操作，只不过参数一个是Callable，一个是Runnable。稍微分析下第三（scheduleAtFixedRate）、四个（scheduleWithFixedDelay）方法，加入initialDelay = 5，period/delay = 3，unit为秒。如果每个线程都是都运行非常良好不存在延迟的问题，那么这两个方法线程运行周期是5、8、11、14、17…….，但是如果存在延迟呢？比如第三个线程用了5秒钟，那么这两个方法的处理策略是怎样的？第三个方法（scheduleAtFixedRate）是周期固定，也就说它是不会受到这个延迟的影响的，每个线程的调度周期在初始化时就已经绝对了，是什么时候调度就是什么时候调度，它不会因为上一个线程的调度失效延迟而受到影响。但是第四个方法（scheduleWithFixedDelay），则不一样，它是每个线程的调度间隔固定，也就是说第一个线程与第二线程之间间隔delay，第二个与第三个间隔delay，以此类推。如果第二线程推迟了那么后面所有的线程调度都会推迟，例如，上面第二线程推迟了2秒，那么第三个就不再是11秒执行了，而是13秒执行。 查看着四个方法的源码，会发现其实他们的处理逻辑都差不多，所以我们就挑scheduleWithFixedDelay方法来分析，如下： public ScheduledFuture scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) { if (command == null || unit == null) throw new NullPointerException(); if (delay 1)) ? delay : overflowFree(delay)); } reExecutePeriodic void reExecutePeriodic(RunnableScheduledFuture task) { if (canRunInCurrentRunState(true)) { super.getQueue().add(task); if (!canRunInCurrentRunState(true) && remove(task)) task.cancel(false); else ensurePrestart(); } } reExecutePeriodic重要的是调用super.getQueue().add(task);将任务task加入的队列DelayedWorkQueue中。ensurePrestart()在【死磕Java并发】—–J.U.C之线程池：ThreadPoolExecutor已经做了详细介绍。 到这里ScheduledFutureTask已经介绍完了，ScheduledFutureTask在ScheduledThreadPoolExecutor扮演作用的重要性不言而喻。其实ScheduledThreadPoolExecutor的实现不是很复杂，因为有FutureTask和ThreadPoolExecutor的支撑，其实现就显得不是那么难了。]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>ScheduledThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java jni原理分析]]></title>
    <url>%2Fposts%2Fjava_jdk_base_jni.html</url>
    <content type="text"><![CDATA[JNI原理解析第二章 开始 本章将引导你了解如何使用Java本地接口。我们将编写一个Java应用程序调用一个C函数来答应“Hello World！”。 2.1 概述 图2.1表明使用JDK或者Java SDK 2发行版编写一个调用C函数来打印“Hello World！”的Java应用程序的过程。这个过程有以下步骤组成： 创建申明了本地方法的类（HelloWorld.java） 使用javac去编译这个HelloWorld源文件，得到一个HelloWorld.class的class文件。javac编译工具是JDK或者Java 2 SDK发行版中提供的。 使用javah -jni去生成包含本地方法函数原型的C头文件（HelloWorld.h）。javah工具也是在JDK或者Java 2 SDK发行版中带有的。 编写本地方法的C实现（HelloWorld.c） 将C实现编译成一个本地库helloWorld.dll或者libHelloWorld.so，使用主机环境中可用的C编译器和连接器 使用Java运行时解析器运行hello world程序。类文件（HelloWorld.class）和本机库（HelloWorld.dll或者HelloWorld.so）都在运行时加载。 本章的剩余部分将详细讲解这些步骤。 2.2 定义本地方法 首先用Java编程语言编写以下程序。这个程序定义了一个包含本地方法print，类名为HelloWorld的类 1234567891011class HelloWorld &#123; private native void print(); public static void main(String[] args) &#123; new HelloWorld().print(); &#125; static &#123; System.loadLibrary(&quot;HelloWorld&quot;); &#125;&#125; HelloWorld类定义从打印本地方法的声明开始。之后是实例化HelloWorld类并调用此示例的print本地方法。类定义最后一部分是一个静态初始化器，它加载包含本地print方法的本地库。 定义一个本地方法例如print和使用Java编程语言定义一个常规的方法存在两个不同的地方。一个本地方法声明必须包含native修饰符。native修饰符表明该方法由其他编程语言实现。此外本地方法声明以分号终结（语句终结符），因为在这个类中没有实现这个本地方法。我们会在独立的c文件中完成print方法的编写。 在本地方法print能够被调用前，实现了print方法的本地库必须被加载。在这个例子中，我们在HelloWorld类的静态初始化块中将本地库加载进来。Java虚拟机在调用HelloWorld类的任何方法前先运行静态初始化块的代码，因此可以肯定在本地方法print被调用前，本地库就已经被加载了。 我们定义了一个可以运行HelloWorld类的main方法。HelloWorld.main方法以与常规方法相同的方式调用print本地方法。 System.loadLibrary使用库名字，找到与库名字相关的本地库，并将本地库加载到应用程序中。我们会在本书的后面部分讨论准确的加载过程。现在只需要记住，为了使System.loadLibrary(“HelloWorld”)能够成功，我们需要在win32系统上创建一个HelloWorld.dll文件，在Solaris系统中创建一个libHelloWorld.so文件。 2.3 编译HelloWorld类 在你完成HelloWorld类的编写，将源码保存到一个名为HelloWorld.java的文件中。使用JDK或者Java SDK 2中带有的javac工具进行编译： 1javac HelloWorld.java 这条指令会在当前目录中产生一个HelloWorld.class文件。 2.4 创建本地方法的头文件 接下来我们会使用javah工具来生成一个JNI类型的头文件，这个文件在后面使用C语言完成本地方法时是非常有用的。执行javah的指令如下： 1javah -jni HelloWorld 头文件的名字是类名并在其后面加上”.h”结尾。上面的指令会生成一个名字为HelloWorld.h的文件。在这里我们不会列出这个头文件的内容。这个文件的最重要的部分是Java_HelloWorld_print函数原型，它是实现了HelloWorld.print方法的C函数： 12JNIEXPORT void JNICALL Java_HelloWorld_print (JNIEnv *, jobject); 现在先忽略JNIEXPORT和JNICALL宏。你可能有注意到本地方法的C实现接受两个参数，尽管相应本地方法的定义（指HelloWorld.java中的定义）却没有接受任何参数。每一个本地方法实现的第一个参数是一个JNIEnv接口指针。第二个参数是引用HelloWorld对象本身，类似于C++的this指针。在本书的后面我们会讨论如何使用JNIEnv接口指针和jobject参数，但是在这个例子将忽略这两个参数。 2.5 编写本地方法实现 使用javah来生成的JNI类型头文件能够帮助你使用C/C++来完成本地方法的实现。你编写的函数必须遵循生成的头文件中的函数原型。在C文件HelloWorld.c中，你可以按照下面的代码来实现HelloWorld.print方法。 12345678910#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;HelloWorld.h&gt;JNIEXPORT void JNICALL Java_HelloWorld_print (JNIEnv *env, jobject obj)&#123; printf(&quot;Hello World!\n&quot;); return ;&#125; 这个本地方法的实现是非常简单的。它使用printf函数来显示字符串“Hello World！”，然后就返回。就像前面提到的，JNIEnv指针和obj对象引用都忽略了。 这个C程序包含三个头文件： jni.h：此头文件提供本地代码调用JNI函数所需的信息。 编写本机方法时，必须始终将此文件包含在C或C源文件中。 stdio.h：上面的代码片段还包括了stdio.h因为它使用printf函数 HelloWorld.h：通过javah工具生成的头文件。它包含Java_HelloWorld_print的函数原型。 2.6 编译C源码并生成一个本地库 请记住，你在文件HelloWorld.java文件中创建一个HelloWorld类时，包含一条将本地库加载到程序中的代码： 1System.loadLibrary(&quot;HelloWorld&quot;); 现在所有需要的C源码都已经编写完成了，现在你需要编译HelloWorld.c文件并创建一个本地库。 不同的操作系统提供不同的方式去创建本地库。在Solaris上，下述命令能够创建一个名为libHelloWorld.so的动态库。 1cc -G -I/java/include -I/java/include/solaris HelloWorld.c -o libHelloWorld.so -G编译选项表明让C编译器生成一个动态库而不是常规的Solaris可执行文件。在win32系统中，下面的指令使用Microsoft Visual C++编译器创建的动态链接库（DLL）HelloWold.dll 1cl -Ic:\java\include -Ic:\java\include\win32 -MD -LD HelloWorld.c -FeHelloWorld.dll -MD编译选项表明HelloWorld.dll和win32多线程C库链接。-LD编译选项表明C编译器产生一个DLL文件而不是常规的Win32可执行文件。当然不管在Win32还是Solaris系统，你都需要在你的电脑上设置好头文件的包含路径。 博主注：我使用的编译环境是Ubuntu 16.04版本，JDK版本是openjdk 1.8，使用上面的指令是不行的，下面是我使用的编译指令 1cc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -I. -fPIC -shared HelloWorld.c -o libHelloWorld.so 当然你也可以使用gcc，其中，JAVA_HOME是我配置到.bashrc中的路径： 1export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 大家可以按照各自的JAVA_HOME进行配置，这样就能够编译成功了。 2.7 运行程序 到这里，运行该程序的两个主件都已经准备好了。类文件（HelloWor.class）调用一个本地方法，本地库（HelloWorld.dll）实现这个本地方法。因为HelloWorld类包含它自己的main方法，在Solaris和Win32上，可以通过如下方法执行这个程序： 1java HelloWorld 你能够看到程序输出如下信息: 1Hello World！ 为了让你的程序能够正确的运行，正确设置好本地库的路径是非常重要的。本地库路径是一系列文件目录，当Java虚拟机加载本地库时会搜索这些路径。如果你没有正确设置本地库路径，你会看到如下类似的错误log： 1234java.lang.UnsatisfiedLinkError: no HelloWorld in library path at java.lang.Runtime.loadLibrary(Runtime.java) at java.lang.System.loadLibrary(System.java) at HelloWorld.main(HelloWorld.java) 需要确保本地库在设置的本地库路径的其中一个目录中。如果你在Solaris系统上运行，LD_LIBRARY_PATH环境变量是用来设置本地库路径的。确保该环境变量的路径包含动态库libHelloWorld.so文件所在的目录。如果libHelloWorld.so文件在当前目录，在标准shell或者KornShell中，你可以通过如下两条指令来设置LD_LIBRARY_PATH环境变量 12LD_LIBRARY_PATH=. export LD_LIBRARY_PATH 在C Shell中的等价指令如下： 1setenv LD_LIBRARY_PATH . 如果你是在Windows 95或者Windows NT上运行，确保HelloWorld.dll在当前目录，或者其所在的目录已经列在PATH环境变量中。 在Java 2 SDK 1.2发行版中，你可以像下面的指令一样，通过java命令行来指定本地库的的路径： 1java -Djava.library.path=. HelloWorld -D命令行选项设置了一个Java平台属性。将java.library.path设置为“.”，“.”表明Java虚拟机会在当前路径中搜索本地库。 第二章 内容补充 在原文中，构建JNI程序的方法只介绍了一个，其实构建JNI程序还有另外一种方法，这种方法我们称之为动态注册，相对的之前的方法我们称之为静态注册。我们先将方法介绍后，再看一下这两种方法有什么区别。 从一个例子出发，例子和第二章的例子一样，也是在Java中调用一个native方法打印出“Hello World！”的字样。Java侧的代码如下： 123456789101112class HelloWorld &#123; private native void helloworld(); public static void main(String[] args) &#123; HelloWorld h = new HelloWorld(); h.helloworld(); &#125; static &#123; System.loadLibrary(&quot;HelloWorld&quot;); &#125;&#125; 代码意思都是一样的，都是在HelloWorld类的main方法中创建一个对象，然后调用native层的方法HelloWorld来打印字符串。下面部分是native层的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;jni.h&gt;void JNICALL native_helloworld(JNIEnv* env, jobject ojb)&#123; printf(&quot;Hello World!\n&quot;); return;&#125;static const JNINativeMethod gMethods[] = &#123; &#123;&quot;helloworld&quot;, &quot;()V&quot;, (void *)native_helloworld&#125;&#125;;static jclass myClass;static const char* const ClassName=&quot;HelloWorld&quot;;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) &#123; JNIEnv* env = NULL; jint result = -1; if((*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) return -1; myClass = (*env)-&gt;FindClass(env, ClassName); if(myClass == NULL) &#123; printf(&quot;Cannot get class:%s\n&quot;, ClassName); return -1; &#125; if((*env)-&gt;RegisterNatives(env, myClass, gMethods, sizeof(gMethods)/sizeof(gMethods[0])) &lt; 0) &#123; printf(&quot;Register native methods failed.\n&quot;); return -1; &#125; printf(&quot;--------JNI_OnLoad---------\n&quot;); return JNI_VERSION_1_6;&#125; 首先要介绍的是JNI_OnLoad方法，这个方法是自动调用的，在Java侧，我们在静态代码块内通过System.loadLibrary，加载动态库的时候，相应的动态库的JNI_OnLoad方法就会自动执行。 在JNI_OnLoad方法中，带有的参数是JavaVM而不是我们常见的JNIENV，所以需要向获取到JNIEnv对象，然后我们通过JNIEnv的FindClass方法找到我们需要动态注册的类。 最后我们通过RegisterNatives方法，将gMethods数组中的Java层的函数和native层的函数动态绑定起来。 其中JNINativeMethod是一个结构体，定义如下： 12345typedef struct &#123; const char* name; const char* signature; void* fnPtr;&#125; JNINativeMethod; name指的是Java中定义的方法， signature指的是方法的描述符，也可以叫做签名，“()V”中“()”表示的是方法的参数为void，“V”表示的是返回值为void，具体的定义在第四章会讲到，这里可以先跳过。fnPtr指向的是native的方法名。 最后按照第二章中介绍的方法，编译运行就可以了。 动态注册和静态注册相比，动态注册更加灵活而且简单，不像静态注册那样，还需要用java和javah编译后才得出最后的函数名，如果中间Java文件改动，添加了native方法或者修改了native方法的函数名，又要重新做上面的步骤，麻烦。看过Android源码的朋友都应该发现了，Android中的JNI相关内容几乎都是用动态注册方法的。 静态注册Java侧代码如下： 1234567891011121314class Information &#123; private native void name(); private native void addr(); public static void main(String[] args) &#123; Information in = new Information(); in.name(); in.addr(); &#125; static &#123; System.loadLibrary(&quot;Information&quot;); &#125;&#125; 然后通过指令javac Information.java编译出Information.class，通过指令javah -jni Information获取到Information.h文件，这个.h文件中就包含需要完成的native方法。 创建Information_static.c文件，代码如下: 123456789101112131415#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &quot;Information.h&quot;JNIEXPORT void JNICALL Java_Information_name (JNIEnv * env, jobject obj)&#123; printf(&quot;My name is Jimmy Chen.\n&quot;);&#125; JNIEXPORT void JNICALL Java_Information_addr (JNIEnv * env, jobject obj)&#123; printf(&quot;My address is Guangdong Province.\n&quot;);&#125; 通过指令 cc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -I. -fPIC -shared Information_static.c -o libInformation.so 编译出.so库，最后通过指令java -Djava.library.path=. Information 运行该程序就能得到想要的结果了。 动态注册首先，Java侧的代码不需要变动。 native侧的话，创建一个Information_dynamic.c文件，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;jni.h&gt;#include &lt;stdio.h&gt;void native_name(JNIEnv * env, jobject obj)&#123; printf(&quot;My name is Jimmy Chen.\n&quot;);&#125;void native_addr(JNIEnv * env, jobject obj)&#123; printf(&quot;My addr is Guangdong Provice.\n&quot;);&#125;const static JNINativeMethod gMethods[] = &#123; &quot;name&quot;, &quot;()V&quot;, (void *)native_name, &quot;addr&quot;, &quot;()V&quot;, (void *)native_addr&#125;;static jclass myClass;static const char * const ClassName = &quot;Information&quot;;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reversed)&#123; JNIEnv *env = NULL; jint result = -1; if((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) return -1; myClass = (*env)-&gt;FindClass(env, ClassName); if(myClass == NULL) &#123; printf(&quot;Can not find class:%s.\n&quot;, ClassName); return -1; &#125; if((*env)-&gt;RegisterNatives(env, myClass, gMethods, sizeof(gMethods)/sizeof(gMethods[0])) &lt; 0) &#123; printf(&quot;Register native mthods error.\n&quot;); return -1; &#125; printf(&quot;-----JNI_OnLoad Success-----\n&quot;); return JNI_VERSION_1_6; &#125; 最后按照静态方法的编译和执行指令，编译运行即可，记住编译的时候将C文件名改为Information_dynamic.c文件就行了。 第三章 基本类型、字符串和数组 当面对Java应用程序混合本地编程语言代码时，程序员经常会问的一个问题是：Java编程语言中的数据类型是如何映射到C/C++等本地编程语言中的数据类型的。上一章中介绍的“Hello World！”示例中，我们没有任何的参数需要传输给本地方法，本地方法也没有返回任何结果给调用者。本地方法只是简单的打印一条信息然后返回。 在实践中，许多程序都需要传送参数给本地方法，而且需要从本地方法中获取返回值。本章，我们将介绍如何在Java编程语言编写的代码和本地编程语言编写的代码之间交换数据类型。我们从原始类型，例如整型和常用的对象类型，例如字符串和数组开始讲解。我们将把任意对象的完整处理留到下一章，下一章我们将会介绍本地方法的代码如何访问字段和进行方法调用。 3.1 一个简单的本地方法 让我们先从一个简单的程序开始，这个程序和上一章的HelloWorld程序没有多少不同。示例程序，Prompt.java，包含一个打印一个字符串、等待用户输入、最后将用户输入的内容返回给调用函数的本地方法。该程序的代码如下： 1234567891011121314class Prompt &#123; // native method that prints a prompt and reads a line private native String getLine(String prompt); public static void main(String args[]) &#123; Prompt p = new Prompt(); String input = p.getLine(&quot;Type a line: &quot;); System.out.println(&quot;User typed: &quot; + input); &#125; static &#123; System.loadLibrary(&quot;Prompt&quot;); &#125;&#125; Prompt.main调用本地方法Prompt.getLine来获取用户的输入。在静态初始化块中调用System.loadLibrary方法将名为Prompt的本地库加载到程序中。 3.1.1 本地方法的C原型 Prompt.getLine方法可以使用以下C函数实现： 12JNIEXPORT jstring JNICALL Java_Prompt_getLine (JNIEnv *, jobject, jstring); 你可以使用javah工具来生成包含上述函数原型的头文件。JNIEXPORT和JNICALL宏（在JNI.h都在文件中定义）确保这个函数从本地库中导出而且C编译器使用该函数的正确调用约定生成代码。C函数的名称是通过连接“Java_”前缀、类名称和方法名称构成的。11.3节包含如何形成C函数名称的更准确的描述。 3.1.2 本地方法参数 如2.4节所述，本地方法实现（如Java_Prompt_getLine）除了在本地方法中声明的参数外，还接受两个标准参数。第一个参数是JNIEnv接口指针，指向函数表指针的位置。每个方法表中的指针指向一个JNI函数。本地方法始终通过JNI函数之一访问Java虚拟机中的数据结构。如图3.1所示JNIEnv接口指针： 第二个参数取决于本地方法是实例方法静态方法还是实例方法。实例化本地方法的第二个参数是对该方法的调用对象的应用，与C++语言中的this指针类似。静态本地方法的第二个参数是对定义该方法的类的应用。我们的例子，Java_Prompt_getLine实现为一个实例化本地方法。所以第二个参数jobject就是对对象本身的引用。 3.1.3 类型映射 本地方法声明中的参数类型在本地编程语言中都有相应的类型。JNI中定义了一组对应于Java编程语言中类型的C/C++类型。在Java编程语言中存在着两种类型：基本类型，如int、float和char以及引用类型，如类、实例和数组。在Java编程语言中字符串是java.lang.String类的实例化。 JNI以不同的方式处理基本类型和引用类型。基本类型的映射是直接的。Java编程语言中的int类型映射为C/C++的jint（定义在jni.h中，为32位有符号整型数），Java编程语言中的float类型映射为C/C++的jfloat（定义在jni.h中，为32位浮点类型数）。12.1.1节包含所有在JNI中定义的基本类型（这里简单把截图放一下，如下图)。 JNI传递对象给本地方法作为不透明引用。不透明引用指的是引用Java虚拟机内部数据类型的C指针类型。对于程序员而言，Java虚拟机内部数据的准确布局是隐藏的。本地代码可以通过JNIEnv接口指针指向的适当的函数来操作底层对象。例如，java.lang.String对应于JNI类型jstring，jstring引用的确切位置和本地代码是不相关的。本地代码通过jni函数，例如GetStringUTFChars来获取string的内容。 所有的JNI类型都有类型jobject（感觉应该是jobject的子类的意思），为了方便和增强类型安全性，JNI定义了一组在概念上是jobject的子类型的引用类型（A是B的子类型，那么A的每个实例对象都会是B的实例对象（博主注：大概应该是这个意思吧））。这些子类型对应于Java编程语言中经常使用的引用类型。例如：jstring表示字符串，jobjectArray表示对象数据，12.1.2节(这里也简单把截图放一下，如下图)完整的列出了JNI参考类型及其子类型的关系。 3.2 访问字符串 Java_Prompt_getLine接收prompt参数为一个jstring类型。jstring类型在Java虚拟机代表着字符串，但是有不同于常规的C字符串（指向字符的指针，char *）。你不能将jstring作为常规C字符串来使用。运行下面的代码将不会得到期望的结果，而事实上很可能会导致Java虚拟机崩溃。 123456JNIEXPORT jstring JNICALLJava_Prompt_getLine(JNIEnv *env, jobject obj, jstring prompt) &#123; /* ERROR: incorrect use of jstring as a char* pointer */ printf(&quot;%s&quot;, prompt); ...&#125; 3.2.1 转换为本地字符串 你的本地代码必须使用恰当的JNI函数将jstring对象转换为C/C++字符串。JNI同时支持将jstring转换为Unicode和UTF-8字符串。Unicode字符串使用16位值表示字符，而UTF-8字符串则使用向上兼容7位ASCII字符串的编码方法。尽管UTF-8字符串包含非ASCII字符，但是其表现类似于使用NULL终止符的C字符串。值在1到127之间的所有7位ASCII字符在UTF-8字符串中编码保持不变。一个字节中的最高位被设置了，表示多字节编码的16位Unicode值的开始。 Java_Prompt_getLine方法调用JNI方法GetStringUTFChars来读取字符串的内容。可以通过JNIEnv接口指针使用GetStringUTFChars方法。它将通常在Java虚拟机中实现为Unicode序列的jstring引用转换为UTF-8格式的C式字符串。如果你可以确定原始的字符串只包含7位ASCII字符，你可以将转换后的字符串传给C库函数，例如printf（我们会在8.2节讨论佮处理非ASCII字符串）。 123456789101112131415161718#include &quot;Prompt.h&quot;#include &lt;stdio.h&gt;JNIEXPORT jstring JNICALL Java_Prompt_getLine (JNIEnv *env, jobject obj, jstring prompt)&#123; char buf[128]; const jbyte *str; str = (*env)-&gt;GetStringUTFChars(env, prompt, NULL); if(str == NULL) return NULL; printf(&quot;%s&quot;, str); (*env)-&gt;ReleaseStringUTFChars(env, prompt, str); /* We assume here that the user does not type more than * 127 characters */ scanf(&quot;%s&quot;, buf); return (*env)-&gt;NewStringUTF(env, buf);&#125; 不要忘记检查GetStringUTFChars的返回值，这是因为Java虚拟机的实现决定内部需要申请内存来容纳UTF-8字符串，内存的申请是有可能会失败的。如果内存申请失败，那么GetStringUTFChars将会返回NULL并且会抛出OutOfMemoryError异常。正如我们会在第六章介绍的一样，在JNI中抛出异常和在Java中抛出异常是不同的。通过JNI抛出的挂起异常不会自动更改本地C代码的控制流程。相反我们需要一个显示的return语句来跳过C函数中的剩余语句。Java_Prompt_getLine返回后，该异常会返回给Prompt.getLine的调用者Prompt.main函数中。 3.2.2 释放本地字符串资源 当你的本地代码使用完通过GetStringUTFChars获取的UTF-8字符串后，需要调用ReleaseStringUTFChars，调用ReleaseStringUTFChars表明本地代码不再需要GetStringUTFChars返回的UTF-8字符串了，调用ReleaseStringUTFChars就能够释放掉UTF-8字符串占用的内存。不调用ReleaseStringUTFChars进行内存释放会导致内存泄漏，最终导致内存耗尽。 3.2.3 创建新字符串 通过调用JNI函数NewStringUTF，你可以在本地代码中创建一个新的java.lang.String实例。NewStringUTF方法使用一个UTF-8格式的C式字符串作为参数并生成一个java.lang.String实例对象。新构造的java.lang.String实例和给定的UTF-8 C式字符串有相同的Unicode序列。如果虚拟机没办法申请足够的内存来构造java.lang.String实例的话，NewStringUTF会抛出一个OutOfMemoryError异常并返回NULL。在这个例子中，我们不需要检查返回值，因为本地代码会在之后立刻返回。如果NewStringUTF调用失败，OutOfMemoryError异常会在该方法的调用者Prompt.main中被抛出。如果NewStringUTF调用成功，它会返回一个指向新构造的java.lang.String对象的引用。这个新构造的实例会在Prompt.getLine中返回，并在Prompt.main中赋值给input。 3.2.4 其他JNI字符串方法 除了之前介绍的GetStringUTFChars、ReleaseStringUTFChars和NewStringUTF函数外，JNI中还支持其他的字符串相关方法。GetStringChars和ReleaseStringChars获取以Unicode格式表示的字符串字符。当操作系统支持将Unicode作为本地字符串格式的时候，这些函数将会非常有用。 UTF-8字符串常以‘\0’结尾，而Unicode字符串却不是。为了统计一个jstring引用中的Unicode字符个数时，JNI程序员可以调用GetStringLength。为了统计一个UTF-8格式的jstring对象占用多少字节时，可以对GetStringUTFChars的返回值调用ANSI C函数strlen来获得，或者直接对jstring引用调用JNI函数GetStringUTFLength来获得。GetStringUTFChars和GetStringChars方法的第三个参数需要做些而外的解释： const jchar *GetStringChars(JNIEnv *env, jstring str, jboolean *isCopy); 从GetStringChars方法返时，如果返回的字符串是原始java.lang.String实例中的字符的副本，那么isCopy指向的内存地址的值被设置为JNI_TURE。如果返回的字符串是原始java.lang.String实例中字符的的直接引用，那么isCopy指向的内存地址的值被设置为JNI_FALSE。当isCopy指向的内存地址的值被设置为JNI_FALSE时，本地代码不能修改返回的字符串的内容。如果违反该规则，将会导致原始的java.lang.String实例对象也被修改。这将打破java.lang.String不可修改规则。 大部分情况是将NULL作为isCopy的参数传递给方法，因为你不用关注Java虚拟机返回的是java.lang.String实例的副本还是直接引用。 通常无法预测虚拟机是否会复制给定的java.lang.String中的字符。因此程序员必须了解到诸如GetStringChars之类的函数可能需要与java.lang.String实例中的字符数成比例的时间和空间开销。在典型的Java虚拟机实现中，垃圾收集器重新定位堆中的对象。一旦将指向java.lang.String实例的直接指针传回给本地代码中，垃圾收集器将不能重新定位java.lang.String实例。换句话说，虚拟机必须固定java.lang.String实例，因为过多的固定会导致内存碎片，所以虚拟机实现可以自由的选择为每个GetStringChars调用复制字符还是固定实例。 当你不再需要访问GetStringChars函数返回的字符串元素时，不要忘记调用ReleaseStringChars。不管GetStringChars中的isCopy设置为JNI_FALSE还是JNI_TRUE，ReleaseStringChars都是必须调用的。ReleaseStringChars会释放副本或者取消固定实例，具体取决于GetStringChars返回实例的副本还是固定实例。 3.2.5 在Java 2 SDK 1.2中新添加的JNI字符串函数 为了增加虚拟机返回java.lang.String实例字符的直接指针的可能性，Java 2 SDK版本1.2引入了一组新的Get/ReleaseStringCritical函数。 在表面上，它们似乎与Get/ReleaseStringChars函数类似，如果可能的话，它们返回一个指向字符的指针; 否则，会复制一份。 但是，如何使用这些功能有很大的限制。 你必须将这对函数里的代码视为在临界区中运行，在临界区内，本地代码不能随意（arbitrary，博主这里翻译为随意的，但是感觉有点不对，但是不知道怎么翻译好，独占？感觉跟Linux内核中断处理有点像）调用JNI函数或者其他任意的会引起当前线程阻塞以及会等待Java虚拟机中另一个线程的本地函数。例如，当前线程不能够等待另一个线程的I/O输入流。这些限制使得虚拟机可以在本地代码持有通过GetStringCritical获取的字符串元素的直接指针时禁用垃圾回收。当垃圾收集器被禁用，其他触发垃圾收集器的线程都会被挂起。在Get/ReleaseStringCritical对之间的本地代码不能调用回引起阻塞的调用以及创建新对象。否则虚拟机可能会引起死锁，考虑如下场景： 由另一个线程触发的垃圾回收无法进行，直到当前线程完成阻塞调用并重新启用垃圾回收。 同时，当前的线程无法进行，因为阻塞调用需要获得一个已经被另一个正在等待执行垃圾回收的线程持有的锁。 重叠调用多对GetStringCritical和ReleaseStringCritical是安全的。例如： 1234567jchar *s1, *s2;s1 = (*env)-&gt;GetStringCritical(env, jstr1); if (s1 == NULL) &#123;... /* error handling */ &#125;s2 = (*env)-&gt;GetStringCritical(env, jstr2); if (s2 == NULL) &#123;(*env)-&gt;ReleaseStringCritical(env, jstr1, s1); ... /* error handling */&#125; ... /* use s1 and s2 */(*env)-&gt;ReleaseStringCritical(env, jstr1, s1); (*env)-&gt;ReleaseStringCritical(env, jstr2, s2); Get/ReleaseStringCritical对的使用不需要以堆栈顺序严格嵌套。我们不能忘记检查其因内存不足导致返回值为NULL的情况，因为GetStringCritical仍然可以分配一个缓冲区，并且如果虚拟机内部表示不同格式的数组，则复制数组。例如，Java虚拟机可能不会连续存储数组。在这种情况下，GetStringCritical必须复制jstring实例中的所有字符，以便将本地代码的连续字符数组返回。 为了避免死锁，你应该确保你的本地代码在调用GetStringCritical之后和在调用ReleaseStringCritical之前不应当随意调用JNI函数，在临界区中唯一允许的JNI函数是嵌套调用Get/ReleaseStringCritical和Get/ReleasePrimitiveArrayCritical。 JNI不支持GetStringUTFCritical和ReleaseStringUTFCritical方法。这些函数几乎都需要虚拟机创建字符串的副本，这是因为虚拟机实现几乎在内部都是使用Unicode格式来存储字符串。 另外在Java SDK 2 Release 1.2中增加的函数是GetStringRegion和GetStringUTFRegion。这些函数将字符串元素复制到一个预先分配的内存当中。Prompt.getLine方法可以使用GetStringUTFRegion进行重写： 12345678910JNIEXPORT jstring JNICALLJava_Prompt_getLine(JNIEnv *env, jobject obj, jstring prompt) &#123; /* assume the prompt string and user input has less than 128 characters */ char outbuf[128], inbuf[128]; int len = (*env)-&gt;GetStringLength(env, prompt); (*env)-&gt;GetStringUTFRegion(env, prompt, 0, len, outbuf); printf(&quot;%s&quot;, outbuf); scanf(&quot;%s&quot;, inbuf); return (*env)-&gt;NewStringUTF(env, inbuf); &#125; GetStringUTFRegion将字符串开始的下标和长度作为参数，这两个值都是以Unicode字符来统计。这个函数同时做边界检查，同时有必要会抛出StringIndexOutOfBoundsExecption异常。上面的代码中，我们从字符串引用本身获取到长度，因此可以确认不会出现下标越界（但是上面的代码缺少对prompt的检查，以确保其长度低于128个字符）。 3.2.6 JNI字符串函数总结 &esmp;表3.1中列出所有字符串相关的JNI函数，Java 2 SDK 1.2版本增加了一些增强某些字符串操作性能的新功能。 除了提高性能之外，增加的功能不支持新的操作。 表3.1 JNI字符串函数总结 JNI函数 描述 从哪个版本开始 GetStringChars\ReleaseStringChars 获取或释放指向Unicode格式的字符串内容的指针。可能会返回字符串的副本。 JDK 1.1 GetStringUTFChars\ReleaseStringUTFChars 获取或释放指向UTF-8格式的字符串内容指针。可能会返回字符串的副本 JDK 1.1 GetStringLength 返回字符串中Unicode字符的数量 JDK 1.1 GetStringUTFLength 返回以UTF-8格式表示字符串所需的字节数（不包括尾数0）。 JDK 1.1 NewString 创建拥有和给定的Unicode格式C式字符串相同字符序列的java.lang.String实例 JDK 1.1 NewStringUTF 创建拥有和给定的UTF-8格式C式字符串相同字符序列的java.lang.String实例 JDK 1.1 GetStringCritical\ReleaseStringCritical 获取指向Unicode格式的字符串内容的指针。 可能会返回字符串的副本。本地代码不能在Get/ReleaseStringCritical调用中间阻塞 Java 2 SDK 1.2 GetStringRegion\SetStringRegion 以Unicode格式将字符串的内容复制到预分配的C缓冲器到或从预分配的C缓冲区中复制。 Java 2 JDK 1.2 GetStringUTFRegion\SetStringUTFRegion 以UTF-8格式将字符串的内容复制到预分配的C缓冲区中或从预分配的C缓冲区中复制 Java 2 JDK 1.2 3.2.7 选择合适的字符串函数 图3.2中表明程序员应该如何在JDK release 1.1和Java 2 SDK release 1.2中选择合适字符串相关函数。 如果你使用的是1.1或者1.1和1.2发行版的JDK，那么除了Get/ReleaseStringChars和Get/ReleaseStringUTFChars外没有其余的选择了。 如果你是使用Java 2 JDK release 1.2及以上的版本进行编程，并且想字符串的内容复制到已经分配了C缓冲区中，使用GetStringRegion或者GetStringUTFRegion。 对于小型固定大小的字符串，Get/SetStringRegion和Get/SetStringUTFRegion几乎总是首选函数，因为C缓冲区在C堆栈上进行分配是开销是非常小的。在字符串中复制少量字符的开销是微不足道的。 Get/SetStringRegion和Get/SetStringUTFRegion的一个优点是它们不执行内存分配，因此不会引起意外的内存不足异常。 如果确保不能发生索引溢出，则不需要进行异常检查。Get/SetStringRegion和Get/SetStringUTFRegion的另一个优点是您可以指定起始索引和字符数。 如果本地代码仅需要访问长字符串中的字符子集，那么这些函数是合适的。 使用GetStringCritical函数必须非常小心。你必须确保当持有一个通过GetStringCritical返回的指针时，本地代码在Java虚拟机中不会创建新对象或者会引起系统死锁的阻塞性调用。 下面是一个实例，演示了使用GetStringCritical产生的微妙问题。下面的代码获取字符串的内容，并调用fprintf函数将字符写入到文件句柄fd中： 1234567/* This is not safe! */const char *c_str = (*env)-&gt;GetStringCritical(env, j_str, 0); if (c_str == NULL) &#123;.../* error handling */ &#125;fprintf(fd, &quot;%s\n&quot;, c_str);(*env)-&gt;ReleaseStringCritical(env, j_str, c_str); 上述代码的问题是当当前线程禁用垃圾收集时，写入文件句柄并不总是安全的。假设，例如，另一个线程T等待从fd文件句柄读取。 让我们进一步假设操作系统缓冲的设置方式使得fprintf调用等待，直到线程T完成从fd读取所有挂起的数据。我们已经构建了可能的死锁场景：如果线程T不能分配足够的内存 作为从文件句柄读取的缓冲区，它必须请求垃圾回收。 垃圾回收请求将被阻止，直到当前线程执行ReleaseStringCritical，直到fprintf调用返回为止。 然而，fprintf调用正在等待线程T从文件句柄中完成读取。 以下代码虽然与上述示例类似，但几乎肯定是无死锁的： 1234567/* This code segment is OK. */const char *c_str = (*env)-&gt;GetStringCritical(env, j_str, 0); if (c_str == NULL) &#123; ... /* error handling */&#125; DrawString(c_str); (*env)-&gt;ReleaseStringCritical(env, j_str, c_str); DrawString是一个能直接将字符串写到屏幕上的系统调用。除非屏幕显示驱动程序也是在同一虚拟机中运行的Java应用程序，否则DrawString函数将不会无限期地阻止等待垃圾收集发生。 总而言之，您需要考虑一对Get/ReleaseStringCritical调用之间所有可能的阻塞行为。 3.3 访问数组 JNI以不同的方式对待基本数据类型数组和对象数组。基本数据类型数组包含基本数据类型，例如int和boolean。对象数据包含引用类型元素，例如类实例或其他数组。例如下面使用Java编程语言编写的代码中： 1234int[] iarr;float[] farr; Object[] oarr; int[][] arr2; iarr和farr是基本数据类型数组，而oarr和arr2是对象数组。 在本地代码中访问基本数据类型数组所需要的方法和访问字符串所需要的本地方法类似。让我们看一个基本例子，以下程序调用本地方法sumArray，它将int数组的内容相加。 123456789101112131415class IntArray &#123; private native int sumArray(int[] arr); public static void main(String[] args) &#123; IntArray p = new IntArray(); int arr[] = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i; &#125; int sum = p.sumArray(arr); System.out.println(&quot;sum = &quot; + sum); &#125; static &#123; System.loadLibrary(&quot;IntArray&quot;); &#125; &#125; 3.3.1 在C中访问数组 数据由jarray引用类型及其“子类型”（如jintArray）表示。正如jstring不是C式字符串一样，jarray也不是C式数据。你不能直接访问jarray引用来完成Java_IntArray_sumArray本地方法的编写。下面的C代码是非法的也不会获取到想要的结果： 1234567/* This program is illegal! */ JNIEXPORT jint JNICALL Java_IntArray_sumArray(JNIEnv *env, jobject obj, jintArray arr) &#123; int i, sum = 0; for (i = 0; i &lt; 10; i++) &#123; sum += arr[i]; &#125; &#125; 你应该使用恰当的JNI函数来访问基本数据类型数组中的元素，就像下面展示的正确的例子一样： 123456789JNIEXPORT jint JNICALL Java_IntArray_sumArray(JNIEnv *env, jobject obj, jintArray arr) &#123; jint buf[10]; jint i, sum = 0; (*env)-&gt;GetIntArrayRegion(env, arr, 0, 10, buf); for (i = 0; i &lt; 10; i++) &#123; sum += buf[i]; &#125; return sum; &#125; 3.3.2 访问基本数据类型数组 前面的例子中使用GetIntArrayRegion函数来复制整型数组中的所有元素到C缓冲区中。第三个参数是需要复制的元素的起始索引，第四个参数表示需要复制的元素的总数。一旦元素存储在C缓冲区中，我们就能够在本地代码中访问他们了。异常检查是不需要的，因为在这个例子中，我们知道数组的长度为10，因此不会引发索引越界问题。 JNI支持相应的SetIntArrayRegion函数，该函数允许本机代码修改int类型的数组元素。 还支持其他原始类型的数组（如boolean、short和float类型）。 JNI支持一系列Get/ReleaseArrayElements（博主注 表示的是基本类型，例如int、float等，因为博客Markdown解析不好，实在没办法弄好，各位看官就将就看了，下同）函数（包括例如Get/ReleaseIntArrayElements），允许本机代码获得对原始数组元素的直接指针。因为底层垃圾收集器不支持固定，所以虚拟机可能会返回指向基本数据类型数组的副本的指针。我们可以使用GetIntArrayElements来重写3.3.1节中的本地代码实现函数（包括例如Get/ReleaseIntArrayElements），允许本机代码获得对原始数组元素的直接指针。因为底层垃圾收集器不支持固定，所以虚拟机可能会返回指向基本数据类型数组的副本的指针。我们可以使用GetIntArrayElements来重写3.3.1节中的本地代码实现： 12345678910111213JNIEXPORT jint JNICALL Java_IntArray_sumArray(JNIEnv *env, jobject obj, jintArray arr) &#123; jint *carr; jint i, sum = 0; carr = (*env)-&gt;GetIntArrayElements(env, arr, NULL); if (carr == NULL) &#123; return 0; /* exception occurred */ &#125; for (i=0; i&lt;10; i++) &#123; sum += carr[i]; &#125; (*env)-&gt;ReleaseIntArrayElements(env, arr, carr, 0); return sum;&#125; GetArrayLength方法返回基本数据类型数组或对象数组中元素的个数。当第一次分配数组的时候，其长度就固定了。 Java 2 SDK 1.2中介绍了Get/ReleasePrimitiveArrayCritical函数。当本地代码访问基本数据类型数组的时候，这些函数允许虚拟机禁用垃圾回收器。程序员注意使用这两个函数必须跟使用Get/ReleaseStringCritical函数一样小心。在Get/ReleasePrimitiveArrayCritical函数对中的本地代码不能随意调用JNI方法，不能进行可能导致死锁的阻塞操作。 3.3.3 访问基本数据类型数组总结 表3.2中列出了访问基本数据类型数据的相关JNI方法，Java 2 JDK 1.2版本中增加了一些增加特定数组操作性能的函数，增加的函数没有提供新的操作，只是做了操作性能的提升而已： 表3.2 访问基本数据类型数组总结 JNI函数 描述 从哪个版本开始 GetArrayRegion\SetArrayRegion 复制基本数据类型数组的内容到C缓冲区或者将C缓冲区的内容复制出来 JDK 1.1 GetArrayElements\ReleaseArrayElements 获取一个指向基本数据类型数组内容的指针，可能会返回该数组的副本 JDK 1.1 GetArrayLength 返回数组中元素的个数 JDK 1.1 NewArray 创建一个给定长度的数组 JDK 1.1 GetPrimitiveArrayCriticalReleasePrimitiveArrayCritical 获取一个指向基本数据类型数组内容的指针，可能禁用垃圾收集器或者返回该数组的副本 Java 2 JDK 1.2 3.3.4 选择合适的基本类型数组函数 图3.3表明，在JDK 1.1和Java 2 JDK 1.2版本中，程序员应如何选择恰当的JNI函数来访问基本数据类型数组。 如果你需要将数组内容复制到C缓冲区或者从C缓冲区中将内容复制到数组中，应当使用Get/SetArrayRegion家族函数。这些函数会进行边界检查，并且如果有必要的话会抛出ArrayIndexOutOfBoundsException异常。第3.3.1节中的本地方法实现中使用GetIntArrayRegion方法从jarray引用中复制10个元素。 对于小型固定大小的阵列，Get/SetArrayRegion几乎总是首选函数，因为C缓冲区可以非常方便的从C堆栈中分配。复制少量数组元素的开销是微不足道的。 Get/SetArrayRegion函数允许您指定起始索引和元素数量，因此如果本地代码只需要访问大型数组中的元素的一个子集，则它们是首选函数。 如果没有预分配的C缓冲区，则原始数组的大小不确定，并且本机代码在持有指向数组元素的指针时不发出阻塞调用，请使用Java 2 SDK版本1.2中的Get/ReleasePrimitiveArrayCritical函数。 就像Get/ReleaseStringCritical函数一样，必须非常小心地使用Get/ReleasePrimitiveArrayCritical函数，以避免死锁。 使用Get/ReleaseArrayElements系列函数总是安全的。 虚拟机或者返回指向数组元素的直接指针，或者返回一个保存数组元素副本的缓冲区。 3.3.5 访问对象数组 JNI提供了一对单独的函数来访问对象数组。GetObjectArrayElement返回给定索引处的元素，而SetObjectArrayElement更新给定索引处的元素。与原始数组类型的情况不同，您不能一次获取所有对象元素或复制多个对象元素。字符串和数组是引用类型，你可以使用Get/SetObjectArrayElememt访问字符串数组和数组的数组。 下面的代码调用一个本地函数来创建一个int型二维数组，然后打印给数组的内容。 12345678910111213141516class ObjectArrayTest &#123; private static native int[][] initInt2DArray(int size); public static void main(String[] args) &#123; int[][] i2arr = initInt2DArray(3); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.print(&quot; &quot; + i2arr[i][j]); &#125; System.out.println(); &#125; &#125; static &#123; System.loadLibrary(&quot;ObjectArrayTest&quot;); &#125; &#125; 本地方法initInt2DArray根据给定的大小创建一个二维数组，该本地方法分配和创建二维数组的代码可能如下所示： 1234567891011121314151617181920212223242526272829JNIEXPORT jobjectArray JNICALLJava_ObjectArrayTest_initInt2DArray(JNIEnv *env, jclass cls, int size)&#123; jobjectArray result; int i; jclass intArrCls = (*env)-&gt;FindClass(env, &quot;[I&quot;); if (intArrCls == NULL) &#123; return NULL; /* exception thrown */ &#125; result = (*env)-&gt;NewObjectArray(env, size, intArrCls, NULL); if (result == NULL) &#123; return NULL; /* out of memory error thrown */ &#125; for (i = 0; i &lt; size; i++) &#123; jint tmp[256]; /* make sure it is large enough! */ int j; jintArray iarr = (*env)-&gt;NewIntArray(env, size); if (iarr == NULL) &#123; return NULL; /* out of memory error thrown */ &#125; for (j = 0; j &lt; size; j++) &#123; tmp[j] = i + j; &#125; (*env)-&gt;SetIntArrayRegion(env, iarr, 0, size, tmp); (*env)-&gt;SetObjectArrayElement(env, result, i, iarr); (*env)-&gt;DeleteLocalRef(env, iarr); &#125; return result; &#125; initInt2DArray方法首先调用JNI函数FindClass来获取一个对二维int类型数组的元素类的引用。FindClass的参数“[I”是一个对于与Java编程语言中int[]类型的JNI类描述符（12.3.2节）。如果类型查询失败，FindClass会返回NULL并抛出异常（例如由于缺少类文件或者内存不足的情况）。 下一步，NewObjectArray函数分配一个数组，其元素类型由intArrCls类应用决定。NewObjectArray仅仅分配第一个维度，我们仍然需要填写构成第二个维度的数组元素。Java虚拟机中没有特殊的数据类型来表示多维数组。一个二维数组其实就是一个数组。 创建第二维数组的代码是简单易懂的。NewIntArray分配独立的数组元素，SetIntArrayRegion将tmp缓冲区的内容复制到新分配的一维数组中。完成SetObjectArrayElement调用后，第i个一维数组的第j个元素的值为i+j。执行ObjectArrayTest.main方法可以获得如下输出： 1230 1 21 2 32 3 4 在循环结尾调用DeleteLocalRef确保虚拟机不会因为保存JNI引用例如iarr，而导致内存耗尽。5.2.1节将解释为什么以及何时需要调用DeleteLocalRef。 第三章之刻意练习Practice 1 在Java侧初始化两条提示语句，一个提示输入姓名，另一个提示输入住址，然后编写一个native方法，将其中的提示语句传给native方法，然后再native方法中获取输入，将输入的内容返回给Java侧，在Java侧打印native方法中输入的内容。（当然有时间的朋友可以尝试使用静态注册JNI方法和动态注册JNI方法这两种方式） 静态注册方式 1.1 Java侧代码： 12345678910111213141516171819class Practice1 &#123; private native String getInformation(String prompt); public static void main(String[] args) &#123; String NamePrompt = &quot;Please enter your name:&quot;; String AddrPrompt = &quot;Please enter your addr:&quot;; Practice1 p = new Practice1(); String Name = p.getInformation(NamePrompt); String Addr = p.getInformation(AddrPrompt); System.out.println(&quot;Name: &quot; + Name); System.out.println(&quot;Addr: &quot; + Addr); &#125; static &#123; System.loadLibrary(&quot;Practice1&quot;); &#125;&#125; 1.2 javah -jni产生的头文件 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class Practice1 */#ifndef _Included_Practice1#define _Included_Practice1#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: Practice1 * Method: getInformation * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_Practice1_getInformation (JNIEnv *, jobject, jstring);#ifdef __cplusplus&#125;#endif#endif 1.3 静态注册方法编写 123456789101112131415161718192021222324252627#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;Practice1.h&quot;JNIEXPORT jstring JNICALL Java_Practice1_getInformation (JNIEnv * env, jobject obj, jstring prompt)&#123; // 下面这里用jbyte * 和 char *都是可以的 char * c_prompt; char input[128]; c_prompt = (*env)-&gt;GetStringUTFChars(env, prompt, NULL); if(c_prompt == NULL) &#123; printf(&quot;GetStringUTFChars return NULL.\n&quot;); return NULL; &#125; printf(&quot;%s&quot;, c_prompt); // 这里记得释放字符串占用的空间 (*env)-&gt;ReleaseStringUTFChars(env, prompt, c_prompt);// scanf(&quot;%s&quot;, input); gets(input); // 返回创建的String对象 return (*env)-&gt;NewStringUTF(env, input);&#125; 动态注册方式 动态注册JNI方法，签名的Java文件不用改，需要改的是Native侧的实现部分，下面是修改后的c文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;jni.h&gt;#include &lt;stdio.h&gt;JNIEXPORT jstring JNICALL native_getInformation(JNIEnv * env, jobject obj, jstring prompt)&#123; jbyte * c_prompt; jbyte input[128]; c_prompt = (*env)-&gt;GetStringUTFChars(env, prompt, NULL); if (c_prompt == NULL) &#123; printf(&quot;GetStringUTFChars return NULL.\n&quot;); return NULL; &#125; printf(&quot;%s&quot;, c_prompt); (*env)-&gt;ReleaseStringUTFChars(env, prompt, c_prompt); gets(input); return (*env)-&gt;NewStringUTF(env, input);&#125;const static JNINativeMethod gMethods[] = &#123; &quot;getInformation&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, (void *)native_getInformation&#125;;static jclass myClass;static const char * ClassName = &quot;Practice1&quot;;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM * vm, void * reversed)&#123; JNIEnv * env = NULL; jint result = -1; if((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) return -1; myClass = (*env)-&gt;FindClass(env, ClassName); if(myClass == NULL) &#123; printf(&quot;FindClass return NULL.\n&quot;); return -1; &#125; if((*env)-&gt;RegisterNatives(env, myClass, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) &lt; 0) &#123; printf(&quot;RegisterNatives return error.\n&quot;); return -1; &#125; printf(&quot;-----JNI_OnLoad Success-----\n&quot;); return JNI_VERSION_1_6;&#125; Practice 2现在玩点特别的，现在我们设计一种简单的字符串加密算法，实际的算法部分我们都在native层实现，这样就可以通过编译成动态库（应该不会那么容易被破解查看里面的代码吧？），将算法部分保存起来，达到保护的作用。具体的设置想法如下：在Java侧处理字符串的输入，然后我们将字符串传给native层处理，native层的算法我们设计得简单点咯，第一个字符加1,、第二个字符加2、第三个字符加3、依次类推。字符串解密算法就是加密算法的逆过程，肯定有很多不严谨的地方，所以仅供娱乐练习JNI 2.1 Java侧代码 12345678910111213141516171819202122232425import java.util.Scanner;class Practice2 &#123; private native String string_encode(String input); private native String string_decode(String input); public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Practice2 p = new Practice2(); System.out.println(&quot;Enter the string you want to encode: &quot;); String need_encode_string = sc.nextLine(); String encode_string = p.string_encode(need_encode_string); System.out.println(&quot;After encoded, the string is &quot; + encode_string); System.out.println(&quot;Enter the string you want to decode: &quot;); String need_decode_string = sc.nextLine(); String decode_string = p.string_decode(need_decode_string); System.out.println(&quot;After decoded, the string is &quot; + decode_string); &#125; static &#123; System.loadLibrary(&quot;Practice2&quot;); &#125;&#125; 2.2 Native侧代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;JNIEXPORT jstring JNICALL native_encode_string(JNIEnv * env, jobject obj, jstring input)&#123; // 直接使用JNI函数获取字符串长度 jsize input_length = (*env)-&gt;GetStringUTFLength(env, input); printf(&quot;input_length = %d\n&quot;, input_length); // 分配C缓冲区，这里需要是char *类型，曾试过使用jchar *类型分配，到调用free的时候会出现segment fault char * input_buf = (char *)malloc(input_length + 1); if(input_buf == NULL) &#123; printf(&quot;malloc buffer return error.\n&quot;); return NULL; &#125; // 将字符串内容复制到C缓冲区中 (*env)-&gt;GetStringUTFRegion(env, input, 0, input_length, input_buf); // 按照算法处理 for(int i = 0; i &lt; input_length; i++) &#123; input_buf[i] += i; &#125; input_buf[input_length] = &apos;\0&apos;; // 将加密后的内容生成新的字符串 jstring result = (*env)-&gt;NewStringUTF(env, (const char *)input_buf); free(input_buf); if(result == NULL) &#123; printf(&quot;NewStringUTF return error.\n&quot;); return NULL; &#125; else return result;&#125;JNIEXPORT jstring JNICALL native_decode_string(JNIEnv * env, jobject obj, jstring input)&#123; jsize input_length = (*env)-&gt;GetStringUTFLength(env, input); char * input_buf = (char *)malloc(input_length + 1); if(input_buf == NULL) &#123; printf(&quot;malloc buffer return error.\n&quot;); return NULL; &#125; (*env)-&gt;GetStringUTFRegion(env, input, 0, input_length, input_buf); // 按照算法解密 for(int i = 0; i &lt; input_length; i++) &#123; input_buf[i] -= i; &#125; input_buf[input_length] = &apos;\0&apos;; jstring result = (*env)-&gt;NewStringUTF(env, (const char *)input_buf); free(input_buf); if(result == NULL) &#123; printf(&quot;NewStringUTF return error.\n&quot;); return NULL; &#125; else return result;&#125;const static JNINativeMethod gMethods[] = &#123; &#123;&quot;string_encode&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, native_encode_string&#125;, &#123;&quot;string_decode&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, native_decode_string&#125;&#125;;static jclass myClass;static const char * ClassName = &quot;Practice2&quot;;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM * vm, void * reversed)&#123; JNIEnv * env = NULL; if((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; printf(&quot;GetEnv return error.\n&quot;); return -1; &#125; myClass = (*env)-&gt;FindClass(env, ClassName); if(myClass == NULL) &#123; printf(&quot;FindClass return error.\n&quot;); return -1; &#125; if((*env)-&gt;RegisterNatives(env, myClass, gMethods, sizeof(gMethods)/sizeof(gMethods[0])) &lt; 0) &#123; printf(&quot;RegisterNatives return error.\n&quot;); return -1; &#125; return JNI_VERSION_1_6;&#125; 最后编译运行就可以了。 Practice 3下面测试下时间性能，在Java侧编写一个冒泡排序算法，在native也编写一个冒泡排序算法，比较这两个时间性能，这里不能仅仅侧native的时间性能，还应该包括调用JNI的时间。一样仅供JNI编程练习，别太较真。 3.1 Java侧代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Random;class Practice3 &#123;private native void bubble_sort(int[] iarray, int arr_length);private static final int ARRAY_SIZE = 100000;private void BubbleSort(int[] iarray, int arr_length) &#123; int temp; for (int n=0; n&lt;arr_length; n++) &#123; for (int m=n+1; m&lt;arr_length; m++) &#123; if(iarray[n] &gt; iarray[m]) &#123; temp = iarray[n]; iarray[n] = iarray[m]; iarray[m] = temp; &#125; &#125; &#125;&#125;public static void main(String args[]) &#123; int max = 10000; int[] OriArray = new int[ARRAY_SIZE]; int[] NativeArray = new int[ARRAY_SIZE]; int[] JavaArray = new int[ARRAY_SIZE]; Random random = new Random(); Practice3 p = new Practice3(); System.out.println(&quot;General Array:&quot;); for(int i = 0; i &lt; ARRAY_SIZE; i++) &#123; int s = random.nextInt(max); OriArray[i] = s; NativeArray[i] = s; JavaArray[i] = s; &#125; System.out.println(&quot;Java Bubble test:&quot;); long JavaStart = System.currentTimeMillis(); p.BubbleSort(JavaArray, ARRAY_SIZE); long JavaEnd = System.currentTimeMillis(); System.out.println(&quot;Java bubble sort need &quot; + ((JavaEnd - JavaStart) / 1000.0) + &quot; seconds&quot;); System.out.println(&quot;Native Bubble test:&quot;); long NativeStart = System.currentTimeMillis(); p.bubble_sort(NativeArray, ARRAY_SIZE); long NativeEnd = System.currentTimeMillis(); System.out.println(&quot;Native bubble sort need &quot; + ((NativeEnd - NativeStart) / 1000.0) + &quot; seconds&quot;); System.out.println(&quot;Java sorted array: &quot;); for (int i=0; i&lt;30; i++) &#123; System.out.print(JavaArray[i]); if((i + 1) % 10 == 0) System.out.println(); else System.out.print(&quot; &quot;); &#125; System.out.println(&quot;Native sorted array: &quot;); for (int i=0; i&lt;30; i++) &#123; System.out.print(NativeArray[i]); if((i + 1) % 10 == 0) System.out.println(); else System.out.print(&quot; &quot;); &#125;&#125;static &#123; System.loadLibrary(&quot;Practice3&quot;);&#125;&#125; 3.2 Native侧代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;jni.h&gt;#include &lt;stdio.h&gt;JNIEXPORT void JNICALL native_bubble_sort(JNIEnv * env, jobject obj, jintArray array, jint size)&#123; // 在C空间中获取数组内容 jint * iArray = (*env)-&gt;GetIntArrayElements(env, array, NULL); jint temp = 0; // 对获取到的数组内容进行排序 for(int i = 0; i &lt; size; i++) for(int j = i+1; j &lt; size; j++) &#123; if(iArray[i] &gt; iArray[j]) &#123; temp = iArray[i]; iArray[i] = iArray[j]; iArray[j] = temp; &#125; &#125; // 对排序后的数组内容写回到Java虚拟机中 (*env)-&gt;SetIntArrayRegion(env, array, 0, size, iArray); // 释放资源 (*env)-&gt;ReleaseIntArrayElements(env, array, iArray, 0); return;&#125;const static JNINativeMethod gMethods[] = &#123; &#123;&quot;bubble_sort&quot;, &quot;([II)V&quot;, native_bubble_sort&#125;&#125;;static jclass myClass;static const char * ClassName = &quot;Practice3&quot;;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM * vm, void * reversed)&#123; JNIEnv * env = NULL; if((*vm)-&gt;GetEnv(vm, (void **)&amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; printf(&quot;GetEnv return error.\n&quot;); return -1; &#125; myClass = (*env)-&gt;FindClass(env, ClassName); if(myClass == NULL) &#123; printf(&quot;FindClass return error.\n&quot;); return -1; &#125; if((*env)-&gt;RegisterNatives(env, myClass, gMethods, sizeof(gMethods)/sizeof(gMethods[0])) &lt; 0) &#123; printf(&quot;RegisterNatives return error.\n&quot;); return -1; &#125; return JNI_VERSION_1_6;&#125; 最后发现，上面的代码，在Java侧做冒泡排序，I5-3320M的CPU，需要15.几秒，而native侧就要18.几秒，一方面Java调用native方法比Java调用Java方法要耗时，其次从虚拟机中复制数组数据到C缓冲区中也要时间。所以怎么看好像在native侧做排序都没有占到好处，不过也可能是native方法编写得不够有效率，不过目前就先这样了，毕竟才重新开始学JNI，有很多地方还不够熟悉的，后续有机会找到好方法再改进。 第四章 字段和方法 现在你已经知道了JNI是如何让本地代码访问基本数据类型和引用类型，例如字符串和数组，下一步需要学习怎么样和任意对象的字段和方法进行交互。除了访问字段外，这里还包括在本地代码中调用使用Java编程语言编写的方法，这通常称为从本地代码执行回调。 我们将首先介绍支持字段访问和方法回调的JNI函数。本章的后面部分我们会讨论通过简单但是有效的缓存技术使这些操作更加有效率。本章最后部分，我们会讨论调用本地方法和从本地方法中访问字段以及执行回调的性能特性。 4.1 访问字段 Java编程语言支持两种类型的字段。类的每个实例对象都有该类实例字段的单独副本，而类的所有实例都贡献该类的静态字段。JNI提供方法使得本地代码能够获取或者设置对象中的实例字段和类中的静态字段。让我们首先看一个例子程序，看该例子是如何本地代码实现是如何访问实例字段的。 1234567891011121314class InstanceFieldAccess &#123; private String s; private native void accessField(); public static void main(String args[]) &#123; InstanceFieldAccess c = new InstanceFieldAccess(); c.s = &quot;abc&quot;; c.accessField(); System.out.println(&quot;In Java:&quot;); System.out.println(&quot; c.s = \&quot;&quot; + c.s + &quot;\&quot;&quot;); &#125; static &#123; System.loadLibrary(&quot;InstanceFieldAccess&quot;); &#125; &#125; InstanceFiledAccess类定义了一个实例字段s，main方法中创建类一个该类的对象，设置实例字段，然后调用本地方法InstanceFiledAccess.accessFiled。我们即将会看到，本地方法会打印实例字段现在得值，然后再将该实例字段的值设置为一个新的值。等到本地方法返回后，我们会再次打印这个字段的值，以演示该字段的值确实是改变了。下面是本地方法InstanceFiledAccess.accessField方法的具体实现： 1234567891011121314151617181920212223242526272829303132JNIEXPORT void JNICALLJava_InstanceFieldAccess_accessField(JNIEnv *env, jobject obj) &#123; jfieldID fid; /* store the field ID */ jstring jstr; const char *str; /* Get a reference to obj’s class */ jclass cls = (*env)-&gt;GetObjectClass(env, obj); printf(&quot;In C:\n&quot;); /* Look for the instance field s in cls */ fid = (*env)-&gt;GetFieldID(env, cls, &quot;s&quot;,&quot;Ljava/lang/String;&quot;); if (fid == NULL) &#123; return; /* failed to find the field */ &#125; /* Read the instance field s */ jstr = (*env)-&gt;GetObjectField(env, obj, fid); str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); if (str == NULL) &#123; return; /* out of memory */ &#125; printf(&quot; c.s = \&quot;%s\&quot;\n&quot;, str); (*env)-&gt;ReleaseStringUTFChars(env, jstr, str); /* Create a new string and overwrite the instance field */ jstr = (*env)-&gt;NewStringUTF(env, &quot;123&quot;); if (jstr == NULL) &#123; return; /* out of memory */ &#125; (*env)-&gt;SetObjectField(env, obj, fid, jstr);&#125; 搭配InstanceFieldAccess本地库执行InstanceFiledAccess可以得到如下输出： 1234In C: c.s = &quot;abc&quot; In Java: c.s = &quot;123&quot; 4.1.1 访问实例字段的过程 要访问实例字段，本地方法遵循两步过程。首先，调用GetFieldID从类引用、字段名和字段描述符中取得字段ID。 1fid = (*env)-&gt;GetFieldID(env, cls, &quot;s&quot;, &quot;Ljava/lang/String;&quot;); 这个示例代码通过在实例引用obj上调用GetObjectClass来获得类引用，obj引用将作为第二个参数传送给本地方法实现。 你一旦取得了字段ID，你可以将对象引用和字段ID传给合适的实例字段访问函数： 1jstr = (*env)-&gt;GetObjectField(env, obj, fid); 因为字符串和数组是特殊类型的对象，我们使用GetObjectField来访问字符串实例字段。除了Get/SetObjectField外，JNI还支持其他的函数例如GetIntField和SetFloatField来访问基本数据类型的实例字段。 4.1.2 字段描述符 你可能注意到在上一节中，我们使用了特殊编码的C字符串”Ljava/lang/String”来代表Java编程语言中的实例字段。这些C字符串就称为JNI字段描述符。 字符串的内容是由声明的字段决定的。例如，使用“I”代表一个int字段，“F”代表float字段，“D”代表double字段，“Z”代表boolean字段。 引用类型的字段描述符，例如java.lang.String，以字母L开头，紧接着是JNI类描述字段并以分号作为终结符。完全限定类名中的“.”分隔符在JNI类描述符中更改为“/”，因此你为类型为java.lang.String的字段形成的字段描述符为：”Ljava/lang/String;”。 数组类型的描述符包含“[”字符，紧接着是数组组件类型的描述符。例如，“[I”是int[]字段类型的字段描述符。12.3.3节（图片先放一下）包含字段描述符的细节以及其在Java编程语言中的对应类型。 你可以使用javap工具（随JDK或者Java 2 SDK一同发布）从类文件中生成字段描述符。通常javap会打印给定类的方法和字段类型，如果你使用-s选项（和-p选项来显示私有成员），javap只打印JNI描述符。 1javap -s -p InstanceFieldAccess 上面的指令会给出包含字段s的JNI描述符信息： 123...s Ljava/lang/String; ... 使用javap工具有助于消除手工导出JNI描述符字符串时可能发生的错误。 4.1.3 访问静态字段让我们看看InstanceFieldAccess示例的一个小小的变化： 1234567891011121314class StaticFielcdAccess &#123; private static int si; private native void accessField(); public static void main(String args[]) &#123; StaticFieldAccess c = new StaticFieldAccess(); StaticFieldAccess.si = 100; c.accessField(); System.out.println(&quot;In Java:&quot;); System.out.println(&quot; StaticFieldAccess.si = &quot; + si); &#125; static &#123; System.loadLibrary(&quot;StaticFieldAccess&quot;); &#125; &#125; StaticFieldAccess类包含一个静态整型资源si，StaticFieldAccess.main方法首先创建一个对象，初始化静态字段，然后调用本地方法StaticFieldAccess.accessField。正如我们即将见到的那样，本地方法先打印静态字段现在的值，然后给该静态字段设置一个新的值。为了验证这个静态字段的值是否真的改变了，在调用完该静态方法后再次打印该静态字段的值。 下面是静态方法StaticFieldAccess.accessField的实现代码： 12345678910111213141516171819JNIEXPORT void JNICALLJava_StaticFieldAccess_accessField(JNIEnv *env, jobject obj) &#123; jfieldID fid; /* store the field ID */ jint si; /* Get a reference to obj’s class */ jclass cls = (*env)-&gt;GetObjectClass(env, obj); printf(&quot;In C:\n&quot;); /* Look for the static field si in cls */ fid = (*env)-&gt;GetStaticFieldID(env, cls, &quot;si&quot;, &quot;I&quot;); if (fid == NULL) &#123; return; /* field not found */ &#125; /* Access the static field si */ si = (*env)-&gt;GetStaticIntField(env, cls, fid); printf(&quot; StaticFieldAccess.si = %d\n&quot;, si); (*env)-&gt;SetStaticIntField(env, cls, fid, 200);&#125; 使用本地库运行程序会产生以下输出： 1234In C: StaticFieldAccess.si = 100 In Java: StaticFieldAccess.si = 200 如何访问一个静态字段和如何访问一个实例字段存在两个不同的地方： 对于静态字段，你应该调用GetStaticFieldID，而相对的对于实例字段，你应该调用GetFieldID。GetStaticFieldID和GetFieldID都有相同的返回类型就fieldID。 一旦取得了静态字段ID，你将类引用传送类引用给合适静态字段访问函数，而对于实例字段，你应该传送对象引用。 4.2 调用方法 在Java编程语言中，存在几种类型的方法。实例方法必须通过特定类的实例来调用，而静态方法可以独立于任何实例被调用。下一节我们将讨论构造函数。 JNI支持一组完整的函数，允许你在本地代码中进行回调操作。下面的示例程序中包含本地方法，它依次调用用Java语言实现的实例方法。 12345678910111213class InstanceMethodCall &#123; private native void nativeMethod(); private void callback() &#123; System.out.println(&quot;In Java&quot;); &#125; public static void main(String args[]) &#123; InstanceMethodCall c = new InstanceMethodCall(); c.nativeMethod(); &#125; static &#123; System.loadLibrary(&quot;InstanceMethodCall&quot;); &#125; &#125; 下面是本地代码的实现： 12345678910JNIEXPORT void JNICALLJava_InstanceMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; jclass cls = (*env)-&gt;GetObjectClass(env, obj); jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;callback&quot;, &quot;()V&quot;); if (mid == NULL) &#123; return; /* method not found */ &#125; printf(&quot;In C\n&quot;); (*env)-&gt;CallVoidMethod(env, obj, mid); &#125; 运行上面的程序可以获得如下输出： 12In CIn Java 4.2.1 调用实例方法 Java_InstanceMethodCall_nativeMethod方法实现表明需要两个步骤来调用一个实例方法： 本地方法首先调用JNI方法GetMethodID。GetMethodID对给定的类进行方法查询。查询是基于方法的名字和方法的类型描述符的。如果这个方法不存在，GetMethodID放回NULL，在这个点上，从本地方法立刻返回并且会导致在调用InstanceMethodCall.nativeMethod的代码中抛出NoSuchMethodError异常。 本地方法然后调用CallVoidMethod。Ca llVoidMethod调用一个返回类型为void的实例方法。你将对象，方法ID和实际的参数（但是上面的实例中，这些都为空）传送给CallVoidMethod。 除了CallVoidMethod方法外，JNI支持其他返回类型的方法调用函数。例如，如果你回调的方法返回一个int类型的值，然后你的本地方法可以使用CallIntMethod。类似的，你可以使用CallObjectMethod来调用返回值为对象（包含java.lang.String实例和数组）的方法。 你可以使用CallMethod系列函数来调用接口函数。你必须从接口类型中导出方法ID。下面的代码片段，在一个java.lang.Thread实例中调用Runnable.run方法： 123456789101112jobject thd = ...; /* a java.lang.Thread instance */ jmethodID mid;jclass runnableIntf =(*env)-&gt;FindClass(env, &quot;java/lang/Runnable&quot;); if (runnableIntf == NULL) &#123; ... /* error handling */&#125;mid = (*env)-&gt;GetMethodID(env, runnableIntf, &quot;run&quot;, &quot;()V&quot;); if (mid == NULL) &#123; ... /* error handling */ &#125;(*env)-&gt;CallVoidMethod(env, thd, mid); ... /* check for possible exceptions */ 我们已经在3.3.5节中看到过FindClass返回一个明明类的引用。这里我们也可以用它来获取一个命名接口的引用。 4.2.2 生成方法描述符 JNI使用描述符字符串来表示方法类型，类似于它如何表示字段类型。方法描述符组合了参数类型和返回类型。参数类型首先出现，并被一对括号括起来，参数类型按照方法声明的中的顺序列出。多个参数之间没有分隔符，如果一个方法没有参数，则用一对空的圆括号表示。将方法的返回类型放在参数类型的右括号后面。 举个例子，“(I)V”表明该方法有一个类型为int的参数并且返回类型为void。“()D”表明该方法不需要参数并且返回一个double值。不要让C函数原型如“int f(void)”误导你认为“(V)I”是一个有效的方法描述符，这里应该使用“()I”作为其方法描述符。方法描述符可能包含类描述符，例如如下方法： 1native private String getLine(String); 其方法描述符为 1(Ljava/lang/String;)Ljava/lang/String; 12.3.4节给出了如何构建JNI方法描述符的完整描述。你可以使用javap工具打印JNI方法描述符。例如执行如下指令： 1javap -s -p InstanceMethodCall 你可以获取到如下输出信息： 12345...private callback ()Vpublic static main ([Ljava/lang/String;)V private native nativeMethod ()V ... -s标志通知javap输出JNI描述符字符串，而不是他们在Java编程语言中出现类型。-p标志使javap在其输出中包含有关该类的私有成员的信息 4.2.3 调用静态方法 前面的例子演示了在本地代码中如何调用一个实例方法。类似的，你可以通过下面的一些步骤从本地方法中进行静态方法回调： 通过GetStaticMethodID获取静态方法ID，而不是GetMethodID 将类、方法ID和参数传给静态方法调用函数之一：CallStaticVoidMethod，CallStaticBooleanMethod等。 在允许你调用静态方法的函数和允许你调用实例方法的函数中有一个关键性的区别，前者使用类引用作为参数，而后者使用对象引用作为参数。例如：将类引用传递给CallStaticVoidMethod，但是将对象引用传递给CallVoidMethod。 在Java编程语言层面，您可以使用两种可选语法来调用类Cls中的静态方法f：Cls.f或obj.f，其中obj是Cls的实例。（后者是推荐的编程风格。）在JNI中，当从本地代码发出静态方法调用时，必须始终指定类引用。 让我们看一个实例：在静态代码中使用回调调用一个静态方法。它和之前的InstanceMethodCall有一些不同： 12345678910111213class StaticMethodCall &#123; private native void nativeMethod(); private static void callback() &#123; System.out.println(&quot;In Java&quot;); &#125; public static void main(String args[]) &#123; StaticMethodCall c = new StaticMethodCall(); c.nativeMethod(); &#125; static &#123; System.loadLibrary(&quot;StaticMethodCall&quot;); &#125; &#125; 下面是本地方法的实现： 12345678910JNIEXPORT void JNICALLJava_StaticMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; jclass cls = (*env)-&gt;GetObjectClass(env, obj); jmethodID mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;callback&quot;, &quot;()V&quot;); if (mid == NULL) &#123; return; /* method not found */ &#125; printf(&quot;In C\n&quot;); (*env)-&gt;CallStaticVoidMethod(env, cls, mid); &#125; 确保你将通过cls（用粗体突出显示），而不是obj传递给CallStaticVoidMethod。运行上述程序可以得到如下结果： 12In C In Java 4.2.4 调用父类的实例方法 你可以调用在父类中定义但是被实例对象所在的类覆盖的实例方法。JNI为此提供了一组CallNonvirtualMethod方法。要调用超类中定义的实例方法，请执行下面的步骤： 使用GetMethodID而不是GetStaticMethodID从超类引用中获取方法ID 将对象、超类、方法ID和参数传给非虚调用函数系列之一，例如CallNonvirtualVoidMethod、CallNonvirtualBooleanMethod等。 你需要调用超类的实例方法的机会相对较少，该工具类似于使用Java编程语言中的以下构造来调用覆盖的超类方法（如f）： 1super.f(); CallNonvirtualVoidMethod方法同样能够用来调用构造函数，如下节中介绍的一样。 4.3 调用构造方法 在JNI中，可以按照类似于调用实例方法的那些步骤来来调用构造方法。要获取构造方法的方法ID，在方法描述符中将“”作为方法名并且将“V”作为返回类型。然后你可以通过传递方法ID给JNI函数（例如NewObject）来调用构造函数。以下代码实现了JNI函数NewString的等效功能，它从Unicode字符中创建一个java.lang.String对象并存储在一个C缓冲区中： 123456789101112131415161718192021222324252627282930313233jstring MyNewString(JNIEnv *env, jchar *chars, jint len) &#123; jclass stringClass; jmethodID cid; jcharArray elemArr; jstring result; stringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (stringClass == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Get the method ID for the String(char[]) constructor */ cid = (*env)-&gt;GetMethodID(env, stringClass, &quot;&quot;, &quot;([C)V&quot;); if (cid == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Create a char[] that holds the string characters */ elemArr = (*env)-&gt;NewCharArray(env, len); if (elemArr == NULL) &#123; return NULL; /* exception thrown */ &#125; (*env)-&gt;SetCharArrayRegion(env, elemArr, 0, len, chars); /* Construct a java.lang.String object */ result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr); /* Free local references */ (*env)-&gt;DeleteLocalRef(env, elemArr); (*env)-&gt;DeleteLocalRef(env, stringClass); return result;&#125; 这个例子是复杂的，值得进行仔细的分析。首先，FindClass返回java.lang.String类的引用。下一步，GetMethodID返回字符串构造函数（String(char[] chars)）的方法ID。然后我们调用NewCharArray分配一个字符数组来存放所有的字符元素。JNI函数调用由方法ID指定的构造函数。NewObject将需要构造的类的引用、构造函数的方法ID和需要传送给构造方法的参数作为参数。 DeleteLocalRef调用允许虚拟机释放elemArr和stringClass占用的本地资源。5.2.1节会提供一个详细的描述说明什么时候和为什么需要调用DeleteLocalRef。 字符串是对象，这个例子进一步突出了这一点。但是这个例子也引出了一个问题。鉴于我们可以使用其他的JIN函数实现等效的功能，为什么JNI还要提供NewString之类的函数呢？这是因为内置的字符串函数要比本地代码调用java.lang.String API更有效率。因为String是最使用的对象类型，所以在JNI中值得特别支持。 也可以使用CallNonvirtualVoidMethod函数调用构造函数。在这种情况下，本地代码必须首先通过AllocObject函数创建一个为初始化的对象。上面的单个NewObject调用 1result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr); 可以被AllocObject后跟一个CallNonvirtualVoidMethod代替。 123456789result = (*env)-&gt;AllocObject(env, stringClass); if (result) &#123; (*env)-&gt;CallNonvirtualVoidMethod(env, result, stringClass, cid, elemArr); /* we need to check for possible exceptions */ if ((*env)-&gt;ExceptionCheck(env)) &#123; (*env)-&gt;DeleteLocalRef(env, result); result = NULL; &#125;&#125; AllocObject创建一个为初始化的对象，并且必须小心使用，以便每个对象最多调用一个构造函数。本地代码不应该在同一个对象上多次调用构造函数。 有时候你会发现，先创建一个为初始化的对象然后调用构造函数是非常有用的。但是在更多的时候你应该调用NewObject，并避免使用更容易产生错误的AllocObject/CallNonvirtualVoidMethod方法对。 4.4 缓存字段和方法ID 获取字段和方法ID需要基于字段和方法ID的名字和描述符进行符号查找。符号查找消耗相对较多，本节我们将介绍一种能够减少这种开销的技术。这种方法是计算字段和方法ID，然后缓存它们以便后续重复使用。有两种方法来缓存字段和方法ID，具体取决于是在使用字和方法ID时执行缓存还是在静态初始化块中定义字段或者方法来执行缓存。 4.4.1 在使用时执行缓存 字段或者方法ID可以在本地代码访问字段值或者执行方法回调的时候被缓存。在下面的Java_InstanceFieldAccess_accessField函数实现中，使用静态变量对方法ID进行缓存，以便在每次调用InstanceFieldAccess.accessField方法时，不需要重新计算了。 123456789101112131415161718192021222324252627282930JNIEXPORT void JNICALLJava_InstanceFieldAccess_accessField(JNIEnv *env, jobject obj) &#123; static jfieldID fid_s = NULL; /* cached field ID for s */ jclass cls = (*env)-&gt;GetObjectClass(env, obj); jstring jstr; const char *str; if (fid_s == NULL) &#123; fid_s = (*env)-&gt;GetFieldID(env, cls, &quot;s&quot;, &quot;Ljava/lang/String;&quot;); if (fid_s == NULL) &#123; return; /* exception already thrown */ &#125; &#125; printf(&quot;In C:\n&quot;); jstr = (*env)-&gt;GetObjectField(env, obj, fid_s); str = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); if (str == NULL) &#123; return; /* out of memory */ &#125; printf(&quot; c.s = \&quot;%s\&quot;\n&quot;, str); (*env)-&gt;ReleaseStringUTFChars(env, jstr, str); jstr = (*env)-&gt;NewStringUTF(env, &quot;123&quot;); if (jstr == NULL) &#123; return; /* out of memory */ &#125; (*env)-&gt;SetObjectField(env, obj, fid_s, jstr); &#125; 加粗显示的静态变量fid_s保存了为InstanceFiledAccess.s预先计算的方法ID。该静态变量初始化为NULL，当InstanceFieldAccess.accessField方法第一次被调用时，它计算该字段ID然后将其缓存到该静态变量中以方便后续使用。 你可能注意到上面的代码中存在着明显的竞争条件。多个线程可能同时调用InstanceFieldAccess.accessField方法并且同时计算相同的字段ID。一个线程可能会覆盖另一个线程计算好的静态变量fid_s。幸运的是，虽然这种竞争条件在多线程中导致重复的工作，但是明显是无害的。同一个类的同一个字段被多个线程计算出来的字段ID必然是相同的。 根据上面的想法，我们同样可以在MyNewString例子的开始部分缓存java.lang.String构造方法的方法ID。 123456789101112131415161718192021222324252627282930313233343536jstringMyNewString(JNIEnv *env, jchar *chars, jint len) &#123; jclass stringClass; jcharArray elemArr; static jmethodID cid = NULL; jstring result; stringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (stringClass == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Note that cid is a static variable */ if (cid == NULL) &#123; /* Get the method ID for the String constructor */ cid = (*env)-&gt;GetMethodID(env, stringClass, &quot;&quot;, &quot;([C)V&quot;); if (cid == NULL) &#123; return NULL; /* exception thrown */ &#125; &#125; /* Create a char[] that holds the string characters */ elemArr = (*env)-&gt;NewCharArray(env, len); if (elemArr == NULL) &#123; return NULL; /* exception thrown */ &#125; (*env)-&gt;SetCharArrayRegion(env, elemArr, 0, len, chars); /* Construct a java.lang.String object */ result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr); /* Free local references */ (*env)-&gt;DeleteLocalRef(env, elemArr); (*env)-&gt;DeleteLocalRef(env, stringClass); return result;&#125; 当MyNewString第一次被调用的时候，我们为java.lang.String构造器计算方法ID。加粗突出显示的静态变量cid缓存这个结果。 4.4.2 在类的静态初始化块中执行缓存 当我们在使用时缓存字段或方法ID的时候，我们必须引入一个坚持来坚持字段或方法ID是否已被缓存。当ID已经被缓存时，这种方法不仅在“快速路径”上产生轻微的性能影响，而且还可能导致缓存和检查的重复工作。举个例子，如果多个本地方法全部需要访问同一个字段，然后他们就需要计算和检查相应的字段ID。在许多情况下，在程序能够有机会调用本地方法前，初始化本地方法所需要的字段和方法ID会更为方便。虚拟机会在调用该类中的任何方法前，总是执行类的静态初始化器。因此，一个计算并缓存字段和方法ID的合适位置是在该字段和方法ID的类的静态初始化块中。例如，要缓存InstanceMethodCall.callback的方法ID，我们引入了一个新的本地方法initIDs，它由InstanceMethodCall类的静态初始化器调用： 123456789101112131415class InstanceMethodCall &#123; private static native void initIDs(); private native void nativeMethod(); private void callback() &#123; System.out.println(&quot;In Java&quot;); &#125; public static void main(String args[]) &#123; InstanceMethodCall c = new InstanceMethodCall(); c.nativeMethod(); &#125; static &#123; System.loadLibrary(&quot;InstanceMethodCall&quot;); initIDs(); &#125; &#125; 跟4.2节的原始代码相比，上面的程序包含二外的两行（用粗体突出显示），initIDs的实现仅仅是简单的为InstanceMethodCall.callback计算和缓存方法ID。 12345jmethodID MID_InstanceMethodCall_callback; JNIEXPORT void JNICALL Java_InstanceMethodCall_initIDs(JNIEnv *env, jclass cls) &#123; MID_InstanceMethodCall_callback = (*env)-&gt;GetMethodID(env, cls, &quot;callback&quot;, &quot;()V&quot;); &#125; 在InstanceMethodCall类中，在执行任何任何方法（例如nativeMethod或main）之前虚拟机先运行静态初始化块。当方法ID已经缓存到一个全局变量中，InstanceMethodCall.nativeMethod方法的本地实现就不再需要执行符号查找了。 12345JNIEXPORT void JNICALLJava_InstanceMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; printf(&quot;In C\n&quot;); (*env)-&gt;CallVoidMethod(env, obj, MID_InstanceMethodCall_callback); &#125; 4.4.3 缓存ID的两种方法之间的比较 如果JNI程序员无法控制定义了字段和方法的类的源代码，那么在使用时缓存ID是合理的解决方案。例如在MyNewString例子当中，我们没有办法为了预先计算和缓存java.lang.String构造器的方法ID而向java.lang.String类中插入一个用户定义的initIDs本地方法。与在定义类的静态初始化块中执行缓存相比，在使用时进行缓存存在许多缺点： 如之前解释，在使用的时候进行缓存，在快速路径执行过程中需要进行检查，而且可能对同一个字段和方法ID进行重复的检查和初始化。 方法和字段ID仅在类卸载前有效，如果你是在运行时缓存字段和方法ID，则必须确保只要本地代码仍然依赖缓存ID的值时，定义类就不能被卸载或者重新加载。（下一章将介绍如何通过使用JNI创建对该类的引用来保护类不被卸载。）另一方面，如果缓存是在定义类的静态初始化块中完成的，当类被卸载并稍后重新加载时，缓存的ID将会自动重新计算。 因此在可行的情况下，最好在其定义类的静态初始化块中缓存字段和方法ID。 4.5 JNI字段和方法的操作性能 知道如何缓存字段和方法ID以提高性能后，你可能在想：使用JNI访问字段和调用方法的性能特性如何？从本地代码中执行方法回调的成本和调用本地方法的成本以及调用常规方法的成本相比如何？这个问题的答案无疑取决于底层虚拟机实现JNI的效率性了。因此不可能给出准确的性能特性，这些性能特性被保证适用于各种各样的虚拟机实现。相反我们将会分析本地方法调用和JNI字段和方法操作的固有成本，并未JNI程序员和实现者提供一般的性能指南。让我们首先开始比较Java/native调用和Java/Java调用的成本。由于以下的原因Java/native调用可能比Java/Java调用慢： 在Java虚机实现中，本地方法调用最有可能遵循与Java/Java调用不同的约定。因此，虚拟机必须执行额外的操作来构建参数，并在跳到本地方法入口之前设置堆栈结构。 虚拟机经常使用内联方法调用。内联Java/native调用比内联Java/Java调用要困难得多。 我们估计，一个典型的虚拟机实现执行Java/native调用比执行Java/Java调用大概慢两到三倍。因为Java/Java调用只需要几个周期，所以额外的开销基本可以忽略不计，除非本地方法执行一些微不足道的操作。构建一个Java虚拟机实现，让其Java/native调用性能接近或者等于Java/Java调用是可行的。（例如，这种虚拟机可以将JNI调用规则调整为和Java/Java调用规则一样。） native/Java回调的性能特性在技术上类似于Java/native调用。理论上，native/Java回调的开销也可能是Java/Java调用的两到三倍内。但是在实际上，native/Java调用相对少见，虚拟机通常不会优化优化回调性能。在撰写本文时，许多虚拟机实现使得native/Java回调的开销可以比Java/Java调用高出10倍。 使用JNI进行字段访问的开销主要是通过JNIEnv调用的成本。本地代码不是直接引用对象，而是通过C调用的返回值来引用对象。函数调用时必须的，因为它将本地代码与虚拟机实现维护的内部兑现表示隔离起来。JNI字段访问的开销是可以忽略不计的，因为函数调用只需要几个周期 第五章 本地和全局引用 JNI将实例和数组类型（例如jobject、jclass、jstring和jarray）公开为不透明引用。本地代码不能直接检查不透明引用指针的内容。而是通过JNI函数来获取不透明引用所指向的数据结构。通过处理不透明引用，你不必担心依赖于特定Java虚拟机的内部对象数据结构布局。但是，在JNI中，你需要了解更多有关于不同类型的引用： JNI支持三中透明引用：本地引用，全局引用和弱全局引用 本地和全局引用拥有不同的生命周期。本地引用会被自动回收，而全局引用和弱全局引用会一直存在直到程序员将其释放 一个本地或全局引用保持被引用的对象不会被垃圾回收。但是一个弱全局引用允许被引用的对象呗垃圾回收。 并非所有的引用都可以在所有的上下文中使用。例如，在创建引用返回后的本地代码中使用本地引用是非法的。 在本章中，我们将详细讨论这些问题。 正确管理JNI引用对于编写可靠和节省空间的代码至关重要。 5.1 本地和全局引用 什么是本地和全局引用，以及他们有什么不同呢？我们会用一系列的实例来说明本地和全局引用。 5.1.1 本地引用大多数JNI方法会创建本地引用。例如，JNI方法NewObject创建一个新的实例对象并返回引用该对象的本地引用。 本地引用仅在创建它的本地方法的动态上下文中有效，并且仅在该方法的一次调用中有效。在本地方法执行期间创建的所有本地引用将在本地方法返回后被释放。 不能在本地方法中通过静态变量来储存本地引用，并在后续调用中使用相同的引用。例如下面的代码，是4.4.4节的MyNewString方法的修改版本，在这里使用了不正确的本地引用。 123456789101112131415161718192021/* This code is illegal */ jstringMyNewString(JNIEnv *env, jchar *chars, jint len) &#123; static jclass stringClass = NULL; jmethodID cid; jcharArray elemArr; jstring result; if (stringClass == NULL) &#123; stringClass = (*env)-&gt;FindClass(env, “java/lang/String”); if (stringClass == NULL) &#123; return NULL; &#125; &#125; /* It is wrong to use the cached stringClass here, because it may be invalid. */ cid = (*env)-&gt;GetMethodID(env, stringClass, &quot;&quot;, &quot;([C)V&quot;); ... elemArr = (*env)-&gt;NewCharArray(env, len); ... result = (*env)-&gt;NewObject(env, stringClass, cid, elemArr); (*env)-&gt;DeleteLocalRef(env, elemArr); return result;&#125; 这里已经消除了和我们将要讨论的没有直接关系的行。在静态变量中缓存stringClass的目的可能是想消除重复执行如下函数调用的开销： 1FindClass(env, &quot;java/lang/String&quot;); 这不是正确的方法，因为FindClass返回一个指向java.lang.String类对象的本地引用。下面分析为什么这样会引发问题，假设C.f本地方法实现调用MyNewString： 12345JNIEXPORT jstring JNICALL Java_C_f(JNIEnv *env, jobject this) &#123; char *c_str = ...; ... return MyNewString(c_str); &#125; 在本地方法C.f调用返回后，虚拟机会释放所有在Java_C_f运行期间创建的本地引用。这些释放的本地引用包括对储存在stringClass变量中的类对象的本地引用。在后面，MyNewString调用将会尝试使用一个无效的本地引用，这可能导致内存损坏或者引发系统崩溃。例如，如下的代码片段使两个连续的调用到C.f并导致MyNewString遇到无效的本地引用： 1234...... = C.f(); // The first call is perhaps OK. ... = C.f(); // This would use an invalid local reference.... 有两种方法能够使一个本地方法无效。如前所述，在本地方法返回后，虚拟机会自动的释放所有在该本地方法执行期间创建的本地引用。另外，程序员可能想使用JNI函数例如，DeleteLocalRef来显示的管理本地引用的生命周期。 如果虚拟机会在本地方法返回后自动释放，为什么还需要显示释放本地引用呢？本地引用防止被引用的对象被垃圾收集器回收，一直持续到本地引用无效为止。例如，在MyNewString中的DeleteLocalRef调用允许数组对象elemArr立即被垃圾收集器回收。否则，虚拟机只会在MyNewString调用的本地方法返回后（例如上面的C.f）释放elemArr对象。 一个本地引用在其销毁之前，可能传递给多个本地方法。例如，MyNewString方法返回一个通过NewObject创建的字符串引用。然后由MyNewString的调用者决定是否释放由MyNewString返回的本地引用。在Java_C_f例子中，C.f又作为本地方法调用的结果返回MyNewString的结果。在虚拟机从JAVA_C_f函数接收到本地引用后，他将底层字符串对象给c.f的调用者然后销毁最初由JNI函数NewObject创建的本地引用，然后销毁最初由JNI函数NewObject创建的本地引用。 地引用当然仅在创建它的线程中有效。在一个线程中创建的本地引用不能够在其他线程中使用。在本地方法中将本地引用储存在全局变量中，并期望在另一个线程中使用是一个编程错误。 5.1.2 全局引用 你可以在跨多个本地方法调用中使用全局变量。全局引用可以跨多线程使用并保持有效，直到程序员释放它为止。和本地引用一样，一个全局引用能够确保被引用的对象不会被垃圾收集器回收。 和本地引用不同的是，本地引用可以通过大多数JNI函数创建，但是全局引用只可以通过一个JNI方法（NewGlobalRef）创建。接下来的MyNewString版本显示如何使用全局引用。我们突出显示下面的代码和在上一节中错误地缓存本地引用的代码之间的区别： 123456789101112131415161718192021222324/* This code is OK */ jstring MyNewString(JNIEnv *env, jchar *chars, jint len) &#123; static jclass stringClass = NULL; ... if (stringClass == NULL) &#123; jclass localRefCls = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); if (localRefCls == NULL) &#123; return NULL; /* exception thrown */ &#125; /* Create a global reference */ stringClass = (*env)-&gt;NewGlobalRef(env, localRefCls); /* The local reference is no longer useful */ (*env)-&gt;DeleteLocalRef(env, localRefCls); /* Is the global reference created successfully? */ if (stringClass == NULL) &#123; return NULL; /* out of memory exception thrown */ &#125; &#125; ... &#125; 这个修改版本中将从FindClass返回的本地引用传送给NewGlobalRef，该方法创建一个指向java.lang.String对象的全局引用。我们检查在删除localRefCls后NewGlobalRef是否成功创建了stringClass，因为这两种情况下都需要删除本地引用localRefCls。 5.1.3 弱全局引用 弱全局引用是在Java 2 JDK 1.2中新加入的。弱全局引用通过NewGlobalWeakRef创建，通过DeleteGlobalWeakRef释放。和全局引用一样，弱全局引用跨本地方法调用和跨线程调用依旧有效。而和全局引用不同的是，弱全局引用不能防止底层数据对象被垃圾收集器回收。 MyNewString示例显示了如何缓存java.lang.String的全局引用。MyNewString示例可以使用弱全局引用来缓存java.lang.String类。我们是使用全局引用还是弱全局引用并不重要，因为java.lang.String是一个系统类，永远不会被垃圾收集器回收。当本机代码缓存的引用不能使底层对象不被垃圾回收时，弱全局引用变得更加有用。例如，假设一个本地方法mypks.MyCls.f对类mypks.MyCls2进行缓存。在弱全局引用中缓存类仍然允许mypkg.MyCls2被卸载。 1234567891011121314JNIEXPORT void JNICALL Java_mypkg_MyCls_f(JNIEnv *env, jobject self) &#123; static jclass myCls2 = NULL; if (myCls2 == NULL) &#123; jclass myCls2Local = (*env)-&gt;FindClass(env, &quot;mypkg/MyCls2&quot;); if (myCls2Local == NULL) &#123; return; /* can’t find class */ &#125; myCls2 = NewWeakGlobalRef(env, myCls2Local); if (myCls2 == NULL) &#123; return; /* out of memory */ &#125; &#125; ... /* use myCls2 */ &#125; 我们假设MyCls和MyCls2有相同的生命周期（例如，它们可能是通过同一个类加载器加载的）。但是我们没有考虑到这样一个场景，在MyCls及其本地方法实现Java_mypks_MyCls仍在使用的情况下，MyCls2卸载并在稍后重新加载。如果这种情况发生了，我们必须检查缓存的弱引用是否仍然指向一个存活的类对象，或者指向已经没垃圾收集器回收的类对象。下一节将介绍如何对弱全局引用执行此类检查。 5.1.4 引用比较 在给定的两个本地、全局、弱全局引用中，可以使用IsSameObject方法来检查它们是否引用同一个对象。例如： 1(*env)-&gt;IsSameObject(env, obj1, obj2) 如果obj1和obj2引用同一个对象，那么这个方法就放回JNI_TRUE（或者1），否则返回JNI_FALSE（或者0）。 在JNI中，NULL引用是指向Java虚拟机中的空对象，如果obj是被本地或者全局引用，则可以使用： 1(*env)-&gt;IsSameObject(env, obj, NULL) 或者 1obj == NULL 来确认obj是否引用一个空对象。 弱引用对象使用的规则有一些不同。NULL弱引用引用空对象。 然而，IsSameObject对于弱全局引用具有特殊用途。您可以使用IsSameObject来确定非NULL弱全局引用是否仍然指向一个活动对象。假设wobj是一个非NULL的弱全局引用。以下调用： 1(*env)-&gt;IsSameObject(env, wobj, NULL) 如果wobj引用一个已经被回收的对象，则返回JNI_TRUE，如果wobj仍然引用一个存活的对象，则返回JNI_FALSE。 5.2 释放引用 除了被引用对象占用的内存外，每个JNI引用本身都会消耗一定量的内存。作为一个JNI程序员，你应该了解到你的程序在一个给定的时间内，将会使用的引用数量。特别是，你应该意识到你的程序在执行期间的某个时间点上，允许创建的本地引用数量的上限，即使这些本地引用最后会被虚拟机自动释放。暂时性的过多创建引用，可能会导致内存耗尽。 5.2.1 释放本地引用在大多数情况下，在实现一个本地方法的时候，你不用过多的考虑释放本地对象。当本地方法返回到调用者处时，Java虚拟机会为你释放它们。但是JNI程序员有时候应该显示的释放本地引用以避免内存占用过多。考虑一下情况： 你需要在一个本地方法调用中创建大量的本地引用。这可能导致JNI内部本地引用表溢出，因此立即删除那些不再需要的本地引用将是一个好方法。例如，在以下程序段中，本地代码有遍历一个大的字符串数组的可能。每次迭代后，本地代码应该显示的释放对字符串元素的本地引用。如下所示： 12345for (i = 0; i &lt; len; i++) &#123; jstring jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); ... /* process jstr */ (*env)-&gt;DeleteLocalRef(env, jstr); &#125; 你想编写一个从未知上下文中调用的函数。在第4.3节中显示的MyNewString示例说明使用DeleteLocalRef在函数中快速删除本地引用，否则每次调用MyNewString函数后都会分配两个本地引用。 你的本地方法不会返回。一个本地方法可能进入无限事件调度循环中，释放在循环内创建的本地引用将是非常重要的，这样它们就不会无限积累，导致内存泄漏。 你的本地方法访问一个大对象，因而需要创建该对象的本地引用。然后，native方法在返回给调用者前可以进行额外的计算。对大对象的本地引用将阻止对象在本地方法返回前本垃圾收集器回收，即使对象不再在本地方法的剩余部分使用。例如在以下程序片段中，由于事先已经显示的调用DeleteLocalRef了，因此在执行函数longyComputation时，垃圾收集器可能会释放lref引用的对象。 12345678/* A native method implementation */ JNIEXPORT void JNICALLJava_pkg_Cls_func(JNIEnv *env, jobject this) &#123; lref = ... /* a large Java object */ ... /* last use of lref */ (*env)-&gt;DeleteLocalRef(env, lref); lengthyComputation(); /* may take some time */ return; /* all local refs are freed */&#125; 5.2.2 在Java 2 JDK 1.2中管理本地引用 Java 2 JDK 1.2中提供了一组而外的函数用于管理本地应用的生命周期。这些函数是EnsureLocalCapacity、NewLocalRef、PushLocalFrame和PopLocalFrame。 JNI规范规定虚拟机能够自动确保每个本地方法能够创建至少16个本地引用。经验表明，除了与虚拟机中的对象进行复杂的交互外，对于大多数本地方法，这个数量已经足够。但是如果，需要创建而外的本地引用，那么本地方法可能会发出一个EnsureLocalCapacity调用，以确保有足够的本地引用空间。例如，上述示例的轻微变化为循环执行期间创建的所有本地参考提供足够的容量，如果有足够的内存可用： 123456789/* The number of local references to be created is equal to the length of the array. */if ((*env)-&gt;EnsureLocalCapacity(env, len)) &lt; 0) &#123; ... /* out of memory */&#125; for (i = 0; i &lt; len; i++) &#123; jstring jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); ... /* process jstr */ /* DeleteLocalRef is no longer necessary */ &#125; 当然和之前立即删除本地引用的版本相比，上面的版本需要消耗更多的内存。或者，Push / PopLocalFrame函数允许程序员创建本地引用的嵌套范围。 例如，我们也可以重写同样的例子，如下所示： 123456789#define N_REFS ... /* the maximum number of local references used in each iteration */for (i = 0; i &lt; len; i++) &#123; if ((*env)-&gt;PushLocalFrame(env, N_REFS) &lt; 0) &#123; ... /* out of memory */ &#125; jstr = (*env)-&gt;GetObjectArrayElement(env, arr, i); ... /* process jstr */ (*env)-&gt;PopLocalFrame(env, NULL); &#125; PushLocalFrame为特定数量的本地引用创建一个新的范围。PopLocalFrame破坏超出的范围，释放该范围内的所有本地引用。使用Push/PopLocalFrame的好处是它们可以管理本地引用的生命周期，而无需担心在执行过程中可能会创建的每个本地引用。在上面的例子中，如果处理jstr的计算创建了额外的本地引用，则这些本地引用将会在PopLocalFrame返回后被释放。 当你编写期望返回一个本地引用的实例程序时，NewLocalRef函数很有用。我们将在5.3节中演示NewLocalRef函数的用法。 本地代码可能会创建超出默认容量16或者PushLocalFrame或者EnsureLocalCapacity调用中保留的容量的本地引用。虚拟机将会尝试分配本地引用所需的内存。然而不能保证，这些内存是可用的。如果分配内存失败，虚拟机将会退出。你应该为本地引用保留足够的内存和尽快释放本地引用以避免这种意外的虚拟机退出。 Java 2 JDK 1.2提供了一个命令行参数-verbose:jni。当使能这个参数，虚拟机会报告超过预留容量的本地引用创建情况。 5.2.3 释放全局变量 当你的本地代码不再需要访问一个全局引用时，你应该调用DeleteGlobalRef方法。如果你忘记调用这个函数，虚拟机将无法通过垃圾收集器回收相应的对象，即使这个对象再也不会在系统的其他地方中使用。 当你的本地代码不再需要访问一个弱全局引用时，你应该调用DeleteWeakGlobalRef方法。如果你忘记调用这个函数，Java虚拟机仍然能够通过垃圾收集器收集底层对象，当时将无法回收该弱全局引用对象占用的内存。 5.3 引用管理规范 我们现在已经准备好基于我们前面的几节介绍的内容，来处理在本地代码中管理JNI引用的规则。目的是消除不必要的内存使用和对象保留。 通常来说有两种本地代码，直接实现在任意上下文中使用的本地方法和效用函数的函数。 当编写直接实现本地方法时，你需要注意避免在循环中过多的创建本地引用以及由不返回的本地方法创建的不需要的本地引用。在本地方法返回后，留下最多16个本地引用由虚拟机删除是可以接受的。本地方法调用不能导致全局引用或者弱全局引用累积，因为全局引用和弱全局引用在本地方法返回后不会释放。编写本机实用程序函数时，必须注意不要在整个函数中的任何执行路径上泄漏任何本地引用。因为效用函数可以从意料之外的上下文重复调用，任何不必要的引用创建都可能导致内存溢出。 当一个返回基本类型的函数被调用时，它不会产生额外的本地、全局、弱全局引用累积副作用。 当一个返回引用类型的函数被调用，它不能有本地、全局、弱全局引用的额外累积，除非这个引用被当做返回值。 为了缓存的目的，一个函数创建一些全局或弱全局引用是可以接受的，因为仅在第一次调用的时候会创建这些引用。 如果一个函数返回一个引用，你应该使用函数规范的返回引用部分。他不应该在某些时候返回本地引用，而在其他时候返回全局引用。调用者需要知道函数的返回类型，以便正确的管理自己的JNI引用。例如，以下代码重复的调用了一个函数GetInfoString。我们需要知道GetInfoString返回的引用类型，以便能够在每次迭代后正确释放返回的JNI引用。 12345while (JNI_TRUE) &#123; jstring infoString = GetInfoString(info); ... /* process infoString */ ??? /* we need to call DeleteLocalRef, DeleteGlobalRef, or DeleteWeakGlobalRef depending on the type of reference returned by GetInfoString. */&#125; 在Java 2 JDK 1.2中，NewLocalRef函数经常用于确保函数返回一个本地引用。为了说明，让我们对MyNewString函数进行另一个（有点设计的）更改。以下版本在全局引用中缓存经常请求的字符串（例如“CommonString”）： 123456789101112131415161718jstring MyNewString(JNIEnv *env, jchar *chars, jint len) &#123; static jstring result; /* wstrncmp compares two Unicode strings */ if (wstrncmp(&quot;CommonString&quot;, chars, len) == 0) &#123; /* refers to the global ref caching &quot;CommonString&quot; */ static jstring cachedString = NULL; if (cachedString == NULL) &#123; /* create cachedString for the first time */ jstring cachedStringLocal = ... ; /* cache the result in a global reference */ cachedString =(*env)-&gt;NewGlobalRef(env, cachedStringLocal); &#125; return (*env)-&gt;NewLocalRef(env, cachedString); &#125; ... /* create the string as a local reference and store in result as a local reference */ return result; &#125; 正常的代码路径返回作为本地引用的字符串。正如前面解释的那样，我们必须在一个全局引用中保存缓存的字符串，让其能够被多个本地方法和多个线程访问。加粗显示的行创建一个新的引用对象，其引用同一个缓存在全局引中的对象。作为其调用者契约的一部分，MyNewString经常返回一个本地引用。 Push/PopLocalFrame方法对于管理本地引用的声明周期是非常简便的。如果你在一个本地方法的入口调用PushLocalFrame，需要在本地方法返回前调用PopLocalFrame以确保所有在本地方法执行期间创建的本地引用都会被回收。Push/PopLocalFrame函数是非常有效率的。强烈建议你使用它们。 如果你在函数的入口调用了PushLocalFrame，记得在程序的所有退出路径上调用PopLocalFrame。例如，下面的程序有一个PushLocalFrame调用，但是却需要多个PopLocalFrame调用。 1234567891011121314151617jobject f(JNIEnv *env, ...) &#123; jobject result; if ((*env)-&gt;PushLocalFrame(env, 10) &lt; 0) &#123; /* frame not pushed, no PopLocalFrame needed */ return NULL; &#125; ... result = ...; if (...) &#123; /* remember to pop local frame before return */ result = (*env)-&gt;PopLocalFrame(env, result); return result; &#125; ... result = (*env)-&gt;PopLocalFrame(env, result); /* normal return */ return result;&#125; 错误的放置PopLocalFrame调用回引起不确定的行为，例如导致虚拟机崩溃。 上面的例子也表明为什么有时指定PopLocalFrame的第二个参数是有用的。result本地引用最初在由PushLocalFrame构造的新框架中创建的。PopLocalFrame将其作为第二个参数，result转换为前一贞中的新的本地引用，然后弹出最顶层的框架。 第六章 异常 我们已经遇到大量在本地代码中需要检查执行JNI方法后可能产生的错误。这一章将介绍本地代码如何从这些错误状况中检测和修复。 我们将会重点关注作为JNI函数调用的结果发生的错误，而不是在本地代码中发生的任意错误。如果一个本地方法进行了操作系统调用，则只需要按照文档说明的方式来检查系统调用中可能发生的错误。另一方面，如果本地方法想Java API方法进行回调，则必须按照本章中描述的步骤来正确的检查和修复方法执行期间可能产生的异常。 6.1 概述我们通过一些列的例子来介绍JNI异常处理函数。 6.1.1 在本地代码中缓存和抛出异常 下面的程序显示如何定义一个会抛出异常的本地方法。CatchThrow类定义了一个doit方法，并且表明该方法会抛出一个IllegalArgumentException： 12345678910111213141516171819class CatchThrow &#123; private native void doit() throws IllegalArgumentException; private void callback() throws NullPointerException &#123; throw new NullPointerException(&quot;CatchThrow.callback&quot;); &#125; public static void main(String args[]) &#123; CatchThrow c = new CatchThrow(); try &#123; c.doit(); &#125; catch (Exception e) &#123; System.out.println(&quot;In Java:\n\t&quot; + e); &#125; &#125; static &#123; System.loadLibrary(&quot;CatchThrow&quot;); &#125; &#125; CatchThrow.main方法调用本地方法doit，doit的实现如下： 123456789101112131415161718192021222324JNIEXPORT void JNICALL Java_CatchThrow_doit(JNIEnv *env, jobject obj) &#123; jthrowable exc; jclass cls = (*env)-&gt;GetObjectClass(env, obj); jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;callback&quot;, &quot;()V&quot;); if (mid == NULL) &#123; return; &#125; (*env)-&gt;CallVoidMethod(env, obj, mid); exc = (*env)-&gt;ExceptionOccurred(env); if (exc) &#123; /* We don&apos;t do much with the exception, except that we print a debug message for it, clear it, and throw a new exception. */ jclass newExcCls; (*env)-&gt;ExceptionDescribe(env); (*env)-&gt;ExceptionClear(env); newExcCls = (*env)-&gt;FindClass(env,&quot;java/lang/IllegalArgumentException&quot;); if (newExcCls == NULL) &#123; /* Unable to find the exception class, give up. */ return; &#125; (*env)-&gt;ThrowNew(env, newExcCls, &quot;thrown from C code&quot;); &#125; &#125; 搭配本地库运行这个程序可以得到如下输出： 123456java.lang.NullPointerException: at CatchThrow.callback(CatchThrow.java) at CatchThrow.doit(Native Method) at CatchThrow.main(CatchThrow.java)In Java: java.lang.IllegalArgumentException: thrown from C code 这个回调方法抛出一个NullPointerException异常。当CallVoidMethod将控制权返回给本地方法后，本地代码通过JNI方法ExceptionOccurred会检测到这个异常。在我们的例子当中，当异常被检测到，本地方法通过调用ExceptionDescribe会输出一个关于这个异常的描述性信息，使用ExceptionClear方法清除这个异常并且抛出一个IllegalArgumentException异常作为替代。 通过JNI（例如通过调用ThrowNew）引起的挂起异常不会立刻破坏本地方法的执行。这和Java编程语言中异常的行为是不同的。当使用Java编程语言抛出一个异常的时候，Java虚拟机会自动将控制流程转移到最近的符合异常类型的try/catch代码块中。然后Java虚拟机会清除这个挂起的异常并执行异常处理。相比之下，在异常发生之后，JNI程序员必须显示的进行流程控制。 6.1.2 一个有用的辅助函数 抛出一个异常，首先需要查找这个异常的类然后调用ThrowNew方法。为了简化这个任务，我们可以编写一个抛出一个命名异常的有用函数： 123456789void JNU_ThrowByName(JNIEnv *env, const char *name, const char *msg) &#123; jclass cls = (*env)-&gt;FindClass(env, name); /* if cls is NULL, an exception has already been thrown */ if (cls != NULL) &#123; (*env)-&gt;ThrowNew(env, cls, msg); &#125; /* free the local ref */ (*env)-&gt;DeleteLocalRef(env, cls);&#125; 在本书中，JNU表示JNI Utilities。JNU_ThrowByName首先通过FindClass方法找到异常的类。如果FindClass调用失败（返回NULL），虚拟机必须抛出一个异常（例如NoClassDefFoundError）。在本次JNU_ThrowByName不会尝试抛出另外一个异常。如果FindClass成功返回，我们通过调用ThrowNew抛出一个命名的异常。当JNU_ThrowByName调用返回的时，它保证有一个挂起的异常，尽管这个挂起的异常不一定是由name参数指定的。在这个方法中，我们确保删除引用异常类的本地引用。如果FindClass失败并返回NULL，将NULL传递给DeleteLocalRef将会是一个空操作，这将是一个恰当的操作。 6.2 恰当的异常处理 JNI程序员必须遇见所有可能的异常情况并且编写相应的代码检查和处理这些情况。适当的异常处理有时候是乏味的，但是为了提高程序的鲁棒性却是必须的。 6.2.1 异常检查有两种方式检查是否有错误产生了。 （1）大多数JNI方法使用一个明显的返回值（例如NULL）来表明产生了一个错误。返回错误值也意味着在当前线程中产生了一个挂起的异常。（在返回值中编码错误情况是C中的常见用法） 下面的例子中表明GetFieldID返回NULL值来检查错误情况。例子包含两个部分：类Window定义了一些实例字段（handle，length和width）并且有一个本地方法用来缓存这些字段的字段ID。尽管这些字段确实已经在Window类中了，我们仍然需要检查GetFieldID可能返回的错误值，因为虚拟机可能无法分配足够的内容用于保存字段ID。 123456789101112131415161718192021222324252627/* a class in the Java programming language */ public class Window &#123; long handle; int length; int width; static native void initIDs(); static &#123; initIDs(); &#125; &#125;/* C code that implements Window.initIDs */ jfieldID FID_Window_handle; jfieldID FID_Window_length; jfieldID FID_Window_width;JNIEXPORT void JNICALL Java_Window_initIDs(JNIEnv *env, jclass classWindow) &#123; FID_Window_handle =(*env)-&gt;GetFieldID(env, classWindow, &quot;handle&quot;, &quot;J&quot;); if (FID_Window_handle == NULL) &#123; /* important check. */ return; /* error occurred. */ &#125; FID_Window_length =(*env)-&gt;GetFieldID(env, classWindow, &quot;length&quot;, &quot;I&quot;); if (FID_Window_length == NULL) &#123; /* important check. */ return; /* error occurred. */ &#125; FID_Window_width = (*env)-&gt;GetFieldID(env, classWindow, &quot;width&quot;, &quot;I&quot;); /* no checks necessary; we are about to return anyway */&#125; （2）当使用一个JNI方法，它的返回值无法标记一个错误的产生的时候，本地代码就必须依赖引起异常来进行错误检查。在当前线程中，用于检查是否有挂起的异常的JNI函数是ExceptionOccurred。（ExceptionCheck在Java 2 JDK 1.2版本中加入。）例如，JNI方法CallIntMethod不能通过编码一个错误情况来作为返回值，典型的错误情况返回值例如-1和NULL都不能很好的工作，因为当他们调用这个方法时，这些都是合理的返回值。考虑有一个Fraction类，它的floor方法返回分数值的整数部分并且有其他的本地代码调用这个函数。 123456789101112131415161718public class Fraction &#123; // details such as constructors omitted int over, under; public int floor() &#123; return Math.floor((double)over/under); &#125; &#125;/* Native code that calls Fraction.floor. Assume method ID MID_Fraction_floor has been initialized elsewhere. */ void f(JNIEnv *env, jobject fraction) &#123; jint floor = (*env)-&gt;CallIntMethod(env, fraction, MID_Fraction_floor); /* important: check if an exception was raised */ if ((*env)-&gt;ExceptionCheck(env)) &#123; return; &#125; ... /* use floor */ &#125; 当JNI函数返回不同的错误代码是，本地代码仍然可能通过显示调用类检查异常，例如ExceptionCheck。不管怎么样，通过检查不同的返回值仍然是高效的。如果一个JNI方法返回其错误值，那么在当前线程后续处理中调用ExceptionCheck方法将保证返回JNI_TRUE。 6.2.2 异常处理本地代码可以通过两种方式处理挂起的异常： 本地代码实现能够选择立即返回，在方法调用者处进行异常处理 本地代码可以通过调用ExceptionClear来清除异常然后执行它自己的异常处理函数 在调用任何后续JNI函数之前，检查、处理和清除挂起的异常时非常重要的。在带有挂起的异常，尚未明确清理的异常时调用大多数JNI方法都有可能导致意外的结果。当在当前线程中有一个挂起的异常时，你仅可以安全的调用一小部分JNI方法，11.8.2节列出了这些JNI函数的完整列表。一般来说，当存在一个挂起的异常时，你可以调用专门的JNI函数来处理异常和释放通过JNI暴露出来的各种虚拟机资源。 当异常发生时，经常有必要去释放各种资源。在下面的例子当中，本地方法首先通过一个GetStringChars调用获取字符串的内容。如果在后续的处理中产生错误，它会调用ReleaseStringChars： 12345678910111213141516JNIEXPORT void JNICALLJava_pkg_Cls_f(JNIEnv *env, jclass cls, jstring jstr) &#123; const jchar *cstr = (*env)-&gt;GetStringChars(env, jstr); if (c_str == NULL) &#123; return; &#125; ... if (...) &#123; /* exception occurred */ (*env)-&gt;ReleaseStringChars(env, jstr, cstr); return; &#125; ... /* normal return */ (*env)-&gt;ReleaseStringChars(env, jstr, cstr); &#125; 第一次调用ReleaseStringChars是在有挂起的线程出现的时候。本地方法实现释放字符串资源并在之后立即返回，而不需要首先清除异常。 6.2.3 有用的辅助函数中的异常 程序员编写有用的辅助函数时应特别注意确保异常传播到本地调用方法中。我们特别强调一下两点： 优选方案，辅助函数应该提供特殊的返回值指示发生了异常。这简化了调用者检查待处理异常的任务。 此外，辅助函数应遵循在管理异常代码是注意管理本地应用的规则。 为了说明，让我们介绍一个基于实例方法的名字和描述符执行回调的辅助函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071jvalue JNU_CallMethodByName(JNIEnv *env, jboolean *hasException, jobject obj, const char *name, const char *descriptor, ...)&#123; va_list args; jclass clazz; jmethodID mid; jvalue result; if((*env)-&gt;EnsureLocalCapacity(env, 2) == JNI_OK) &#123; clazz = (*env)-&gt;GetObjectClass(env, obj); mid = (*env)-&gt;GetMethodID(env, clazz, name, descriptor); if(mid) &#123; const char *p = descriptor; /* skip over argument types to find out the return type */ while (*p != &apos;)&apos;) p++; /* skip &apos;)&apos; */ p++; va_start(args, descriptor); switch (*p) &#123; case &apos;V&apos;: (*env)-&gt;CallVoidMethodV(env, obj, mid, args); break; case &apos;[&apos;: case &apos;L&apos;: result.l = (*env)-&gt;CallObjectMethodV(env, obj, mid, args); break; case &apos;Z&apos;: result.z = (*env)-&gt;CallBooleanMethodV(env, obj, mid, args); break; case &apos;B&apos;: result.b = (*env)-&gt;CallByteMethodV(env, obj, mid, args); break; case &apos;C&apos;: result.c = (*env)-&gt;CallCharMethodV(env, obj, mid, args); break; case &apos;S&apos;: result.s = (*env)-&gt;CallShortMethodV(env, obj, mid, args); break; case &apos;I&apos;: result.i = (*env)-&gt;CallIntMethodV(env, obj, mid, args); break; case &apos;J&apos;: result.j = (*env)-&gt;CallLongMethodV(env, obj, mid, args); break; case &apos;F&apos;: result.f = (*env)-&gt;CallFloatMethodV(env, obj, mid, args); break; case &apos;D&apos;: result.d = (*env)-&gt;CallDoubleMethodV(env, obj, mid, args); break; default: (*env)-&gt;FatalError(env, &quot;illegal descriptor&quot;); &#125; va_end(args); &#125; (*env)-&gt;DeleteLocalRef(env, clazz); &#125; if (hasException) &#123; *hasException = (*env)-&gt;ExceptionCheck(env); &#125; return result&#125; 除了其他参数以外，JNU_CallMethodByName还有一个指向jboolean的指针。如果在一切正常，jboolean将被设置为JNI_FALSE，如果在执行这个函数期间的任何时候发生了异常，那么jboolean将被设置为JNI_TRUE。这将给JNU_CallMethoByName的调用者一个明显的方法去检查是否有发生异常。 JNU_CallMethodByName首先确保他能够创建两个本地引用：一个用于类引用，另一个用于方法调用返回的结果。接下来，它从对象获取到类引用，并查找到方法ID。根据返回值的类型，switch语句将调度到相应的JNI方法调用函数。回调返回后，如果hasException不为NULL，我们调用ExceptionCheck来检查挂起的异常。 ExceptionCheck方法是在Java 2 SDK 1.2中新加进去的。它类似于ExceptionOccurred函数。不同之处在于ExceptionCheck不会返回对异常对象的引用，但是当有挂起的异常时返回JNI_TRUE，在没有挂起的异常的时候放回JNI_FALSE。当本地代码仅需要知道是否发生异常但是不需要获取对异常对象的引用时，ExceptionCheck简化了本地引用的管理。前面的代码在使用JDK 1.1中，将重写如下： 12345if (hasException) &#123; jthrowable exc = (*env)-&gt;ExceptionOccurred(env); *hasException = exc != NULL; (*env)-&gt;DeleteLocalRef(env, exc);&#125; 额外的DeleteLocalRef调用时必须的，以删除对异常对象的本地引用。 使用JNU_CallMethodByName方法，我们可以重写4.2节中InstanceMethodCall.nativeMethod的实现： 12345JNIEXPORT void JNICALLJava_InstanceMethodCall_nativeMethod(JNIEnv *env, jobject obj) &#123; printf(&quot;In C\n&quot;); JNU_CallMethodByName(env, NULL, obj, &quot;callback&quot;, &quot;()V&quot;); &#125; 在JNU_CallMethodByName调用会我们不需要检查异常，因为本地代码会立刻返回。 第七章：调用接口这一章用于说明在你的本地代码中如何嵌入一个Java虚拟机。Java虚拟机实现通过作为一个本地库来传输,本地应用程序可以连接此库并使用调用接口来加载Java虚拟机。的确，在JDK或Java 2 SDK版本中的标准启动器指令只不过是一个和Java虚拟机链接的简单c程序。启动器解析命令行参数、加载虚拟机、并通过调用借口运行Java程序。 7.1 创建Java虚拟机为了说明调用借口，让我们先看一个加载一个Java虚拟机并调用按照如下定义的Prog.main方法的C程序 12345public class Prog &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World &quot; + args[0]); &#125;&#125; 接下来的C程序，invoke.c，加载一个Java虚拟机并调用Prog.main方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;jni.h&gt;#define PATH_SEPARATOR &apos;;&apos; /* define it to be &apos;:&apos; on Solaris */ #define USER_CLASSPATH &quot;.&quot; /* where Prog.class is */ main() &#123; JNIEnv *env; JavaVM *jvm; jint res; jclass cls; jmethodID mid; jstring jstr; jclass stringClass; jobjectArray args;#ifdef JNI_VERSION_1_2 JavaVMInitArgs vm_args; JavaVMOption options[1]; options[0].optionString = &quot;-Djava.class.path=&quot; USER_CLASSPATH; vm_args.version = 0x00010002; vm_args.options = options; vm_args.nOptions = 1; vm_args.ignoreUnrecognized = JNI_TRUE; /* Create the Java VM */ res = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;vm_args); #else JDK1_1InitArgs vm_args; char classpath[1024]; vm_args.version = 0x00010001; JNI_GetDefaultJavaVMInitArgs(&amp;vm_args); /* Append USER_CLASSPATH to the default system class path */ sprintf(classpath, &quot;%s%c%s&quot;, vm_args.classpath, PATH_SEPARATOR, USER_CLASSPATH); vm_args.classpath = classpath; /* Create the Java VM */ res = JNI_CreateJavaVM(&amp;jvm, &amp;env, &amp;vm_args); #endif /* JNI_VERSION_1_2 */ if (res &lt; 0) &#123; fprintf(stderr, &quot;Can&apos;t create Java VM\n&quot;); exit(1); &#125; cls = (*env)-&gt;FindClass(env, &quot;Prog&quot;); if (cls == NULL) &#123; goto destroy; &#125; mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (mid == NULL) &#123; goto destroy; &#125; jstr = (*env)-&gt;NewStringUTF(env, &quot; from C!&quot;); if (jstr == NULL) &#123; goto destroy; &#125; stringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr); if (args == NULL) &#123; goto destroy; &#125; (*env)-&gt;CallStaticVoidMethod(env, cls, mid, args); destroy: if ((*env)-&gt;ExceptionOccurred(env)) &#123; (*env)-&gt;ExceptionDescribe(env); &#125; (*jvm)-&gt;DestroyJavaVM(jvm); 上面的代码条件性的编译特定于JDK 1.1版本的Java虚拟机实现的初始化结构体JDK1_1InitArgs。Java 2 SDK 1.2版本中仍旧可以支持JDK1_1InitArgs，尽管其引入了一种称为JavaVMInitArgs的初始化结构体。常量JAVA_VERSION_1_2在Java 2 SDK 1.2版本中定义，而在JDK 1.1版本中是没有定义的。 当它针对的是1.1版本时，C代码通过调用JNI_GetDefaultJavaVMInitArgs来获取默认的虚拟机设置。JNI_GetDefaultJavaVMInitArgs在vm_args参数中返回诸如堆大小、栈大小、默认类路径等值。然后我们追加Prog.class所在的目录到vm_args.classpath中。 当它是针对的是1.2版本时，C代码创建一个JavaVMInitArgs结构体。虚拟机初始化结构体保存在JavaVMOption数组当中，你可以设置和Java命令行选项对应的常规选项（如-Djava.class.path=.）和虚拟机实现特定的选项（如-Xmx64m)。设置ignoreUnrecognized字段为JNI_TRUE说明虚拟机忽略不能识别的虚拟机特定选项。 在设置好虚拟机初始化结构体后，C程序调用JNI_CreateJavaVM来加载和初始化Java虚拟机。JNI_CreateJavaVM将填充两个返回值： jvm，指向新创建的Java虚拟机的接口指针 env，指向当前线程的JNIEnv的接口指针，本地方法将通过env接口指针来调用JNI方法 当JNI_CreateJavaVM成功返回时，当前本地线程就已经将自身引导到Java虚拟机中。在这个点上，它就像一个本地方法一样运行，因此，除了别的以外，它可以发出JNI调用来调用Prog.main方法。 最终程序会调用DestroyJavaVM来卸载Java虚拟机。（不幸的是，你不能在JDK 1.1版本和Java 2 SDK 1.2版本中卸载Java虚拟机实现，在这些版本中，DestroyJavaVM总是返回错误代码。）运行上面的程序，将得到: Hello World from C! 7.2 将本地应用程序与Java虚拟机相连调用接口需要你将你的程序例如invoke.c，和一个Java虚拟机实现相连。如何和Java虚拟机相连取决于本地引用程序是仅部署在特定的Java虚拟机实现还是它被设计为与来自不同供应商的各种虚拟机实现一起工作。 7.2.1 与已知的Java虚拟机链接你可能决定了你的程序仅部署在特定的Java虚拟机实现上。在这种情况下，你可以将本地应用程序和实现了虚拟机的本地库相连，例如在Solaris系统，JDK 1.1版本中，你可以使用下面的指令来编译和链接invoke.c： 1cc -I -L -lthread -ljava invoke.c -lthread选项表明我们使用Java虚拟机以及本地线程支持（8.1.5节）。-ljava选项表明libjava.so是实现了Java虚拟机的Solaris共享库。 在Win32系统使用Microsoft Visual C++编译器，编译和链接同一个程序的命令行为 1cl -I -MD invoke.c -link &lt;javai.lib dir&gt;\javai.lib 当然你需要提供与机器上的JDK安装相对应的正确的包含和库目录。-MD选项确保你的本地应用程序和Win32多线程C库链接，在JDK 1.1版本和Java 2 JDK 1.2版本的Java虚拟机实现使用的是同一个本地C库。cl命令参考Win32中附带的JDK版本1.1中的javai.lib文件，以获取有关在虚拟机中实现的调用接口函数（JNI_CreateJavaVM）的链接信息。在运行时真实使用的JDK 1.1虚拟机实现被包含在一个名为javai.dll的单独动态链接库中。相反，在链接时和运行时都是用相同的Solaris动态库（.so文件）。 在Java 2 JDK 1.2版本中，虚拟机库的名字已更改为Solaris上的libjvm.so，以及Win32上的jvm.lib和jvm.dll。通常不同的供应商可能会以不同的方式命名虚拟机实现。 一旦编译和链接完成，你可以从命令行运行生成的可执行文件。你可能会收到系统找不到共享库或动态链接库的错误。在Solaris系统上，如果错误信息显示系统找不到动态库libjava.so（libjvm.so在Java 2 JDK 1.2版本上），则需要将包含虚拟机库的目录添加到LD_LIBRARY_PATH变量中。在Win32系统上，错误信息可能表示为它找不到动态链接库javai.dll（或者jvm.dll在Java 2 JDK 1.2版本上），如果是这种情，请将包含该DLL的目录添加到PATH环境变量中。 7.2.2 与未知的Java虚拟机链接如果应用程序旨在使用来自不同供应商的虚拟机实现，则无法将本地应用程序链接到特定的虚拟机实现库。因为JNI没有指定实现Java虚拟机的本地库的名称，所以你应该准备好使用不同的Java虚拟机实现。例如，在Win32上，虚拟机在JDK版本1.1中作为javai.dll发布，在Java 2 SDK版本1.2中作为jvm.dll发布。 解决方案是使用运行时动态链接来加载应用程序所需的特定虚拟机库。虚拟机库的名称可以轻松的以应用程序特定的方式配置，例如以下Win32代码为虚拟机库的路径找到JNI_CreateJavaVM的函数入口点： 12345678/* Win32 version */void *JNU_FindCreateJavaVM(char *vmlibpath) &#123; HINSTANCE hVM = LoadLibrary(vmlibpath); if (hVM == NULL) &#123; return NULL; &#125; return GetProcAddress(hVM, &quot;JNI_CreateJavaVM&quot;); &#125; LoadLibrary和GetProcAddreee是在Win32系统上，用于动态链接的API函数。尽管LoadLibrary能够接受实现了Java虚拟机的本地库的名字（例如“jvm”）或者路径（例如”C:\jdk1.2\jre\bin\classic\jvm.dll”），传送本地库绝对路劲给JNU_FindCreateJavaVM将是最好的选择。依靠LoadLibrary来搜索jvm.dll，使您的应用程序易于进行配置更改，例如PATH环境变量的添加。 Solaris系统的版本是类似的： 12345678/* Solaris version */void *JNU_FindCreateJavaVM(char *vmlibpath) &#123; void *libVM = dlopen(vmlibpath, RTLD_LAZY); if (libVM == NULL) &#123; return NULL; &#125; return dlsym(libVM, &quot;JNI_CreateJavaVM&quot;); &#125; dlopen和dlsym函数支持在Solaris系统上动态链接共享库。 7.3 附加本地线程假设你有一个多线程应用程序，例如一个用C写的Web服务器。随着HTTP请求的到来，服务器创建一些本地线程来同时处理HTTP请求。我们希望在此服务器中嵌入一个Java虚拟机，以便多个线程可以同时在Java虚拟机中执行操作，如图7.1所示： 服务器生成的本地方法的生命周期可能比Java虚拟机更短。因此，我们需要一种方式来将本地线程附加到已经运行的Java虚拟机，在附加的本地线程中执行JNI调用，然后将本地线程从Java虚拟机中脱离不会其他已连接的线程。接下来的示例，attach.c，说明如何使用调用接口将本地线程附加到虚拟机上，改程序是使用Win32线程API编写的。可以为Solaris和其他操作系统编写类似的版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* Note: This program only works on Win32 */ #include &lt;windows.h&gt; #include &lt;jni.h&gt;JavaVM *jvm; /* The virtual machine instance */ #define PATH_SEPARATOR &apos;;&apos;#define USER_CLASSPATH &quot;.&quot; /* where Prog.class is */void thread_fun(void *arg) &#123; jint res; jclass cls; jmethodID mid; jstring jstr; jclass stringClass; jobjectArray args; JNIEnv *env; char buf[100]; int threadNum = (int)arg; /* Pass NULL as the third argument */ #ifdef JNI_VERSION_1_2 res = (*jvm)-&gt;AttachCurrentThread(jvm, (void**)&amp;env, NULL);#else res = (*jvm)-&gt;AttachCurrentThread(jvm, &amp;env, NULL);#endif if (res &lt; 0) &#123; fprintf(stderr, &quot;Attach failed\n&quot;); return; &#125; cls = (*env)-&gt;FindClass(env, &quot;Prog&quot;); if (cls == NULL) &#123; goto detach; &#125; mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (mid == NULL) &#123; goto detach; &#125; sprintf(buf, &quot; from Thread %d&quot;, threadNum); jstr = (*env)-&gt;NewStringUTF(env, buf); if (jstr == NULL) &#123; goto detach; &#125; stringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr); if (args == NULL) &#123; goto detach; &#125; (*env)-&gt;CallStaticVoidMethod(env, cls, mid, args); detach: if ((*env)-&gt;ExceptionOccurred(env)) &#123; (*env)-&gt;ExceptionDescribe(env); &#125; (*jvm)-&gt;DetachCurrentThread(jvm); &#125; main() &#123; JNIEnv *env; int i; jint res;#ifdef JNI_VERSION_1_2 JavaVMInitArgs vm_args; JavaVMOption options[1]; options[0].optionString = &quot;-Djava.class.path=&quot; USER_CLASSPATH; vm_args.version = 0x00010002; vm_args.options = options; vm_args.nOptions = 1; vm_args.ignoreUnrecognized = TRUE; /* Create the Java VM */ res = JNI_CreateJavaVM(&amp;jvm, (void**)&amp;env, &amp;vm_args); #else JDK1_1InitArgs vm_args; char classpath[1024]; vm_args.version = 0x00010001; JNI_GetDefaultJavaVMInitArgs(&amp;vm_args); /* Append USER_CLASSPATH to the default system class path */ sprintf(classpath, &quot;%s%c%s&quot;, vm_args.classpath, PATH_SEPARATOR, USER_CLASSPATH); vm_args.classpath = classpath; /* Create the Java VM */ res = JNI_CreateJavaVM(&amp;jvm, &amp;env, &amp;vm_args); #endif /* JNI_VERSION_1_2 */ if (res &lt; 0) &#123; fprintf(stderr, &quot;Can&apos;t create Java VM\n&quot;); exit(1); &#125; for (i = 0; i &lt; 5; i++) /* We pass the thread number to every thread */ _beginthread(thread_fun, 0, (void *)i); Sleep(1000); /* wait for threads to start */ (*jvm)-&gt;DestroyJavaVM(jvm);&#125; attach.c是invoke.c的变体，本地代码不是在主线程中调用Prog.main，而是启动五个线程。一旦它启动线程，它等待他们启动然后调用DestroyJavaVM。每个产生的线程都将自己链接到Java虚拟机，调用Prog.main方法，最后在其终止运行前将其从Java虚拟机中分离出来。DestroyJavaVM将在所有五个线程终止后返回。现在我们先忽略DestroyJavaVM的返回值，因为这个方法在JDK 1.1版本和Java 2 JDK 1.2版本上并没有完全实现。 JNI_AttachCurrentThread将NULL作为其第三个参数，Java 2 JDK 1.2版本中引入JNI_ThreadAttachArgs结构体，它允许你指定其他参数，例如你要附加的线程组。JNI_ThreadAttachArgs结构体的细节将在13.2节中作为JNI_AttachCurrentThread规范的一部分进行描述。 当程序执行DetachCurrentThread函数时，它将释放属于当前线程的所有本地引用。运行程序会产生以下输出： 12345Hello World from thread 1 Hello World from thread 0 Hello World from thread 4 Hello World from thread 2 Hello World from thread 3 输出的确切顺序可能会根据线程调度中的随机因素而变化。 JNI实现原理JNI系列：JavaVM和JNIEnv等原理http://blog4jimmy.com/2017/11/242.htmlhttp://blog4jimmy.com/category/the_java_native_interface_programmer_guide_and_specificationjnihttp://blog.guorongfei.com/2017/01/24/android-jni-tips-md/https://www.cnblogs.com/fnlingnzb-learner/p/7366025.htmlhttps://www.zybuluo.com/cxm-2016/note/566619https://blog.csdn.net/omnispace/article/details/73320940反射：http://blog4jimmy.com/2017/11/224.html http://androidxref.com/8.0.0_r4/xref/libnativehelper/include/nativehelper/jni.h 插件机制：https://github.com/tiann/epic/tree/master/library/src/main/cpphttps://blog.csdn.net/omnispace/article/details/73320940 JNI的实现可涉及两个关键类:JNIEnv和JavaVM。JavaVM：这个代表java的虚拟机。所有的工作都是从获取虚拟机的接口开始的。 第一种方式，在加载动态链接库的时候，JVM会调用JNI_OnLoad(JavaVM jvm, void reserved)（如果定义了该函数）。第一个参数会传入JavaVM指针。 第二种方式，在native code中调用JNI_CreateJavaVM(&amp;jvm, (void*)&amp;env, &amp;vm_args)可以得到JavaVM指针。 两种情况下，都可以用全局变量，比如JavaVM g_jvm来保存获得的指针以便在任意上下文中使用。 Android系统是利用第二种方式Invocation interface来创建JVM的。 JNIEnv：JNI Interface Pointer, 是提供JNI Native函数的基础环境，线程相关，不同线程的JNIEnv相互独立。 JNIEnv只在当前线程中有效。本地方法不 能将JNIEnv从一个线程传递到另一个线程中。相同的 Java 线程中对本地方法多次调用时，传递给该本地方法的JNIEnv是相同的。但是，一个本地方法可被不同的 Java 线程所调用，因此可以接受不同的 JNIEnv。 JavaVM则可以在进程中的各线程间共享。理论上一个进程可以有多个JavaVM,但Android只允许一个（JavaVm and JIEnv）。需要强调的是JNIEnv是跟线程相关的。sdk文档中强调了do not cache JNIEnv*，要用的时候在不同线程中再通过JavaVM *jvm的方法来获取与当前线程相关的JNIEnv*。两者都可以理解为函数表(Function Pointer Table), 前者是使用Java程序创建的运行环境(从属于一个JVM)提供JNI Native函数。 注意点：http://www.10tiao.com/html/330/201711/2653579453/1.html pthread_key:https://zhuanlan.zhihu.com/p/33411235 http://blog.csdn.net/zsl_oo7/article/details/71081291http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/function.html 12345678910111213141516171819## 调用Java层的方法1. 通过 `jclass clazz = env-&gt;FindClass(&quot;含有路径的类名&quot;);` 找到类2. 通过 `jmethodID mid = env-&gt;GetMethodID(clazz,&quot;方法名&quot;,&quot;方法签名信息&quot;);`找到Java层方法的ID * 注意 jmethodID 是一个专门记录 Java 层方法的类型 * 类似的还有一个 jfieldID3. 通过 `env-&gt;CallxxxMethod(jobj,mid,param1,param2...);` 调用 Java 层的方法 * CallxxxMethod 中的 xxx 是 Java 方法的返回值类型，比如 CallVoidMethod，CallIntMethod * 第一个参数是指调用哪个对象的方法，就是 Java 中`.`前面的那个对象 * 第二个参数 Java 中的 MethodID * 后面的参数就是 Java 方法的参数了，其类型都要是 java 中能处理的类型，比如 jstring，jint，jobject## get和set Java层的field1. 通过 `jclass clazz = env-&gt;FindClass(&quot;含有路径的类名&quot;);` 找到类2. 通过 `jfieldID fid = env-&gt;GetFieldID(clazz,&quot;成员名&quot;,&quot;成员类型标示&quot;);`找到Java层成员变量的ID3. 通过 `GetxxxField(env,obj,fid);` / `SetxxxField(env,obj,fid,value);` 来get/set相应的成员变量]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java nio源码]]></title>
    <url>%2Fposts%2Fjava_jdk_base_nio.html</url>
    <content type="text"><![CDATA[同步异步阻塞非阻塞 一般来说 I/O 模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞 四种IO模型 同步阻塞 IO ： 在此种方式下，用户进程在发起一个 IO 操作以后，必须等待 IO 操作的完成，只有当真正完成了 IO 操作以后，用户进程才能运行。 JAVA传统的 IO 模型属于此种方式！ 同步非阻塞 IO:在此种方式下，用户进程发起一个 IO 操作以后 边可 返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。其中目前 JAVA 的 NIO 就属于同步非阻塞 IO 。 异步阻塞 IO ： 此种方式下是指应用发起一个 IO 操作以后，不等待内核 IO 操作的完成，等内核完成 IO 操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问 IO 是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！ 异步非阻塞 IO: 在此种模式下，用户进程只需要发起一个 IO 操作然后立即返回，等 IO 操作真正的完成以后，应用程序会得到 IO 操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的 IO 读写操作，因为 真正的 IO读取或者写入操作已经由 内核完成了。目前 Java 中还没有支持此种 IO 模型。 总结：JAVA NIO是同步非阻塞io。同步和异步说的是消息的通知机制，阻塞非阻塞说的是线程的状态 。下面说说我的理解，client和服务器建立了socket连接：1、同步阻塞io：client在调用read（）方法时，stream里没有数据可读，线程停止向下执行，直至stream有数据。阻塞：体现在这个线程不能干别的了，只能在这里等着同步：是体现在消息通知机制上的，即stream有没有数据是需要我自己来判断的。 2、同步非阻塞io：调用read方法后，如果stream没有数据，方法就返回，然后这个线程就就干别的去了。非阻塞：体现在，这个线程可以去干别的，不需要一直在这等着同步：体现在消息通知机制，这个线程仍然要定时的读取stream，判断数据有没有准备好，client采用循环的方式去读取，可以看出CPU大部分被浪费了 3、异步非阻塞io：服务端调用read()方法，若stream中无数据则返回，程序继续向下执行。当stream中有数据时，操作系统会负责把数据拷贝到用户空间，然后通知这个线程，这里的消息通知机制就是异步！而不是像NIO那样，自己起一个线程去监控stream里面有没有数据！这是我的理解，不确定对不对 2.1 blocking IO（阻塞）我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。 女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。网络中IO阻塞如下图所示： blocking IO（阻塞） 当用户进程调用了recvfrom这个系统调用，内核就开始了IO的第一个阶段：准备数据。对于网络IO来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候内核就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当内核一直等到数据准备好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 2.2 nonblocking IO（非阻塞）我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。网络IO非阻塞如下图所示： nonblocking IO（非阻塞） 从图中可以看出，当用户进程发出read操作时，如果内核中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 所以，用户进程其实是需要不断的主动询问内核数据好了没有。 2.3 IO multiplexing（IO多路复用）我一次性带了多个女友（女性朋友）都要在那里吃饭，然后我苦逼的在餐厅等着不断询问几个女友的饭是否有好了的，这时我的女友们就可以出去继续逛街，然后我一但发现某个女友的饭好了就打电话通知该女友来吃饭！ IO multiplexing（IO多路复用） 当用户进程调用了select，那么整个进程会被block，而同时，内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 2.4 asynchronous IO（异步）女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示： asynchronous IO（异步） 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个signal，告诉它read操作完成了。 到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。 三、阻塞与非阻塞 先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在内核还准备数据的情况下会立刻返回。 简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。详细区别如下图所示： 阻塞与非阻塞 Java NIO总结本文译自Jakob Jenkov的Java NIO。注意，并非逐字翻译，删除了原文中碎碎念的部分，有些地方也加入了自己的理解。 Java NIO，即Java New IO，是从Java 1.4开始引入的新的IO API，用以取代标准Java IO和网络API，当然，NIO的工作方式也与标准的IO API不同，有下面三个特点： Java NIO：通道（Channel）和缓冲区（Buffer） 在标准的IO API中，使用的是字节流和字符流。在NIO中使用的是通道和缓冲区。数据总是会从通道读出到缓冲区中，或者从缓冲区写入通道中。 Java NIO：非阻塞IO 使用Java NIO可以实现非阻塞IO。例如，使用一个线程从通道读出数据到缓冲区中，在数据读出的同时，该线程还可以做其他事情。当数据全部读取到缓冲区中后，该线程可以继续处理它。反之，从缓冲区中将数据写入通道时也可以做相同的处理。 Java NIO：选择器（Selector） 选择器是Java NIO中的一个概念，指的是可以监视多个通道事件（如连接打开，数据到达等等）的一个对象。因此，单个线程可以通过使用选择器对多个通道的数据进行监视。 Java NIO 概要Java NIO有下面三个核心组件构成： 通道 Channel 缓冲区 Buffer 选择器 Selector 尽管Java NIO的类和组件有很多，但是我认为其核心API就是由通道，缓冲区和选择器组成的，而如Pipe和FileLock之类的其他组件，仅仅是为方便使用这三个核心组件而设计的工具类。因此，本章将只会关注这三个核心组件。 通道和缓冲区通常，NIO的所有IO都是从一个通道开始的。通道和流(Stream)有点类似，数据可以 从通道读出到缓冲区中，也可以从缓冲区写入到通道中。图示说明如下： Java NIO: 数据从通道读出到缓冲区，从缓冲区写入到通道 通道和缓冲区的具体类型有好几种。以下是Java NIO中通道的主要实现： FileChanel DatagramChannel SocketChannel ServerSocketChannel 如你所见，这些通道实现涵盖了UDP+TCP网络IO，以及文件IO。这些类都实现了一些有意思的接口，为简单起见，本章不会介绍这些接口。 在Java NIO中核心缓冲区的实现类如下： ByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer 这些缓冲区涵盖了可以通过NIO发送的基本数据类型： byte short int long float double 以及char 除此之外，Java NIO中还有一个MappedByteBuffer实现，用来连接内存映射文件，本章也不做介绍。 选择器选择器可以让一个线程处理多个通道。当应用程序打开多个连接（Channel），而每个连接的数据流量都很低时，就使用选择器比较方便了，比如聊天室服务器。 下图表示了如何使用一个线程通过选择器来处理三个通道： Java NIO: 一个线程通过选择器来处理三个通道 要使用选择器，需要先将通道注册到选择器中，之后就可以调用它的select()方法。该方法一直阻塞到所注册通道中某个事件就绪为止。一旦方法返回，线程就可以处理这些事件。这些事件包括有连接进来，数据接收等。 Java NIO 通道前文提到Java NIO 通道与流类似，但是有以下不同： 可以对通道进行读和写。而流只能是单向的，只能读或者只能写 通道可以异步读和写 通道中的数据总是要先读到一个缓冲区中，或者要从一个缓冲区中写入 请牢记这张图，数据可以 从通道读出到缓冲区中，也可以从缓冲区写入到通道中： Java NIO: 数据从通道读出到缓冲区中，也可以从缓冲区写入到通道中 通道的实现Java NIO中最重要的通道实现如下： FileChannel 从文件读取数据，或将数据写入文件 DatagramChannel 使用UDP协议通过网络来读写数据 SocketChannel 使用TCP协议通过网络来读写数据 ServerSocketChannel 像WEB服务器一样监听进来的TCP连接，对于每一个进来的连接都会创建一个SocketChannel 基本的通道举例下面是一个使用FileChannel来读取数据到缓冲区的基本示例： 123456789101112131415161718RandomAccessFile aFile = RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf);while (bytesRead != -1) &#123; System.out.println(&quot;\n=====Read &quot; + bytesRead); buf.flip(); while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); &#125; buf.clear(); bytesRead = inChannel.read(buf);&#125;aFile.close(); 注意到buf.flip()调用。首先将数据读到缓冲区中，然后切换缓冲区为读模式，接着从缓冲区读数据。下一章会详细介绍这一过程。 Java NIO 缓冲区在与NIO的通道交互时，会用到Java NIO缓冲区。再次强调，数据可以 从通道读出到缓冲区中，也可以从缓冲区写入到通道中。 其实，缓冲区说白了就是一块内存区域，可以写入数据，之后再读取数据。只不过这块内存区域被包装成一个NIO的缓冲区对象，并提供了一些方法以便于对其进行操作。 基本的缓冲区使用方法使用缓冲区读写数据时基本上需要以下四步： 将数据写入到缓冲区中 调用buffer.flip()方法 将数据从缓冲区中读出 调用buffer.clear()或者buffer.compact()方法 当往缓冲区里写入数据时，缓冲区会记录实际写入的数据量。一旦需要读出数据时，需要调用flip()方法将缓冲区从写模式切换为读模式。在读模式下，可以读出缓冲区中所有已写入的数据。 当所有数据读取完毕之后，需要清空缓冲区，以便准备下次写入。有两种方法： 调用clear()：清空全部缓冲区 或者调用compact()：清空缓冲区中已读数据的部分。未读数据会移动到缓冲区的开头位置，新数据会写在未读数据之后。 下面是一个简单的示例，在write，flip，read和clear部分给出了注释。 1234567891011121314151617RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();//创建一个容量为48字节的缓冲区ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); //write：从通道中读出数据到缓冲区while (bytesRead != -1) &#123; buf.flip(); //flip: 将缓冲区切换到读模式 while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); // read: 一次读取一字节 &#125; buf.clear(); //clear: 清空缓冲区，准备下次读入 bytesRead = inChannel.read(buf);&#125;aFile.close(); 缓冲区三个重要属性： capacity, position和limit之前提到，缓冲区其实就是一块内存区域，可以写入数据，之后再读取数据。只不过这块内存区域被包装成一个NIO的缓冲区对象，并提供了一些方法以便于对其进行操作。 想要了解缓冲区如何工作，就必须先理解它的三个重要属性，它们是： capacity 容量 position 位置 limit 上限 position和limit具体含义取决于缓冲区是在读模式还是写模式。capacity的含义固定的，表示缓冲区的固定大小，与缓冲区所在的模式无关。下图表示了在不同模式下这三个属性的含义： Java NIO: 缓冲区属性 容量：capacity 作为一块内存区域，缓冲区是有固定大小的，称之为capacity。也就是说只能在缓冲区中最多写入capacity这么多的byte，long，char类型的数据。一旦满了，就需要先清空（已读数据，或者全部清空）才能再往里面写入数据。就像往洗澡盆里放水一样。 位置：position 当往缓冲期里写数据时，总是会从某个位置(position)开始。刚开始时，position是0。当写入一个byte或者long类型的数据后，position会指向下一个可写入的位置。显然，postion的最大值等于capacity-1。 当从缓冲区中读取数据时，也总是会从某个位置开始。当缓冲区从写模式切换到读模式后，postion会被重置为0。当从缓冲区中读取数据时，postion会指向下一个可读取的位置。 上限：limit 在写模式下，缓冲区的limit指的是可以往缓冲区里写入多少数据。即，写模式下limit和capacity的含义相同。 当缓冲区切换到读模式后，limit指的是可以从缓冲区中读出多少数据。因此，当缓冲区切换到读模式后，limit会设置为写模式时position的值。换句话说，可以读取已写入的所有数据(limit被设置为已写入的字节数，该数值其实就是写模式下的position值)。 上面的解释有点绕，还是拿洗澡盆举例：写模式下，limit就是洗澡盆的上沿高度；读模式下，limit就是洗澡盆中水的高度。 缓冲区类型Java NIO中提供了以下几种缓冲区实现： ByteBuffer MappedByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer 可以看到，缓冲区类型与不同的数据类型相对应。也就是说，缓冲区中的数据可以是以char， short，int，long， float 或者 double为单位的。 为缓冲区申请空间想获取缓冲区就必须为其申请空间。每种类型的缓冲区都有allocate()方法。以下就是一个申请大小为 48字节 的ByteBuffer的示例： 1ByteBuffer buf = ByteBuffer.allocate(48); 而下面是一个申请大小为 1024个字符 （注意：单位不一样了哦！）的CharBuffer的示例： 1CharBuffer buf = CharBuffer.allocate(1024); 像缓冲区写入数据两种方法： 将数据从通道写入到缓冲区 1int bytesRead = inChannel.read(buf); //读出到缓冲区中 通过使用缓冲区的put()方法将数据直接写入到缓冲区 1buf.put(127); 其实还有很多不同版本的put()方法，可以让你以不同的方式向缓冲区中写入数据，比如：向缓冲区中的指定位置写入数据，或者向缓冲区中写入一个byte类型的数组。具体可以参考相关的JavaDoC。 flip()flip()方法会将缓冲区从写模式切换为读模式，也就是将limit设置为position，然后重置position为0。 换言之，现在的position表示的就是当前读的位置，而limit则表示了在缓冲区中写入了多少字节或者字符等 - 还有多少字节或者字符可以读出。 从缓冲区中读取数据也是两种方法： 从缓冲区中读取数据写入到通道中 1int bytesWritten = inChannel.write(buf); 使用get()方法，直接从缓冲区中读取数据 1byte aByte = buf.get(); 其实还有很多不同版本的get()方法，可以以不同的方式读取缓冲区的数据，比如：从缓冲区中的指定位置开始读出数据，或者从缓冲区中读取数据存放到byte类型的数组。具体可以参考相关的JavaDoC。 rewind()rewind()方法会将position重置为0，这样可以重复读取缓冲区中的所有数据。而limit值不变，仍然表示缓冲区中可以读出多少个元素（字节、字符等等）。 clear() 和 compact()缓冲区中的所有数据都读取完毕之后，就需要重置缓冲区以便再次写入。这时可以调用clear()方法或者compact()方法。 如果调用了clear()方法，position会重置为0，limit会设置为capacity，即，缓冲区会被清空。但是缓冲区中的数据不会被清除。只有这几个属性表示可以从哪里开始往缓冲区里写入数据。 如果缓冲区中有未读数据，而此时调用了clear()方法，那么这些未读数据就会被『遗忘』，意味着没有属性会标记哪部分数据已读，哪部分未读。 如果缓冲区中有未读数据，之后还要继续读出，但是此时要先写入一部分数据，这时就需要使用compact()方法，而不是clear()方法。 compact()方法会将所有未读数据复制到缓冲区开头，然后会将position设置为最后一个未读数据之后。而limit仍然会设置为capacity，就和clear()方法中的一样。现在，就可以继续往缓冲期写入而不会覆盖未读数据。 mark() 和 reset()通过调用mark()方法，可以在缓冲区中的指定位置做打个标签，随后可以通过调用reset()方法将缓冲区的position重置到打标签的位置。比如这样： 123456buffer.mark(); // 在当前位置打个标签// 连续调用几次 buffer.get() 方法，让子弹飞一会儿。。。// 比如：挨个儿解析每个元素buffer.reset(); // 将position重置到打过标签的位置 equals() 和 compareTo()还可以使用equals() 和 compareTo()比较两个缓冲区。 equals() 两个缓冲区是相等的条件是： 有相同的数据类型（byte，char等） 在缓冲区中剩余的byte，char等个数相等 在缓冲区中所有剩余的byte，char都相同 可以看出，equals()方法只比较缓冲区的一部分，而不是每一个元素。实际上，它只会比较缓冲区的剩余元素，其中剩余元素是指从position到limit之间的元素。 compareTo() compareTo()会使用某种排序方法来比较两个缓冲区中的剩余元素（byte，char等），一个缓冲区比另外一个缓冲区小的条件是： 第一个不相等的元素小于另一个缓冲区中对应的元素 所有元素都相等，但是第一个缓冲区比另一个短（第一个缓冲区元素个数比另外一个少） Java NIO Scatter（分散）、Gather（聚集）Java NIO内建了对Scatter（分散）和Gather（聚集）的支持。Scatter和Gather是从通道中读取数据，或者写入数据到通道时的概念。 从一个通道进行 分散读取 是指将通道中的数据读取到多个缓冲区中。也就是说，将数据从一个通道中『分散』到多个缓冲区中。聚集写入 到通道是指把多个缓冲区中的数据写入到一个通道中。也就是说，由多个缓冲区将数据『聚集』到一个通道中。 在需要对传输的数据进行分开处理的场合，Scatter和Gather会非常有用。比如，一份由消息头和消息体构成的数据，可能会需要将消息头和消息体分散地放在不同的缓冲区中，以便于分别处理他们。 分散读（Scattering Reads）分散读就是从单个Channel中读取数据到多个Buffer中。分散读的原理如下图所示： Java NIO: 分散读 下面的代码片段说明了如何执行分散读： 123456ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] bufferArray = &#123; header, body &#125;;channel.read(bufferArray); 注意到，多个缓冲区会首先组成一个数组，然后将缓冲区数组作为channel.read()方法的参数传入。接着read()方法开始按照缓冲区数组中每个缓冲区的顺序依次往里填充数据。当一个缓冲区写满之后，通道会继续向下一个缓冲区中填充。 在进行分散读时，总是会在填满一个缓冲区后再填充下一个，这就决定了这种方法不适用于处理大小不固定的消息。换言之，在消息头和消息体构成的数据中，如果消息头是固定大小的，比如128字节，那么就可以使用分散读来处理。 聚集写（Gathering Writes）聚集写就是把数据从多个缓冲区中集中写到一个通道中。聚集写的原理如下图所示： Java NIO: 聚集写 下面的代码片段说明了如何执行聚集写： 12345678ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);//把数据写入各个缓冲区中ByteBuffer[] bufferArray = &#123; header, body &#125;;channel.write(bufferArray); 缓冲区数组会被传入到write()方法中，该方法会按照数组中每个缓冲区的顺序依次向通道中写入缓冲区的数据。注意，这里只会写入缓冲区中position和limit之间的数据。因此，对于一个大小为128字节的缓冲区，其中包含了58字节的数据，那么只会向通道中写入58字节。所以，与分散读相比，聚集写还可以处理大小不固定的消息。 Java NIO 通道间的数据传递在Java NIO中，如果有一个通道是FileChannel，那么数据可以从一个通道直接传递到另一个通道。在FileChannel中为此专门提供了transferFrom()方法和transferTo()方法。 transferFrom()FileChannel.transferFrom()方法会从源通道将数据传递到FileChannel。示例如下： 12345678910RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();toChannel.transferFrom(fromChannel, position, count); 参数position表示从指定位置开始往目标文件里面写入数据，count表示最多传输的数据个数。如果源通道中的数据少于count个字节，则实际传输的数据量少于请求的数据量。 此外，某些SocketChannel实现会只传输当前通道中已经就绪的数据，即使之后SocketChannel可能会到达更多的数据。因此，从SocketChannel向FileChannel中传递数据时，可能不会将请求的所有数据（count）都传递过去。 transferTo()transferTo()会从一个FileChannel向其它通道中传递数据。示例如下： 12345678910RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();fromChannel.transferTo(position, count, toChannel); 注意到这个示例与前面的示例非常相似，唯一不同的是调用了哪个FileChannel对象的方法，剩下的全部相同。 而对于SocketChannel来说，transferTo()方法也会有同样的问题。SocketChannel会一直接收来自FileChannel的数据，直到其目标缓冲区被填满才停止。 Java NIO：选择器（Selector）选择器是Java NIO中用以检查一个或者多个NIO通道的组件，决定了那个通道是可以读或者可以写。由此，单个线程可以管理多个通道，进而可以处理多个网络连接。 为什么使用选择器?使用单线程处理多通道的好处是，处理通道时需要的线程更少了。事实上，可以只使用一个线程来处理所有的通道。对于操作系统来说，线程上下文切换的代价是很大的，而且每个线程也会占用一定的系统资源（比如内存）。因此，线程越少越好。 但是还需要记住一点，现在操作系统和CPU处理多任务的能力越来越强，多线程的开销也越来越小。实际上，对于多核CPU来说，没有多任务反而会浪费CPU资源。不管怎样，关于多任务还是单线程的讨论已经超出了本文的范围，这里只需要知道：你可以使用选择器来让单个线程管理多个通道就行了。 下图表示了如何使用一个线程通过选择器来处理3个通道： Java NIO: 使用一个线程通过选择器来处理3个通道 创建选择器代码如下： 1Selector selector = Selector.open(); 将通道注册到选择器中想要通过选择器来使用通道，必须先向选选择器中注册该通道。像这样： 12channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); 通道只有在非阻塞模式下才能使用选择器。这就意味着FileChannel是不能使用选择器的，原因是FileChannel是无法切换到非阻塞模式下的，而基于Socket的通道是可以的。 注意register()方法的第二个参数。这是一个所谓的兴趣集合（interest set），意思是选择器对通道中的哪些事件感兴趣，以监听这类事件。可以监听的事件类型有四种： Connect - 连接就绪 Accept - 建立连接 Read - 读就绪 Write - 写就绪 通道触发了一个事件，其实就是说这个事件已经就绪。因此，我们可以说一个已经成功连接到另外一个服务器的通道为『Connect』就绪状态。一个可以接受传入连接的服务器Socket通道为『Accept』就绪状态。一个有数据可以读取的通道为『Read』就绪状态。一个可以写入数据的通道为『Write』就绪状态。 这四种类型的事件用以下四个SelectionKey常量来表示： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果选择器对多个事件感兴趣，可以使用OR（或）操作将这些常量合并，像这样： 1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; SelectionKey在前文中，在将通道注册到选择器时，调用了register()方法，返回值为SelectionKey对象。SelectionKey对象包含了几个有意思的属性： 兴趣集合（interest set） 就绪状态集合（ready set） 通道 选择器 附加对象 (可选) 下面详细介绍这些属性。 兴趣集合（interest set）兴趣集合（interest set）表示做 选择 时感兴趣的事件集合，正如前文 将通道注册到选择器中 的那样，可以通过SelectionKey来读写这个兴趣集合： 123456int interestSet = selectionKey.interestOps();boolean isInterestedInAccept = interestSet &amp; SelectionKey.OP_ACCEPT;boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE; 显然，可以使用AND（与）操作来判断给定的集合中是否包含了某个事件。 就绪状态集合（ready set）就绪状态集合（ready set），顾名思义，就是指通道中已经就绪的操作集合。在做出『选择』之后，主要就是对就绪状态集合进行操作。关于『选择』会在随后进行介绍。可以使用下面的方法来访问该集合： 1int readySet = selectionKey.readyOps(); 也可以使用和兴趣集合同样的方法来检测就绪状态集合，看看当前通道有哪些事件、操作已经就绪了。此外，还可以使用下面四个方法，它们都会返回一个布尔型的值： 1234selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); 通道 + 选择器访问SelectionKey中的通道和选择器很简单，只需要： 12Channel channel = selectionKey.channel();Selector selector = selectionKey.selector(); 附加对象可以在SelectionKey中附加一个对象，以便于识别给定通道，或者为通道附加更多信息。比如，附加与通道一起使用的缓冲区，或者附加包含更多聚集数据的对象。方法如下： 12selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment(); 当然，可以在注册到选择器的同时在register()方法中附加对象，像这样： 1SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); 通过选择器『选择』通道一旦在选择器中注册了一个或者几个通道之后，就可以调用select()方法。这些方法会返回你感兴趣的事件已经就绪状态的通道，比如Connect，Accept，Read 或者 Write。换言之，如果想选择可以读取数据的通道，select()方法会返回那些Read就绪的通道。select()方法有下面几种重载模式： int select() - 会被阻塞到所注册的事件就绪为止 int select(long timeout) - 也会阻塞，但是可以设置阻塞超时时间（参数timeout） int selectNow() - 不会阻塞，会立即返回任何就绪的通道 int类型的返回值表示有多少个通道已经就绪，即，在最后一次调用select()方法后有多少通道已经就绪。假如调用了一次select()方法，返回了1，说明有一个通道已经就绪；此时再调用一次select()方法，又有一个Channel也变成就绪状态，则还是会返回1。如果不对第一次已经就绪的那个通道做任何处理的话，这时应该有两个通道是处于就绪状态的。但是在每次调用select()方法时，只会有一个通道变为就绪状态。 selectedKeys()在调用select()方法后，其返回值说明有几个通道已经就绪，这时可以调用selectedKeys()方法，通过『已选择键集合』来访问这些通道，像这样： 1Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); 当向选择器中使用Channel.register()方法注册通道时，会返回一个SelectionKey对象。该对象代表了注册到选择器中的通道。可以通过SelectionKey的selectedKeySet()方法来访问这些对象。 遍历『已选择键集合』就可以访问已经就绪的各个通道，如下所示： 1234567891011121314151617181920Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // ServerSocketChannel可以接受连接 &#125; else if (key.isConnectable()) &#123; // 已经连接到远程服务器 &#125; else if (key.isReadable()) &#123; // 通道可以读取 &#125; else if (key.isWritable()) &#123; // 通道可以写入 &#125; keyIterator.remove();&#125; 遍历『已选择键集合』中的每一个键值，判断每一个键值对应的状态集合，看看哪些事件已经就绪。 注意到在最后调用了keyIterator.remove()方法，在通道处理完成之后必须这样做的原因是选择器不会自己从已选择键集合中去掉SelectionKey实例。当下次通道就绪时，选择器会将它再次加入到已选择就绪集合中。 SelectionKey.channel()返回的通道实例需要强制转换成要处理的通道类型，比如ServerSocketChannel或者SocketChannel等。 wakeUp()对于一个在调用select()方法后被阻塞的线程，即使没有任何就绪的通道，也可以唤醒它，让它先离开select()方法。具体方法是，让另外一个线程来调用第一个线程所在选择器的wakeUp()方法。在select()方法中阻塞的线程会立即返回。 如果另外一个线程调用了wakeUp()方法，而目前没有阻塞在select()方法中的线程，那么下一个调用select()方法的线程会被立即『唤醒』。 close()在操作完选择器之后需要调用选择器的close()方法，来关闭选择器，并释放注册到该选择器上的所有的SelectionKey对象，而那些通道自身是不会被关闭的。 选择器的完整示例这是一个完整的例子，打开选择器，向其注册通道（不包含通道的初始化），然后持续的监视选择器中的四个事件（Accept，Connect，Read，Write）的就绪状态。 123456789101112131415161718192021222324252627Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) &#123; int readyChannels = selector.select(); if(readyChannels == 0) continue; Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // ServerSocketChannel可以接受连接 &#125; else if (key.isConnectable()) &#123; // 已经连接到远程服务器 &#125; else if (key.isReadable()) &#123; // 通道可以读取 &#125; else if (key.isWritable()) &#123; // 通道可以写入 &#125; keyIterator.remove(); &#125;&#125; Java NIO 重要的通道实现FileChannelJava NIO的FileChannel是连接到文件的通道，可以通过它读写文件。Java NIO的FileChannel可以替代标准的Java IO API来读写文件。 FileChannel不能设置为非阻塞模式，只能运行在阻塞模式下。 打开FileChannel在使用FileChannel之前必须先打开它。但是FileChannel是无法直接打开的，它需要通过InputStream，OutputStream，或者RandomAccessFile才能得到。如下： 12RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel(); 从FileChannel中读取数据通过调用read()方法可以完成，如下： 12ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); 首先分配一个缓冲区，然后使用read()方法将数据从通道中读取到缓冲区中。方法的返回值说明有多少字节已经读出到缓冲区中，如果返回-1，说明已经到达文件末尾。 向FileChannel中写入数据通过调用write()方法可以完成，该方法需要传入一个缓冲区，如下： 1234567891011String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) &#123; channel.write(buf);&#125; 可以看到write()方法是在while循环中被调用的，因为并不知道具体会有多少字节要写入到通道中，所以只能不停地循环调用write()方法，直到缓冲区中没有数据为止。 关闭FileChannel当然，使用完后必须关闭FileChannel，像这样： 1channel.close(); FileChannel 位置不管是读还是写FileChannel，都需要从某个指定的位置开始。通过调用FileChannel对象的position()方法可以获得当前位置。还可以使用position(long pos)方法来设置位置，例如： 12long pos channel.position();channel.position(pos +123); 如果将位置设置到文件末尾之后，试图从该位置读取通道时，会返回-1，也就是文件结束标志。 如果将位置设置到文件末尾之后，向通道写入数据，文件会被撑大到指定的位置，并写入数据。这有可能导致『文件空洞』，也就是说物理磁盘文件中会有空隙。 FileChannel 大小long fileSize = channel.size(); 会返回当前通道所连接的文件的大小。 FileChannel 截断FileChannel.truncate()方法用来截断文件，可以用它来将文件截断为指定的大小，比如channel.truncate(1024);就会将文件截成1024字节的大小。 FileChannel 强制写入FileChannel.force()方法会将所有通道中未写入的数据全部写入到磁盘中。有时操作系统会把数据缓存到内存中以保证性能，所以不能确保写入到通道中的数据就一定会被写入到磁盘中，直到调用force()方法。 force()方法有一个布尔类型的参数，表示是否也写入文件的元数据（比如权限等），像这样： 1channel.force(true); SocketChannelJava NIO SocketChannel 是连接到 TCP 网络套接字的一种通道。它其实就是Java NIO中的标准Java网络Socket。有两种创建方法： 打开SocketChannel并连接到网络中的某个服务器 在ServerSocketChannel中当有连接进来时，可以创建一个SocketChannel 打开SocketChannel12SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80)); 关闭SocketChannel同样，在使用完后也需要关闭通道，像这样： 1socketChannel.close(); 从SocketChannel中读取数据调用read()方法就可以了： 12ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = socketChannel.read(buf); 首先分配一个缓冲区，数据会从SocketChannel中读取到缓冲区中。然后，调用read()方法读取数据，返回实际读到缓冲区中的字节数。如果返回-1，则说明已经到达数据末尾（连接被关闭）。 向SocketChannel中写入数据调用write()方法，并提供一个缓冲区作为参数就可以了： 1234567891011String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) &#123; channel.write(buf);&#125; 可以看到write()方法是在while循环中被调用的，因为并不知道具体会有多少字节要写入到通道中，所以只能不停地循环调用write()方法，直到缓冲区中没有数据为止。 非阻塞模式SocketChannel可以设置成非阻塞模式。在非阻塞模式下，可以异步地调用connect()， read() 和 write() 方法。 connect()在非阻塞模式下，如果调用SocketChannel的connect()方法，该方法可能会在连接没有就绪时就返回。想要确定连接是否已经建立，可以调用finishConnect()方法，就像这样： 123456socketChannel.configureBlocking(false);socketChannel.connect(new InetSocketAddress(&quot;http://example.com&quot;, 80));while(! socketChannel.finishConnect() )&#123; //等待，或者干点别的... &#125; read()非阻塞模式下的read()方法可能会在尚未读取任何数据时就立即返回，因此必须要注意返回值，看看到底有没有读到数据。 write()非阻塞模式下的write()方法可能会在尚未写入任何数据时就立即返回，因此需要在循环调用write()方法。之前的write()方法也是这么用的，并没有什么不同。 非阻塞模式与选择器SocketChannel的非阻塞模式可以与选择器搭配，更好地进行工作。在选择器中注册若干个SocketChannel，可以向选择器询问哪个通道可以读，哪个通道可以写等。之后会详细介绍。 ServerSocketChannelJava NIO ServerSocketChannel是能够 监听TCP连接 的一种通道，就像标准Java网络中的ServerSocket一样，只不过它位于java.nio.channels包包中。简单的示例如下： 12345678ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));while(true)&#123; SocketChannel socketChannel = serverSocketChannel.accept(); // 开始处理socketChannel...&#125; 打开ServerSocketChannel像这样： 1ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); 关闭ServerSocketChannel当然，用完之后也得关闭，像这样： 1serverSocketChannel.close(); 监听连接ServerSocketChannel.accept()方法会监听新进来的连接，该方法会返回一个带有新进入连接的SocketChannel。换言之，accept()会被阻塞到有新的连接进来。 一般我们不会满足于只监听一个连接，所以accept()一般会被放在一个循环中，像这样： 12345while(true)&#123; SocketChannel socketChannel = serverSocketChannel.accept(); // 开始处理socketChannel...&#125; 当然，也可以使用其他的标识来退出循环，而不是true的无限循环。 非阻塞模式ServerSocketChannel可以切换为非阻塞模式。在该模式下，accept()方法会立即返回，因此如果没任何连接到达的话，可能会返回空（null）。因此，这种情况下需要检查返回的SocketChannel是否为null，就像这样： 123456789101112ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));serverSocketChannel.configureBlocking(false);while(true)&#123; SocketChannel socketChannel = serverSocketChannel.accept(); if(socketChannel != null)&#123; // 开始处理socketChannel... &#125;&#125; Java NIO：非阻塞型服务器即使理解了Java NIO非阻塞模式（选择器，通道，缓冲区等）是如何工作的，设计一个非阻塞型服务器仍旧很难。比起阻塞IO来说，非阻塞IO包含更多的挑战。本章会讨论非阻塞型服务器会面临的几个重要技术课题，同时会介绍一些可能的解决方案。 虽然本章描述的思想是围绕Java NIO来设计的，但是这种思想也适用于任何有类似于『选择器构架』的其他语言中。本章都是建立在Jakob Jenkov的一个简单非阻塞型服务器实现的基础上的，代码可以在这里下载到。 非阻塞型IO管道非阻塞型IO管道是处理非阻塞IO的各个组件组成的一个链，包含了以非阻塞方式处理读和写的过程。图示如下： Java NIO: 非阻塞型IO管道 组件会使用选择器来检查某个通道何时有数据可以读取，然后主机读取数据并根据输入的数据来产生输出，之后输出会再次写入到通道中去。 非阻塞型IO管道不需要同时读数据和写数据，有些管道可能只读取数据，而有些管道可能只写入数据。 上图中只描述了单个组件。事实上一个非阻塞型IO管道可能会包含若干个组件来处理进来的数据。非阻塞型IO管道的长度取决于这个管道需要做什么。 非阻塞型IO管道可能会同时从多个通道中读取输入，比如，从多个SocketChannel中读取数据。 上图中的流程控制也被简化了。其实是组件主动通过选择器从通道中读取数据的，而不是像图示的那样，好像是通道主动将数据推到选择器，选择器再传递给组件，请不要误解。 非阻塞型 vs. 阻塞型IO管道非阻塞型与阻塞型IO管道的最大区别就是数据是如何从通道（Socket或者文件）中读取的。 通常，IO管道会从某个流（从Socket或者文件）中读取数据，将数据分割为一个个连贯的消息（Message）。这和词法分析中将数据流分解为一个个标记(Token)，然后用标记解析器(Tokenizer)进行解析的道理是一样的。而这里，会将数据流分解成比标记更大的消息。负责将数据流分解成消息的组件称之为 消息读取器（Message Reader），简单描述如下图： Java NIO: 消息读取器 阻塞型IO管道会使用类似于InputStream的接口，一个字节一个字节地从通道中读取数据。这种类似于InputStream的接口在调用是会被阻塞，直到有数据可以读出为止。这就是阻塞型消息读取器的实现原理。 使用阻塞型IO接口会大大简化消息读取器的实现。阻塞型消息读取器永远不需要考虑下面这几种情况： 数据流中无数据可读 只从数据流读取了消息的一部分 消息解析需要暂停和继续 类似地，阻塞型 消息写入器（Message Writer） （负责将消息写入到流的组件）也无需考虑下面这两种情况： 只写入了消息的一部分 消息的写入可以暂停和继续 阻塞型IO管道的缺点虽然阻塞型IO管道易于实现，不幸的是它的缺点，就是每个分解成消息的流都需要一个独立的线程来处理。必须这样做的原因是每个流的IO接口都会被阻塞，直到有数据读出为止。这就意味着单个线程不能够先尝试去读取一个流，当没有数据时再尝试去读取下一个流。只要这个线程去读取某个流，它就会被阻塞，直到有数据读出为止，该线程才能继续工作。 如果IO管道是处理很多并发连接的服务器的一部分，那么服务器就需要为每个活动的连接来创建一个线程。在只有上百个并发量的情况下，任何时候服务器可能都不会产生问题。但是，在百万级别的并发量下，这种设计可能就不能很灵活的应对了。每个线程会占用320K（32位的JVM）到1024K（64为的JVM）的内存，所以一百万个线程会占用1TB的内存！这还仅仅是在服务器处理任何传入消息之前（要知道，服务器在处理各种传入的消息时还会产生很多对象，还需要更多的内存）。 为了减少或者保持线程数，很多服务器都设计为使用一个线程池（比如100个线程）每次从到达的连接中读取消息。到达的连接会组成一个队列，线程池中的线程会依次、分批处理这个队列中的连接。如下图： 通过线程池处理连接队列 但是，这种设计需要到达的各个连接经常性地发送数据。假如到达的连接长时间处于不活跃状态，最终线程池中的所有线程都可能被这些不活跃连接所阻塞。这就意味着服务器会变慢，或者没有响应。 还有一些服务器在设计时，为了缓解这一问题，会在线程池中线程的量上加入一些灵活性。比如，如果线程池中的线程已经用光，就再创建更多的线程来承载负荷。这种解决方法可以处理更多可能会让服务器失去响应的慢连接（不活跃连接）。但是记住，在服务器中实际能跑多少条线程还是有上限的，因此，如果有一百万个慢连接，服务器就可能承担不了了。 基本的非阻塞型IO管道设计非阻塞型IO管道可以使用一个线程从多个流中读取消息。这需要这些流能够切换到非阻塞模式。在非阻塞模式下，当尝试从流中读取数据时，可能会返回0，也可能返回更多的字节。如果是0，说明流中无数据可读，如果是1个字节以上，说明流中有东西可读。 为了避免检查返回值是0还是有数据可读，可以使用Java NIO的选择器。在选择器中，可以注册若干个实现了SelectableChannel接口的通道实例。当在选择器上调用select() 或者 selectNow()方法时，选择器会告诉你那些个通道有数据可读。如下图所示： 基本的非阻塞型IO管道设计 读取不完整消息在从SelectableChannel类型的通道中读取数据时，我们并不清楚读取的数据块中到底是完整的一条消息，还是多条消息。数据块中可能只包含了消息的一部分，或者全部消息，或者好几条消息，比如1.5条或2.5条消息，如下图那样： 数据块中可能包含的消息数量 在处理部分消息时，会遇到下面两个课题： 检测数据块中是否有完整的一条消息 在获取到剩余的数据之前，如何处理这些不完整的消息 消息完整性检测需要消息读取器检查数据块中的数据是否至少包含一条完整的消息。如果有一条或者多条完整的消息，那么这些消息会被送到管道中进行处理。消息完整性检测会很频繁的执行，所以必须让这一过程尽可能快速地执行。 只要数据块中存在不完整消息，不管是自身不完整，还是位于一条或者多条完整消息之后，这些消息片段必须先保存起来，直到通道中其余的部分到达为止。 消息完整性检测和不完整消息的存储都由消息读取器负责。为了避免不同通道的消息发生混乱，需要为每一个通道配备一个消息读取器。设计方案如下图： 每一个通道配备一个消息读取器 从选择器中获取有数据可读的通道之后，与该通道对应的消息读取器开始从通道中读取数据并分解为一条条的消息。如果分解后有完整的消息，则将这些完整消息传递到下一个组件中进行处理。 显然，消息读取器是和通信协议相关的。它需要知道所处理消息的格式。假如服务器的实现需要支持跨协议，那么就需要将消息读取器以插件的方式来实现 - 可能会以某种配置参数的形式传入到消息读取器工厂类中。 保存不完整消息现在，我们已经决定让消息读取器来保存那些不完整的消息，直到全部消息已经读取到为止，这就需要想想具体如何保存这些消息。 在设计上需要考虑以下两个方面： 要尽量减少数据复制操作，因为复制的数据越多，性能越低 要将完整的消息以连续的字节顺序保存，以更方便的解析这些消息 每个消息读取器配备一个缓冲区显然，这些不完整的消息需要保存在某种类型的缓冲区上。最直接的实现方法是为每个消息读取器都设置一个内部缓冲区。那么，这个缓冲区需要多大呢？它需要足够大，以至于能存放可允许的最大消息。也就是说，假如最大可允许的消息是1MB，那么每个消息读取器的内部缓冲区就需要至少1MB。 当连接数达到百万级时，让每个连接使用1MB显然是不现实的。1百万x1MB还是1TB的内存！更甚，如果最大消息大小为16MB，或者128MB呢？ 可变缓冲区另外一种可能的选择是为每个消息读取器的内部缓冲区设置为大小可变的。可变缓冲区开始会很小，之后如果消息变大了，那么缓冲区也跟着变大。这样一来每个连接也就不会非得需要比如1MB的缓冲区，它们只需要按照实际需求来分配缓冲区，直到下一条消息到达为止。 可变缓冲区的实现方法有很多种，各有优缺点。接下来会详细讨论。 拷贝时可变缓冲区可变缓冲区的第一种实现方法是开始很小，比如4KB。如果消息大于4KB，就会分配更大的缓冲区，比如8KB，然后将原来4KB缓冲区中的数据复制到大缓冲区中。 这种拷贝时可变缓冲区实现的优点是，一个消息的所有数据都会存放在连续的字节数组中，进而让之后的消息解析更加容易。缺点是对消息越大，数据复制操作会越多。 为了减少数据复制次数，可以深入分析整个系统的消息大小，来确定一个可以减少数据复制次数的缓冲区大小。比如，你发现系统中大多数消息仅仅是简单的小数据量的请求和响应，一般都不会超过4KB。那么，缓冲区的初始大小就应该是4KB。 随后你可能还会发现那些大于4KB的消息常常是因为它们包含了一个文件，而经过调查发现系统中传入的文件大小不会超过128KB，那么将缓冲区的二次扩容大小设置为128KB也是合理的。 最后你发现一但消息超过了128KB之后，大小就无固定模式可寻，那么缓冲区的最终大小可能就需要设置成最大消息的大小了。 根据系统中传入消息大小而设置的以上三个缓冲区的大小值，在一定程度上可以减少数据复制的次数。4KB以下的消息永远不会复制。1百万并发连接的话，也就需要1百万x4KB=4GB的内存，现在（~2017年）的服务器都能扛得住。大小在4KB到128KB之间的消息会复制一次，而且只会往128KB的缓冲区中复制4KB的数据。而128KB到最大消息大小之间的消息会被复制两次：第一次复制4KB，第二次复制128KB，即使是最大的消息，一共也只需要复制132KB的数据。128KB以上的消息不是很多的话，这也是可以接受的。 一旦消息处理完之后，分配的内存就可以释放了。这样一来，同一个连接中下一条消息来之后就只需要最小大小的缓冲区。这就需要保证各个连接之间高效的内存共享。在同一时间，所有的连接都需要大缓冲区的情况是不太可能发生的。 Jakob Jenkov也实现了一个支持可变数组的内存缓冲区，详细可以参考这篇文章。 追加时可变缓冲区让缓冲区可变的另外一种方法是用多个数组组成一个缓冲区。当需要更大的缓冲区时，只需要再申请一个缓冲区往里继续写数据就行。 这种缓冲区的增加方法有两种。一种是申请多个字节数组，并且将这些数组作为一个列表来保存。另外一种方法是在一个较大的、可共享的字节数组中分割一部分区域（分区），然后将这些分区作为缓冲区，保存为一个列表。这两种方法差别不大，个人认为分区策略要更好。 通过追加数组或者分区来扩大缓冲区方法的优点是在写入数据时没有数据复制发生。所有的数据都可以直接从通道复制到缓冲区或者分区中。缺点是数据没有保存在单独连续的数组中，这就使得之后的消息解析更加困难，因为解析器需要检查每个数组的结束位置以及全部数组列表中的结束位置。由于需要检查已写入数据中消息的结束位置，这一模型使用起来也不会很容易。 TLV编码的消息有一些协议的消息是使用TLV（Type：类型，Length：消息长度，Value：消息内容）格式来编码的。这就意味着当消息到达之后，消息的总长度就存在消息头中，这样服务器就可以立即知道需要为全部消息分配多大内存了。 TLV编码使得内存管理更加简单。可以立即知道消息占用多大内存，缓冲区中也不会有空间浪费发生。缺点是，在所有数据到达之前就已经为这些数据预先分配好了内存。少数几个发送大块消息的慢连接也可能会耗尽所有可用内存，导致服务器无法响应。 可以通过使用内部包含多个TLV的消息格式来解决这一问题。这样一来，可以为每一个TLV来分配内存而不是整个消息，而且只需要为那些已经到达的消息来分配内存。但是，如果TLV部分很大的话，还是会像大块消息一样影响到内存管理。 另外一种变通方法是，为那些未接收的消息设定超时时间，比如10~15秒钟。如果正巧有很多条大块消息同时到达时，服务器有可能会短时间失去响应，但是这个方法可以保证服务器之后能够恢复响应。另外，在遭受到蓄意DoS（拒绝服务）攻击时，服务器上的内存还是可能会消耗殆净。 TLV编码有不同的变种。至于使用多少字节来表示类型和长度，这都取决于每种不同的TLV编码。有些TLV编码会将消息长度作为第一个字段，之后是类型，最后是消息内容（也就是LTV编码）。尽管字段的顺序不一样，但这些还是属于TLV的变种。 TLV编码格式大大简化了内存管理，这也是为什么说HTTP1.1协议很烂的原因之一。HTTP2.0中也想通过使用LTV格式编码的数据帧来解决这个问题。 写入不完整的消息在非阻塞型IO管道中数据写入也是一个课题。非阻塞模式下，当在通道上调用write(ByteBuffer)方法时，并不能保证到底能在ByteBuffer中写入多少数据。write(ByteBuffer)方法会返回实际写入的字节数，所以跟踪实际写入的数据量也是可能的。而真正的课题是：如何跟踪那些不完整消息的写入过程，以确保最终全部消息都能够成功写入。 为了管理通道中的不完整消息的写入过程，创建一个消息写入器。和消息读取器一样，每个通道都需要一个消息写入器。在消息写入器内部，会追踪到底写入了当前消息的多少字节。 如果消息写入器收到的消息量比它能够直接写入到通道中的多时，就需要在消息写入器中进行消息排队。消息写入器会尽可能快地向通道中写入数据。消息写入器的简单设计图如下： 使用消息写入器来写入不完整的消息 为了让消息写入器能够发送之前发送的不完整消息，需要不时地调用消息写入器，以便其能够发送更多的数据。 服务器中的连接越多，消息写入器的实例也就越多。检查一百万个消息写入器中那些有数据可以写入是一个很慢的过程。首先，一些消息写入器可能都没任何消息可写。我们不想连它们也检查。其次，并不是所有的通道都进入了写就绪的状态，我们也不想在这些未就绪的通道上浪费时间。 要检测通道是否可写，可以将其注册到选择器中。然而，并不想把所有的通道都注册到选择器中。想象一下，一百万个大部分闲置的连接，而这一百万个连接全部注册到一个选择器中。之后一旦调用select()方法，这些通道基本上都会进入写就绪状态（要知道大部分连接都是闲置的话，几乎是一呼百应）。这样一来，你不得不挨个检查这些通道上的消息写入器，看看有没有消息可以写。 为了避免检查消息写入器有无消息可写，同时所有的通道中是否有消息送达，可以使用以下两步式解决方法： 当消息被写入到消息写入器时，消息写入器把对应的通道注册到选择器中（如果对应的通道没有被注册的话） 当服务器空闲时，它可以问选择器那些通道可以写。对于每个可写入的通道，让它所对应的消息写入器向通道中写入数据。如果这个消息写入器中所有的消息都已经写入完毕，则把该通道从选择器中注销。 这小小的两步式解决方法保证了只有注册到选择器中的通道才是有消息可写入的通道。 总结一下可以看出，非阻塞服务器需要不时地检查进来的数据，看看是否有完整的消息可接收。在一条或者多条完整消息被接收之前，服务器可能要检查好多次，光检查一次是不够的。 类似地，非阻塞服务器也要不时地检查是否有数据需要写。如果有的话，还需要检查相应的连接是否已经准备好可写入。在消息排队时光检查一次是不够的，因为有可能只写入了消息的一部分。 最终，在所有的非阻塞型服务器中会有规律的执行三种『管道』： 检查打开的连接中是否有新数据到达的『读管道』 处理任何到达的完整消息的『数据处理管道』 检查是否可以向任何打开的连接中写入响应消息的『写管道』 这三个管道会循环执行。对他们的执行过程进行优化也是可能的。比如，在没有消息排队时可以跳过写管道。或者，没有新到的完整消息时，可以跳过消息处理管道。 服务器的总体循环时序图如下： 非阻塞型服务器的总体循环时序图 感觉理解困难的话可以直接看这里的代码。 上面代码中实现的非阻塞型服务器使用了一个双线程模型。第一个线程负责从ServerSocketChannel中接收连接。第二个线程来处理已经接收到的连接，比如读取消息，处理消息，以及向连接中写入响应消息。原理图如下： 非阻塞型服务器线程模型 DatagramChannelJava NIO DatagramChannel是可以接受和发送 UDP 数据包的一种通道。因为UDP是一种无连接的传输层协议，所以不能像其他的通道那样对DatagramChannel读取和写入数据，而是需要发送和接收数据。 打开DatagramChannel下面的例子在UDP端口9999上打开了通道： 12DatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(9999)); 接收数据使用receive()方法，像这样： 1234ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();channel.receive(buf); receive()方法会将接收到的数据包复制到给定的缓冲区中。如果接受到数据包比给定的缓冲区大，多出来的数据会被默默地丢掉。 发送数据使用send()方法，像这样： 123456789String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();int bytesSent = channel.send(buf, new InetSocketAddress(&quot;example.com&quot;, 80)); 上面的例子中向『example.com』服务器的80端口发送一个字符串。在这个端口上没有任何监听，所以什么也不会发生。当然，我们也不知道数据包是否已经被接收，因为UDP协议并不会保证数据一定会被送达。 连接到指定地址将DatagramChannel绑定到某个网络地址也是可能的。因为UDP是无连接的协议，这里的绑定不是像TCP通道那样真的与服务器建立连接。而是将DatagramChannel锁定到这个地址，这样可以只向这个地址发送和接收数据。例如： 1channel.connect(new InetSocketAddress(&quot;example.com&quot;, 80)); 当连接之后，可以像使用常规的通道一样使用read()和write()方法了。然而要记住，这并不能保证数据一定会送达。例如： 12int bytesRead = channel.read(buf); int bytesWritten = channel.write(buf); Java NIO PipeJava NIO Pipe是两个线程之间的单向数据连接。一个Pipe有一个源通道（Source Channel）和一个目的通道（Sink Channel）。向目的通道写数据，从源通道读取数据。图示如下： Java NIO Pipe内部构成 创建一个Pipe1Pipe pipe = Pipe.open(); 写数据向Pipe中写入数据时需要访问它的目的通道，如下： 1Pipe.SinkChannel sinkChannel = pipe.sink(); 之后就可以调用SinkChannel的write()方法： 1234567891011String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) &#123; sinkChannel.write(buf);&#125; 读数据从Pipe中读取数据时需要访问它的源通道： 1Pipe.SourceChannel sourceChannel = pipe.source(); 之后就可以调用SourceChannel的read()方法： 12ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); 返回值表示向缓冲区中读出了多少字节的数据。 Java NIO vs. IO在学习Java NIO和IO API是，总会有一个问题： 什么时候该用Java NIO，什么时候该用 IO? 本章会介绍Java NIO和IO的不同之处，用例，以及它们会对编码带来的影响。 Java NIO和IO的主要不同之处简单概括如下表，随后会详细展开。 IO NIO 面向流 面向缓冲区 阻塞IO 非阻塞IO - 选择器 面向流 vs. 面向缓冲区Java IO是面向流设计的，Java NIO是面向缓冲区设计的，具体什么意思呢？ Java IO是面向流设计的，意味着可以从一个流中每次读取一个或者若干个字节。而至于如何处理读到的字节取决于你。它们不会被缓存到任何地方。甚至，无法前后移动流中的数据，想要前后移动流中的数据的话，需要先把它们缓存到一个缓冲区中。 Java NIO是面向缓冲区设计的，意味这数据先被存放到一个缓冲区中，然后再去处理它们。可以按需对缓冲区中数据来回移动。在处理上更加灵活。但是，需要检查缓冲区是否包含了所有要处理的数据。而且，还需要保证在往缓冲区中写入数据时不要覆盖里面未处理的数据。 阻塞IO vs. 非阻塞IOJava IO的各种流都是阻塞型的。也就是说，当一个线程执行了read()或write()时，这个线程会被阻塞到有数据可以读写为止。该线程在此期间不能干任何事情。 Java NIO的非阻塞模式可以使一个线程向通道请求数据，而且只会取得当前可用的部分，即使没有数据的话，线程也不会被阻塞，而是会去做其他事情。 线程在非阻塞IO调用时，空闲时间可以用在其他的通道上做IO操作。这样就保证了单个线程可以管理多个通道的输入和输出。 选择器Java NIO的选择器可以让单个线程来监视多个通道的输入。可以把多个通道注册到一个选择器中，然后使用这个线程来『选择』一个有数据可以处理的通道，或者『选择』一个可以写入的通道。选择器使得单个线程管理多通道变得更简单。 NIO和IO对应用程序设计的影响在IO层是选择NIO还是IO可能影响到应用程序设计的以下几个方面： 对NIO和IO类的API调用 数据处理 数据处理线程的多少 API调用显然，在使用NIO时的API调用与使用IO时是不同的，这没有什么好奇怪的。只不过不是从InputStream中一个字节一个字节的读取数据，而是先将数据读取到缓冲区中，然后再进行处理。 数据处理与IO相比，使用纯NIO实现时的数据处理也会有影响。 在使用IO时，会从InputStream或者Reader中一个字节一个字节的读取数据。假设一下处理以下的结构化数据流： 1234Name: AnnaAge: 25Email: anna@mailserver.comPhone: 1234567890 对上面文本的处理过程可能像下面这样： 12345678InputStream input = ... ; // 从客户端套接字中获取InputStreamBufferedReader reader = new BufferedReader(new InputStreamReader(input));String nameLine = reader.readLine();String ageLine = reader.readLine();String emailLine = reader.readLine();String phoneLine = reader.readLine(); 注意到这时的处理状态取决于程序执行到了哪一步。换言之，当第一个reader.readLine()返回时，可以确定地知道已经读取了一整行数据。这就是为什么说readLine()会一直阻塞到读完一整行数据。也可以知道这行数据包含了『Name』字段，同样地，当第二个readLine()返回时，可以知道这行包含了『Age』，以此类推。 可以看出，只有有新数据读取时程序才会继续执行，而且每一步都会知道读到的数据是什么。一旦执行的线程处理过了某一部分数据后，它就不会再返回（大多数情况下不会）。下图说明了这一原则： Java IO: 从阻塞的流中读取数据 NIO的实现就不一样了。简单的例子如下： 12ByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buffer); 注意在第二行，将数据读到了ByteBuffer中，当方法返回时，也不知道到底缓冲区中读到了多少字节。这会在一定程度上是数据处理变得困难。 假设，第一次调用read(buffer)之后，缓冲区中只读入了半行数据，比如『Name: An』。这样的数据能处理么？并不能。还需要等到这行数据全部读到缓冲区中才能进行有效的处理。 那么要如何知道缓冲区中已经有足够的数据可以用来有效的处理呢？这个，不太可能。唯一的方法是去看缓冲区中的数据。到头来可能会去缓冲区里查看好几次才能确定所有的数据都到齐了。从程序设计角度来说，这非常低效而且可能会变得很糟糕。比如： 123456ByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buffer);while(! bufferFull(bytesRead) ) &#123; bytesRead = inChannel.read(buffer);&#125; bufferFull()方法必须追踪有多少数据已经读入到缓冲区中，然后返回true或者false，取决于缓冲区是否填满。换言之，缓冲区中的数据可以处理时，认为缓冲区已经填满。 bufferFull()方法会扫描整个缓冲区，但是同时还要保持缓冲区的状态。否则，下一个读入数据的位置可能不对。虽然这不太可能，但是还需要注意一下。 如果缓冲区已满，就可以处理数据了。如果未满，在某些特殊情况下可能需要处理已经到达的一部分数据。但是大多数情况下，这是不太合理的。 判断缓冲区数据是否就绪的循环设计图如下： Java NIO 判断缓冲区数据是否就绪 小结NIO使得用单个（或者少数几个）线程管理多个通道（网络连接或者文件）成为可能，但代价是比起处理阻塞流来，数据的解析会变得更加复杂。 如果需要同时间管理上千个连接，每个连接发送的数据量很小，比如聊天服务器，使用NIO来实现服务器可能会有优势。类似地，如果需要与其他主机维持很多打开着的连接，比如P2P网络，使用单线程来管理所有出站连接也是一个优势。这种单线程对多连接的设计思想如图所示： Java NIO 单线程对多连接 如果只有很少几个连接，它们都占用高带宽，每次发送大量数据，可能传统的IO服务器实现更适合这种场景。传统IO服务器的设计原理如下图： Java IO 单线程对单连接 Java NIO PathPath接口是Java 6和Java7中Java NIO 2更新的一部分。在Java 7的Java NIO中加入了Path接口，它位于java.nio.file包中，所以这个接口的完整名称是java.nio.file.Path。 Path接口表示文件系统中的路径，可以是文件路径或者目录路径，可以是相对路径或者绝对路径。绝对路径是从根目录开始一直到指定的文件或者目录的完整路径。相对路径是相对于某个目录开始，到指定的文件或者目录的路径。这里请不要与操作系统的PATH环境变量搞混了。java.nio.file.Path和PATH环境变量没有半毛钱关系。 java.nio.file.Path在和很多方面与java.io.File相似，也有几个小地方不同。在大多数情况下，可以使用Path接口来代替File类。 创建Path实例使用之前必须前创建Path实例，在这里使用java.nio.file.Paths类的静态方法get()来获取一个Path实例。如下所示： 123456789import java.nio.file.Path;import java.nio.file.Paths;public class PathExample &#123; public static void main(String[] args) &#123; Path path = Paths.get(&quot;/tmp/data/myfile.txt&quot;); &#125;&#125; 上面的代码中，可以把Paths.get()看成是产生Path实例的一个工厂。 Paths.get()中的参数决定了是创建一个相对路径的Path实例还是绝对路径的Path实例。上面的例子中使用的是从根目录开始的/tmp/data/myfile.txt绝对路径，在Windows系统中，它是这样的：c:\\data\\myfile.txt。 当然，也可以使用相对路径，对应的方法就变成了Paths.get(basePath, relativePath)。如下所示： 12Path projects = Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;);Path file = Paths.get(&quot;d:\\data&quot;, &quot;projects\\a-project\\myfile.txt&quot;); 第一行表示创建了一个指向d:\data\projects目录的实例。第二行表示创建了一个指向d:\data\projects\a-project\myfile.txt文件的实例。 在使用相对路径时，还可以使用两个特殊的路径标识： . 表示当前目录。 12Path currentDir = Paths.get(&quot;.&quot;);System.out.println(currentDir.toAbsolutePath()); 上面的代码会打印出当前代码所在目录的绝对路径。 如果将.放在一个路径中间，意思就是同一个目录下，比如： 1Path currentDir = Paths.get(&quot;d:\\data\\projects\.\a-project&quot;); 其实就是获取d:\data\projects\a-project路径的实例。 .. 表示父目录，或者上层目录。 下面的代码会得到一个指向当前代码所在目录的上一层目录的实例。 1Path parentDir = Paths.get(&quot;..&quot;); 如果在路径中间使用了..，就表示会切换当前目录的上层目录，比如： 12String path = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;Path parentDir2 = Paths.get(path); 上面的代码会得到一个指向d:\data\projects\another-project的实例。 当然，可以混合使用.和..，比如： 1234Path path1 = Paths.get(&quot;d:\\data\\projects&quot;, &quot;.\\a-project&quot;);Path path2 = Paths.get(&quot;d:\\data\\projects\\a-project&quot;, &quot;..\\another-project&quot;); Path.normalize()Path.normalize()方法可以用来规格化路径。规格化的意思是去除路径中间的.和..，并且解析到路径所指的位置。例如： 12345678String originalPath = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;Path path1 = Paths.get(originalPath);System.out.println(&quot;path1 = &quot; + path1);Path path2 = path1.normalize();System.out.println(&quot;path2 = &quot; + path2); 上面的代码直接打印Path实例，事实上是调用了Path.toString()方法。最终的输出结果为： 12path1 = d:\data\projects\a-project\..\another-projectpath2 = d:\data\projects\another-project 可以看到，通过规格化操作，将路径中包含的a-project\..部分被去除了。 Java NIO FilesJava NIO Files类提供了操作文件系统中文件的几种方法。本章只介绍最常用的几个方法，可以参考JavaDoC了解其他的方法。 java.nio.file.Files需要和java.nio.file.Path配合使用，所以进入本章前请务必理解Path。 Files.exists()Files.exists()检查文件系统中给定的Path是否已经存在。 也可以创建一个文件系统中不存在的Path实例。比如，要新建一个目录的话，会先创建一个不存在的Path实例，然后再创建这个目录。 因为Path实例指向的文件可能在文件系统不存在，所以可以使用Files.exists()方法来检查。例如： 12345Path path = Paths.get(&quot;data/logging.properties&quot;);boolean pathExists = Files.exists(path, new LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS&#125;); 上面的代码中，先用需要判断存在与否的路径创建一个Path实例。然后将Path实例作为第一个参数传入Files.exists()方法来检查。 注意到Files.exists()方法的第二个参数。这个参数是影响判断文件存在与否的选项组成的数组。上面的代码中使用了LinkOption.NOFOLLOW_LINKS选项，意思是判断文件存在与否时，不会跟踪判断符号连接（Windows下的快捷方式，macOS下的替身）所指向的文件是否存在。 Files.createDirectory()Files.createDirectory()为给定的Path实例创建一个目录。例如： 12345678910Path path = Paths.get(&quot;data/subdir&quot;);try &#123; Path newDir = Files.createDirectory(path);&#125; catch(FileAlreadyExistsException e)&#123; // 目录已经存在&#125; catch (IOException e) &#123; // 其他地方出了问题 e.printStackTrace();&#125; 以上代码第一行先以给定路径创建Path实例。接着在try-catch中调用Files.createDirectory()方法，并传入Path实例。若创建成功，这返回新建目录的Path实例。 如果指定的目录已经存在，就会抛出java.nio.file.FileAlreadyExistsException异常。如果其他地方处理问题，则会抛出IOException异常。比如新建目录的父目录不存在，就会抛出IOException异常。 覆盖已存在的文件使用Files.copy()方法可以强制覆盖一个已经存在的文件。比如： 123456789101112Path sourcePath = Paths.get(&quot;data/logging.properties&quot;);Path destinationPath = Paths.get(&quot;data/logging-copy.properties&quot;);try &#123; Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);&#125; catch(FileAlreadyExistsException e) &#123; // 目标文件已经存在&#125; catch (IOException e) &#123; // 其他地方出了问题 e.printStackTrace();&#125; 注意到Files.copy()方法的第三个参数，StandardCopyOption.REPLACE_EXISTING就是覆盖已经存在文件的意思。 Files.move()Java NIO Files类中包含了移动文件到另外一个位置的方法。移动文件和重命名文件实质上是一样的，除了移动文件时可以在移动位置的同时改变文件名。没错，可以使用java.io.File中的renameTo()方法，但是现在也可以使用java.nio.file.Files类的Files.move()方法做同样的事情了。比如： 12345678910Path sourcePath = Paths.get(&quot;data/logging-copy.properties&quot;);Path destinationPath = Paths.get(&quot;data/subdir/logging-moved.properties&quot;);try &#123; Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);&#125; catch (IOException e) &#123; //移动文件失败 e.printStackTrace();&#125; 注意到Files.move()方法的第三个参数，这个参数是可选的，表示移动文件时覆盖已经存在的文件。 在移动文件失败时会抛出IOException异常。比如目标文件已经存在，而没有指定StandardCopyOption.REPLACE_EXISTING选项，或者要移动的文件不存在，等等。 Files.delete()Files.delete()方法用来删除文件或者目录。比如： 12345678Path path = Paths.get(&quot;data/subdir/logging-moved.properties&quot;);try &#123; Files.delete(path);&#125; catch (IOException e) &#123; //删除文件失败 e.printStackTrace();&#125; Files.walkFileTree()Files.walkFileTree()方法可以递归遍历目录树。walkFileTree()方法需要一个Path实例和一个FileVisitor作为参数。Path实例指向需要遍历的目录，而FileVisitor在每次遍历时都会调用。 FileVisitor接口的声明如下： 12345678910111213public interface FileVisitor &#123; public FileVisitResult preVisitDirectory( Path dir, BasicFileAttributes attrs) throws IOException; public FileVisitResult visitFile( Path file, BasicFileAttributes attrs) throws IOException; public FileVisitResult visitFileFailed( Path file, IOException exc) throws IOException; public FileVisitResult postVisitDirectory( Path dir, IOException exc) throws IOException;&#125; 在传入到walkFileTree()方法时，必须实现该接口。FileVisitor接口的实现类中的各个方法会在遍历的不同阶段被调用。其实，并不需要实现FileVisitor接口的所有方法，直接继承SimpleFileVisitor类会更简单，这个类是FileVisitor接口的默认实现。例如： 12345678910111213141516171819202122232425Files.walkFileTree(path, new FileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123; System.out.println(&quot;pre visit dir:&quot; + dir); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(&quot;visit file: &quot; + file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException &#123; System.out.println(&quot;visit file failed: &quot; + file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123; System.out.println(&quot;post visit directory: &quot; + dir); return FileVisitResult.CONTINUE; &#125;&#125;); FileVisitor接口的实现类中的各个方法会在遍历的不同阶段被调用。 preVisitDirectory()方法会在服务任何目录之前会被调用 postVisitDirectory()方法会在访问任何目录之后被调用。 visitFile()方法会在每次遍历到文件，记住，不是目录，只是文件时被调用。 visitFileFailed()方法会在访问文件失败时被调用，比如访问权限不足或者其他问题。 这四个方法都应该返回一个FileVisitResult枚举实例。FileVisitResult枚举包含以下几个选项： CONTINUE - 表示遍历可以正常进行 TERMINATE - 表示遍历应该结束 SKIP_SIBLINGS - 表示遍历可以继续，但是不会访问同级的文件或者目录 SKIP_SUBTREE - 表示遍历可以继续，但是不会继续访问当前目录。这个选项只在preVisitDirectory()方法返回时起作用。其他方法只会把它当做CONTINUE来处理。 通过这些方法的返回值，就可以确定遍历操作是否应该继续。 搜索文件下面的例子中，在walkFileTree()方法中使用了SimpleFileVisitor类，来查找名称为README.txt的文件。 123456789101112131415161718192021Path rootPath = Paths.get(&quot;data&quot;);String fileToFind = File.separator + &quot;README.txt&quot;;try &#123; Files.walkFileTree(rootPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; String fileString = file.toAbsolutePath().toString(); //System.out.println(&quot;pathString = &quot; + fileString); if(fileString.endsWith(fileToFind))&#123; System.out.println(&quot;file found at path: &quot; + file.toAbsolutePath()); return FileVisitResult.TERMINATE; &#125; return FileVisitResult.CONTINUE; &#125; &#125;);&#125; catch(IOException e)&#123; e.printStackTrace();&#125; 递归删除目录Files.walkFileTree()方法也可以用来递归地删除一个目录下所有的子目录和文件。Files.delete()只能删除空目录。通过遍历所有的目录，删除每个目录中的所有文件（在visitFile()方法中删除），然后再删除目录本身（在postVisitDirectory()方法中删除），就可以删除所有的子目录和文件了。例如： 123456789101112131415161718192021Path rootPath = Paths.get(&quot;data/to-delete&quot;);try &#123; Files.walkFileTree(rootPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println(&quot;delete file: &quot; + file.toString()); Files.delete(file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123; Files.delete(dir); System.out.println(&quot;delete dir: &quot; + dir.toString()); return FileVisitResult.CONTINUE; &#125; &#125;);&#125; catch(IOException e)&#123; e.printStackTrace();&#125; Files类中的其他方法在java.nio.file.Files中还包含了很多有用的方法。比如创建符号链接，确定文件大小，设置文件权限等等。详细的内容可以参考JavaDoC。 Java NIO AsynchronousFileChannel在Java 7的Java NIO中新加入了AsynchronousFileChannel，它可以异步地读写文件。 创建AsynchronousFileChannel1234Path path = Paths.get(&quot;data/test.xml&quot;);AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ); 上述代码中，首先创建一个指向指定文件的Path实例，然后通过调用open()方法，将Path实例作为第一个参数传给AsynchronousFileChannel。第二个参数表示了要对文件进行何种操作，StandardOpenOption.READ表示要打开文件进行读操作。 读数据在AsynchronousFileChannel中有两种读文件的方法，都是通过调用read()方法来完成。下面详细说明。 通过Future读取数据第一种方法是调用返回Future对象的read()方法。像这样： 1Future&lt;Integer&gt; operation = fileChannel.read(buffer, 0); read()方法的第一个参数是ByteBuffer，从AsynchronousFileChannel读出的数据会转存到这个缓冲区中。第二个参数表示文件中的读取位置。 即使读操作没有完成，read()方法也会立即返回。通过检查返回的Future对象中的isDone()方法来判断读操作是否结束。下面是一个完整的例子： 1234567891011121314AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);ByteBuffer buffer = ByteBuffer.allocate(1024);long position = 0;Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);while(!operation.isDone());buffer.flip();byte[] data = new byte[buffer.limit()];buffer.get(data);System.out.println(new String(data));buffer.clear(); 首先创建一个AsynchronousFileChannel对象，然后又创建一个ByteBuffer。将ByteBuffer作为第一个参数传给read()方法，并指定从0位置开始读取文件。在开始读操作后，循环检查读操作是否完成，虽然这种处理方式会浪费CPU资源，但是无论哪种方法，都需要等待读操作完成。一旦读操作完成后，就打印出缓冲区中的数据。 通过CompletionHandler来读取数据read()方法的第二种重载方式会传入一个CompletionHandler接口实例作为参数，像这样： 123456789101112131415fileChannel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer attachment) &#123; System.out.println(&quot;result = &quot; + result); attachment.flip(); byte[] data = new byte[attachment.limit()]; attachment.get(data); System.out.println(new String(data)); attachment.clear(); &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; &#125;&#125;); 当读操作完成后，会调用CompletionHandler实例的completed()方法。completed()方法的第一个Integer参数说明了读取了多少字节的数据，第二参数attachment其实就是read()方法的第三个参数，这里读写都使用了同一个缓冲区，这里当然可以使用其他的缓冲区。 如果读操作失败了，会调用CompletionHandler实例的failed()方法。 写数据就和写数据一样，写数据时也有两种方法，都是调用AsynchronousFileChannel的write()方法。详述如下。 通过Future写入数据AsynchronousFileChannel可以异步地向文件中写入数据，像这样： 12345678910111213141516Path path = Paths.get(&quot;data/test-write.txt&quot;);AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);ByteBuffer buffer = ByteBuffer.allocate(1024);long position = 0;buffer.put(&quot;test data&quot;.getBytes());buffer.flip();Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);buffer.clear();while(!operation.isDone());System.out.println(&quot;Write done&quot;); 首先将AsynchronousFileChannel以写模式打开，创建一个ByteBuffer并写入一些数据。然后将ByteBuffer中的数据写入到文件中。最后，循环检查返回的Future对象的isDone()方法，看写操作是否完成。 在写入之前，可以用下面的代码确保写入的文件是一定存在的： 123if(!Files.exists(path))&#123; Files.createFile(path);&#125; 通过CompletionHandler来写入数据当然也可使用CompletionHandler来代替Future对象进行数据写入。比如： 1234567891011121314151617181920212223242526Path path = Paths.get(&quot;data/test-write.txt&quot;);if(!Files.exists(path))&#123; Files.createFile(path);&#125;AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);ByteBuffer buffer = ByteBuffer.allocate(1024);long position = 0;buffer.put(&quot;test data&quot;.getBytes());buffer.flip();fileChannel.write(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer attachment) &#123; System.out.println(&quot;bytes written: &quot; + result); &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; System.out.println(&quot;Write failed&quot;); exc.printStackTrace(); &#125;&#125;); 在写入完成后，会调用CompletionHandler实例的completed()方法，如果因为某种原因失败了的话，则会调用failed()方法。这里要特别注意参数attachment的使用方法。 参考：http://xintq.net/2017/06/12/everything-about-java-nio/#%E9%98%BB%E5%A1%9Eio-vs-%E9%9D%9E%E9%98%BB%E5%A1%9Eio https://www.zhihu.com/question/27991975 https://www.jianshu.com/p/f48c8410ac79]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java reflect反射注解动态代理原理]]></title>
    <url>%2Fposts%2Fjava_jdk_base_reflect_proxy.html</url>
    <content type="text"><![CDATA[JAVA反射 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射机制是什么 面试有可能会问到，这句话不管你能不能理解，但是你只要记住就可以了 反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。 反射机制能做什么反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理(ps:这个知识点也很重要，后续会为大家讲到) Java 反射机制的应用场景 逆向代码 ，例如反编译 与注解相结合的框架 例如Retrofit 单纯的反射机制应用框架 例如EventBus 动态生成类框架 例如Gson 反射机制的优点与缺点为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念 静态编译：在编译时确定类型，绑定对象,即通过。 动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 优点 可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。 缺点 对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。 理解Class类和类类型想要了解反射首先理解一下Class类，它是反射实现的基础。类是java.lang.Class类的实例对象，而Class是所有类的类（There is a class named Class）对于普通的对象，我们一般都会这样创建和表示： 1Code code1 = new Code(); 上面说了，所有的类都是Class的对象，那么如何表示呢，可不可以通过如下方式呢： 1Class c = new Class(); 但是我们查看Class的源码时，是这样写的： 123private Class(ClassLoader loader) &#123; classLoader = loader; &#125; 可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，虽然我们不能new一个Class对象，但是却可以通过已有的类得到一个Class对象，共有三种方式，如下： 123Class c1 = Code.class; 这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的Class c2 = code1.getClass(); code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的 Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;); 这种方法是Class类调用forName方法，通过一个类的全量限定名获得 这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。 举个简单例子代码： 12345678910111213141516public class ReflectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //第一种：Class c1 = Code.class; Class class1=ReflectDemo.class; System.out.println(class1.getName()); //第二种：Class c2 = code1.getClass(); ReflectDemo demo2= new ReflectDemo(); Class c2 = demo2.getClass(); System.out.println(c2.getName()); //第三种：Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;); Class class3 = Class.forName(&quot;com.tengj.reflect.ReflectDemo&quot;); System.out.println(class3.getName()); &#125;&#125; 执行结果： 123com.tengj.reflect.ReflectDemocom.tengj.reflect.ReflectDemocom.tengj.reflect.ReflectDemo Java反射相关操作 在这里先看一下sun为我们提供了那些反射机制中的类：java.lang.Class;java.lang.reflect.Constructor; java.lang.reflect.Field;java.lang.reflect.Method;java.lang.reflect.Modifier; 前面我们知道了怎么获取Class，那么我们可以通过这个Class干什么呢？总结如下： 获取成员方法Method 获取成员变量Field 获取构造函数Constructor 下面来具体介绍 获取成员方法信息 两个参数分别是方法名和方法参数类的类类型列表。 12345678public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的//具体使用Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法 Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法 Method method = class1.getMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的public方法 Method declaredMethod = class1.getDeclaredMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的方法 举个例子： 例如类A有如下一个方法： 123public void fun(String name,int age) &#123; System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;); &#125; 现在知道A有一个对象a，那么就可以通过： 1234Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;); //先生成classObject o = c.newInstance(); //newInstance可以初始化一个实例Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);//获取方法method.invoke(o, &quot;tengj&quot;, 10); //通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person &#123; private String name; private int age; private String msg=&quot;hello wrold&quot;; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person() &#123; &#125; private Person(String name) &#123; this.name = name; System.out.println(name); &#125; public void fun() &#123; System.out.println(&quot;fun&quot;); &#125; public void fun(String name,int age) &#123; System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;); &#125;&#125;public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;); Object o = c.newInstance(); Method method = c.getMethod(&quot;fun&quot;, String.class, int.class); method.invoke(o, &quot;tengj&quot;, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1我叫tengj,今年10岁 怎样，是不是感觉很厉害，我们只要知道这个类的路径全称就能玩弄它于鼓掌之间。 有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现： 1.获取所有方法的数组： 1234Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的或者：Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的 2.然后循环这个数组就得到每个方法了： 1for (Method method : methods) 完整代码如下：person类跟上面一样，这里以及后面就不贴出来了，只贴关键代码 1234567891011121314public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;); Method[] methods = c.getDeclaredMethods(); for(Method m:methods)&#123; String methodName= m.getName(); System.out.println(methodName); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 123456getNamesetNamesetAgefunfungetAge 这里如果把c.getDeclaredMethods();改成c.getMethods();执行结果如下，多了很多方法，以为把Object里面的方法也打印出来了，因为Object是所有类的父类： 123456789101112131415getNamesetNamegetAgesetAgefunfunwaitwaitwaitequalstoStringhashCodegetClassnotifynotifyAll 获取成员变量信息 想一想成员变量中都包括什么：成员变量类型+成员变量名 类的成员变量也是一个对象，它是java.lang.reflect.Field的一个对象，所以我们通过java.lang.reflect.Field里面封装的方法来获取这些信息。 单独获取某个成员变量，通过Class类的以下方法实现： 参数是成员变量的名字 12345678public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量//具体实现Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性 Field[] publicFields = class1.getFields();//获取class对象的public属性 Field ageField = class1.getDeclaredField(&quot;age&quot;);//获取class指定属性 Field desField = class1.getField(&quot;des&quot;);//获取class指定的public属性 举个例子： 例如一个类A有如下成员变量： 1private int n; 如果A有一个对象a，那么就可以这样得到其成员变量： 12Class c = a.getClass();Field field = c.getDeclaredField(&quot;n&quot;); 完整代码如下： 123456789101112131415public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;); //获取成员变量 Field field = c.getDeclaredField(&quot;msg&quot;); //因为msg变量是private的，所以不能用getField方法 Object o = c.newInstance(); field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。 Object msg = field.get(o); System.out.println(msg); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1hello wrold 同样，如果想要获取所有成员变量的信息，可以通过以下几步 1.获取所有成员变量的数组： 1Field[] fields = c.getDeclaredFields(); 2.遍历变量数组，获得某个成员变量field 1for (Field field : fields) 完整代码： 12345678910111213public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;); Field[] fields = c.getDeclaredFields(); for(Field field :fields)&#123; System.out.println(field.getName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 123nameagemsg 获取构造函数 最后再想一想构造函数中都包括什么：构造函数参数同上，类的成构造函数也是一个对象，它是java.lang.reflect.Constructor的一个对象，所以我们通过java.lang.reflect.Constructor里面封装的方法来获取这些信息。 单独获取某个构造函数,通过Class类的以下方法实现： 这个参数为构造函数参数类的类类型列表 12345678public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所有的构造器，不包括其父类的构造器public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类//具体Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数 Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数 Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数 Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数 举个例子： 例如类A有如下一个构造函数： 123public A(String a, int b) &#123; // code body&#125; 那么就可以通过： 1Constructor constructor = a.getDeclaredConstructor(String.class, int.class); 来获取这个构造函数。 完整代码： 12345678910111213public class ReflectDemo &#123; public static void main(String[] args)&#123; try &#123; Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;); //获取构造函数 Constructor constructor = c.getDeclaredConstructor(String.class); constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。 constructor.newInstance(&quot;tengj&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 1tengj 注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式： 1fromClass.getDeclaredConstructor(String.class).newInstance(&quot;tengj&quot;); 获取所有的构造函数，可以通过以下步骤实现： 1.获取该类的所有构造函数，放在一个数组中： 1Constructor[] constructors = c.getDeclaredConstructors(); 2.遍历构造函数数组，获得某个构造函数constructor: 1for (Constructor constructor : constructors) 完整代码： 1234567891011public class ReflectDemo &#123; public static void main(String[] args)&#123; Constructor[] constructors = c.getDeclaredConstructors(); for(Constructor constructor:constructors)&#123; System.out.println(constructor); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 12public com.tengj.reflect.Person()public com.tengj.reflect.Person(java.lang.String) 其他方法 注解需要用到的 1234Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解 Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解 Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合 获取class对象的信息 12345678910111213141516boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型 boolean isArray = class1.isArray();//判断是否是集合类 boolean isAnnotation = class1.isAnnotation();//判断是否是注解类 boolean isInterface = class1.isInterface();//判断是否是接口类 boolean isEnum = class1.isEnum();//判断是否是枚举类 boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类 boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰 String className = class1.getName();//获取class名字 包含包名路径 Package aPackage = class1.getPackage();//获取class的包信息 String simpleName = class1.getSimpleName();//获取class类名 int modifiers = class1.getModifiers();//获取class访问权限 Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类 Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类getSuperclass()：获取某类的父类 getInterfaces()：获取某类实现的接口 通过反射了解集合泛型的本质 扩展的知识点，了解就可以了。后续会为大家写一篇关于泛型的文章。 首先下结论： Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。 下面通过一个实例来验证： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 集合泛型的本质 */public class GenericEssence &#123; public static void main(String[] args) &#123; List list1 = new ArrayList(); // 没有泛型 List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); // 有泛型 /* * 1.首先观察正常添加元素方式，在编译器检查泛型， * 这个时候如果list2添加int类型会报错 */ list2.add(&quot;hello&quot;);// list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错 System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 此时list2长度为1 /* * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2 * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int * 型的元素 */ Class c1 = list1.getClass(); Class c2 = list2.getClass(); System.out.println(c1 == c2); // 结果：true，说明类类型完全相同 // 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查 try &#123; Method m = c2.getMethod(&quot;add&quot;, Object.class); // 通过方法反射得到add方法 m.invoke(list2, 20); // 给list2添加一个int型的，上面显示在编译器是会报错的 System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 结果：2，说明list2长度增加了，并没有泛型检查 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; /* * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入 * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。 */ &#125;&#125; 执行结果： 123list2的长度是：1truelist2的长度是：2 思维导图 有助于理解上述所讲的知识点 拓展阅读Java反射机制深入详解 - 火星十一郎 - 博客园Java反射入门 - Trigl的博客 - CSDN博客Java反射机制 - ①块腹肌 - 博客园Java 反射机制浅析 - 孤旅者 - 博客园反射机制的理解及其用途 - 每天进步一点点！ - ITeye博客Java动态代理与反射详解 - 浩大王 - 博客园 JAVA注解概念及作用 概念 注解即元数据,就是源代码的元数据 注解在代码中添加信息提供了一种形式化的方法,可以在后续中更方便的 使用这些数据 Annotation是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具。 作用 生成文档 跟踪代码依赖性，实现替代配置文件功能,减少配置。如Spring中的一些注解 在编译时进行格式检查，如@Override等 每当你创建描述符性质的类或者接口时,一旦其中包含重复性的工作，就可以考虑使用注解来简化与自动化该过程。 什么是java注解？在java语法中，使用@符号作为开头，并在@后面紧跟注解名。被运用于类，接口，方法和字段之上，例如： 1234@Overridevoid myMethod() &#123; ......&#125; 这其中@Override就是注解。这个注解的作用也就是告诉编译器，myMethod()方法覆写了父类中的myMethod()方法。 java中内置的注解java中有三个内置的注解： @Override:表示当前的方法定义将覆盖超类中的方法，如果出现错误，编译器就会报错。 @Deprecated:如果使用此注解，编译器会出现警告信息。 @SuppressWarnings:忽略编译器的警告信息。 本文不在阐述三种内置注解的使用情节和方法，感兴趣的请看这里 元注解 自定义注解的时候用到的，也就是自定义注解的注解；（这句话我自己说的，不知道对不对） 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。 Java5.0定义的4个元注解： @Target @Retention @Documented @Inherited java8加了两个新注解，后续我会讲到。 这些类型和它们所支持的类在java.lang.annotation包中可以找到。 @Target @Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： 类型 用途 CONSTRUCTOR 用于描述构造器 FIELD 用于描述域 LOCAL_VARIABLE 用于描述局部变量 METHOD 用于描述方法 PACKAGE 用于描述包 PARAMETER 用于描述参数 TYPE 用于描述类、接口(包括注解类型) 或enum声明 比如说这个注解表示只能在方法中使用： 12345678910111213@Target(&#123;ElementType.METHOD&#125;)public @interface MyCustomAnnotation &#123;&#125;//使用public class MyClass &#123; @MyCustomAnnotation public void myMethod() &#123; ...... &#125;&#125; @Retention @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： 类型 用途 说明 SOURCE 在源文件中有效（即源文件保留） 仅出现在源代码中，而被编译器丢弃 CLASS 在class文件中有效（即class保留） 被编译在class文件中 RUNTIME 在运行时有效（即运行时保留） 编译在class文件中 使用示例： 12345678/*** * 字段注解接口 */@Target(value = &#123;ElementType.FIELD&#125;)//注解可以被添加在属性上@Retention(value = RetentionPolicy.RUNTIME)//注解保存在JVM运行时刻,能够在运行时刻通过反射API来获取到注解的信息public @interface Column &#123; String name();//注解的name属性&#125; @Documented @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 作用：将注解包含在javadoc中 示例： 123java.lang.annotation.Documented@Documentedpublic @interface MyCustomAnnotation &#123; //Annotation body&#125; @Inherited 是一个标记注解 阐述了某个被标注的类型是被继承的 使用了@Inherited修饰的annotation类型被用于一个class,则这个annotation将被用于该class的子类@Inherited annotation类型是被标注过的class的子类所继承。类并不从实现的接口继承annotation,方法不从它所重载的方法继承annotation 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 作用：允许子类继承父类中的注解 示例，这里的MyParentClass 使用的注解标注了@Inherited，所以子类可以继承这个注解信息： 1234java.lang.annotation.Inherited@Inheritedpublic @interface MyCustomAnnotation &#123;&#125; 1234@MyCustomAnnotationpublic class MyParentClass &#123; ... &#125; 123public class MyChildClass extends MyParentClass &#123; ... &#125; 自定义注解格式123public @interface 注解名&#123; 定义体&#125; 注解参数的可支持数据类型: 所有基本数据类型(int,float,double,boolean,byte,char,long,short) String 类型 Class类型 enum类型 Annotation类型 以上所有类型的数组 规则 修饰符只能是public 或默认(default) 参数成员只能用基本类型byte,short,int,long,float,double,boolean八种基本类型和String,Enum,Class,annotations及这些类型的数组 如果只有一个参数成员,最好将名称设为”value” 注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值 在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值 示例:1234567891011121314151617181920/** * test注解 * @author ddk * */ @Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TestAnnotation &#123; /** * id * @return */ public int id() default -1; /** * name * @return */ public String name() default &quot;&quot;;&#125; 注解处理器类库 java.lang.reflect.AnnotatedElement Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类： Class：类定义 Constructor：构造器定义 Field：累的成员变量定义 Method：类的方法定义 Package：类的包定义 java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息： 方法1： T getAnnotation(Class annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。 方法3：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false. 方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 注解处理器示例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/***********注解声明***************//** * 水果名称注解 * @author peida * */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitName &#123; String value() default &quot;&quot;;&#125;/** * 水果颜色注解 * @author peida * */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitColor &#123; /** * 颜色枚举 * @author peida * */ public enum Color&#123; BULE,RED,GREEN&#125;; /** * 颜色属性 * @return */ Color fruitColor() default Color.GREEN;&#125;/** * 水果供应者注解 * @author peida * */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider &#123; /** * 供应商编号 * @return */ public int id() default -1; /** * 供应商名称 * @return */ public String name() default &quot;&quot;; /** * 供应商地址 * @return */ public String address() default &quot;&quot;;&#125;/***********注解使用***************/public class Apple &#123; @FruitName(&quot;Apple&quot;) private String appleName; @FruitColor(fruitColor=Color.RED) private String appleColor; @FruitProvider(id=1,name=&quot;陕西红富士集团&quot;,address=&quot;陕西省西安市延安路89号红富士大厦&quot;) private String appleProvider; public void setAppleColor(String appleColor) &#123; this.appleColor = appleColor; &#125; public String getAppleColor() &#123; return appleColor; &#125; public void setAppleName(String appleName) &#123; this.appleName = appleName; &#125; public String getAppleName() &#123; return appleName; &#125; public void setAppleProvider(String appleProvider) &#123; this.appleProvider = appleProvider; &#125; public String getAppleProvider() &#123; return appleProvider; &#125; public void displayName()&#123; System.out.println(&quot;水果的名字是：苹果&quot;); &#125;&#125;/***********注解处理器***************///其实是用的反射public class FruitInfoUtil &#123; public static void getFruitInfo(Class&lt;?&gt; clazz)&#123; String strFruitName=&quot; 水果名称：&quot;; String strFruitColor=&quot; 水果颜色：&quot;; String strFruitProvicer=&quot;供应商信息：&quot;; Field[] fields = clazz.getDeclaredFields(); for(Field field :fields)&#123; if(field.isAnnotationPresent(FruitName.class))&#123; FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class); strFruitName=strFruitName+fruitName.value(); System.out.println(strFruitName); &#125; else if(field.isAnnotationPresent(FruitColor.class))&#123; FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor.class); strFruitColor=strFruitColor+fruitColor.fruitColor().toString(); System.out.println(strFruitColor); &#125; else if(field.isAnnotationPresent(FruitProvider.class))&#123; FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider.class); strFruitProvicer=&quot; 供应商编号：&quot;+fruitProvider.id()+&quot; 供应商名称：&quot;+fruitProvider.name()+&quot; 供应商地址：&quot;+fruitProvider.address(); System.out.println(strFruitProvicer); &#125; &#125; &#125;&#125;/***********输出结果***************/public class FruitRun &#123; /** * @param args */ public static void main(String[] args) &#123; FruitInfoUtil.getFruitInfo(Apple.class); &#125;&#125;==================================== 水果名称：Apple 水果颜色：RED 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦 Java 8 中注解新特性 @Repeatable 元注解,表示被修饰的注解可以用在同一个声明式或者类型加上多个相同的注解（包含不同的属性值） @Native 元注解,本地方法 java8 中Annotation 可以被用在任何使用 Type 的地方 123456789101112 //初始化对象时String myString = new @NotNull String();//对象类型转化时myString = (@NonNull String) str;//使用 implements 表达式时class MyList&lt;T&gt; implements @ReadOnly List&lt;@ReadOnly T&gt;&#123;...&#125;//使用 throws 表达式时public void validateValues() throws @Critical ValidationFailedException&#123;...&#125; 思维导图 动态代理Java Proxy和CGLIB动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。静态代理的代理关系在编译时就确定了，而动态代理的代理关系是在编译期确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性。今天我们来探讨Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理。 JDK原生动态代理先从直观的示例说起，假设我们有一个接口Hello和一个简单实现HelloImp： 1234567891011// 接口interface Hello&#123; String sayHello(String str);&#125;// 实现class HelloImp implements Hello&#123; @Override public String sayHello(String str) &#123; return &quot;HelloImp: &quot; + str; &#125;&#125; 这是Java种再常见不过的场景，使用接口制定协议，然后用不同的实现来实现具体行为。假设你已经拿到上述类库，如果我们想通过日志记录对sayHello()的调用，使用静态代理可以这样做： 12345678910// 静态代理方式class StaticProxiedHello implements Hello&#123; ... private Hello hello = new HelloImp(); @Override public String sayHello(String str) &#123; logger.info(&quot;You said: &quot; + str); return hello.sayHello(str); &#125;&#125; 上例中静态代理类StaticProxiedHello作为HelloImp的代理，实现了相同的Hello接口。用Java动态代理可以这样做： 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。 然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。 12345678910111213141516171819202122// Java Proxy// 1. 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。class LogInvocationHandler implements InvocationHandler&#123; ... private Hello hello; public LogInvocationHandler(Hello hello) &#123; this.hello = hello; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(&quot;sayHello&quot;.equals(method.getName())) &#123; logger.info(&quot;You said: &quot; + Arrays.toString(args)); &#125; return method.invoke(hello, args); &#125;&#125;// 2. 然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。Hello hello = (Hello)Proxy.newProxyInstance( getClass().getClassLoader(), // 1. 类加载器 new Class&lt;?&gt;[] &#123;Hello.class&#125;, // 2. 代理需要实现的接口，可以有多个 new LogInvocationHandler(new HelloImp()));// 3. 方法调用的实际处理者System.out.println(hello.sayHello(&quot;I love you!&quot;)); 运行上述代码输出结果： 12日志信息: You said: [I love you!]HelloImp: I love you! 上述代码的关键是Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)方法，该方法会根据指定的参数动态创建代理对象。三个参数的意义如下： loader，指定代理对象的类加载器； interfaces，代理对象需要实现的接口，可以同时指定多个接口； handler，方法调用的实际处理者，代理对象的方法调用都会转发到这里（*注意1）。 newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。理解上述代码需要对Java反射机制有一定了解。动态代理神奇的地方就是： 代理对象是在程序运行时产生的，而不是编译期； 对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法，在invoke()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体，示例中通过反射调用了Hello对象的相应方法，还可以通过RPC调用远程方法。 注意1：对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发。详见JDK Proxy官方文档。 如果对JDK代理后的对象类型进行深挖，可以看到如下信息： 123456# Hello代理对象的类型信息class=class jdkproxy.$Proxy0superClass=class java.lang.reflect.Proxyinterfaces: interface jdkproxy.HelloinvocationHandler=jdkproxy.LogInvocationHandler@a09ee92 代理对象的类型是jdkproxy.$Proxy0，这是个动态生成的类型，类名是形如$ProxyN的形式；父类是java.lang.reflect.Proxy，所有的JDK动态代理都会继承这个类；同时实现了Hello接口，也就是我们接口列表中指定的那些接口。 如果你还对jdkproxy.$Proxy0具体实现感兴趣，它大致长这个样子： 1234567891011121314151617// JDK代理类具体实现public final class $Proxy0 extends Proxy implements Hello&#123; ... public $Proxy0(InvocationHandler invocationhandler) &#123; super(invocationhandler); &#125; ... @Override public final String sayHello(String str)&#123; ... return super.h.invoke(this, m3, new Object[] &#123;str&#125;);// 将方法调用转发给invocationhandler ... &#125; ...&#125; 这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。更多详情，可参考BrightLoong的Java静态代理&amp;动态代理笔记 Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？CGLIB登场。 CGLIB动态代理CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。 来看示例，假设我们有一个没有实现任何接口的类HelloConcrete： 12345public class HelloConcrete &#123; public String sayHello(String str) &#123; return &quot;HelloConcrete: &quot; + str; &#125;&#125; 因为没有实现接口该类无法使用JDK代理，通过CGLIB代理实现如下： 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。 1234567891011121314151617// CGLIB动态代理// 1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。class MyMethodInterceptor implements MethodInterceptor&#123; ... @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; logger.info(&quot;You said: &quot; + Arrays.toString(args)); return proxy.invokeSuper(obj, args); &#125;&#125;// 2. 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。Enhancer enhancer = new Enhancer();enhancer.setSuperclass(HelloConcrete.class);enhancer.setCallback(new MyMethodInterceptor());HelloConcrete hello = (HelloConcrete)enhancer.create();System.out.println(hello.sayHello(&quot;I love you!&quot;)); 运行上述代码输出结果： 12日志信息: You said: [I love you!]HelloConcrete: I love you! 上述代码中，我们通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象，具体到本例，就是HelloConcrete的具体方法。CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。 注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理。 如果对CGLIB代理之后的对象类型进行深挖，可以看到如下信息： 123456# HelloConcrete代理对象的类型信息class=class cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52superClass=class lh.HelloConcreteinterfaces: interface net.sf.cglib.proxy.FactoryinvocationHandler=not java proxy class 我们看到使用CGLIB代理之后的对象类型是cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52，这是CGLIB动态生成的类型；父类是HelloConcrete，印证了CGLIB是通过继承实现代理；同时实现了net.sf.cglib.proxy.Factory接口，这个接口是CGLIB自己加入的，包含一些工具方法。 注意，既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出类似如下异常： 1java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete 同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。 如果你还对代理类cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52具体实现感兴趣，它大致长这个样子： 123456789101112131415161718192021222324// CGLIB代理类具体实现public class HelloConcrete$$EnhancerByCGLIB$$e3734e52 extends HelloConcrete implements Factory&#123; ... private MethodInterceptor CGLIB$CALLBACK_0; // ~~ ... public final String sayHello(String paramString) &#123; ... MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0; if (tmp17_14 != null) &#123; // 将请求转发给MethodInterceptor.intercept()方法。 return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] &#123; paramString &#125;, CGLIB$sayHello$0$Proxy); &#125; return super.sayHello(paramString); &#125; ...&#125; 上述代码我们看到，当调用代理对象的sayHello()方法时，首先会尝试转发给MethodInterceptor.intercept()方法，如果没有MethodInterceptor就执行父类的sayHello()。这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。如何获取CGLIB代理类字节码可参考Access the generated byte[] array directly。 更多关于CGLIB的介绍可以参考Rafael Winterhalter的cglib: The missing manual，一篇很深入的文章。 结语本文介绍了Java两种常见动态代理机制的用法和原理，JDK原生动态代理是Java原生支持的，不需要任何外部依赖，但是它只能基于接口进行代理；CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，但是无法处理final的情况。 动态代理是Spring AOP(Aspect Orient Programming, 面向切面编程)的实现方式，了解动态代理原理，对理解Spring AOP大有帮助。 参考：http://www.cnblogs.com/CarpenterLee/p/8241042.html Android依赖注入 ioc基本思想 = 配置文件 + factory实例 https://www.cnblogs.com/Eason-S/p/5851078.html IOC(Inversion of control):控制反转,依赖注入 概念:控制权有对象本身专享容器,由容器根据配置文件去创建实例,并创建各个实例之间的关系,则通俗的说，对象的创建再也不需要程序员来管理,而是可以有spring容器来进行创建和销毁,我们只需要关注业务逻辑. 依赖IOC容器并管理bean,有两种,一种是BeanFactory,另一种是ApplicationContext,但是APPlicationContext extends BeanFactory. 核心:Spring中,bean工厂创建的各个实例称作bean. 通过 @Inject 注解了构造函数之后，在 Activity 中的 Boss 属性声明之前也添加 @Inject 注解。像这种在属性前添加的 @Inject 注解的目的是告诉 Dagger 哪些属性需要被注入。 public class MainActivity extends Activity { @Inject Boss boss; ... } 最后，我们在合适的位置(例如 onCreate() 函数中)调用 ObjectGraph.inject() 函数，Dagger 就会自动调用上面 (1) 中的生成方法生成依赖的实例，并注入到当前对象(MainActivity)。 public class MainActivity extends Activity { @Inject Boss boss; @Override protected void onCreate(Bundle savedInstanceState) { ObjectGraph.create(AppModule.class).inject(this); } ... } 具体怎么注入即设置的过程后面会详细介绍，这里简单透露下，APT 会在 MainActivity 所在 package 下生成一个辅助类 MainActivity$$InjectAdapter，这个类有个 injectMembers() 函数，代码类似： public void injectMembers(MainActivity paramMainActivity) { paramMainActivity.boss = ((Boss)boss.get()); …… } 上面我们已经通过 ObjectGraph.inject() 函数传入了 paramMainActivity，并且 boss 属性是 package 权限，所以 Dagger 只需要调用这个辅助类的 injectMembers() 函数即可完成依赖注入，这里的 boss.get() 会调用 Boss 的生成函数。 到此为止，使用 Dagger 的 @Inject 方式将一个 Boss 对象注入到 MainActivity 的流程就完成了。 1234567891011121314151617181920212223242526272829303132public class Human &#123; ... @Inject Father father; ... public Human() &#123; &#125;&#125; public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125; 另可以参考：https://blog.csdn.net/lmj623565791/article/details/39269193 Spring依赖注入原理分析2015年07月18日 23:55:58 阅读数：1817 我们知道Spring的依赖注入有四种方式，分别是get/set方法注入、构造器注入、静态工厂方法注入、实例工厂方法注入下面我们先分析下这几种注入方式1、get/set方法注入 1234567891011public class SpringAction &#123; //注入对象springDao private SpringDao springDao; //一定要写被注入对象的set方法 public void setSpringDao(SpringDao springDao) &#123; this.springDao = springDao; &#125; public void ok()&#123; springDao.ok(); &#125;&#125;1234567891011 配置文件如下： 123456&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt; &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt;123456 2、构造器注入 123456789101112131415public class SpringAction &#123; //注入对象springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user)&#123; this.springDao = springDao; this.user = user; System.out.println(&quot;构造方法调用springDao和user&quot;); &#125; public void save()&#123; springDao.save(user); &#125;&#125;123456789101112131415 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt; &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt;12345678 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性：解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理： 1234&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1234 另一种是设置参数类型： 1&lt;constructor-arg type=&quot;java.lang.String&quot; ref=&quot;&quot;/&gt; 1 3、静态工厂方法注入通过调用静态工厂方法来获取自己需要的对象，为了让Spring管理所有对象，我们不能直接通过类名加方法来获取对象，那样就脱离了Spring的管理，而是通过Spring注入的形式来获取 12345678910package com.bless.springdemo.factory;import com.bless.springdemo.dao.FactoryDao;import com.bless.springdemo.dao.impl.FactoryDaoImpl;import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125;&#125;12345678910 同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别: 123456789101112 public class SpringAction &#123; //注入对象 private FactoryDao staticFactoryDao; public void staticFactoryOk()&#123; staticFactoryDao.saveFactory(); &#125; //注入对象的set方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125;&#125;123456789101112 配置文件如下： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot; &gt; &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt; &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt;12345678 4、实例工厂方法注入实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法： 123456public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125;&#125;123456 1234567891011public class SpringAction &#123; //注入对象 private FactoryDao factoryDao; public void factoryOk()&#123; factoryDao.saveFactory(); &#125; public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125;&#125;1234567891011 123456789&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt; &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name=&quot;daoFactory&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt;123456789 对于第1、2种我们用的比较多，对后两种可能比较陌生。下面我们来分析下Spring是如何完成依赖注入的。如果我们去看Spring的源码可能涉及的类和接口相当多，不易掌握，在此我用自己的代码和方式来帮助我们Spring依赖注入的过程。当我们启动Spring容器的时候他会执行以下几个过程：1、加载Xml配置文件(readXML(String filename))在Spring这个由ApplicationContext类完成这一步会解析Xml属性，把bean的属性存放到BeanDefinition类中代码如下： 12345678910111213141516171819202122232425262728293031323334/** * 读取xml配置文件 * @param filename */ private void readXML(String filename) &#123; SAXReader saxReader = new SAXReader(); Document document=null; try&#123; URL xmlpath = this.getClass().getClassLoader().getResource(filename); document = saxReader.read(xmlpath); Map&lt;String,String&gt; nsMap = new HashMap&lt;String,String&gt;(); nsMap.put(&quot;ns&quot;,&quot;http://www.springframework.org/schema/beans&quot;);//加入命名空间 XPath xsub = document.createXPath(&quot;//ns:beans/ns:bean&quot;);//创建beans/bean查询路径 xsub.setNamespaceURIs(nsMap);//设置命名空间 List&lt;Element&gt; beans = xsub.selectNodes(document);//获取文档下所有bean节点 for(Element element: beans)&#123; String id = element.attributeValue(&quot;id&quot;);//获取id属性值 String clazz = element.attributeValue(&quot;class&quot;); //获取class属性值 BeanDefinition beanDefine = new BeanDefinition(id, clazz); XPath propertysub = element.createXPath(&quot;ns:property&quot;); propertysub.setNamespaceURIs(nsMap);//设置命名空间 List&lt;Element&gt; propertys = propertysub.selectNodes(element); for(Element property : propertys)&#123; String propertyName = property.attributeValue(&quot;name&quot;); String propertyref = property.attributeValue(&quot;ref&quot;); PropertyDefinition propertyDefinition = new PropertyDefinition(propertyName, propertyref); beanDefine.getPropertys().add(propertyDefinition); &#125; beanDefines.add(beanDefine); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;12345678910111213141516171819202122232425262728293031323334 2、Bean的实例化在配置文件以bean的id为key，BeanDefinition为value放到Map中 1234567891011121314/** * 完成bean的实例化 */ private void instanceBeans() &#123; for(BeanDefinition beanDefinition : beanDefines)&#123; try &#123; if(beanDefinition.getClassName()!=null &amp;&amp; !&quot;&quot;.equals(beanDefinition.getClassName().trim())) sigletons.put(beanDefinition.getId(), Class.forName(beanDefinition.getClassName()).newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;1234567891011121314 3、为Bean的输入注入值，完成依赖注入 123456789101112131415161718192021222324252627/** * 为bean对象的属性注入值 */ private void injectObject() &#123; for(BeanDefinition beanDefinition : beanDefines)&#123; Object bean = sigletons.get(beanDefinition.getId()); if(bean!=null)&#123; try &#123; PropertyDescriptor[] ps = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors(); for(PropertyDefinition propertyDefinition : beanDefinition.getPropertys())&#123; for(PropertyDescriptor properdesc : ps)&#123; if(propertyDefinition.getName().equals(properdesc.getName()))&#123; Method setter = properdesc.getWriteMethod();//获取属性的setter方法 ,private if(setter!=null)&#123; Object value = sigletons.get(propertyDefinition.getRef()); setter.setAccessible(true); setter.invoke(bean, value);//把引用对象注入到属性 &#125; break; &#125; &#125; &#125; &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125;123456789101112131415161718192021222324252627 其实Spring依赖注入的过程就是这么简单，再就是各种细节了，比如懒加载、单例等的额外处理了。 Android中的aop思路：面向切面编程（AOP，Aspect-oriented programming）需要把程序逻辑分解成『关注点』（concerns，功能的内聚区域）。这意味着，在 AOP 中，我们不需要显式的修改就可以向代码中添加可执行的代码块。这种编程范式假定『横切关注点』（cross-cutting concerns，多处代码中需要的逻辑，但没有一个单独的类来实现）应该只被实现一次，且能够多次注入到需要该逻辑的地方。 代码注入是 AOP 中的重要部分：它在处理上述提及的横切整个应用的『关注点』时很有用，例如日志或者性能监控。这种方式，并不如你所想的应用甚少，相反的，每个程序员都可以有使用这种注入代码能力的场景，这样可以避免很多痛苦和无奈。 AOP 是一种已经存在了很多年的编程范式。我发现把它应用到 Android 开发中也很有用。经过一番调研后，我认为我们用它可以获得很多好处和有用的东西。 术语（迷你术语表）在开始之前，我们先看看需要了解的词汇： Cross-cutting concerns（横切关注点）: 尽管面向对象模型中大多数类会实现单一特定的功能，但通常也会开放一些通用的附属功能给其他类。例如，我们希望在数据访问层中的类中添加日志，同时也希望当UI层中一个线程进入或者退出调用一个方法时添加日志。尽管每个类都有一个区别于其他类的主要功能，但在代码里，仍然经常需要添加一些相同的附属功能。 Advice（通知）: 注入到class文件中的代码。典型的 Advice 类型有 before、after 和 around，分别表示在目标方法执行之前、执行后和完全替代目标方法执行的代码。 除了在方法中注入代码，也可能会对代码做其他修改，比如在一个class中增加字段或者接口。 Joint point（连接点）: 程序中可能作为代码注入目标的特定的点，例如一个方法调用或者方法入口。 Pointcut（切入点）: 告诉代码注入工具，在何处注入一段特定代码的表达式。例如，在哪些 joint points 应用一个特定的 Advice。切入点可以选择唯一一个，比如执行某一个方法，也可以有多个选择，比如，标记了一个定义成@DebguTrace 的自定义注解的所有方法。 Aspect（切面）: Pointcut 和 Advice 的组合看做切面。例如，我们在应用中通过定义一个 pointcut 和给定恰当的advice，添加一个日志切面。 Weaving（织入）: 注入代码（advices）到目标位置（joint points）的过程。 下面这张图简要总结了一下上述这些概念。 那么…我们何时何地应用AOP呢？一些示例的 cross-cutting concerns 如下： 日志 持久化 性能监控 数据校验 缓存 其他更多 取决于你所选的其中一种或其他方案 :)。 工具和库有一些工具和库帮助我们使用 AOP: AspectJ: 一个 JavaTM 语言的面向切面编程的无缝扩展（适用Android）。 Javassist for Android: 用于字节码操作的知名 java 类库 Javassist 的 Android 平台移植版。 DexMaker: Dalvik 虚拟机上，在编译期或者运行时生成代码的 Java API。 ASMDEX: 一个类似 ASM 的字节码操作库，运行在Android平台，操作Dex字节码。 为什么用 AspectJ？我们下面的例子选用 AspectJ，有以下原因： 功能强大 支持编译期和加载时代码注入 易于使用 示例比方说，我们要测量一个方法的性能（执行这个方法需要多长时间）。为此我们用一个 @DebugTrace 的注解标记我们的这个方法，并且无需在每个注解过的方法中编写代码，就可以通过 logcat 输出结果。我们的方法是使用 AspectJ 达到这个目的。 我们看下在底层到底发生了什么： 我们在编译过程中增加一个新的步骤处理注解。 注解的方法内会生成和注入必要的样板代码。 在此，我必须要提到当我研究这些时，发现了Jake Wharton’s Hugo Library 这个项目，支持做同样的事情。因此，我重构了我的代码，看上去和它类似。尽管，我的代码是一个更加原始和简化的版本（顺便提一下，通过看这个项目的代码，我学到了很多）。 工程结构我们会把一个简单的示例应用拆分成两个 modules，第一个包含我们的 Android App 代码，第二个是一个 Android Library 工程，使用 AspectJ 织入代码（代码注入）。 你可能会想知道为什么我们用一个 Android Library 工程，而不是用一个纯的 Java Library：原因是为了使 AspectJ 能在 Android 上运行，我们必须在编译时做一些 hook。这只能使用 andorid-library gradle 插件完成。（先不要为此担心，后面我会给出更多细节。） 创建注解首先我们创建我们的Java注解。这个注解周期声明在 class 文件上（RetentionPolicy.CLASS），可以注解构造函数和方法（ElementType.CONSTRUCTOR 和 ElementType.METHOD）。因此，我们的 DebugTrace.java 文件看上是这样的： 123@Retention(RetentionPolicy.CLASS)@Target(&#123; ElementType.CONSTRUCTOR, ElementType.METHOD &#125;)public @interface DebugTrace &#123;&#125; 我们的性能监控计时类我已经创建了一个简单的计时类，包含 start/stop 方法。下面是 StopWatch.java 文件: 123456789101112131415161718192021222324252627282930313233343536/** * Class representing a StopWatch for measuring time. */public class StopWatch &#123; private long startTime; private long endTime; private long elapsedTime; public StopWatch() &#123; //empty &#125; private void reset() &#123; startTime = 0; endTime = 0; elapsedTime = 0; &#125; public void start() &#123; reset(); startTime = System.nanoTime(); &#125; public void stop() &#123; if (startTime != 0) &#123; endTime = System.nanoTime(); elapsedTime = endTime - startTime; &#125; else &#123; reset(); &#125; &#125; public long getTotalTimeMillis() &#123; return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0; &#125;&#125; DebugLog 类我只是包装了一下 “android.util.Log”，因为我首先想到的是向 android log 中增加更多的实用功能。下面是代码： 1234567891011121314151617/** * Wrapper around &#123;@link android.util.Log&#125; */public class DebugLog &#123; private DebugLog() &#123;&#125; /** * Send a debug log message * * @param tag Source of a log message. * @param message The message you would like logged. */ public static void log(String tag, String message) &#123; Log.d(tag, message); &#125;&#125; Aspect 类现在是时候创建我们的 Aspect 类（TraceAspect.java）了。Aspect 类负责管理注解的处理和代码织入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Aspect representing the cross cutting-concern: Method and Constructor Tracing. */@Aspectpublic class TraceAspect &#123; private static final String POINTCUT_METHOD = &quot;execution(@org.android10.gintonic.annotation.DebugTrace * *(..))&quot;; private static final String POINTCUT_CONSTRUCTOR = &quot;execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))&quot;; @Pointcut(POINTCUT_METHOD) public void methodAnnotatedWithDebugTrace() &#123;&#125; @Pointcut(POINTCUT_CONSTRUCTOR) public void constructorAnnotatedDebugTrace() &#123;&#125; @Around(&quot;methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()&quot;) public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); String className = methodSignature.getDeclaringType().getSimpleName(); String methodName = methodSignature.getName(); final StopWatch stopWatch = new StopWatch(); stopWatch.start(); Object result = joinPoint.proceed(); stopWatch.stop(); DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis())); return result; &#125; /** * Create a log message. * * @param methodName A string with the method name. * @param methodDuration Duration of the method in milliseconds. * @return A string representing message. */ private static String buildLogMessage(String methodName, long methodDuration) &#123; StringBuilder message = new StringBuilder(); message.append(&quot;Gintonic --&gt; &quot;); message.append(methodName); message.append(&quot; --&gt; &quot;); message.append(&quot;[&quot;); message.append(methodDuration); message.append(&quot;ms&quot;); message.append(&quot;]&quot;); return message.toString(); &#125;&#125; 几个在此提到的重点： 我们声明了两个作为 pointcuts 的 public 方法，筛选出所有通过 “org.android10.gintonic.annotation.DebugTrace” 注解的方法和构造函数。 我们使用 “@Around” 注解定义了“weaveJointPoint(ProceedingJoinPoint joinPoint)”方法,使我们的代码注入在使用&quot;@DebugTrace&quot;注解的地方生效。 “Object result = joinPoint.proceed();”这行代码是被注解的方法执行的地方。因此，在此之前，我们启动我们的计时类计时，在这之后，停止计时。 最后，我们构造日志信息，用 Android Log 输出。 ###使 AspectJ 运行在 Anroid 上 现在，所有代码都可以正常工作了，但是，如果我们编译我们的例子，我们并没有看到任何事情发生。原因是我们必须使用 AspectJ 的编译器（ajc，一个java编译器的扩展）对所有受 aspect 影响的类进行织入。这就是为什么，我之前提到的，我们需要在 gradle 的编译 task 中增加一些额外配置，使之能正确编译运行。 我们的 build.gradle 文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.android.build.gradle.LibraryPluginimport org.aspectj.bridge.IMessageimport org.aspectj.bridge.MessageHandlerimport org.aspectj.tools.ajc.Mainbuildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:0.12.+&apos; classpath &apos;org.aspectj:aspectjtools:1.8.1&apos; &#125;&#125;apply plugin: &apos;android-library&apos;repositories &#123; mavenCentral()&#125;dependencies &#123; compile &apos;org.aspectj:aspectjrt:1.8.1&apos;&#125;android &#123; compileSdkVersion 19 buildToolsVersion &apos;19.1.0&apos; lintOptions &#123; abortOnError false &#125;&#125;android.libraryVariants.all &#123; variant -&gt; LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin) JavaCompile javaCompile = variant.javaCompile javaCompile.doLast &#123; String[] args = [&quot;-showWeaveInfo&quot;, &quot;-1.5&quot;, &quot;-inpath&quot;, javaCompile.destinationDir.toString(), &quot;-aspectpath&quot;, javaCompile.classpath.asPath, &quot;-d&quot;, javaCompile.destinationDir.toString(), &quot;-classpath&quot;, javaCompile.classpath.asPath, &quot;-bootclasspath&quot;, plugin.project.android.bootClasspath.join( File.pathSeparator)] MessageHandler handler = new MessageHandler(true); new Main().run(args, handler) def log = project.logger for (IMessage message : handler.getMessages(null, true)) &#123; switch (message.getKind()) &#123; case IMessage.ABORT: case IMessage.ERROR: case IMessage.FAIL: log.error message.message, message.thrown break; case IMessage.WARNING: case IMessage.INFO: log.info message.message, message.thrown break; case IMessage.DEBUG: log.debug message.message, message.thrown break; &#125; &#125; &#125;&#125; 我们的测试方法我们添加一个测试方法，来使用我们炫酷的 aspect 注解。我已经在主 Activity 类中增加了一个方法用来测试。看下代码： 12345678@DebugTraceprivate void testAnnotatedMethod() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 运行我们的应用我们用 gradle 命令编译部署我们的 app 到 android 设备或者模拟器上： 1gradlew clean build installDebug If we open the logcat and execute our sample, we will see a debug log with: 如果我们打开 logcat，执行我们的例子，会看到一条 debug 日志： 1Gintonic --&gt; testAnnotatedMethod --&gt; [10ms] 我们的第一个使用 AOP 的 Androd 应用可以工作了！ 你可以用 Dex Dump 或者任何其他的逆向工具反编译 apk 文件，看一下生成和注入的代码。 回顾回顾总结如下： 我们已经对面向切面编程（AOP）这一范式有了初步体验。 代码注入是 AOP 中的重要部分。 AspectJ 是在 Android 应用中进行代码织入的强大且易用的工具。 我们已经使用 AOP 能力创建了一个可以工作的示例。 参考：https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Android%E4%B8%AD%E7%9A%84AOP%E7%BC%96%E7%A8%8B.md]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>reflect</tag>
        <tag>proxy</tag>
        <tag>anotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 程序优化]]></title>
    <url>%2Fposts%2Fjava_jdk_base_opt_perfermance.html</url>
    <content type="text"><![CDATA[Java程序优化参考书籍： Java程序性能优化 让你的Java程序更快、更稳定.pdf 性能分析-程序性能指标/瓶颈 指标测量，分析瓶颈 更快更省更稳 瓶颈取决于最坏的那个，木桶短板原理 代码优化- Java代码程序优化 数据结构优化 算法优化 数据库优化 NIO/IO优化 引用优化GC 设计模式优化系统优化- JVM优化系统优化- 操作系统调优]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 密码原理]]></title>
    <url>%2Fposts%2Fjava_jdk_base_crypto_utils.html</url>
    <content type="text"><![CDATA[Java密码参考 Java加解密艺术这本书进行整理如下 对称加密 symmetric AesCbcUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.security.symmetric;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * aes cbc and iv demo. * @author fitz * @version 1.0.0 */public class AesCbcUtils &#123; // aes cipher mode public static final String CIPHER_ALGORITHM = &quot;AES/CBC/NoPadding&quot;; // public static final String CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;; /** * encrypt * @param plain 16B * @param key 16B * @param iv 16B * @return byte[] 16B * @throws Exception */ public static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception &#123; if (key == null || key.length != 16 || iv == null || iv.length != 16) &#123; throw new Exception(&quot;key or iv error&quot;); &#125; SecretKeySpec sKeySpec = new SecretKeySpec(key, &quot;AES&quot;); Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, sKeySpec, ivParameterSpec); byte[] encrypted = cipher.doFinal(plain); return encrypted; &#125; /** * decrypt * @param crypt 16B * @param key 16B * @param iv 16B * @return byte[] 16B * @throws Exception */ public static byte[] decrypt(byte[] crypt, byte[] key, byte[] iv) throws Exception &#123; if (key == null || key.length != 16 || iv == null || iv.length != 16) &#123; throw new Exception(&quot;key or iv error&quot;); &#125; SecretKeySpec sKeySpec = new SecretKeySpec(key, &quot;AES&quot;); sKeySpec.getClass().getSimpleName(); Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, sKeySpec, ivParameterSpec); byte[] original = cipher.doFinal(crypt); return original; &#125;&#125; AesUtils 12345678910111213141516171819202122232425262728package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class AesUtils &#123; private static final String KEY_TYPE = &quot;AES&quot;; private static final String CIPER_MODE = &quot;AES/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; CipherAsymmetricUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.Key;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public abstract class CipherAsymmetricUtils &#123; public enum KeyTypeEnum &#123; AES(&quot;AES&quot;), DES(&quot;DES&quot;), DESede(&quot;DESede&quot;), IDEA(&quot;IDEA&quot;); private String keyType; private KeyTypeEnum(String keyType) &#123; this.keyType = keyType; &#125; &#125; public enum WorkTypeEnum &#123; ECB(&quot;ECB&quot;), CBC(&quot;CBC&quot;); private String workType; private WorkTypeEnum(String workType) &#123; this.workType = workType; &#125; &#125; public enum PaddingTypeEnum &#123; NOPadding(&quot;NOPadding&quot;), PKCS5Padding(&quot;PKCS5Padding&quot;), PKCS7Padding(&quot;PKCS7Padding&quot;); private String paddingType; private PaddingTypeEnum(String paddingType) &#123; this.paddingType = paddingType; &#125; &#125; public static byte[] encrypt(Key key, byte[] data, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(data); &#125; public static byte[] decrypt(Key key, byte[] cipherText, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(cipherText); &#125; public static SecretKey generateSecretKey(String keyType) throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(keyType); return keyGenerator.generateKey(); &#125;&#125; Des3Utils 123456789101112131415161718192021222324252627package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class Des3Utils &#123; private static final String KEY_TYPE = &quot;DESede&quot;; private static final String CIPER_MODE = &quot;DESede/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; DesUtils 123456789101112131415161718192021222324252627package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class DesUtils &#123; private static final String KEY_TYPE = &quot;DES&quot;; private static final String CIPER_MODE = &quot;DES/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; CCM IdeaUtils 123456789101112131415161718192021222324252627package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class IdeaUtils &#123; private static final String KEY_TYPE = &quot;IDEA&quot;; private static final String CIPER_MODE = &quot;IDEA/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; PbeUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.security.symmetric;import javax.crypto.*;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.security.InvalidAlgorithmParameterException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.spec.InvalidKeySpecException;/** * @author fitz * @version 1.0 */public class PbeUtils &#123; /** * &lt;pre&gt; * PBEWithMD5AndDES * PBEWithMD5AndTripleDES * PBEWithSHA1AndDESede * PBEWithSHA1AndRC2_40 * &lt;/pre&gt; */ private static final String ALGORITHM = &quot;PBEWithMD5AndTripleDES&quot;; private static final int ITERATION_COUNT = 100; public static SecretKey generateSecrectKey(String passwd) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; PBEKeySpec pbeKeySpec = new PBEKeySpec(passwd.toCharArray()); SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(ALGORITHM); return secretKeyFactory.generateSecret(pbeKeySpec); &#125; public static byte[] generateSalt() &#123; SecureRandom random = new SecureRandom(); return random.generateSeed(8); &#125; public static byte[] encrypt(SecretKey key, byte[] data, byte[] salt) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException &#123; Cipher cipher = Cipher.getInstance(ALGORITHM); PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, ITERATION_COUNT); cipher.init(Cipher.ENCRYPT_MODE, key, pbeParameterSpec); return cipher.doFinal(data); &#125; public static byte[] decrypt(SecretKey key, byte[] cipherText, byte[] salt) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException &#123; Cipher cipher = Cipher.getInstance(ALGORITHM); PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, ITERATION_COUNT); cipher.init(Cipher.DECRYPT_MODE, key, pbeParameterSpec); return cipher.doFinal(cipherText); &#125;&#125; SecretKeyUtils123456789101112131415161718192021222324package com.security.symmetric;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.SecretKeySpec;import java.security.NoSuchAlgorithmException;import java.security.spec.InvalidKeySpecException;import java.security.spec.KeySpec;/** * @author fitz * @version 1.0 */public class SecretKeyUtils &#123; public SecretKey getSecretKey(byte[] keyBytes, String keyType) &#123; SecretKey secretKey = new SecretKeySpec(keyBytes, keyType); return secretKey; &#125; public SecretKey generateSecretKey(String keyType, KeySpec keySpec) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(keyType); return secretKeyFactory.generateSecret(keySpec); &#125;&#125; 非对称加密 CipherAsymmetricUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.security.asymmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.Key;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public abstract class CipherAsymmetricUtils &#123; public enum KeyTypeEnum &#123; RSA(&quot;RSA&quot;), ECC(&quot;ECC&quot;); private String keyType; private KeyTypeEnum(String keyType) &#123; this.keyType = keyType; &#125; &#125; public enum WorkTypeEnum &#123; ECB(&quot;ECB&quot;), CBC(&quot;CBC&quot;); private String workType; private WorkTypeEnum(String workType) &#123; this.workType = workType; &#125; &#125; public enum PaddingTypeEnum &#123; NOPadding(&quot;NoPadding&quot;), PKCS5Padding(&quot;PKCS5Padding&quot;), PKCS7Padding(&quot;PKCS7Padding&quot;); private String paddingType; private PaddingTypeEnum(String paddingType) &#123; this.paddingType = paddingType; &#125; &#125; public static byte[] encrypt(Key key, byte[] data, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(data); &#125; public static byte[] decrypt(Key key, byte[] cipherText, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(cipherText); &#125;&#125; DhKeyAgreementUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.security.asymmetric;import com.security.util.ByteUtils;import org.bouncycastle.crypto.digests.SHA1Digest;import org.bouncycastle.crypto.generators.KDF1BytesGenerator;import org.bouncycastle.crypto.params.ISO18033KDFParameters;import javax.crypto.KeyAgreement;import javax.crypto.SecretKey;import java.math.BigInteger;import java.security.*;import java.security.spec.*;/** * @author fitz * @version 1.0 */public class DhKeyAgreementUtils &#123; public static final String KEY_AGREEMENT_ALGORITHM_DH = &quot;DH&quot;; public static final String KEY_AGREEMENT_ALGORITHM_ECDH = &quot;ECDH&quot;; public static final String SECRET_KEY_ALGORITHM = &quot;AES&quot;; public SecretKey generateSecretKey(PublicKey publicKey, PrivateKey privateKey, String keyAgreementType) throws Exception &#123; KeyAgreement ka = KeyAgreement.getInstance(keyAgreementType); ka.init(privateKey); ka.doPhase(publicKey, true); SecretKey key = ka.generateSecret(SECRET_KEY_ALGORITHM); return key; &#125; public byte[] generateSessionKeyPki(PublicKey publicKey, PrivateKey privateKey) throws Exception &#123; KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;); //EcDhWithNistKdf256 ka.init(privateKey); ka.doPhase(publicKey, true); byte[] secret = ka.generateSecret(); KDF1BytesGenerator kdf1sha1 = new KDF1BytesGenerator(new SHA1Digest()); kdf1sha1.init(new ISO18033KDFParameters(secret)); byte[] key = new byte[16]; kdf1sha1.generateBytes(key,0,key.length); return key; &#125; public void generateDiffHellmanKeys(String keyType, int keySize) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(keySize); KeyPair keyPair = keyPairGenerator.generateKeyPair(); // A privateKey &amp; publicKey PrivateKey privateKeyA = keyPair.getPrivate(); PublicKey publicKeyA = keyPair.getPublic(); // B privateKey &amp; publicKey keyPair = keyPairGenerator.generateKeyPair(); PrivateKey privateKeyB = keyPair.getPrivate(); PublicKey publicKeyB = keyPair.getPublic(); &#125;&#125; EccCipherUtils 12345678910111213141516171819202122232425package com.security.asymmetric;import javax.crypto.BadPaddingException;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.interfaces.ECPrivateKey;import java.security.interfaces.ECPublicKey;/** * @author fitz * @version 1.0 */public class EccCipherUtils &#123; private static final String CIPHER_ALGORITHM = &quot;ECC/ECB/PKCS5Padding&quot;; public static byte[] encrypt(ECPublicKey publicKey, byte[] data, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(publicKey, data, cipherType); &#125; public static byte[] decrypt(ECPrivateKey privateKey, byte[] cipherText, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(privateKey, cipherText, cipherType); &#125;&#125; EccKeyGenerateUtils 12345678910111213141516171819202122232425262728293031323334353637383940package com.security.asymmetric;import org.bouncycastle.util.encoders.Hex;import java.math.BigInteger;import java.security.*;import java.security.spec.ECGenParameterSpec;import java.security.spec.ECParameterSpec;import java.security.spec.ECPoint;import java.security.spec.ECPublicKeySpec;/** * @author fitz * @version 1.0 */public class EccKeyGenerateUtils &#123; /** * generate keypair * @param keyType * @param size * @return KeyPair * can use KeyPair&apos;s getPublic or getPrivate * @throws NoSuchAlgorithmException */ public KeyPair generateKey(String keyType, int size) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(size); return keyPairGenerator.generateKeyPair(); &#125; public PublicKey getPublicKey(String x, String y) throws Exception &#123; ECPoint ecPoint = new ECPoint(new BigInteger(Hex.decode(x)), new BigInteger(Hex.decode(y))); AlgorithmParameters parameters = AlgorithmParameters.getInstance(&quot;EC&quot;, &quot;BC&quot;); parameters.init(new ECGenParameterSpec(&quot;secp256r1&quot;)); ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class); return KeyFactory.getInstance (&quot;EC&quot;).generatePublic(new ECPublicKeySpec(ecPoint, ecParameters)); &#125;&#125; RsaBlockUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.security.asymmetric;import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.Key;/** * no use, just for test block * @author fitz */public class RsaBlockUtils &#123; public static final String CIPHER_ALGORITHM = &quot;RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING&quot;; // for rsa 2048 private static final int KEY_SIZE = 2048; private static final int BLOCK_SIZE = 245; private static final int OUTPUT_BLOCK_SIZE = 256; // for rsa 1024 // private static final int KEY_SIZE = 1024; // private static final int BLOCK_SIZE = 117; // private static final int OUTPUT_BLOCK_SIZE = 128; /** * encryptByPublicKey * @param data * @param publicKey * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, Key publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, publicKey); int blocks = data.length / BLOCK_SIZE; int lastBlockSize = data.length % BLOCK_SIZE; byte[] encryptedData = new byte[(lastBlockSize == 0 ? blocks : blocks + 1) * OUTPUT_BLOCK_SIZE]; for (int i = 0; i &lt; blocks; i++) &#123; cipher.doFinal(data, i * BLOCK_SIZE, BLOCK_SIZE, encryptedData, i * OUTPUT_BLOCK_SIZE); &#125; if (lastBlockSize != 0) &#123; cipher.doFinal(data, blocks * BLOCK_SIZE, lastBlockSize, encryptedData, blocks * OUTPUT_BLOCK_SIZE); &#125; return encryptedData; &#125; /** * decryptByPrivateKey * @param decoded * @param privateKey * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] decoded, Key privateKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, privateKey); int blocks = decoded.length / OUTPUT_BLOCK_SIZE; ByteArrayOutputStream decodedStream = new ByteArrayOutputStream(decoded.length); for (int i = 0; i &lt; blocks; i++) &#123; decodedStream.write(cipher.doFinal(decoded, i * OUTPUT_BLOCK_SIZE, OUTPUT_BLOCK_SIZE)); &#125; return decodedStream.toByteArray(); &#125;&#125; RsaCipherUtils 12345678910111213141516171819202122232425262728293031323334353637package com.security.asymmetric;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.OAEPParameterSpec;import javax.crypto.spec.PSource;import java.security.*;import java.security.spec.*;/** * @author fitz * @version 1.0 */public class RsaCipherUtils &#123; private static final String CIPHER_ALGORITHM = &quot;RSA/ECB/PKCS5Padding&quot;; public static byte[] encrypt(PublicKey publicKey, byte[] data, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(publicKey, data, cipherType); &#125; public static byte[] decrypt(PrivateKey privateKey, byte[] cipherText, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(privateKey, cipherText, cipherType); &#125; public static byte[] encryptOaep(byte[] data, PublicKey publicKey) throws NoSuchProviderException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidParameterSpecException &#123; AlgorithmParameters algp = AlgorithmParameters.getInstance(&quot;OAEP&quot;, &quot;BC&quot;); AlgorithmParameterSpec paramSpec = new OAEPParameterSpec(&quot;SHA-1&quot;, &quot;MGF1&quot;, MGF1ParameterSpec.SHA1, PSource.PSpecified.DEFAULT); algp.init(paramSpec); Cipher oaepFromAlgo = Cipher.getInstance(&quot;RSA/ECB/OAEPWITHSHA-1ANDMGF1PADDING&quot;); oaepFromAlgo.init(Cipher.ENCRYPT_MODE, publicKey, algp); //algp byte[] ct = oaepFromAlgo.doFinal(data); return ct; &#125;&#125; RsaKeyGenerateUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.security.asymmetric;import java.math.BigInteger;import java.security.*;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.*;/** * @author fitz * @version 1.0 */public class RsaKeyGenerateUtils &#123; /** * generate keypair * @param keyType * @param size * @return KeyPair * can use KeyPair&apos;s getPublic or getPrivate * @throws NoSuchAlgorithmException */ public KeyPair generateKey(String keyType, int size) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(size); return keyPairGenerator.generateKeyPair(); &#125; public static Key toPrivateKey(String type, byte[] keyBytes) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(type); return keyFactory.generatePrivate(pkcs8EncodedKeySpec); &#125; public static Key toPublicKey(String type, byte[] keyBytes) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(type); return keyFactory.generatePublic(x509EncodedKeySpec); &#125; /** * Generate public key according to modulus and public exponent java Cipher* * @param modulus modulus * @param exponent public exponent * @return */ public static RSAPublicKey getPublicKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus, 16); BigInteger b2 = new BigInteger(exponent, 16); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2); return (RSAPublicKey) keyFactory.generatePublic(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * Generate private key according to modulus and private exponent java * @param modulus modulus * @param exponent private exponent * @return */ public static RSAPrivateKey getPrivateKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus, 16); BigInteger b2 = new BigInteger(exponent, 16); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(b1, b2); return (RSAPrivateKey) keyFactory.generatePrivate(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; EccParams RsaParams KdfUtils 签名 KeyUtils 12345678910111213141516171819202122232425package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class KeyUtils &#123; public static final String ALGORITHM = &quot;DSA&quot;; /** * generate keypair * @param keyType * @param size * @return KeyPair * can use KeyPair&apos;s getPublic or getPrivate * @throws NoSuchAlgorithmException */ public KeyPair generateKey(String keyType, int size) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(size); return keyPairGenerator.generateKeyPair(); &#125;&#125; EcdsaUtils 123456789101112131415161718192021222324252627282930package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class EcdsaUtils &#123; private static final String KEY_ALGORITHM = &quot;ECDSA&quot;; /** * NONEwithECDSA * RIPEMD160withECDSA * SHA1withECDSA * SHA224withECDSA * SHA256withECDSA * SHA384withECDSA * SHA512withECDSA */ private static final String SIGNATURE_ALGORITHM = &quot;SHA512withECDSA&quot;; public static byte[] sign(PrivateKey privateKey, byte[] data) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.sign(privateKey, data, SIGNATURE_ALGORITHM); &#125; public static boolean verify(PublicKey publicKey, byte[] data, byte[] sign) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.verify(publicKey, data, sign, SIGNATURE_ALGORITHM); &#125;&#125; RsaSignUtils 1234567891011121314151617181920package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class RsaSignUtils &#123; public static final String KEY_ALGORITHM = &quot;RSA&quot;; public static final String SIGNATURE_ALGORITHM = &quot;SHA1withRSA&quot;; public static byte[] sign(PrivateKey privateKey, byte[] data) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.sign(privateKey, data, SIGNATURE_ALGORITHM); &#125; public static boolean verify(PublicKey publicKey, byte[] data, byte[] sign) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.verify(publicKey, data, sign, SIGNATURE_ALGORITHM); &#125;&#125; SignatureUtils 12345678910111213141516171819202122232425package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class SignatureUtils &#123; public static final String SIGNATURE_ALGORITHM = &quot;SHA1withRSA&quot;; public static byte[] sign(PrivateKey privateKey, byte[] data, String signatureType) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; Signature signature = Signature.getInstance(signatureType); signature.initSign(privateKey); signature.update(data); return signature.sign(); &#125; public static boolean verify(PublicKey publicKey, byte[] data, byte[] sign, String signatureType) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; Signature signature = Signature.getInstance(signatureType); signature.initVerify(publicKey); signature.update(data); return signature.verify(sign); &#125;&#125; base64 Base64BcUtils 12345678910111213141516171819package com.security.base64;import org.bouncycastle.util.encoders.Base64;/** * @author fitz * @version 1.0 */public class Base64BcUtils &#123; public static byte[] encode(byte[] bytes) &#123; return Base64.encode(bytes); &#125; public static byte[] decode(byte[] bytes) &#123; return Base64.decode(bytes); &#125;&#125; Base64Utils 123456789101112131415161718package com.security.base64;import java.util.Base64;/** * @author fitz * @version 1.0 */public class Base64Utils &#123; public static byte[] encode(byte[] bytes) &#123; return Base64.getEncoder().encode(bytes); &#125; public static byte[] decode(byte[] bytes) &#123; return Base64.getDecoder().decode(bytes); &#125;&#125; UrlBase64Coder 12345678910111213141516171819202122232425262728package com.security.base64;import org.bouncycastle.util.encoders.UrlBase64;/** * @author fitz * @version 1.0 */public abstract class UrlBase64Coder &#123; public final static String ENCODING = &quot;UTF-8&quot;; public static String encode(String data) throws Exception &#123; byte[] b = UrlBase64.encode(data.getBytes(ENCODING)); return new String(b, ENCODING); &#125; public static String decode(String data) throws Exception &#123; byte[] b = UrlBase64.decode(data.getBytes(ENCODING)); return new String(b, ENCODING); &#125;&#125; hash crc MacStreamUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.security.hash;import org.apache.commons.codec.digest.DigestUtils;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.security.DigestInputStream;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class MacStreamUtils &#123; public static byte[] digest(FileInputStream fis, String type) throws NoSuchAlgorithmException, IOException &#123; DigestInputStream dis = new DigestInputStream(fis, MessageDigest.getInstance(type)); int bufLen = 1024; byte[] buffer = new byte[bufLen]; while (dis.read(buffer, 0, bufLen) &gt; -1) &#123; &#125; dis.close(); MessageDigest md = dis.getMessageDigest(); // can compare with DigestUtils.md5(fis); DigestUtils.md5(fis); return md.digest(); &#125; public static byte[] digest1(FileInputStream fis, String type) throws NoSuchAlgorithmException, IOException &#123; MessageDigest md = MessageDigest.getInstance(type); updateDigest(md, fis); return md.digest(); &#125; /** * ref: DigestUtils md5 * @param digest * @param data * @return * @throws IOException */ public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException &#123; final int STREAM_BUFFER_LENGTH = 1024; final byte[] buffer = new byte[STREAM_BUFFER_LENGTH]; int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH); while (read &gt; -1) &#123; digest.update(buffer, 0, read); read = data.read(buffer, 0, STREAM_BUFFER_LENGTH); &#125; return digest; &#125;&#125; MacUtils 123456789101112131415161718192021222324252627282930313233343536package com.security.hash;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * mac utils * @author fitz * @version 1.0 */public class MacUtils &#123; private static final String HmacMD2 = &quot;HmacMD2&quot;; private static final String HmacMD4 = &quot;HmacMD4&quot;; private static final String HmacSHA224 = &quot;HmacSHA224&quot;; private static final String HmacSHA256 = &quot;HmacSHA256&quot;; private static final String HmacRipeMD128 = &quot;HmacRipeMD128&quot;; private static final String HmacRipeMD160 = &quot;HmacRipeMD160&quot;; public static SecretKey generateSecretKey(String type) throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(type); return keyGenerator.generateKey(); &#125; public static byte[] mac(SecretKey key, byte[] bytes) throws NoSuchAlgorithmException, InvalidKeyException &#123; Mac mac = Mac.getInstance(key.getAlgorithm()); mac.init(key); return mac.doFinal(bytes); &#125;&#125; MessageDigestUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.security.hash;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * message digest utils. * @author fitz * @version 1.0 */public class MessageDigestUtils &#123; private static final String MD2 =&quot;MD2&quot;; private static final String MD5 =&quot;MD5&quot;; private static final String SHA =&quot;SHA&quot;; private static final String SHA_256 =&quot;SHA-256&quot;; private static final String SHA_384 =&quot;SHA-384&quot;; private static final String SHA_512 =&quot;SHA-512&quot;; public static byte[] md2(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(MD2, bytes); &#125; public static byte[] md5(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(MD5, bytes); &#125; public static byte[] sha1(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA, bytes); &#125; public static byte[] sha256(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA_256, bytes); &#125; public static byte[] sha384(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA_384, bytes); &#125; public static byte[] sha512(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA_512, bytes); &#125; private static byte[] md(String type, byte[] bytes) throws NoSuchAlgorithmException &#123; MessageDigest md = MessageDigest.getInstance(type); return md.digest(bytes); &#125;&#125; OtherMessageDigestUtils 123456789101112131415161718192021222324252627282930313233343536package com.security.hash;import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.Security;/** * @author fitz * @version 1.0 */public class OtherMessageDigestUtils &#123; static &#123; if(Security.getProvider(&quot;BC&quot;) == null ) &#123; Security.addProvider(new BouncyCastleProvider()); &#125; &#125; private static final String RipeMD128 =&quot;RipeMD128&quot;; private static final String RipeMD160 =&quot;RipeMD160&quot;; private static final String RipeMD256 =&quot;RipeMD256&quot;; private static final String RipeMD320 =&quot;RipeMD320&quot;; private static final String Tiger =&quot;Tiger&quot;; private static final String Whirlpool =&quot;Whirlpool&quot;; private static final String GOST3411 =&quot;GOST3411&quot;; public static byte[] RipeMD256(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(RipeMD256, bytes); &#125; private static byte[] md(String type, byte[] bytes) throws NoSuchAlgorithmException &#123; MessageDigest md = MessageDigest.getInstance(type); return md.digest(bytes); &#125;&#125; certificate 证书生成 openssl 和 keytool操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374echo offecho 构建目录mkdir certsmkdir crlmkdir newcertsmkdir privateecho 构建文件echo 0 &gt; index.txtecho 01 &gt; serialecho 构建随机数openssl.exe rand -out private/.rand 1000echo 产生私钥openssl.exe genrsa -out private/ca.key.pem 2048openssl.exe genrsa -out private/ca1.key.pem 2048!openssl.exe genrsa -aes256 -out private/ca.key.pem 2048echo 生成根证书请求 ca.csropenssl.exe req -new -key private/ca.key.pem -out private/ca.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security&quot;openssl.exe req -new -key private/ca1.key.pem -out private/ca1.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security1&quot;echo 签发根证书 ca.ceropenssl.exe x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.ceropenssl.exe x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca1.key.pem -in private/ca1.csr -out certs/ca1.cerecho 根证书转换 ca.p12openssl.exe pkcs12 -export -clcerts -in certs/ca.cer -inkey private/ca.key.pem -out certs/ca.p12echo 颁发服务器证书openssl.exe genrsa -out private/server.key.pem 2048echo 生成服务器证书请求 server.csropenssl.exe req -new -key private/server.key.pem -out private/server.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security.server&quot;echo 签发服务器证书 server.ceropenssl.exe x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/server.csr -out certs/server.cerecho 服务器证书转换 server.p12openssl.exe pkcs12 -export -clcerts -in certs/server.cer -inkey private/server.key.pem -out certs/server.p12echo 产生客户私钥openssl.exe genrsa -out private/client.key.pem 2048echo 生成客户证书请求 client.csropenssl.exe req -new -key private/client.key.pem -out private/client.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security.client&quot;echo 签发客户证书 client.ceropenssl.exe x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/client.csr -out certs/client.ceropenssl.exe x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca1.cer -CAkey private/ca1.key.pem -CAserial ca.srl -CAcreateserial -in private/client.csr -out certs/client.cer!openssl.exe ca -in private/client.csr -days 3650 -out certs/client.cer -cert certs/ca.cer -keyfile private/ca.key.pem -notextecho 客户证书转换 client.p12openssl.exe pkcs12 -export -inkey private/client.key.pem -in certs/client.cer -out certs/client.p12echo 根密钥库转换 ca.keystorekeytool -importkeystore -v -srckeystore certs/ca.p12 -srcstorepass 123456 -destkeystore certs/ca.keystore -srcstoretype pkcs12 -deststorepass 123456keytool -list -keystore certs/ca.keystore -v -storepass 123456echo 服务器密钥库转换 server.keystorekeytool -importkeystore -v -srckeystore certs/server.p12 -srcstorepass 123456 -destkeystore certs/server.keystore -srcstoretype pkcs12 -deststorepass 123456keytool -list -keystore certs/server.keystore -v -storepass 123456echo 客户密钥库转换 client.keystorekeytool -importkeystore -v -srckeystore certs/client.p12 -srcstorepass 123456 -destkeystore certs/client.keystore -srcstoretype pkcs12 -deststorepass 123456keytool -list -keystore certs/client.keystore -v -storepass 123456pauseecho on UdpSocket 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.security.certificate.udpsocket;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.SocketException;public class UdpSocket &#123; private byte[] buffer = new byte[1024]; private DatagramSocket receiveSocket; private DatagramSocket sendSocket; private String remoteHost; private int sendPort; public UdpSocket(String localHost, String remoteHost, int receivePort, int sendPort) throws SocketException &#123; this.remoteHost = remoteHost; this.sendPort = sendPort; this.receiveSocket = new DatagramSocket(new InetSocketAddress( localHost, receivePort)); this.sendSocket = new DatagramSocket(); &#125; public byte[] receive() throws IOException &#123; DatagramPacket dp = new DatagramPacket(buffer, buffer.length); receiveSocket.receive(dp); ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(dp.getData(), 0, dp.getLength()); byte[] data = baos.toByteArray(); baos.flush(); baos.close(); return data; &#125; public void send(byte[] data) throws IOException &#123; DatagramPacket dp = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(remoteHost), sendPort); dp.setData(data); sendSocket.send(dp); &#125; public void close() &#123; try &#123; if (receiveSocket.isConnected()) &#123; receiveSocket.disconnect(); receiveSocket.close(); &#125; if (sendSocket.isConnected()) &#123; sendSocket.disconnect(); sendSocket.close(); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;``` - client server package com.security.certificate.clientserver; import com.security.certificate.CertificateUtils; import javax.net.ssl.;import java.io.;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class Client implements Runnable { public static final String PROTOCOL = “TLS”; private static final String PASSWD = “123456”; private static final String ip = “127.0.0.1”; private static final int port = Server.PORT; private SSLSocketFactory socketFactory; public Client() throws Exception { // key manager KeyStore keyStore = getKeyManagerStore(); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, PASSWD.toCharArray()); // trust manager KeyStore trustStore = getTrustManagerStore(); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); // socket init SSLContext sslContext = SSLContext.getInstance(PROTOCOL); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); socketFactory = sslContext.getSocketFactory(); } private static KeyStore getKeyManagerStore() throws CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException { InputStream inputStream = Client.class.getResourceAsStream(&quot;/certs/client.p12&quot;); KeyStore keyStore = CertificateUtils.getKeyStore(inputStream, &quot;123456&quot;); inputStream.close(); return keyStore; } private static KeyStore getTrustManagerStore() throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); InputStream inputStream = Server.class.getResourceAsStream(&quot;/certs/ca.cer&quot;); X509Certificate certificate = (X509Certificate) CertificateUtils.getCertificate(inputStream, &quot;X.509&quot;); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, certificate); return keyStore; } @Override public void run() { int i = 0; while(i++ &lt;= 1) { try { SSLSocket sslSocket = (SSLSocket) socketFactory.createSocket(ip, port); InputStream is = sslSocket.getInputStream(); OutputStream os = sslSocket.getOutputStream(); DataOutputStream out = new DataOutputStream(os); out.writeUTF(&quot;GET /index.html HTTP/1.0&quot;); out.flush(); DataInputStream bin = new DataInputStream(is); String ln; if ((ln = bin.readUTF()) != null) { System.out.println(ln); } } catch (IOException e) { e.printStackTrace(); } } }} 12 package com.security.certificate.clientserver; import com.security.certificate.CertificateUtils; import javax.net.ssl.;import java.io.;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class Server implements Runnable { private SSLServerSocket serverSocket; public static final String PROTOCOL = “TLS”; private static final String PASSWD = “123456”; public static final int PORT = 6666; public Server() throws Exception { // key manager KeyStore keyStore = getKeyManagerStore(); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, PASSWD.toCharArray()); // trust manager KeyStore trustStore = getTrustManagerStore(); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); // ssl server init SSLContext sslContext = SSLContext.getInstance(PROTOCOL); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); SSLServerSocketFactory serverSocketFactory = sslContext.getServerSocketFactory(); serverSocket = (SSLServerSocket) serverSocketFactory.createServerSocket(PORT); serverSocket.setNeedClientAuth(true); } private static KeyStore getKeyManagerStore() throws CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException { InputStream inputStream = Server.class.getResourceAsStream(&quot;/certs/server.p12&quot;); KeyStore keyStore = CertificateUtils.getKeyStore(inputStream, &quot;123456&quot;); inputStream.close(); return keyStore; } private static KeyStore getTrustManagerStore() throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); InputStream inputStream = Server.class.getResourceAsStream(&quot;/certs/ca.cer&quot;); X509Certificate certificate = (X509Certificate) CertificateUtils.getCertificate(inputStream, &quot;X.509&quot;); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, certificate); return keyStore; } @Override public void run() { while (true) { try { SSLSocket socket = (SSLSocket) serverSocket.accept(); socket.startHandshake(); // new Thread(new Runnable() {// @Override// public void run() {// try {// //socket.startHandshake();////// } catch (IOException e) {// e.printStackTrace();// }// }// }); OutputStream outputStream = socket.getOutputStream(); InputStream inputStream = socket.getInputStream(); DataOutputStream out = new DataOutputStream(outputStream); DataInputStream bin = new DataInputStream(inputStream); String str = null; if((str = bin.readUTF()) != null) { System.out.println(str); } out.writeUTF(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;); out.flush(); out.close(); bin.close(); socket.close(); System.out.println(Thread.currentThread().getName()); System.out.println(&quot;ssl socket...&quot;); } catch (Exception e) { e.printStackTrace(); } } } } 12 package com.security.certificate.clientserver; /** @author fitz @version 1.0*/public class ClientServerMain { public static void main(String[] args) throws Exception {Thread serverThread = new Thread(new Server()); serverThread.start(); new Thread(new Client()).start(); }} 123- CertificateUtils package com.security.certificate; import com.security.signature.SignatureUtils; import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.security.*;import java.security.cert.Certificate;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class CertificateUtils { /** p12 @param keyStorePath @param passwd @return @throws KeyStoreException @throws IOException @throws CertificateException @throws NoSuchAlgorithmException*/public static KeyStore getKeyStore(String keyStorePath, String passwd) throws KeyStoreException, IOException, CertificateException, NoSuchAlgorithmException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream fis = new FileInputStream(keyStorePath); keyStore.load(fis, passwd.toCharArray()); fis.close(); return keyStore;} public static KeyStore getKeyStore(InputStream fis, String passwd) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(fis, passwd.toCharArray()); return keyStore;} /** p12 @param keyStorePath @param passwd @return @throws KeyStoreException @throws CertificateException @throws NoSuchAlgorithmException @throws IOException*/public static KeyStore createKeyStore(String keyStorePath, String passwd) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, passwd.toCharArray()); FileOutputStream out = new FileOutputStream(keyStorePath); keyStore.store(out, passwd.toCharArray()); out.close(); return keyStore;} public static void storeKey(KeyStore keyStore, Key key, String alias, String passwd) throws KeyStoreException { keyStore.setKeyEntry(alias, key, passwd.toCharArray(),null);} public static void storeCertificate(KeyStore keyStore, Certificate certificate, String alias) throws KeyStoreException { keyStore.setCertificateEntry(alias, certificate);} public static PrivateKey getPrivateKey(KeyStore keyStore, String alias, String passwd) throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException { return (PrivateKey) keyStore.getKey(alias, passwd.toCharArray());} public static Certificate getCertificate(KeyStore keyStore, String alias) throws KeyStoreException { return keyStore.getCertificate(alias);} public static PublicKey getPublicKey(Certificate cert) { return cert.getPublicKey();} /* @param certPath @param certType can be “X.509” @return @throws CertificateException @throws IOException*/public static Certificate getCertificate(String certPath, String certType) throws CertificateException, IOException { CertificateFactory certificateFactory = CertificateFactory.getInstance(certType); FileInputStream in = new FileInputStream(certPath); Certificate certificate = certificateFactory.generateCertificate(in); in.close(); return certificate;} public static Certificate getCertificate(InputStream is, String certType) throws CertificateException, IOException { CertificateFactory certificateFactory = CertificateFactory.getInstance(certType); Certificate certificate = certificateFactory.generateCertificate(is); return certificate;} public static byte[] sign(KeyStore keyStore, String alias, String passwd, byte[] data) throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, SignatureException, InvalidKeyException { PrivateKey privateKey = getPrivateKey(keyStore, alias, passwd); X509Certificate certificate = (X509Certificate) getCertificate(keyStore, alias); return SignatureUtils.sign(privateKey, data, certificate.getSigAlgName()); } public static boolean verify(X509Certificate certificate, byte[] data, byte[] sign) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initVerify(certificate); return signature.verify(sign); } } 12- HttpsCertificate package com.security.certificate; import javax.net.ssl.*;import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.InputStream;import java.net.URL;import java.security.KeyStore;import java.security.SecureRandom;import java.security.cert.Certificate;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class HttpsCertificate { public static final String PROTOCOL = “TLS”; /** * ssl https best practice * ref: https://developer.android.com/training/articles/security-ssl.html?hl=zh-cn * @throws Exception */ public static void androidHttps() throws Exception { CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); // From https://www.washington.edu/itconnect/security/ca/load-der.crt InputStream caInput = new BufferedInputStream(new FileInputStream(&quot;load-der.crt&quot;)); Certificate ca; try { ca = cf.generateCertificate(caInput); System.out.println(&quot;ca=&quot; + ((X509Certificate) ca).getSubjectDN()); } finally { caInput.close(); } // Create a KeyStore containing our trusted CAs String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // Create a TrustManager that trusts the CAs in our KeyStore String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); // Create an SSLContext that uses our TrustManager SSLContext context = SSLContext.getInstance(&quot;TLS&quot;); context.init(null, tmf.getTrustManagers(), null); // Tell the URLConnection to use a SocketFactory from our SSLContext URL url = new URL(&quot;https://certs.cac.washington.edu/CAtest/&quot;); HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); urlConnection.setSSLSocketFactory(context.getSocketFactory()); InputStream in = urlConnection.getInputStream(); } /** * First and major difference between trustStore and keyStore is that trustStore is used by TrustManager * and keyStore is used by KeyManager class in Java. KeyManager and TrustManager performs different job * in Java, TrustManager determines whether remote connection should be trusted or not i.e. whether remote * party is who it claims to and KeyManager decides which authentication credentials should be sent to the * remote host for authentication during SSL handshake. if you are an SSL Server you will use private key * during key exchange algorithm and send certificates corresponding to your public keys to client, this * certificate is acquired from keyStore. On SSL client side, if its written in Java, it will use certificates * stored in trustStore to verify identity of Server. * * @param password * @param keyStorePath * @param trustStorePath * @return * @throws Exception */ private static SSLSocketFactory getSSLSocketFactory(String password, String keyStorePath, String trustStorePath) throws Exception { KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); KeyStore keyStore = CertificateUtils.getKeyStore(keyStorePath, password); keyManagerFactory.init(keyStore, password.toCharArray()); TrustManagerFactory trustManagerFactory = TrustManagerFactory .getInstance(TrustManagerFactory.getDefaultAlgorithm()); KeyStore trustStore = CertificateUtils.getKeyStore(trustStorePath, password); trustManagerFactory.init(trustStore); SSLContext ctx = SSLContext.getInstance(PROTOCOL); ctx.init(keyManagerFactory.getKeyManagers(), trustManagerFactory .getTrustManagers(), new SecureRandom()); return ctx.getSocketFactory(); } public static void configSSLSocketFactory(HttpsURLConnection conn, String password, String keyStorePath, String trustKeyStorePath) throws Exception { // 获得SSLSocketFactory SSLSocketFactory sslSocketFactory = getSSLSocketFactory(password, keyStorePath, trustKeyStorePath); // 设置SSLSocketFactory conn.setSSLSocketFactory(sslSocketFactory); } } 12345## asn1## util package com.security.util; /** @author fitz @version 1.0*/public class ByteUtils { public static byte[] stringToBytes(String s) { if(s == null || s.length() % 2 != 0) { return null; } int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) { data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character.digit(s.charAt(i+1), 16)); } return data; } public static String bytesToString(byte[] bytes) { final char[] hexChars = {&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;}; char[] chars = new char[bytes.length * 2]; int byteValue; for (int j = 0; j &lt; bytes.length; j++) { byteValue = bytes[j] &amp; 0xFF; chars[j * 2] = hexChars[byteValue &gt;&gt;&gt; 4]; chars[j * 2 + 1] = hexChars[byteValue &amp; 0x0F]; } return new String(chars); }} `]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>crypto</tag>
        <tag>jca</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java io源码]]></title>
    <url>%2Fposts%2Fjava_jdk_base_io.html</url>
    <content type="text"><![CDATA[一、概览Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO 二、磁盘操作File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地输出一个目录下所有文件： 12345678910111213public static void listAllFiles(File dir)&#123; if (dir == null || !dir.exists()) &#123; return; &#125; if (dir.isFile()) &#123; System.out.println(dir.getName()); return; &#125; for (File file : dir.listFiles()) &#123; listAllFiles(file); &#125;&#125; 三、字节操作使用字节流操作进行文件复制： 1234567891011121314public static void copyFile(String src, String dist) throws IOException&#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20 * 1024]; // read() 最多读取 buffer.length 个字节 // 返回的是实际读取的个数 // 返回 -1 的时候表示读到 eof，即文件尾 while (in.read(buffer, 0, buffer.length) != -1) &#123; out.write(buffer); &#125; in.close(); out.close();&#125; Java I/O 使用了装饰者模式来实现。以 InputStream 为例，InputStream 是抽象组件，FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作。FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能，例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 12FileInputStream fileInputStream = new FileInputStream(filePath);BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 四、字符操作不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从字节流解码成字符流； OutputStreamWriter 实现字符流编码成为字节流。 逐行输出文本文件的内容： 12345678910111213public static void readFileContent(String filePath) throws IOException&#123; FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 fileReader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close();&#125; 编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 String 可以看成一个字符序列，可以指定一个编码方式将它转换为字节序列，也可以指定一个编码方式将一个字节序列转换为 String。 1234String str1 = &quot;中文&quot;;byte[] bytes = str1.getBytes(&quot;UTF-8&quot;);String str2 = new String(bytes, &quot;UTF-8&quot;);System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。 1byte[] bytes = str1.getBytes(); 五、对象操作序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 12345678910111213141516171819202122232425262728293031public static void main(String[] args) throws IOException, ClassNotFoundException&#123; A a1 = new A(123, &quot;abc&quot;); String objectFile = &quot;file/a1&quot;; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile)); objectOutputStream.writeObject(a1); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile)); A a2 = (A) objectInputStream.readObject(); objectInputStream.close(); System.out.println(a2);&#125;private static class A implements Serializable&#123; private int x; private String y; A(int x, String y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return &quot;x = &quot; + x + &quot; &quot; + &quot;y = &quot; + y; &#125;&#125; 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。 transient 关键字可以使一些属性不会被序列化。 ArrayList 序列化和反序列化的实现 ：ArrayList 中存储数据的数组是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 六、网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 InetAddress没有公有构造函数，只能通过静态方法来创建实例。 12InetAddress.getByName(String host);InetAddress.getByAddress(byte[] address); URL可以直接从 URL 中读取字节流数据。 123456789101112131415public static void main(String[] args) throws IOException&#123; URL url = new URL(&quot;http://www.baidu.com&quot;); // 字节流 InputStream is = url.openStream(); // 字符流 InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;); BufferedReader br = new BufferedReader(isr); String line = br.readLine(); while (line != null) &#123; System.out.println(line); line = br.readLine(); &#125; br.close();&#125; Sockets ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 Datagram DatagramPacket：数据包类 DatagramSocket：通信类 七、NIO Java NIO Tutorial Java NIO 浅析 IBM: NIO 入门 新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 流与块I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io. 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io. 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。 通道与缓冲区1. 通道通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动，(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 通道包括以下类型： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 2. 缓冲区发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区状态变量 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 状态变量的改变过程举例： ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 ② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 移动设置为 5，limit 保持不变。 ③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 文件 NIO 实例以下展示了使用 NIO 快速复制文件的实例： 1234567891011121314151617public static void fastCopy(String src, String dist) throws IOException&#123; FileInputStream fin = new FileInputStream(src); /* 获取源文件的输入字节流 */ FileChannel fcin = fin.getChannel(); /* 获取输入字节流的文件通道 */ FileOutputStream fout = new FileOutputStream(dist); /* 获取目标文件的输出字节流 */ FileChannel fcout = fout.getChannel(); /* 获取输出字节流的通道 */ ByteBuffer buffer = ByteBuffer.allocateDirect(1024); /* 为缓冲区分配 1024 个字节 */ while (true) &#123; int r = fcin.read(buffer); /* 从输入通道中读取数据到缓冲区中 */ if (r == -1) &#123; /* read() 返回 -1 表示 EOF */ break; &#125; buffer.flip(); /* 切换读写 */ fcout.write(buffer); /* 把缓冲区的内容写入输出文件中 */ buffer.clear(); /* 清空缓冲区 */ &#125;&#125; 选择器NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件具有更好的性能。 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。 1. 创建选择器1Selector selector = Selector.open(); 2. 将通道注册到选择器上123ServerSocketChannel ssChannel = ServerSocketChannel.open();ssChannel.configureBlocking(false);ssChannel.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 它们在 SelectionKey 的定义如下： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4; 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如： 1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 3. 监听事件1int num = selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 4. 获取到达的事件1234567891011Set&lt;SelectionKey&gt; keys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove();&#125; 5. 事件循环因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 1234567891011121314while (true) &#123; int num = selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove(); &#125;&#125; 套接字 NIO 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NIOServer&#123; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); ServerSocketChannel ssChannel = ServerSocketChannel.open(); ssChannel.configureBlocking(false); ssChannel.register(selector, SelectionKey.OP_ACCEPT); ServerSocket serverSocket = ssChannel.socket(); InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 8888); serverSocket.bind(address); while (true) &#123; selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel sChannel = ssChannel1.accept(); sChannel.configureBlocking(false); // 这个新连接主要用于从客户端读取数据 sChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; SocketChannel sChannel = (SocketChannel) key.channel(); System.out.println(readDataFromSocketChannel(sChannel)); sChannel.close(); &#125; keyIterator.remove(); &#125; &#125; &#125; private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); StringBuilder data = new StringBuilder(); while (true) &#123; buffer.clear(); int n = sChannel.read(buffer); if (n == -1) &#123; break; &#125; buffer.flip(); int limit = buffer.limit(); char[] dst = new char[limit]; for (int i = 0; i &lt; limit; i++) &#123; dst[i] = (char) buffer.get(i); &#125; data.append(dst); buffer.clear(); &#125; return data.toString(); &#125;&#125; 1234567891011public class NIOClient&#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); OutputStream out = socket.getOutputStream(); String s = &quot;hello world&quot;; out.write(s.getBytes()); out.close(); &#125;&#125; 内存映射文件内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。 向内存映射文件写入可能是危险的，仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。 下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，您可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。 1MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024); 对比NIO 与普通 I/O 的区别主要有以下两点： NIO 是非阻塞的 NIO 面向块，I/O 面向流 参考：https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Java%20IO.md#%E4%B8%89%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C http://ifeve.com/java-io/]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java collections源码分析原理]]></title>
    <url>%2Fposts%2Fjava_jdk_base_collections_analysis.html</url>
    <content type="text"><![CDATA[collections大纲 ListArrayListLinkedListCopyOnWriteArrayList QueueLinkedListArrayDequePriorityQueueConcurrentLinkedQueue/DequeArrayBlockingQueueLinkedBlockingQueue/DequePriorityBlockingQueueSynchronousQueueDelayQueue SetHashSetLinkedHashSetTreeSetConcurrentSkipListSetCopyOnWriteArraySet Stack MapHashMapLinkedHashMapTreeMapConcurrentHashMapConcurrentSkipListMapWeakHashMap ArrayList概述重要知识点： 实现原理private transient Object[] elementData; 构造函数public ArrayList()可以构造一个默认初始容量为10的空列表； 实现接口List, RandomAccess, Cloneable, java.io.Serializable 扩容原理，如下： 复制system.copyof Arrays.copyOf，System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData = Arrays.copyOf(elementData, size, Object[].class); 扩容条件：在add(ensureCapacityInternal(size + 1);)或者addAll(ensureCapacityInternal(size + 1);)进行判断是否需要扩容。 扩容方法： 1234567891011121314151617181920212223private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; fail-fast机制 ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 机制详解：http://www.cnblogs.com/skywang12345/p/3308762.html iterater初始化过程中保存一个int expectedModCount = modCount;当remove会修改expectedModCount, 每次执行next或者remove都会checkForComodification，看expectedModCount和modCount是否匹配， modCount会被其他线程在list.add或remove操作给修改掉，就变得不一致了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package java.util;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; ... // AbstractList中唯一的属性 // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1 protected transient int modCount = 0; public void ensureCapacity(int minCapacity) &#123; modCount++; //修改modCount int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 删除指定位置的元素 public E remove(int index) &#123; RangeCheck(index); // 修改modCount modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 返回List对应迭代器。实际上，是返回Itr对象。 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; // Itr是Iterator(迭代器)的实现类 private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0; int lastRet = -1; // 修改数的记录值。 // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount； // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; ...&#125; LinkedList 实现接口，implements List, Deque, Cloneable, java.io.Serializable 基本原理是双端队列，注意下Node的新建方式，直接赋值pre和next节点, 代码结果如下： 123456789101112131415transient int size = 0;transient Node&lt;E&gt; first; //链表的头指针transient Node&lt;E&gt; last; //尾指针//存储对象的结构 Node, LinkedList的内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; // 指向下一个节点 Node&lt;E&gt; prev; //指向上一个节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; add方法处理，主要是一些判断和链表操作。单Node注意pre和next，整个LinkedList注意first和last的变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;/** * Links e as first element. */private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125;/*** Links e as last element.*/void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; CopyOnWriteArrayList在线程对其进行些操作的时候，会拷贝一个新的数组以存放新的字段。 private volatile transient Object[] array;//保证了线程的可见性，所有操作直接操作主存。 写操作加锁，读操作不加锁，相对来说读的效率更高 可变操作（add()、set() 和 remove() 等等）的开销很大, 因为通常需要复制整个基础数组。 写操作Object[] newElements = Arrays.copyOf(elements, len + 1);直接加锁，复制，新建一个数组，写回主存，get操作不加锁直接操作 123456789101112131415161718192021222324 /** The lock protecting all mutators */ transient final ReentrantLock lock = new ReentrantLock(); /** The array, accessed only via getArray/setArray. */ private volatile transient Object[] array;//保证了线程的可见性public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//ReentrantLock 保证了线程的可见性和顺序性，即保证了多线程安全。 lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//在原先数组基础之上新建长度＋1的数组，并将原先数组当中的内容拷贝到新数组当中。 newElements[len] = e;//设值 setArray(newElements);//对新数组进行赋值 return true; &#125; finally &#123; lock.unlock(); &#125; &#125; public E get(int index) &#123; return (E)(getArray()[index]); &#125; 迭代不会出现ConcurrentModificationException, 因为迭代器会保存一个快照private final Object[] snapshot;, 而不是直接操作原来的Object[] array，不可变，不会发生同步问题。 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作, 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;public ListIterator&lt;E&gt; listIterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;public ListIterator&lt;E&gt; listIterator(final int index) &#123; Object[] elements = getArray(); int len = elements.length; if (index&lt;0 || index&gt;len) throw new IndexOutOfBoundsException("Index: "+index); return new COWIterator&lt;E&gt;(elements, index);&#125; private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; // 保存数组的快照，是一个不可变的对象 private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; @SuppressWarnings("unchecked") public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; @SuppressWarnings("unchecked") public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125;&#125; 参考：https://blog.csdn.net/mazhimazh/article/details/19210547 synchronized List 线程安全原理，继承层级 mutex就是当前的SynchronizedCollection对象，而SynchronizedRandomAccessList继承自SynchronizedList，SynchronizedList又继承自SynchronizedCollection，所以SynchronizedRandomAccessList中的mutex也就是SynchronizedRandomAccessList的this对象。所以在GoodListHelper中使用的锁list对象，和SynchronizedRandomAccessList内部的锁是一致的，所以它可以实现线程安全性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;T&gt;(list) : new SynchronizedList&lt;T&gt;(list)); &#125; 通过源码，我们还需要知道ArrayList是否实现了RandomAccess接口：public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 查看ArrayList的源码，可以看到它实现了RandomAccess，所以上面的synchronizedList放回的应该是SynchronizedRandomAccessList的实例。接下来看看SynchronizedRandomAccessList这个类的实现：static class SynchronizedRandomAccessList&lt;E&gt; extends SynchronizedList&lt;E&gt; implements RandomAccess &#123; SynchronizedRandomAccessList(List&lt;E&gt; list) &#123; super(list); &#125; SynchronizedRandomAccessList(List&lt;E&gt; list, Object mutex) &#123; super(list, mutex); &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; synchronized(mutex) &#123; return new SynchronizedRandomAccessList&lt;E&gt;( list.subList(fromIndex, toIndex), mutex); &#125; &#125; static final long serialVersionUID = 1530674583602358482L; private Object writeReplace() &#123; return new SynchronizedList&lt;E&gt;(list); &#125; &#125; 因为SynchronizedRandomAccessList这个类继承自SynchronizedList，而大部分方法都在SynchronizedList中实现了，所以源码中只包含了很少的方法，但是通过subList方法，我们可以看到这里使用的锁对象为mutex对象，而mutex是在SynchronizedCollection类中定义的，所以再看看SynchronizedCollection这个类中关于mutex的定义部分源码：static class SynchronizedCollection&lt;E&gt; implements Collection&lt;E&gt;, Serializable &#123; private static final long serialVersionUID = 3053995032091335093L; final Collection&lt;E&gt; c; // Backing Collection final Object mutex; // Object on which to synchronize SynchronizedCollection(Collection&lt;E&gt; c) &#123; if (c==null) throw new NullPointerException(); this.c = c; mutex = this; &#125; SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) &#123; this.c = c; this.mutex = mutex; &#125; &#125; 两种写法造成的线程安全问题12345678910111213141516171819202122232425262728293031323334353637383940@ThreadSafe class GoodListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) &#123; synchronized (list) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125; &#125; &#125;//mutex也就是SynchronizedRandomAccessList=SynchronizedCollection的this对象。所以在GoodListHelper中使用的锁list=mutex对象，和SynchronizedRandomAccessList内部的锁是一致的，所以它可以实现线程安全性。@NotThreadSafe class BadListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125; &#125;// 不安全 contains 和 add 单独安全，组合就不安全了。 @NotThreadSafe class BadListHelper &lt;E&gt; &#123; public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) list.add(x); return absent; &#125; &#125; // 不安全，list是public，可能被外部进行add和remove操作 https://www.cnblogs.com/yaowen/p/5983136.html Vector 相当于给每一个ArrayList操作加了一个synchronize， 但是接口组合调用依然是不安全的，需要注意，这种类似情况可以追溯到ConcurrentHashMap等一些集合的调用。 接口组合调用-线程安全问题ConcurrentHashMap只能保证单次操作的Atomicity，如T1: concurrent_map.insert(key1,val1) T2: concurrent_map.contains(key1)T1 和T2 的操作不会导致race condition.但如果T1 和T2 组合调用是123if (! concurrent_map.contains(key1) &#123; concurrent_map.insert(key1,val1)&#125; 即使 contains 和 insert 他们本身是thread-safe的，由于interleaving会发生在contains和insert中间，你没办法保证这两个操作组合起来的atomicity. 这是用目前几乎所有的thread-safe entity 的一大问题之一：小的thread-safe entity 如果要组合成大的thread-safe entity, 小entity的抽象便没办法维持；比如说，在你这个例子里，当你单独使用contains 或者 insert 的时候，不需要给 key1上锁，因为这个已经抽象在concurrent_map 里面了，但当你想把这两个操作合起来使用并继续保持atomicity，就必须要给key1 上锁，就破坏了concurrent_map 的抽象。有兴趣的话可以看 此书（http://bt.nitk.ac.in/c/15a/co403/notes/SLoCA-TM.pdf）的1.1.2小节，专门讲了这个composition 问题。 参考：http://a123159521.iteye.com/blog/1245116https://www.jianshu.com/p/a20052ac48f1 HashMap HashMap底层就是一个数组结构，数组中的每一项又是一个链表.12345678910111213141516171819202122public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init();&#125; 我们着重看一下第18行代码table = new Entry[capacity];。这不就是Java中数组的创建方式吗？也就是说在构造函数中，其创建了一个Entry的数组，其大小为capacity（目前我们还不需要太了解该变量含义），那么Entry又是什么结构呢？看一下源码：123456789101112131415161718192021static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ……&#125;//jdk1.8static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; 扩容机制threshold和loadFactor，hashcode等 int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 首先,Node[] table的初始化长度length(默认值是16),Load factor为负载因子(默认值是0.75),threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说,在数组定义好长度之后,负载因子越大,所能容纳的键值对个数越多。 结合负载因子的定义公式可知,threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目,超过这个数目就重新resize(扩容),扩容后的HashMap容量是之前容量的两倍。 确定哈希桶数组索引位置1234567//方法一:static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; //在JDK1.8的实现中,优化了高位运算的算法,通过hashCode()的高16位异或低16位实现的:(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16),主要是从速度、功效、质量来考虑的,这么做可以在数组table的length比较小的时候,也能保证考虑到高低Bit都参与到Hash的计算中,同时不会有太大的开销。1234//方法二:static int indexFor(int h, int length) &#123; //jdk1.7的源码,jdk1.8没有这个方法,但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 它通过h &amp; (table.length -1)来得到该对象的保存位,而HashMap底层数组的长度总是2的n次方,这是HashMap在速度上的优化。当length总是2的n次方时,h&amp; (length-1)运算等价于对length取模,也就是h%length,但是&amp;比%具有更高的效率。 扩容方法 newTable[i]的引用赋给了e.next,也就是使用了单链表的头插入方式,同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话),这一点和Jdk1.8有区别,下文详解。在旧数组中同一条Entry链上的元素,通过重新计算索引位置后,有可能被放到了新数组的不同位置上。 扩容技巧：我们使用的是2次幂的扩展(指长度扩为原来2倍),所以,元素的位置要么是在原位置,要么是在原位置再移动2次幂的位置 12345678910111213141516171819202122232425262728293031void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1),这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //!!将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用(for循环后,旧的Entry数组不再引用任何对象) do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //!!重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; 冲突解决方法: 链地址，开放地址(线性探测、二次探测、再哈希法) put操作和红黑树性能优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①:tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②:计算index,并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③:节点key存在,直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④:判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤:该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥:超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; !()[http://atecher.net/2017/09/21/Java-Java8-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap/hashMap_put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png] fail-fast通过modeCount体现 fail-fast 机制是java集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。 例如：当某一个线程A通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出 ConcurrentModificationException异常，产生 fail-fast 事件。 这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容（当然不仅仅是HashMap才会有，其他例如ArrayList也会）的修改都将增加这个值（大家可以再回头看一下其源码，在很多操作中都有modCount++这句），那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。12345678HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125;&#125; 在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map： 注意到modCount声明为volatile，保证线程之间修改的可见性。123final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); 在HashMap的API中指出： 由所有HashMap类的“collection 视图方法”所返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。 注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。 参考： http://atecher.net/2017/09/21/Java-Java8-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap/ https://github.com/atecher/atecher.github.io/blob/blog-source/source/_posts/Java-Java8-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap.md 遍历 HashMap的两种遍历方式 第一种 1234567 Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); &#125; 效率高,以后一定要使用此种方式！第二种1234567 Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; Object key = iter.next(); Object val = map.get(key);Object key = iter.next(); Object val = map.get(key); &#125; 效率低,以后尽量少使用！ LinkedHashMap 排序模式accessOrder默认插入顺序，构造函数设置为true后，变成访问顺序。new LinkedHashMap&lt;String, String&gt;(16,0.75f,true); 继承与HashMap(public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;)、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。 LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。12345678910111213141516171819/*** The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;* for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.* 如果为true，则按照访问顺序；如果为false，则按照插入顺序。*/private final boolean accessOrder;/*** 双向链表的表头元素。 */private transient Entry&lt;K,V&gt; header;/*** LinkedHashMap的Entry元素。* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 */private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; ……&#125; LinkedHashMap中的Entry集成与HashMap的Entry，但是其增加了before和after的引用，指的是上一个元素和下一个元素的引用。 removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素 put/get操作。 HashMap.put: 12345678910111213141516171819public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125; 重写方法：1234567891011121314151617181920212223242526272829303132333435363738void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125;&#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 调用create方法，将新元素以双向链表的的形式加入到映射中。 createEntry(hash, key, value, bucketIndex); // 删除最近最少使用元素的策略定义 Entry&lt;K,V&gt; eldest = header.after; if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key); &#125; else &#123; if (size &gt;= threshold) resize(2 * table.length); &#125;&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old); table[bucketIndex] = e; // 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。 e.addBefore(header); size++;&#125;private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 读取getLinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。1234567891011121314151617181920212223242526272829303132333435public V get(Object key) &#123; // 调用父类HashMap的getEntry()方法，取得要查找的元素。 Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; // 记录访问顺序。 e.recordAccess(this); return e.value;&#125;void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; // 如果定义了LinkedHashMap的迭代顺序为访问顺序， // 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。 if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125;&#125;/*** Removes this entry from the linked list.*/private void remove() &#123; before.after = after; after.before = before;&#125;/**clear链表，设置header为初始状态*/public void clear() &#123; super.clear(); header.before = header.after = header;&#125; cache的两种实现 lrucache-&gt;linkedHashMap(false) 插入顺序排序 fifocache-&gt;linkedHashMap(true) 访问顺序排序 其中有两种比较简单的方法，如下：1234567891011121314151617181920212223242526public class LRU&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;&#123; private static final long serialVersionUID = 1L; private static final int maxSize = 0; public LRU(int maxSize) &#123; this.maxSize = maxSize; super(16, 0.75, true); // lru super(16, 0.75, false); // fifo &#125; /** * @description 重写LinkedHashMap中的removeEldestEntry方法，当LRU中元素多余maxSize个时， * 删除最不经常使用的元素 * @param eldest * @return * @see java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry) */ @Override protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) &#123; if(size() &gt; maxSize)&#123; return true; &#125; return false; &#125;&#125; HashTableHashTable和HashMap采用相同的存储机制，二者的实现基本一致，不同的是： （1）HashMap是非线程安全的，HashTable是线程安全的，内部的方法基本都经过synchronized修饰。 （2）因为同步、哈希性能等原因，性能肯定是HashMap更佳，因此HashTable已被淘汰。 （3） HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。 （4）HashMap默认初始化数组的大小为16，HashTable为11。前者扩容时乘2，使用位运算取得哈希，效率高于取模。而后者为乘2加1，都是素数和奇数，这样取模哈希结果更均匀。 （5）HashMap可以允许插入null key和null value； HashTable和ConcurrentHashMap都不可以插入null key和null value ConcurrentHashMap 参考： https://www.cnblogs.com/study-everyday/p/6430462.html#autoid-2-2-3 https://blog.csdn.net/m0_37135421/article/details/80551884#t11 http://www.jasongj.com/java/concurrenthashmap/ https://www.cnblogs.com/huaizuo/p/5413069.html ConcurrentHashMap的结构中包含的Segment的数组，在默认的并发级别会创建包含16个Segment对象的数组。通过我们上面的知识，我们知道每个Segment又包含若干个散列表的桶，每个桶是由HashEntry链接起来的一个链表。如果key能够均匀散列，每个Segment大约守护整个散列表桶总数的1/16。 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; jdk1.7, ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成, Segment数组的意义就是将一个大的table分割成多个小的table来进行加锁，也就是上面的提到的锁分离技术，而每一个Segment元素存储的是HashEntry数组+链表，这个和HashMap的数据存储结构一样。 put操作 对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置 static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable { 从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒。它使用了自旋锁，如果tryLock获取锁失败，说明锁被其它线程占用，此时通过循环再次以tryLock的方式申请锁。如果在循环过程中该Key所对应的链表头被修改，则重置retry次数。如果retry次数超过一定值，则使用lock方法申请锁。 get操作ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null size操作计算ConcurrentHashMap的元素大小是一个有趣的问题，因为他是并发操作的，就是在你计算size的时候，他还在并发的插入数据，可能会导致你计算出来的size和你实际的size有相差（在你return size的时候，插入了多个数据），要解决这个问题，JDK1.7版本用两种方案第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回。123456789101112131415161718192021try &#123; for (;;) &#123; if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; if (sum == last) break; last = sum; &#125; &#125;finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125;&#125; JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本 put操作 如果没有初始化就先调用initTable（）方法来进行初始化过程如果没有hash冲突就直接CAS插入如果还在进行扩容操作就先进行扩容如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容 ConcurrentHashMap的get操作的流程很简单，也很清晰，可以分为三个步骤来描述 计算hash值，定位到该table索引位置，如果是首节点符合就返回如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null size操作1234567891011121314151617public int size() &#123; long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);&#125;final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; //变化的数量 long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。 TreeMapConcurrentSkipListMap到目前为止，我们在Java世界里看到了两种实现key-value的数据结构：Hash、TreeMap，这两种数据结构各自都有着优缺点。 Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。 红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。 然而，这次介绍第三种实现key-value的数据结构：SkipList。SkipList有着不低于红黑树的效率，但是其原理和实现的复杂度要比红黑树简单多了。 SkipList什么是SkipList？Skip List ，称之为跳表，它是一种可以替代平衡树的数据结构，其数据元素默认按照key值升序，天然有序。Skip list让已排序的数据分布在多层链表中，以0-1随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。 我们先看一个简单的链表，如下： 如果我们需要查询9、21、30，则需要比较次数为3 + 6 + 8 = 17 次，那么有没有优化方案呢？有！我们将该链表中的某些元素提炼出来作为一个比较“索引”，如下： 我们先与这些索引进行比较来决定下一个元素是往右还是下走，由于存在“索引”的缘故，导致在检索的时候会大大减少比较的次数。当然元素不是很多，很难体现出优势，当元素足够多的时候，这种索引结构就会大显身手。 SkipList的特性SkipList具备如下特性： 由很多层结构组成，level是通过一定的概率随机产生的 每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法 最底层(Level 1)的链表包含所有元素 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素 我们将上图再做一些扩展就可以变成一个典型的SkipList结构了 SkipList的查找SkipListd的查找算法较为简单，对于上面我们我们要查找元素21，其过程如下： 比较3，大于，往后找（9）， 比9大，继续往后找（25），但是比25小，则从9的下一层开始找（16） 16的后面节点依然为25，则继续从16的下一层找 找到21 如图 红色虚线代表路径。 SkipList的插入SkipList的插入操作主要包括： 查找合适的位置。这里需要明确一点就是在确认新节点要占据的层次K时，采用丢硬币的方式，完全随机。如果占据的层次K大于链表的层次，则重新申请新的层，否则插入指定层次 申请新的节点 调整指针 假定我们要插入的元素为23，经过查找可以确认她是位于25后，9、16、21前。当然需要考虑申请的层次K。 如果层次K &gt; 3 需要申请新层次（Level 4） 如果层次 K = 2 直接在Level 2 层插入即可 这里会涉及到以个算法：通过丢硬币决定层次K，该算法我们通过后面ConcurrentSkipListMap源码来分析。还有一个需要注意的地方就是，在K层插入元素后，需要确保所有小于K层的层次都应该出现新节点。 SkipList的删除删除节点和插入节点思路基本一致：找到节点，删除节点，调整指针。 比如删除节点9，如下： ConcurrentSkipListMap通过上面我们知道SkipList采用空间换时间的算法，其插入和查找的效率O(logn)，其效率不低于红黑树，但是其原理和实现的复杂度要比红黑树简单多了。一般来说会操作链表List，就会对SkipList毫无压力。 ConcurrentSkipListMap其内部采用SkipLis数据结构实现。为了实现SkipList，ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中Node表示最底层的单链表有序节点、Index表示为基于Node的索引层，HeadIndex用来维护索引层次。到这里我们可以这样说ConcurrentSkipListMap是通过HeadIndex维护索引层次，通过Index从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层Node时，就只需要比较很小一部分数据了。在JDK中的关系如下图： Node 1234567static final class Node&lt;K,V&gt; &#123; final K key; volatile Object value; volatile ConcurrentSkipListMap.Node&lt;K, V&gt; next; /** 省略些许代码 */&#125; Node的结构和一般的单链表毫无区别，key-value和一个指向下一个节点的next。 Index 1234567static class Index&lt;K,V&gt; &#123; final ConcurrentSkipListMap.Node&lt;K,V&gt; node; final ConcurrentSkipListMap.Index&lt;K,V&gt; down; volatile ConcurrentSkipListMap.Index&lt;K,V&gt; right; /** 省略些许代码 */&#125; Index提供了一个基于Node节点的索引Node，一个指向下一个Index的right，一个指向下层的down节点。 HeadIndex 1234567static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; //索引层，从1开始，Node单链表层为0 HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125; HeadIndex内部就一个level来定义层级。 ConcurrentSkipListMap提供了四个构造函数，每个构造函数都会调用initialize()方法进行初始化工作。 123456789final void initialize() &#123; keySet = null; entrySet = null; values = null; descendingMap = null; randomSeed = seedGenerator.nextInt() | 0x0100; // ensure nonzero head = new ConcurrentSkipListMap.HeadIndex&lt;K,V&gt;(new ConcurrentSkipListMap.Node&lt;K,V&gt;(null, BASE_HEADER, null), null, null, 1);&#125; 注意，initialize()方法不仅仅只在构造函数中被调用，如clone，clear、readObject时都会调用该方法进行初始化步骤。这里需要注意randomSeed的初始化。 12private transient int randomSeed;randomSeed = seedGenerator.nextInt() | 0x0100; // ensure nonzero randomSeed一个简单的随机数生成器（在后面介绍）。 put操作CoucurrentSkipListMap提供了put()方法用于将指定值与此映射中的指定键关联。源码如下： 12345public V put(K key, V value) &#123; if (value == null) throw new NullPointerException(); return doPut(key, value, false);&#125; 首先判断value如果为null，则抛出NullPointerException，否则调用doPut方法，其实如果各位看过JDK的源码的话，应该对这样的操作很熟悉了，JDK源码里面很多方法都是先做一些必要性的验证后，然后通过调用do**()方法进行真正的操作。 doPut()方法内容较多，我们分步分析。 12345678910private V doPut(K key, V value, boolean onlyIfAbsent) &#123; Node&lt;K,V&gt; z; // added node if (key == null) throw new NullPointerException(); // 比较器 Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (Node&lt;K, V&gt; b = findPredecessor(key, cmp), n = b.next; ; ) &#123; /** 省略代码 */ doPut()方法有三个参数，除了key,value外还有一个boolean类型的onlyIfAbsent，该参数作用与如果存在当前key时，该做何动作。当onlyIfAbsent为false时，替换value，为true时，则返回该value。用代码解释为： 1234 if (!map.containsKey(key)) return map.put(key, value);else return map.get(key); 首先判断key是否为null，如果为null，则抛出NullPointerException，从这里我们可以确认ConcurrentSkipList是不支持key或者value为null的。然后调用findPredecessor()方法，传入key来确认位置。findPredecessor()方法其实就是确认key要插入的位置。 1234567891011121314151617181920212223242526272829303132333435363738private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123; if (key == null) throw new NullPointerException(); // don&apos;t postpone errors for (;;) &#123; // 从head节点开始，head是level最高级别的headIndex for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123; // r != null，表示该节点右边还有节点，需要比较 if (r != null) &#123; Node&lt;K,V&gt; n = r.node; K k = n.key; // value == null，表示该节点已经被删除了 // 通过unlink()方法过滤掉该节点 if (n.value == null) &#123; //删掉r节点 if (!q.unlink(r)) break; // restart r = q.right; // reread r continue; &#125; // value != null，节点存在 // 如果key 大于r节点的key 则往前进一步 if (cpr(cmp, key, k) &gt; 0) &#123; q = r; r = r.right; continue; &#125; &#125; // 到达最右边，如果dowm == null，表示指针已经达到最下层了，直接返回该节点 if ((d = q.down) == null) return q.node; q = d; r = d.right; &#125; &#125; &#125; findPredecessor()方法意思非常明确：寻找前辈。从最高层的headIndex开始向右一步一步比较，直到right为null或者右边节点的Node的key大于当前key为止，然后再向下寻找，依次重复该过程，直到down为null为止，即找到了前辈，看返回的结果注意是Node，不是Item，所以插入的位置应该是最底层的Node链表。 在这个过程中ConcurrentSkipListMap赋予了该方法一个其他的功能，就是通过判断节点的value是否为null，如果为null，表示该节点已经被删除了，通过调用unlink()方法删除该节点。 123final boolean unlink(Index&lt;K,V&gt; succ) &#123; return node.value != null &amp;&amp; casRight(succ, succ.right);&#125; 删除节点过程非常简单，更改下right指针即可。 通过findPredecessor()找到前辈节点后，做什么呢？看下面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; // 前辈节点的next != null if (n != null) &#123; Object v; int c; Node&lt;K,V&gt; f = n.next; // 不一致读，主要原因是并发，有节点捷足先登 if (n != b.next) // inconsistent read break; // n.value == null，该节点已经被删除了 if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // 前辈节点b已经被删除 if (b.value == null || v == n) // b is deleted break; // 节点大于，往前移 if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123; b = n; n = f; continue; &#125; // c == 0 表示，找到一个key相等的节点，根据onlyIfAbsent参数来做判断 // onlyIfAbsent ==false，则通过casValue，替换value // onlyIfAbsent == true，返回该value if (c == 0) &#123; if (onlyIfAbsent || n.casValue(v, value)) &#123; @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v; return vv; &#125; break; // restart if lost race to replace value &#125; // else c &lt; 0; fall through &#125; // 将key-value包装成一个node，插入 z = new Node&lt;K,V&gt;(key, value, n); if (!b.casNext(n, z)) break; // restart if lost race to append to b break outer; &#125; 找到合适的位置后，就是在该位置插入节点咯。插入节点的过程比较简单，就是将key-value包装成一个Node，然后通过casNext()方法加入到链表当中。当然是插入之前需要进行一系列的校验工作。 在最下层插入节点后，下一步工作是什么？新建索引。前面博主提过，在插入节点的时候，会根据采用抛硬币的方式来决定新节点所插入的层次，由于存在并发的可能，ConcurrentSkipListMap采用ThreadLocalRandom来生成随机数。如下： 1int rnd = ThreadLocalRandom.nextSecondarySeed(); 抛硬币决定层次的思想很简单，就是通过抛硬币如果硬币为正面则层次level + 1 ，否则停止，如下： 123// 抛硬币决定层次while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0) ++level; 在阐述SkipList插入节点的时候说明了，决定的层次level会分为两种情况进行处理，一是如果层次level大于最大的层次话则需要新增一层，否则就在相应层次以及小于该level的层次进行节点新增处理。 level &lt;= headIndex.level 123456// 如果决定的层次level比最高层次head.level小，直接生成最高层次的index// 由于需要确认每一层次的down，所以需要从最下层依次往上生成if (level &lt;= (max = h.level)) &#123; for (int i = 1; i &lt;= level; ++i) idx = new ConcurrentSkipListMap.Index&lt;K,V&gt;(z, idx, null);&#125; 从底层开始，小于level的每一层都初始化一个index，每次的node都指向新加入的node，down指向下一层的item，右侧next全部为null。整个处理过程非常简单：为小于level的每一层初始化一个index，然后加入到原来的index链条中去。 level &gt; headIndex.level 123456789101112131415161718192021222324252627282930313233// leve &gt; head.level 则新增一层 else &#123; // try to grow by one level // 新增一层 level = max + 1; // 初始化 level个item节点 @SuppressWarnings(&quot;unchecked&quot;) ConcurrentSkipListMap.Index&lt;K,V&gt;[] idxs = (ConcurrentSkipListMap.Index&lt;K,V&gt;[])new ConcurrentSkipListMap.Index&lt;?,?&gt;[level+1]; for (int i = 1; i &lt;= level; ++i) idxs[i] = idx = new ConcurrentSkipListMap.Index&lt;K,V&gt;(z, idx, null); // for (;;) &#123; h = head; int oldLevel = h.level; // 层次扩大了，需要重新开始（有新线程节点加入） if (level &lt;= oldLevel) // lost race to add level break; // 新的头结点HeadIndex ConcurrentSkipListMap.HeadIndex&lt;K,V&gt; newh = h; ConcurrentSkipListMap.Node&lt;K,V&gt; oldbase = h.node; // 生成新的HeadIndex节点，该HeadIndex指向新增层次 for (int j = oldLevel+1; j &lt;= level; ++j) newh = new ConcurrentSkipListMap.HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j); // HeadIndex CAS替换 if (casHead(h, newh)) &#123; h = newh; idx = idxs[level = oldLevel]; break; &#125; &#125; 当抛硬币决定的level大于最大层次level时，需要新增一层进行处理。处理逻辑如下： 初始化一个对应的index数组，大小为level + 1，然后为每个单位都创建一个index，个中参数为：Node为新增的Z，down为下一层index，right为null 通过for循环来进行扩容操作。从最高层进行处理，新增一个HeadIndex，个中参数：节点Node，down都为最高层的Node和HeadIndex，right为刚刚创建的对应层次的index，level为相对应的层次level。最后通过CAS把当前的head与新加入层的head进行替换。 通过上面步骤我们发现，尽管已经找到了前辈节点，也将node插入了，也确定确定了层次并生成了相应的Index，但是并没有将这些Index插入到相应的层次当中，所以下面的代码就是将index插入到相对应的层当中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 从插入的层次level开始 splice: for (int insertionLevel = level;;) &#123; int j = h.level; // 从headIndex开始 for (ConcurrentSkipListMap.Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123; if (q == null || t == null) break splice; // r != null；这里是找到相应层次的插入节点位置，注意这里只横向找 if (r != null) &#123; ConcurrentSkipListMap.Node&lt;K,V&gt; n = r.node; int c = cpr(cmp, key, n.key); // n.value == null ，解除关系，r右移 if (n.value == null) &#123; if (!q.unlink(r)) break; r = q.right; continue; &#125; // key &gt; n.key 右移 if (c &gt; 0) &#123; q = r; r = r.right; continue; &#125; &#125; // 上面找到节点要插入的位置，这里就插入 // 当前层是最顶层 if (j == insertionLevel) &#123; // 建立联系 if (!q.link(r, t)) break; // restart if (t.node.value == null) &#123; findNode(key); break splice; &#125; // 标志的插入层 -- ，如果== 0 ，表示已经到底了，插入完毕，退出循环 if (--insertionLevel == 0) break splice; &#125; // 上面节点已经插入完毕了，插入下一个节点 if (--j &gt;= insertionLevel &amp;&amp; j &lt; level) t = t.down; q = q.down; r = q.right; &#125; &#125; 这段代码分为两部分看，一部分是找到相应层次的该节点插入的位置，第二部分在该位置插入，然后下移。 至此，ConcurrentSkipListMap的put操作到此就结束了。代码量有点儿多，这里总结下： 首先通过findPredecessor()方法找到前辈节点Node 根据返回的前辈节点以及key-value，新建Node节点，同时通过CAS设置next 设置节点Node，再设置索引节点。采取抛硬币方式决定层次，如果所决定的层次大于现存的最大层次，则新增一层，然后新建一个Item链表。 最后，将新建的Item链表插入到SkipList结构中。 get操作相比于put操作 ，get操作会简单很多，其过程其实就只相当于put操作的第一步： 123456789101112131415161718192021222324252627282930private V doGet(Object key) &#123; if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (ConcurrentSkipListMap.Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; Object v; int c; if (n == null) break outer; ConcurrentSkipListMap.Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) == 0) &#123; @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v; return vv; &#125; if (c &lt; 0) break outer; b = n; n = f; &#125; &#125; return null; &#125; 与put操作第一步相似，首先调用findPredecessor()方法找到前辈节点，然后顺着right一直往右找即可，同时在这个过程中同样承担了一个删除value为null的节点的职责。 remove操作remove操作为删除指定key节点，如下： 123public V remove(Object key) &#123; return doRemove(key, null);&#125; 直接调用doRemove()方法，这里remove有两个参数，一个是key，另外一个是value，所以doRemove方法即提供remove key，也提供同时满足key-value。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162final V doRemove(Object key, Object value) &#123; if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (ConcurrentSkipListMap.Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; Object v; int c; if (n == null) break outer; ConcurrentSkipListMap.Node&lt;K,V&gt; f = n.next; // 不一致读，重新开始 if (n != b.next) // inconsistent read break; // n节点已删除 if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; // b节点已删除 if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) &lt; 0) break outer; // 右移 if (c &gt; 0) &#123; b = n; n = f; continue; &#125; /* * 找到节点 */ // value != null 表示需要同时校验key-value值 if (value != null &amp;&amp; !value.equals(v)) break outer; // CAS替换value if (!n.casValue(v, null)) break; if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // retry via findNode else &#123; // 清理节点 findPredecessor(key, cmp); // clean index // head.right == null表示该层已经没有节点，删掉该层 if (head.right == null) tryReduceLevel(); &#125; @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v; return vv; &#125; &#125; return null; &#125; 调用findPredecessor()方法找到前辈节点，然后通过右移，然后比较，找到后利用CAS把value替换为null，然后判断该节点是不是这层唯一的index，如果是的话，调用tryReduceLevel()方法把这层干掉，完成删除。 其实从这里可以看出，remove方法仅仅是把Node的value设置null，并没有真正删除该节点Node，其实从上面的put操作、get操作我们可以看出，他们在寻找节点的时候都会判断节点的value是否为null，如果为null，则调用unLink()方法取消关联关系，如下： 123456if (n.value == null) &#123; if (!q.unlink(r)) break; // restart r = q.right; // reread r continue;&#125; size操作ConcurrentSkipListMap的size()操作和ConcurrentHashMap不同，它并没有维护一个全局变量来统计元素的个数，所以每次调用该方法的时候都需要去遍历。 12345678public int size() &#123; long count = 0; for (Node&lt;K,V&gt; n = findFirst(); n != null; n = n.next) &#123; if (n.getValidValue() != null) ++count; &#125; return (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;&#125; 调用findFirst()方法找到第一个Node，然后利用node的next去统计。最后返回统计数据，最多能返回Integer.MAX_VALUE。注意这里在线程并发下是安全的。 ConcurrentSkipListMap过程其实不复杂，相比于ConcurrentHashMap而言，是简单的不能再简单了。对跳表SkipList熟悉的话，ConcurrentSkipListMap 应该是盘中餐了。 我们知道线程Thread可以调用setPriority(int newPriority)来设置优先级的，线程优先级高的线程先执行，优先级低的后执行。而前面介绍的ArrayBlockingQueue、LinkedBlockingQueue都是采用FIFO原则来确定线程执行的先后顺序，那么有没有一个队列可以支持优先级呢？ PriorityBlockingQueue 。 PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序升序排序，当然我们也可以通过构造函数来指定Comparator来对元素进行排序。需要注意的是PriorityBlockingQueue不能保证同优先级元素的顺序。 PriorityBlockingQueue二叉堆由于PriorityBlockingQueue底层采用二叉堆来实现的，所以有必要先介绍下二叉堆。 二叉堆是一种特殊的堆，就结构性而言就是完全二叉树或者是近似完全二叉树，满足树结构性和堆序性。树机构特性就是完全二叉树应该有的结构，堆序性则是：父节点的键值总是保持固定的序关系于任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。它有两种表现形式：最大堆、最小堆。 最大堆：父节点的键值总是大于或等于任何一个子节点的键值（下右图） 最小堆：父节点的键值总是小于或等于任何一个子节点的键值（下走图） 二叉堆一般用数组表示，如果父节点的节点位置在n处，那么其左孩子节点为：2 n + 1 ，其右孩子节点为2 (n + 1)，其父节点为（n - 1） / 2 处。上左图的数组表现形式为： 二叉堆的基本结构了解了，下面来看看二叉堆的添加和删除节点。二叉堆的添加和删除相对于二叉树来说会简单很多。 添加元素首先将要添加的元素N插添加到堆的末尾位置（在二叉堆中我们称之为空穴）。如果元素N放入空穴中而不破坏堆的序（其值大于跟父节点值（最大堆是小于父节点）），那么插入完成。否则，我们则将该元素N的节点与其父节点进行交换，然后与其新父节点进行比较直到它的父节点不在比它小（最大堆是大）或者到达根节点。 假如有如下一个二叉堆 这是一个最小堆，其父节点总是小于等于任一一个子节点。现在我们添加一个元素2。 第一步：在末尾添加一个元素2，如下： 第二步：元素2比其父节点6小，进行替换，如下： 第三步：继续与其父节点5比较，小于，替换： 第四步：继续比较其跟节点1，发现跟节点比自己小，则完成，到这里元素2插入完毕。所以整个添加元素过程可以概括为：在元素末尾插入元素，然后不断比较替换直到不能移动为止。 复杂度：Ο(logn) 删除元素删除元素与增加元素一样，需要维护整个二叉堆的序。删除位置1的元素（数组下标0），则把最后一个元素空出来移到最前边，然后和它的两个子节点比较，如果两个子节点中较小的节点小于该节点，就将他们交换，知道两个子节点都比该元素大为止。 就上面二叉堆而言，删除的元素为元素1。 第一步：删掉元素1，元素6空出来，如下： 第二步：与其两个子节点（元素2、元素3）比较，都小，将其中较小的元素（元素2）放入到该空穴中： 第三步：继续比较两个子节点（元素5、元素7），还是都小，则将较小的元素（元素5）放入到该空穴中： 第四步：比较其子节点（元素8），比该节点小，则元素6放入该空穴位置不会影响二叉堆的树结构，放入： 到这里整个删除操作就已经完成了。 二叉堆的添加、删除操作还是比较简单的，很容易就理解了。下面我们就参考该内容来开启PriorityBlockingQueue的源代码研究。 PriorityBlockingQueuePriorityBlockingQueue继承AbstractQueue，实现BlockingQueue接口。 12public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable 定义了一些属性 12345678910111213141516171819202122232425// 默认容量 private static final int DEFAULT_INITIAL_CAPACITY = 11; // 最大容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; // 二叉堆数组 private transient Object[] queue; // 队列元素的个数 private transient int size; // 比较器，如果为空，则为自然顺序 private transient Comparator&lt;? super E&gt; comparator; // 内部锁 private final ReentrantLock lock; private final Condition notEmpty; // private transient volatile int allocationSpinLock; // 优先队列：主要用于序列化，这是为了兼容之前的版本。只有在序列化和反序列化才非空 private PriorityQueue&lt;E&gt; q; 内部仍然采用可重入锁ReentrantLock来实现同步机制，但是这里只有一个notEmpty的Condition，了解了ArrayBlockingQueue我们知道它定义了两个Condition，之类为何只有一个呢？原因就在于PriorityBlockingQueue是一个无界队列，插入总是会成功，除非消耗尽了资源导致服务器挂。 入列PriorityBlockingQueue提供put()、add()、offer()方法向队列中加入元素。我们这里从put()入手：put(E e) ：将指定元素插入此优先级队列。 123public void put(E e) &#123; offer(e); // never need to block&#125; PriorityBlockingQueue是无界的，所以不可能会阻塞。内部调用offer(E e)： 123456789101112131415161718192021222324252627public boolean offer(E e) &#123; // 不能为null if (e == null) throw new NullPointerException(); // 获取锁 final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; // 扩容 while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; // 根据比较器是否为null，做不同的处理 if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; // 唤醒正在等待的消费者线程 notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true; &#125; siftUpComparable当比较器comparator为null时，采用自然排序，调用siftUpComparable方法： 1234567891011121314151617private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; // “上冒”过程 while (k &gt; 0) &#123; // 父级节点 （n - ） / 2 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; // key &gt;= parent 完成（最大堆） if (key.compareTo((T) e) &gt;= 0) break; // key &lt; parant 替换 array[k] = e; k = parent; &#125; array[k] = key; &#125; 这段代码所表示的意思：将元素X插入到数组中，然后进行调整以保持二叉堆的特性。 siftUpUsingComparator当比较器不为null时，采用所指定的比较器，调用siftUpUsingComparator方法： 123456789101112private static &lt;T&gt; void siftUpUsingComparator(int k, T x, Object[] array, Comparator&lt;? super T&gt; cmp) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (cmp.compare(x, (T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = x; &#125; 扩容：tryGrow 12345678910111213141516171819202122232425262728293031323334private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // 扩容操作使用自旋，不需要锁主锁，释放 Object[] newArray = null; // CAS 占用 if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; // 新容量 最小翻倍 int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : (oldCap &gt;&gt; 1)); // 超过 if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; // 最大容量 &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; // 扩容后allocationSpinLock = 0 代表释放了自旋锁 &#125; &#125; // 到这里如果是本线程扩容newArray肯定是不为null，为null就是其他线程在处理扩容，那就让给别的线程处理 if (newArray == null) Thread.yield(); // 主锁获取锁 lock.lock(); // 数组复制 if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; 整个添加元素的过程和上面二叉堆一模一样：先将元素添加到数组末尾，然后采用“上冒”的方式将该元素尽量往上冒。 出列PriorityBlockingQueue提供poll()、remove()方法来执行出对操作。出对的永远都是第一个元素：array[0]。 123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return dequeue(); &#125; finally &#123; lock.unlock(); &#125; &#125; 先获取锁，然后调用dequeue()方法： 12345678910111213141516171819202122private E dequeue() &#123; // 没有元素 返回null int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; // 出对元素 E result = (E) array[0]; // 最后一个元素（也就是插入到空穴中的元素） E x = (E) array[n]; array[n] = null; // 根据比较器释放为null，来执行不同的处理 Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125; &#125; siftDownComparable 如果比较器为null，则调用siftDownComparable来进行自然排序处理： 1234567891011121314151617181920212223242526private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array, int n) &#123; if (n &gt; 0) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x; // 最后一个叶子节点的父节点位置 int half = n &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // 待调整位置左节点位置 Object c = array[child]; //左节点 int right = child + 1; //右节点 //左右节点比较，取较小的 if (right &lt; n &amp;&amp; ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0) c = array[child = right]; //如果待调整key最小，那就退出，直接赋值 if (key.compareTo((T) c) &lt;= 0) break; //如果key不是最小，那就取左右节点小的那个放到调整位置，然后小的那个节点位置开始再继续调整 array[k] = c; k = child; &#125; array[k] = key; &#125; &#125; 处理思路和二叉堆删除节点的逻辑一样：就第一个元素定义为空穴，然后把最后一个元素取出来，尝试插入到空穴位置，并与两个子节点值进行比较，如果不符合，则与其中较小的子节点进行替换，然后继续比较调整。 siftDownUsingComparator 如果指定了比较器，则采用比较器来进行调整： 12345678910111213141516171819private static &lt;T&gt; void siftDownUsingComparator(int k, T x, Object[] array, int n, Comparator&lt;? super T&gt; cmp) &#123; if (n &gt; 0) &#123; int half = n &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = array[child]; int right = child + 1; if (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; 0) c = array[child = right]; if (cmp.compare(x, (T) c) &lt;= 0) break; array[k] = c; k = child; &#125; array[k] = x; &#125;&#125; PriorityBlockingQueue采用二叉堆来维护，所以整个处理过程不是很复杂，添加操作则是不断“上冒”，而删除操作则是不断“下掉”。掌握二叉堆就掌握了PriorityBlockingQueue，无论怎么变还是不离其宗。对于PriorityBlockingQueue需要注意的是他是一个无界队列，所以添加操作是不会失败的，除非资源耗尽。 前面的BlockingQueue都是单向的FIFO队列，而LinkedBlockingDeque则是一个由链表组成的双向阻塞队列，双向队列就意味着可以从对头、对尾两端插入和移除元素，同样意味着LinkedBlockingDeque支持FIFO、FILO两种操作方式。 LinkedBlockingDeque是可选容量的，在初始化时可以设置容量防止其过度膨胀，如果不设置，默认容量大小为Integer.MAX_VALUE。 DelayQueue是一个支持延时获取元素的无界阻塞队列。里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行。也就是说只有在延迟期到时才能够从队列中取元素。 DelayQueue主要用于两个方面：- 缓存：清掉缓存中超时的缓存数据- 任务超时处理 DelayQueueDelayQueue实现的关键主要有如下几个： 可重入锁ReentrantLock 用于阻塞和通知的Condition对象 根据Delay时间排序的优先级队列：PriorityQueue 用于优化阻塞通知的线程元素leader ReentrantLock、Condition这两个对象就不需要阐述了，他是实现整个BlockingQueue的核心。PriorityQueue是一个支持优先级线程排序的队列（参考【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue），leader后面阐述。这里我们先来了解Delay，他是实现延时操作的关键。 DelayedDelayed接口是用来标记那些应该在给定延迟时间之后执行的对象，它定义了一个long getDelay(TimeUnit unit)方法，该方法返回与此对象相关的的剩余时间。同时实现该接口的对象必须定义一个compareTo 方法，该方法提供与此接口的 getDelay 方法一致的排序。 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125; 如何使用该接口呢？上面说的非常清楚了，实现该接口的getDelay()方法，同时定义compareTo()方法即可。 内部结构先看DelayQueue的定义： 123456789101112131415public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; /** 可重入锁 */ private final transient ReentrantLock lock = new ReentrantLock(); /** 支持优先级的BlockingQueue */ private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); /** 用于优化阻塞 */ private Thread leader = null; /** Condition */ private final Condition available = lock.newCondition(); /** * 省略很多代码 */&#125; 看了DelayQueue的内部结构就对上面几个关键点一目了然了，但是这里有一点需要注意，DelayQueue的元素都必须继承Delayed接口。同时也可以从这里初步理清楚DelayQueue内部实现的机制了：以支持优先级无界队列的PriorityQueue作为一个容器，容器里面的元素都应该实现Delayed接口，在每次往优先级队列中添加元素时以元素的过期时间作为排序条件，最先过期的元素放在优先级最高。 offer()1234567891011121314151617public boolean offer(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 向 PriorityQueue中插入元素 q.offer(e); // 如果当前元素的对首元素（优先级最高），leader设置为空，唤醒所有等待线程 if (q.peek() == e) &#123; leader = null; available.signal(); &#125; // 无界队列，永远返回true return true; &#125; finally &#123; lock.unlock(); &#125;&#125; offer(E e)就是往PriorityQueue中添加元素，具体可以参考（【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue）。整个过程还是比较简单，但是在判断当前元素是否为对首元素，如果是的话则设置leader=null，这是非常关键的一个步骤，后面阐述。 take()123456789101112131415161718192021222324252627282930313233343536373839404142public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; // 对首元素 E first = q.peek(); // 对首为空，阻塞，等待off()操作唤醒 if (first == null) available.await(); else &#123; // 获取对首元素的超时时间 long delay = first.getDelay(NANOSECONDS); // &lt;=0 表示已过期，出对，return if (delay &lt;= 0) return q.poll(); first = null; // don&apos;t retain ref while waiting // leader != null 证明有其他线程在操作，阻塞 if (leader != null) available.await(); else &#123; // 否则将leader 设置为当前线程，独占 Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; // 超时阻塞 available.awaitNanos(delay); &#125; finally &#123; // 释放leader if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; // 唤醒阻塞线程 if (leader == null &amp;&amp; q.peek() != null) available.signal(); lock.unlock(); &#125;&#125; 首先是获取对首元素，如果对首元素的延时时间 delay &lt;= 0 ，则可以出对了，直接return即可。否则设置first = null，这里设置为null的主要目的是为了避免内存泄漏。如果 leader != null 则表示当前有线程占用，则阻塞，否则设置leader为当前线程，然后调用awaitNanos()方法超时等待。 first = null 这里为什么如果不设置first = null，则会引起内存泄漏呢？线程A到达，列首元素没有到期，设置leader = 线程A，这是线程B来了因为leader != null，则会阻塞，线程C一样。假如线程阻塞完毕了，获取列首元素成功，出列。这个时候列首元素应该会被回收掉，但是问题是它还被线程B、线程C持有着，所以不会回收，这里只有两个线程，如果有线程D、线程E…呢？这样会无限期的不能回收，就会造成内存泄漏。 这个入队、出对过程和其他的阻塞队列没有很大区别，无非是在出对的时候增加了一个到期时间的判断。同时通过leader来减少不必要阻塞。 LinkedBlockingDequeLinkedBlockingDeque 继承AbstractQueue，实现接口BlockingDeque，而BlockingDeque又继承接口BlockingQueue，BlockingDeque是支持两个附加操作的 Queue，这两个操作是：获取元素时等待双端队列变为非空；存储元素时等待双端队列中的空间变得可用。这两类操作就为LinkedBlockingDeque 的双向操作Queue提供了可能。BlockingDeque接口提供了一系列的以First和Last结尾的方法，如addFirst、addLast、peekFirst、peekLast。 1234567891011121314151617181920212223public class LinkedBlockingDeque&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingDeque&lt;E&gt;, java.io.Serializable &#123; // 双向链表的表头 transient Node&lt;E&gt; first; // 双向链表的表尾 transient Node&lt;E&gt; last; // 大小，双向链表中当前节点个数 private transient int count; // 容量，在创建LinkedBlockingDeque时指定的 private final int capacity; final ReentrantLock lock = new ReentrantLock(); private final Condition notEmpty = lock.newCondition(); private final Condition notFull = lock.newCondition();&#125; 通过上面的Lock可以看出，LinkedBlockingDeque底层实现机制与LinkedBlockingQueue一样，依然是通过互斥锁ReentrantLock 来实现，notEmpty 、notFull 两个Condition做协调生产者、消费者问题。 与其他BlockingQueue一样，节点还是使用内部类Node： 1234567891011static final class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; prev; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125;&#125; 双向嘛，节点肯定得要有前驱prev、后继next咯。 基础方法LinkedBlockingDeque 的add、put、offer、take、peek、poll系列方法都是通过调用XXXFirst，XXXLast方法。所以这里就仅以putFirst、putLast、pollFirst、pollLast分析下。 putFirstputFirst(E e) :将指定的元素插入此双端队列的开头，必要时将一直等待可用空间。 12345678910111213141516public void putFirst(E e) throws InterruptedException &#123; // check null if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); // 获取锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; while (!linkFirst(node)) // 在notFull条件上等待，直到被唤醒或中断 notFull.await(); &#125; finally &#123; // 释放锁 lock.unlock(); &#125;&#125; 先获取锁，然后调用linkFirst方法入列，最后释放锁。如果队列是满的则在notFull上面等待。linkFirst设置Node为对头： 1234567891011121314151617181920212223private boolean linkFirst(Node&lt;E&gt; node) &#123; // 超出容量 if (count &gt;= capacity) return false; // 首节点 Node&lt;E&gt; f = first; // 新节点的next指向原first node.next = f; // 设置node为新的first first = node; // 没有尾节点，设置node为尾节点 if (last == null) last = node; // 有尾节点，那就将之前first的pre指向新增node else f.prev = node; ++count; // 唤醒notEmpty notEmpty.signal(); return true;&#125; linkFirst主要是设置node节点队列的列头节点，成功返回true，如果队列满了返回false。整个过程还是比较简单的。 putLastputLast(E e) :将指定的元素插入此双端队列的末尾，必要时将一直等待可用空间。 123456789101112public void putLast(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; while (!linkLast(node)) notFull.await(); &#125; finally &#123; lock.unlock(); &#125;&#125; 调用linkLast将节点Node链接到队列尾部： 123456789101112131415161718192021private boolean linkLast(Node&lt;E&gt; node) &#123; if (count &gt;= capacity) return false; // 尾节点 Node&lt;E&gt; l = last; // 将Node的前驱指向原本的last node.prev = l; // 将node设置为last last = node; // 首节点为null，则设置node为first if (first == null) first = node; else //非null，说明之前的last有值，就将之前的last的next指向node l.next = node; ++count; notEmpty.signal(); return true;&#125; pollFirstpollFirst()：获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 null。 123456789public E pollFirst() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return unlinkFirst(); &#125; finally &#123; lock.unlock(); &#125;&#125; 调用unlinkFirst移除队列首元素： 1234567891011121314151617181920212223242526272829private E unlinkFirst() &#123; // 首节点 Node&lt;E&gt; f = first; // 空队列，直接返回null if (f == null) return null; // first.next Node&lt;E&gt; n = f.next; // 节点item E item = f.item; // 移除掉first ==&gt; first = first.next f.item = null; f.next = f; // help GC first = n; // 移除后为空队列，仅有一个节点 if (n == null) last = null; else // n的pre原来指向之前的first，现在n变为first了，pre指向null n.prev = null; --count; notFull.signal(); return item;&#125; pollLastpollLast():获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 null。 123456789public E pollLast() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return unlinkLast(); &#125; finally &#123; lock.unlock(); &#125;&#125; 调用unlinkLast移除尾结点，链表空返回null ： 123456789101112131415161718private E unlinkLast() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; l = last; if (l == null) return null; Node&lt;E&gt; p = l.prev; E item = l.item; l.item = null; l.prev = l; // help GC last = p; if (p == null) first = null; else p.next = null; --count; notFull.signal(); return item;&#125; LinkedBlockingDeque大部分方法都是通过linkFirst、linkLast、unlinkFirst、unlinkLast这四个方法来实现的，因为是双向队列，所以他们都是针对first、last的操作，看懂这个整个LinkedBlockingDeque就不难了。 掌握了双向队列的插入、删除操作，LinkedBlockingDeque就没有任何难度可言了，数据结构的重要性啊！！！！ SynchronousQueue数据结构 由于SynchronousQueue的支持公平策略和非公平策略，所以底层可能两种数据结构：队列（实现公平策略）和栈（实现非公平策略），队列与栈都是通过链表来实现的。具体的数据结构如下 说明：数据结构有两种类型，栈和队列；栈有一个头结点，队列有一个头结点和尾结点；栈用于实现非公平策略，队列用于实现公平策略。 SynchronousQueue源码分析 3.1 类的继承关系 12public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;&#125; 说明：SynchronousQueue继承了AbstractQueue抽象类，AbstractQueue定义了对队列的基本操作；同时实现了BlockingQueue接口，BlockingQueue表示阻塞型的队列，其对队列的操作可能会抛出异常；同时也实现了Searializable接口，表示可以被序列化。 3.2 类的内部类 SynchronousQueue的内部类框架图如下 说明：其中比较重要的类是左侧的三个类，Transferer是TransferStack栈和TransferQueue队列的公共类，定义了转移数据的公共操作，由TransferStack和TransferQueue具体实现，WaitQueue、LifoWaitQueue、FifoWaitQueue表示为了兼容JDK1.5版本中的SynchronousQueue的序列化策略所遗留的，这里不做具体的讲解。下面着重看左侧的三个类。 ① Transferer ;) 1234567891011121314151617abstract static class Transferer&lt;E&gt; &#123; /** * Performs a put or take. * * @param e if non-null, the item to be handed to a consumer; * if null, requests that transfer return an item * offered by producer. * @param timed if this operation should timeout * @param nanos the timeout, in nanoseconds * @return if non-null, the item provided or received; if null, * the operation failed due to timeout or interrupt -- * the caller can distinguish which of these occurred * by checking Thread.interrupted. */ // 转移数据，put或者take操作 abstract E transfer(E e, boolean timed, long nanos);&#125; ;) 说明：Transferer定义了transfer操作，用于take或者put数据。transfer方法由子类实现。 ② TransfererStack 1. 类的继承关系 1static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123;&#125; http://www.cnblogs.com/leesf456/p/5560362.html 作为BlockingQueue中的一员，SynchronousQueue与其他BlockingQueue有着不同特性： SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。 因为没有容量，所以对应 peek, contains, clear, isEmpty … 等方法其实是无效的。例如clear是不执行任何操作的，contains始终返回false,peek始终返回null。 SynchronousQueue分为公平和非公平，默认情况下采用非公平性访问策略，当然也可以通过构造函数来设置为公平性访问策略（为true即可）。 若使用 TransferQueue, 则队列中永远会存在一个 dummy node（这点后面详细阐述）。 SynchronousQueue非常适合做交换工作，生产者的线程和消费者的线程同步以传递某些信息、事件或者任务。 与其他BlockingQueue一样，SynchronousQueue同样继承AbstractQueue和实现BlockingQueue接口： 12public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable SynchronousQueue提供了两个构造函数： 123456789public SynchronousQueue() &#123; this(false);&#125;public SynchronousQueue(boolean fair) &#123; // 通过 fair 值来决定公平性和非公平性 // 公平性使用TransferQueue，非公平性采用TransferStack transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125; TransferQueue、TransferStack继承Transferer，Transferer为SynchronousQueue的内部类，它提供了一个方法transfer()，该方法定义了转移数据的规范，如下： 123abstract static class Transferer&lt;E&gt; &#123; abstract E transfer(E e, boolean timed, long nanos);&#125; transfer()方法主要用来完成转移数据的，如果e != null，相当于将一个数据交给消费者，如果e == null，则相当于从一个生产者接收一个消费者交出的数据。 SynchronousQueue采用队列TransferQueue来实现公平性策略，采用堆栈TransferStack来实现非公平性策略，他们两种都是通过链表实现的，其节点分别为QNode，SNode。TransferQueue和TransferStack在SynchronousQueue中扮演着非常重要的作用，SynchronousQueue的put、take操作都是委托这两个类来实现的。 TransferQueueTransferQueue是实现公平性策略的核心类，其节点为QNode，其定义如下： 12345678910111213static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; &#123; /** 头节点 */ transient volatile QNode head; /** 尾节点 */ transient volatile QNode tail; // 指向一个取消的结点 //当一个节点中最后一个插入时，它被取消了但是可能还没有离开队列 transient volatile QNode cleanMe; /** * 省略很多代码O(∩_∩)O */&#125; 在TransferQueue中除了头、尾节点外还存在一个cleanMe节点。该节点主要用于标记，当删除的节点是尾节点时则需要使用该节点。 同时，对于TransferQueue需要注意的是，其队列永远都存在一个dummy node，在构造时创建： 12345TransferQueue() &#123; QNode h = new QNode(null, false); // initialize to dummy node. head = h; tail = h;&#125; 在TransferQueue中定义了QNode类来表示队列中的节点，QNode节点定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static final class QNode &#123; // next 域 volatile QNode next; // item数据项 volatile Object item; // 等待线程，用于park/unpark volatile Thread waiter; // to control park/unpark //模式，表示当前是数据还是请求，只有当匹配的模式相匹配时才会交换 final boolean isData; QNode(Object item, boolean isData) &#123; this.item = item; this.isData = isData; &#125; /** * CAS next域，在TransferQueue中用于向next推进 */ boolean casNext(QNode cmp, QNode val) &#123; return next == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; /** * CAS itme数据项 */ boolean casItem(Object cmp, Object val) &#123; return item == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; /** * 取消本结点，将item域设置为自身 */ void tryCancel(Object cmp) &#123; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this); &#125; /** * 是否被取消 * 与tryCancel相照应只需要判断item释放等于自身即可 */ boolean isCancelled() &#123; return item == this; &#125; boolean isOffList() &#123; return next == this; &#125; private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = QNode.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;item&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 上面代码没啥好看的，需要注意的一点就是isData，该属性在进行数据交换起到关键性作用，两个线程进行数据交换的时候，必须要两者的模式保持一致。 TransferStackTransferStack用于实现非公平性，定义如下： 123456789101112131415static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123; static final int REQUEST = 0; static final int DATA = 1; static final int FULFILLING = 2; volatile SNode head; /** * 省略一堆代码 O(∩_∩)O~ */&#125; TransferStack中定义了三个状态：REQUEST表示消费数据的消费者，DATA表示生产数据的生产者，FULFILLING，表示匹配另一个生产者或消费者。任何线程对TransferStack的操作都属于上述3种状态中的一种（对应着SNode节点的mode）。同时还包含一个head域，表示头结点。 内部节点SNode定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static final class SNode &#123; // next 域 volatile SNode next; // 相匹配的节点 volatile SNode match; // 等待的线程 volatile Thread waiter; // item 域 Object item; // data; or null for REQUESTs // 模型 int mode; /** * item域和mode域不需要使用volatile修饰，因为它们在volatile/atomic操作之前写，之后读 */ SNode(Object item) &#123; this.item = item; &#125; boolean casNext(SNode cmp, SNode val) &#123; return cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; /** * 将s结点与本结点进行匹配，匹配成功，则unpark等待线程 */ boolean tryMatch(SNode s) &#123; if (match == null &amp;&amp; UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123; Thread w = waiter; if (w != null) &#123; // waiters need at most one unpark waiter = null; LockSupport.unpark(w); &#125; return true; &#125; return match == s; &#125; void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this); &#125; boolean isCancelled() &#123; return match == this; &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long matchOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = SNode.class; matchOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;match&quot;)); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 上面简单介绍了TransferQueue、TransferStack，由于SynchronousQueue的put、take操作都是调用Transfer的transfer()方法，只不过是传递的参数不同而已，put传递的是e参数，所以模式为数据（公平isData = true，非公平mode= DATA），而take操作传递的是null，所以模式为请求（公平isData = false，非公平mode = REQUEST），如下： 1234567891011121314151617// put操作public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); if (transferer.transfer(e, false, 0) == null) &#123; Thread.interrupted(); throw new InterruptedException(); &#125;&#125;// take操作public E take() throws InterruptedException &#123; E e = transferer.transfer(null, false, 0); if (e != null) return e; Thread.interrupted(); throw new InterruptedException();&#125; 公平模式公平性调用TransferQueue的transfer方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798E transfer(E e, boolean timed, long nanos) &#123; QNode s = null; // 当前节点模式 boolean isData = (e != null); for (;;) &#123; QNode t = tail; QNode h = head; // 头、尾节点 为null，没有初始化 if (t == null || h == null) continue; // 头尾节点相等（队列为null） 或者当前节点和队列节点模式一样 if (h == t || t.isData == isData) &#123; // tn = t.next QNode tn = t.next; // t != tail表示已有其他线程操作了，修改了tail，重新再来 if (t != tail) continue; // tn != null，表示已经有其他线程添加了节点，tn 推进，重新处理 if (tn != null) &#123; // 当前线程帮忙推进尾节点，就是尝试将tn设置为尾节点 advanceTail(t, tn); continue; &#125; // 调用的方法的 wait 类型的, 并且 超时了, 直接返回 null // timed 在take操作阐述 if (timed &amp;&amp; nanos &lt;= 0) return null; // s == null，构建一个新节点Node if (s == null) s = new QNode(e, isData); // 将新建的节点加入到队列中，如果不成功，继续处理 if (!t.casNext(null, s)) continue; // 替换尾节点 advanceTail(t, s); // 调用awaitFulfill, 若节点是 head.next, 则进行自旋 // 若不是的话, 直接 block, 直到有其他线程 与之匹配, 或它自己进行线程的中断 Object x = awaitFulfill(s, e, timed, nanos); // 若返回的x == s表示，当前线程已经超时或者中断，不然的话s == null或者是匹配的节点 if (x == s) &#123; // 清理节点S clean(t, s); return null; &#125; // isOffList：用于判断节点是否已经从队列中离开了 if (!s.isOffList()) &#123; // 尝试将S节点设置为head，移出t advanceHead(t, s); if (x != null) s.item = s; // 释放线程 ref s.waiter = null; &#125; // 返回 return (x != null) ? (E)x : e; &#125; // 这里是从head.next开始，因为TransferQueue总是会存在一个dummy node节点 else &#123; // 节点 QNode m = h.next; // 不一致读，重新开始 // 有其他线程更改了线程结构 if (t != tail || m == null || h != head) continue; /** * 生产者producer和消费者consumer匹配操作 */ Object x = m.item; // isData == (x != null)：判断isData与x的模式是否相同，相同表示已经匹配了 // x == m ：m节点被取消了 // !m.casItem(x, e)：如果尝试将数据e设置到m上失败 if (isData == (x != null) || x == m || !m.casItem(x, e)) &#123; // 将m设置为头结点，h出列，然后重试 advanceHead(h, m); continue; &#125; // 成功匹配了，m设置为头结点h出列，向前推进 advanceHead(h, m); // 唤醒m上的等待线程 LockSupport.unpark(m.waiter); return (x != null) ? (E)x : e; &#125; &#125;&#125; 整个transfer的算法如下：\1. 如果队列为null或者尾节点模式与当前节点模式一致，则尝试将节点加入到等待队列中（采用自旋的方式），直到被匹配或、超时或者取消。匹配成功的话要么返回null（producer返回的）要么返回真正传递的值（consumer返回的），如果返回的是node节点本身则表示当前线程超时或者取消了。\2. 如果队列不为null，且队列的节点是当前节点匹配的节点，则进行数据的传递匹配并返回匹配节点的数据\3. 在整个过程中都会检测并帮助其他线程推进 当队列为空时，节点入列然后通过调用awaitFulfill()方法自旋，该方法主要用于自旋/阻塞节点，直到节点被匹配返回或者取消、中断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Object awaitFulfill(QNode s, E e, boolean timed, long nanos) &#123; // 超时控制 final long deadline = timed ? System.nanoTime() + nanos : 0L; Thread w = Thread.currentThread(); // 自旋次数 // 如果节点Node恰好是head节点，则自旋一段时间，这里主要是为了效率问题，如果里面阻塞，会存在唤醒、线程上下文切换的问题 // 如果生产者、消费者者里面到来的话，就避免了这个阻塞的过程 int spins = ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0); // 自旋 for (;;) &#123; // 线程中断了，剔除当前节点 if (w.isInterrupted()) s.tryCancel(e); // 如果线程进行了阻塞 -&gt; 唤醒或者中断了，那么x != e 肯定成立，直接返回当前节点即可 Object x = s.item; if (x != e) return x; // 超时判断 if (timed) &#123; nanos = deadline - System.nanoTime(); // 如果超时了，取消节点,continue，在if(x != e)肯定会成立，直接返回x if (nanos &lt;= 0L) &#123; s.tryCancel(e); continue; &#125; &#125; // 自旋- 1 if (spins &gt; 0) --spins; // 等待线程 else if (s.waiter == null) s.waiter = w; // 进行没有超时的 park else if (!timed) LockSupport.park(this); // 自旋次数过了, 直接 + timeout 方式 park else if (nanos &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanos); &#125;&#125; 在自旋/阻塞过程中做了一点优化，就是判断当前节点是否为对头元素，如果是的则先自旋，如果自旋次数过了，则才阻塞，这样做的主要目的就在如果生产者、消费者立马来匹配了则不需要阻塞，因为阻塞、唤醒会消耗资源。在整个自旋的过程中会不断判断是否超时或者中断了，如果中断或者超时了则调用tryCancel()取消该节点。 tryCancel 123void tryCancel(Object cmp) &#123; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);&#125; 取消过程就是将节点的item设置为自身（itemOffset是item的偏移量）。所以在调用awaitFulfill()方法时，如果当前线程被取消、中断、超时了那么返回的值肯定时S，否则返回的则是匹配的节点。如果返回值是节点S，那么if(x == s)必定成立，如下： 12345Object x = awaitFulfill(s, e, timed, nanos);if (x == s) &#123; // wait was cancelled clean(t, s); return null;&#125; 如果返回的x == s成立，则调用clean()方法清理节点S： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void clean(QNode pred, QNode s) &#123; // s.waiter = null; while (pred.next == s) &#123; QNode h = head; QNode hn = h.next; // hn节点被取消了，向前推进 if (hn != null &amp;&amp; hn.isCancelled()) &#123; advanceHead(h, hn); continue; &#125; // 队列为空，直接return null QNode t = tail; if (t == h) return; QNode tn = t.next; // 不一致，说明有其他线程改变了tail节点，重新开始 if (t != tail) continue; // tn != null 推进tail节点，重新开始 if (tn != null) &#123; advanceTail(t, tn); continue; &#125; // s 不是尾节点 移出 if (s != t) &#123; QNode sn = s.next; // 如果s已经被移除退出循环，否则尝试断开s if (sn == s || pred.casNext(s, sn)) return; &#125; // s是尾节点，则有可能会有其他线程在添加新节点，则cleanMe出场 QNode dp = cleanMe; // 如果dp不为null，说明是前一个被取消节点，将其移除 if (dp != null) &#123; QNode d = dp.next; QNode dn; if (d == null || // 节点d已经删除 d == dp || // 原来的节点 cleanMe 已经通过 advanceHead 进行删除 !d.isCancelled() || // 原来的节点 s已经删除 (d != t &amp;&amp; // d 不是tail节点 (dn = d.next) != null &amp;&amp; // dn != d &amp;&amp; // that is on list dp.casNext(d, dn))) // d unspliced // 清除 cleanMe 节点, 这里的 dp == pred 若成立, 说明清除节点s，成功, 直接return, 不然的话要再次循环 casCleanMe(dp, null); if (dp == pred) return; &#125; else if (casCleanMe(null, pred)) // 原来的 cleanMe 是 null, 则将 pred 标记为 cleamMe 为下次 清除 s 节点做标识 return; &#125;&#125; 这个clean()方法感觉有点儿难度，我也看得不是很懂。这里是引用http://www.jianshu.com/p/95cb570c8187 删除的节点不是queue尾节点, 这时 直接 pred.casNext(s, s.next) 方式来进行删除(和ConcurrentLikedQueue中差不多) 删除的节点是队尾节点 此时 cleanMe == null, 则 前继节点pred标记为 cleanMe, 为下次删除做准备 此时 cleanMe != null, 先删除上次需要删除的节点, 然后将 cleanMe至null, 让后再将 pred 赋值给 cleanMe 非公平模式非公平模式transfer方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394E transfer(E e, boolean timed, long nanos) &#123; SNode s = null; // constructed/reused as needed int mode = (e == null) ? REQUEST : DATA; for (;;) &#123; SNode h = head; // 栈为空或者当前节点模式与头节点模式一样，将节点压入栈内，等待匹配 if (h == null || h.mode == mode) &#123; // 超时 if (timed &amp;&amp; nanos &lt;= 0) &#123; // 节点被取消了，向前推进 if (h != null &amp;&amp; h.isCancelled()) // 重新设置头结点（弹出之前的头结点） casHead(h, h.next); else return null; &#125; // 不超时 // 生成一个SNode节点，并尝试替换掉头节点head (head -&gt; s) else if (casHead(h, s = snode(s, e, h, mode))) &#123; // 自旋，等待线程匹配 SNode m = awaitFulfill(s, timed, nanos); // 返回的m == s 表示该节点被取消了或者超时、中断了 if (m == s) &#123; // 清理节点S，return null clean(s); return null; &#125; // 因为通过前面一步将S替换成了head，如果h.next == s ，则表示有其他节点插入到S前面了,变成了head // 且该节点就是与节点S匹配的节点 if ((h = head) != null &amp;&amp; h.next == s) // 将s.next节点设置为head，相当于取消节点h、s casHead(h, s.next); // 如果是请求则返回匹配的域，否则返回节点S的域 return (E) ((mode == REQUEST) ? m.item : s.item); &#125; &#125; // 如果栈不为null，且两者模式不匹配（h != null &amp;&amp; h.mode != mode） // 说明他们是一队对等匹配的节点，尝试用当前节点s来满足h节点 else if (!isFulfilling(h.mode)) &#123; // head 节点已经取消了，向前推进 if (h.isCancelled()) casHead(h, h.next); // 尝试将当前节点打上&quot;正在匹配&quot;的标记，并设置为head else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123; // 循环loop for (;;) &#123; // s为当前节点，m是s的next节点， // m节点是s节点的匹配节点 SNode m = s.next; // m == null，其他节点把m节点匹配走了 if (m == null) &#123; // 将s弹出 casHead(s, null); // 将s置空，下轮循环的时候还会新建 s = null; // 退出该循环，继续主循环 break; &#125; // 获取m的next节点 SNode mn = m.next; // 尝试匹配 if (m.tryMatch(s)) &#123; // 匹配成功，将s 、 m弹出 casHead(s, mn); // pop both s and m return (E) ((mode == REQUEST) ? m.item : s.item); &#125; else // 如果没有匹配成功，说明有其他线程已经匹配了，把m移出 s.casNext(m, mn); &#125; &#125; &#125; // 到这最后一步说明节点正在匹配阶段 else &#123; // head 的next的节点，是正在匹配的节点，m 和 h配对 SNode m = h.next; // m == null 其他线程把m节点抢走了，弹出h节点 if (m == null) casHead(h, null); else &#123; SNode mn = m.next; if (m.tryMatch(h)) casHead(h, mn); else h.casNext(m, mn); &#125; &#125; &#125;&#125; 整个处理过程分为三种情况，具体如下：\1. 如果当前栈为空获取节点模式与栈顶模式一样，则尝试将节点加入栈内，同时通过自旋方式等待节点匹配，最后返回匹配的节点或者null（被取消）\2. 如果栈不为空且节点的模式与首节点模式匹配，则尝试将该节点打上FULFILLING标记，然后加入栈中，与相应的节点匹配，成功后将这两个节点弹出栈并返回匹配节点的数据\3. 如果有节点在匹配，那么帮助这个节点完成匹配和出栈操作，然后在主循环中继续执行 当节点加入栈内后，通过调用awaitFulfill()方法自旋等待节点匹配： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123; // 超时 final long deadline = timed ? System.nanoTime() + nanos : 0L; // 当前线程 Thread w = Thread.currentThread(); // 自旋次数 // shouldSpin 用于检测当前节点是否需要自旋 // 如果栈为空、该节点是首节点或者该节点是匹配节点，则先采用自旋，否则阻塞 int spins = (shouldSpin(s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0); for (;;) &#123; // 线程中断了，取消该节点 if (w.isInterrupted()) s.tryCancel(); // 匹配节点 SNode m = s.match; // 如果匹配节点m不为空，则表示匹配成功，直接返回 if (m != null) return m; // 超时 if (timed) &#123; nanos = deadline - System.nanoTime(); // 节点超时，取消 if (nanos &lt;= 0L) &#123; s.tryCancel(); continue; &#125; &#125; // 自旋;每次自旋的时候都需要检查自身是否满足自旋条件，满足就 - 1，否则为0 if (spins &gt; 0) spins = shouldSpin(s) ? (spins-1) : 0; // 第一次阻塞时，会将当前线程设置到s上 else if (s.waiter == null) s.waiter = w; // 阻塞 当前线程 else if (!timed) LockSupport.park(this); // 超时 else if (nanos &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanos); &#125;&#125; awaitFulfill()方法会一直自旋/阻塞直到匹配节点。在S节点阻塞之前会先调用shouldSpin()方法判断是否采用自旋方式，为的就是如果有生产者或者消费者马上到来，就不需要阻塞了，在多核条件下这种优化是有必要的。同时在调用park()阻塞之前会将当前线程设置到S节点的waiter上。匹配成功，返回匹配节点m。 shouldSpin()方法如下： 1234boolean shouldSpin(SNode s) &#123; SNode h = head; return (h == s || h == null || isFulfilling(h.mode));&#125; 同时在阻塞过程中会一直检测当前线程是否中断了，如果中断了，则调用tryCancel()方法取消该节点，取消过程就是将当前节点的math设置为当前节点。所以如果线程中断了，那么在返回m时一定是S节点自身。 123void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this);&#125; awaitFullfill()方法如果返回的m == s，则表示当前节点已经中断取消了，则需要调用clean()方法，清理节点S： 123456789101112131415161718192021222324252627void clean(SNode s) &#123; // 清理item域 s.item = null; // 清理waiter域 s.waiter = null; // past节点 SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; // 从栈顶head节点，取消从栈顶head到past节点之间所有已经取消的节点 // 注意：这里如果遇到一个节点没有取消，则会退出while SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // 如果p节点已经取消了，则剔除该节点 // 如果经历上面while p节点还没有取消，则再次循环取消掉所有p 到past之间的取消节点 while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125; clean()方法就是将head节点到S节点之间所有已经取消的节点全部移出。【不清楚为何要用两个while，一个不行么】 ArrayBlockingQueueArrayBlockingQueue，一个由数组实现的有界阻塞队列。该队列采用FIFO的原则对元素进行排序添加的。 ArrayBlockingQueue为有界且固定，其大小在构造时由构造函数来决定，确认之后就不能再改变了。ArrayBlockingQueue支持对等待的生产者线程和使用者线程进行排序的可选公平策略，但是在默认情况下不保证线程公平的访问，在构造时可以选择公平策略（fair = true）。公平性通常会降低吞吐量，但是减少了可变性和避免了“不平衡性”。 ArrayBlockingQueue先看ArrayBlockingQueue的定义： 1234567891011121314public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable &#123; private static final long serialVersionUID = -817911632652898426L; final Object[] items; int takeIndex; int putIndex; int count; // 重入锁 final ReentrantLock lock; // notEmpty condition private final Condition notEmpty; // notFull condition private final Condition notFull; transient ArrayBlockingQueue.Itrs itrs;&#125; 可以清楚地看到ArrayBlockingQueue继承AbstractQueue，实现BlockingQueue接口。看过java.util包源码的同学应该都认识AbstractQueue，改类在Queue接口中扮演着非常重要的作用，该类提供了对queue操作的骨干实现（具体内容移驾其源码）。BlockingQueue继承java.util.Queue为阻塞队列的核心接口，提供了在多线程环境下的出列、入列操作，作为使用者，则不需要关心队列在什么时候阻塞线程，什么时候唤醒线程，所有一切均由BlockingQueue来完成。 ArrayBlockingQueue内部使用可重入锁ReentrantLock + Condition来完成多线程环境的并发操作。 items，一个定长数组，维护ArrayBlockingQueue的元素 takeIndex，int，为ArrayBlockingQueue对首位置 putIndex，int，ArrayBlockingQueue对尾位置 count，元素个数 lock，锁，ArrayBlockingQueue出列入列都必须获取该锁，两个步骤公用一个锁 notEmpty，出列条件 notFull，入列条件 入队ArrayBlockingQueue提供了诸多方法，可以将元素加入队列尾部。 add(E e) ：将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException offer(E e) :将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false offer(E e, long timeout, TimeUnit unit) :将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间 put(E e) :将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间 方法较多，我们就分析一个方法：add(E e)： 12345678910public boolean add(E e) &#123; return super.add(e);&#125; public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException(&quot;Queue full&quot;);&#125; add方法调用offer(E e)，如果返回false，则直接抛出IllegalStateException异常。offer(E e)为ArrayBlockingQueue实现： 123456789101112131415public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 方法首先检查是否为null，然后获取lock锁。获取锁成功后，如果队列已满则直接返回false，否则调用enqueue(E e)，enqueue(E e)为入列的核心方法，所有入列的方法最终都将调用该方法在队列尾部插入元素： 12345678910private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; 该方法就是在putIndex（对尾）为知处添加元素，最后使用notEmpty的signal()方法通知阻塞在出列的线程（如果队列为空，则进行出列操作是会阻塞）。 出队ArrayBlockingQueue提供的出队方法如下： poll() :获取并移除此队列的头，如果此队列为空，则返回 null poll(long timeout, TimeUnit unit) :获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要） remove(Object o) :从此队列中移除指定元素的单个实例（如果存在） take() :获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要） poll() 123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; 如果队列为空返回null，否则调用dequeue()获取列头元素： 123456789101112private E dequeue() &#123; final Object[] items = this.items; E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return x; &#125; 该方法主要是从列头（takeIndex 位置）取出元素，同时如果迭代器itrs不为null，则需要维护下该迭代器。最后调用notFull.signal()唤醒入列线程。 take() 1234567891011public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; take()与poll()存在一个区别就是count == 0 时的处理，poll()直接返回null，而take()则是在notEmpty上面等待直到被入列的线程唤醒。 ConcurrentLinkedQueueConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。上一篇文章介绍了JDK java.util.concurrent包下很重要的一个类：ConcurrentHashMap，今天来看下另一个重要的类——ConcurrentLinkedQueue。在多线程编程环境下并发安全队列是不可或缺的一个重要工具类，为了实现并发安全可以有两种方式：一种是阻塞式的，例如：LinkedBlockingQueue；另一种即是我们将要探讨的非阻塞式，例如：ConcurrentLinkedQueue。相比较于阻塞式，非阻塞的最显著的优点就是性能，非阻塞式算法使用CAS来原子性的更新数据，避免了加锁的时间，同时也保证了数据的一致性。 简单介绍ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。 结构预览首先看看结构图： 图1：ConcurrentLinkedQueue结构图：从图中可以看到ConcurrentLinkedQueue中包含两个内部类：Node和Itr。Node用来表示ConcurrentLinkedQueue链表中的一个节点，通过Node的next字段指向下一个节点，从而形成一个链表结构；Itr实现Iterator接口，用来遍历ConcurrentLinkedQueue。ConcurrentLinkedQueue中的方法不多，其中最主要的两个方法是：offer(E)和poll()，分别实现队列的两个重要的操作：入队和出队。 方法 含义 offer(E) 插入一个元素到队列尾部 poll() 从队列头部取出一个元素 add(E) 同offer(E) peek() 获取头部元素，但不删除 isEmpty() 判断队列是否为空 size() 获取队列长度(元素个数) contains(Object) 判断队列是否包含指定元素 remove(Object) 删除队列中指定元素 toArray(T[]) 将队列的元素复制到一个数组 iterator() 返回一个可遍历该队列的迭代器 下面会着重分析offer(E)和poll()两个方法，同时会讲解remove(Object)和iterator()方法。 常用方法解读入队——offer首先看看入队操作，由于是无阻塞的队列，所以整个入队操作是在无锁模式下进行的，下面来分析下JDK到底是如何实现无锁并保证安全性的。 123456789101112131415161718192021222324/** * Inserts the specified element at the tail of this queue. * * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Queue#offer&#125;) * @throws NullPointerException if the specified element is null */public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); Node&lt;E&gt; n = new Node&lt;E&gt;(e, null); for (;;) &#123;//① Node&lt;E&gt; t = tail;//② Node&lt;E&gt; s = t.getNext();//② if (t == tail) &#123;//③ if (s == null) &#123;//④ if (t.casNext(s, n)) &#123;//⑥ casTail(t, n);//⑦ return true; &#125; &#125; else &#123; casTail(t, s);//⑤ &#125; &#125; &#125;&#125; 代码不长，但是思路还是很巧妙的，下面我们逐句深入分析每一行代码。if (e == null) throw new NullPointerException(); Node n = new Node(e, null);检查NULL，避免NullPointerException，然后创建一个Node，该Node的item为传入的参数e，next为NULL。for (;;) {}接着是一个死循环，死循环保证该入队操作能够一直重试直至入队成功。Node t = tail; Node s = t.getNext();使用局部变量t引用tail节点，同时获取tail节点的next节点，赋予变量s。if (t == tail) {}只有在t==tail的情况下才会执行入队操作，否则进行下一轮循环，直到t==tail，因为是无锁模式，所以如果同时有多个线程在执行入队操作，那么在一个线程读取了tail之后，很可能会有其他线程已经修改了tail（此处的修改是指将tail指向另一个节点，所以t还引用着原来的节点，导致t!=tail，而并非是修改了tail所指向的节点的值），此处的判断避免了一开始的错误，但是并不能保证后续的执行过程中不会插入其他线程的操作，其实ConcurrentLinkedQueue的设计使得if内的代码即使在有其他线程插入的情况下依旧能够很好地执行，下面我们接着分析。 if (s == null) {} else { casTail(t, s); }这里判断s（tail的next是否为NULL），如果不为NULL，则直接将tail指向s。这里需要说明一下：由于tail指向的是队列的尾部，所以tail的next应该始终是NULL，那么当发生tail的next不为NULL，则说明当前队列处于不一致状态，这时当前线程需要帮助队列进入一致性状态，这就是ConcurrentLinkedQueue设计的巧妙之处！那么如果帮助队列进入一致性状态呢？这个问题我们先留着，继续看什么情况下会导致队列进入不一致状态！ 1234if (t.casNext(s, n)) &#123; casTail(t, n); return true;&#125; 这几句代码完成了入队的操作，第一步CAS的设置t（指向tail）的next为n（新创建的节点），该更新操作能够完成的前提是t的next值==s，即tail的next值在该线程首次读取期间并未发生变化。此处的CAS操作保证了tail的next值更新的原子性，所以不会出现不一致情况。当成功更新了tail的next节点之后，接下来就是原子性的更新tail为n，此处如果更新成功，则入队顺利完成完成，但是奇怪的是如果此处更新失败，入队依旧是成功的！为什么呢？看下文。 我们试想如果一个线程成功的原子性更新了tail的next值为新创建的节点，由于Node的next是volatile修饰的，所以会立即被之后的所有线程可见，那么就会出现tail未变化但是tail的next已经不是NULL了，此时就会出现上面提到的tail的next不为NULL的情况了，现在我们再来看看上面是如何处理这种情况的，casTail(t, s);，从这句可以看出当一个线程看到tail的next不为NULL时就会直接将tail更新成s（tail的next所指向的节点），即将tail指向其next节点，当然这里的更新也是CAS保证的原子性更新。为什么敢这么大胆，正是因为如果当前线程（T1）看到tail的next不为NULL，那么必然是有一个线程（T2）处于入队操作中，且成功执行了t.casNext(s, n)（将新创建的节点赋到tail的next上），正准备执行casTail(t, n);（将tail执行其next指向的节点），那么T1直接将T2准备做的工作完成，然后再进入循环重新进行入队操作，而T2也不在乎自己这一步是否顺利完成，反正只要有人完成了就行，所以T2就直接返回入队成功，最终T1帮助T2顺利完成了入队操作，并且全程无锁，此设计真的是巧妙啊~~~ 下面我们使用流程图形象的描绘下入队过程，整个入队方法被划分成7步（见上面的代码中的注释）。说明：虽然入队是在无锁模式下进行，但是由于使用CAS进行原子性更新，所以很多地方其实还是实现了线程安全的，除了⑥-&gt;⑦，下面的图描绘的也正是⑥-&gt;⑦这一步可能出现的冲突情况。 图2：ConcurrentLinkedQueue入队流程图： 上面介绍了ConcurrentLinkedQueue是如何实现无锁入队的，但是我们只说明了多个线程同时入队操作是线程安全的，但是如果多个线程同时进行入队和出队，以及删除操作呢？这个问题在下面分析另外两个方法时会提到，同时最后也会进行一个总结，下面我们先看看删除操作是如何实现的。 删除——remove先介绍删除，是因为出队操作有个地方需要在这里提前介绍下。 1234567891011public boolean remove(Object o) &#123; if (o == null) return false;// ① for (Node&lt;E&gt; p = first(); p != null; p = p.getNext()) &#123;// ② E item = p.getItem();// ③ if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null))// ④ return true; &#125; return false;&#125; 源码中的注释申明了remove方法会使用equals()判断两个节点的值与待删除的值是否相同，同时如果队列有多个与待删除值相同的节点则只删除最前面的一个节点。 同样remove()方法也是无锁模式，①判断是否为NULL，②从队列头部开始查找，③获取每个节点的item值，用于跟o进行equals比较，前面三步都很平常，重点在④，if (item != null &amp;&amp; o.equals(item) &amp;&amp; p.casItem(item, null))这里首先判断item不为NULL，然后判断item与o相等，前面两个都满足的话，那说明已经查找到一个节点的值与待删除的值一样，后面就是删除该节点，这里删除其实并非真的删除，而只是原子性的将节点的item值设置为NULL。从上面的分析可以看出ConcurrentLinkedQueue的删除只是将队列中的某个节点值置为NULL，由于Node的item是volatile的，所以不存在线程安全问题，同时由于remove并未修改队列的结构，所以多个线程同时进行remove，或者同其他方法一起进行也不会发生线程安全性问题。 出队——poll出队从逻辑上来说就是从队列的头部往外取出数据并删除，下面看看ConcurrentLinkedQueue是如何实现无锁出队的。 12345678910111213141516171819202122public E poll() &#123; for (;;) &#123;// ① Node&lt;E&gt; h = head;// ② Node&lt;E&gt; t = tail;// ② Node&lt;E&gt; first = h.getNext();// ② if (h == head) &#123;// ③ if (h == t) &#123;// ④ if (first == null)// ⑤ return null; else casTail(t, first);// ⑥ &#125; else if (casHead(h, first)) &#123;// ⑦ E item = first.getItem();// ⑧ if (item != null) &#123;// ⑨ first.setItem(null);// ⑩ return item; &#125; // else skip over deleted item, continue loop, &#125; &#125; &#125;&#125; 出队的步骤略多些，不过理解了也就很简单了。首先①是一个死循环；②的三步分别是获取head/tail/head.next三个节点；③判断h==head，避免操作过程中已有其他线程移动了head；④判断head是否等于tail，即队列是否为NULL，说到这里我们先来看看head和tail在队列中到底处于什么位置。我们用一个队列入队出队的时序图来描绘下在入队和出队过程中head和tail到底是如何变化的。 图3：ConcurrentLinkedQueue队列时序图：从图中我们可以看出head的next指向的是队列的第一个元素，我们出队也是将head的next指向的元素出队，同时head==tail说明队列已经没有元素了。明白了这两点我们再接着④分析，如果④这里为真，说明队列已经为NULL，接着⑤判断f（head的next指向的节点）是否为NULL，不为NULL则执行⑥将tail指向f，到这里如果理解了上面入队操作，那么应该是可以理解这一步的用意的——帮助其他线程执行入队操作，跟入队时的⑤是一样的，因为head==tail，head的next不为NULL，则说明tail的next不为NULL，所以要将tail重新指向他的next，帮助正在执行入队的线程完成入队工作。理解了这一步那么出队操作就已经理解了一大半了，下面继续看⑦⑧⑨⑩。 如果head!=tail，则队列不为NULL，那么直接将head指向下一个节点，将当前节点踢出队列即可，当然需要CAS保证原子性更新，然后将踢出队列的节点的item取出返回，并置为NULL即完成了出队操作。这里需要注意的是如果被踢出队列的节点的item是NULL，说明该节点已经被删除了（因为remove()方法只是将节点的item设置为NULL，而不将节点踢出队列），那就只能再次循环了。再提一点，为什么⑦⑧⑨⑩能够被线程安全的执行，因为在⑦这一步是原子更新的，而且更新之后这个节点就立即不会被其他任何线程访问到了，所以后面⑧⑨⑩想怎么处理都是安全的。 到这里出队操作应该很清楚了，下面就来综合分析下为什么针对ConcurrentLinkedQueue的整个入队/出队/删除都是不需要锁的。 上面已经分析了如果多个线程同时访问其中任一个方法（offer/poll/remove）都是无需加锁而且线程安全的 由于remove方法不修改ConcurrentLinkedQueue的结构，所以跟其他两个方法都不会有冲突 如果同时两个线程，一个入队，一个出队，在队列不为NULL的情况下是不是有任何问题的，因为一个操作tail，一个操作head，完全不相关。但是如果队列为NULL时还是会发生冲突的，因为tail==head。这里我们在分析出队时也提到了，如果出队线程发现tail的next不为NULL，那么就会感知到当前有一个线程在执行入队操作，所以出队线程就会帮助入队线程完成入队操作，而且每个操作都是通过CAS保证原子性更新，所以就算同时两个线程，一个入队，一个出队也不会发生冲突。 综上，ConcurrentLinkedQueue最终实现了无锁队列。 使用场景ConcurrentLinkedQueue适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。下面我们来简单对比下ConcurrentLinkedQueue与我们常用的阻塞队列LinkedBlockingQueue的性能。表1：入队性能对比 线程数 ConcurrentLinkedQueue耗时(ms) LinkedBlockingQueue耗时(ms) 5 22 29 10 50 59 20 99 112 30 139 171 测试数据：N个线程，每个线程入队10000个元素。 参考： http://vickyqi.com/2015/10/29/JDK%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94ConcurrentLinkedQueue/ http://cmsblogs.com/?p=2611 SetHashSetLinkedHashSetTreeSetConcurrentSkipListSetCopyOnWriteArraySet 参考Reference:https://github.com/CarpenterLee/JCFInternalshttp://calvin1978.blogcn.com/articles/collection.htmlhttp://wiki.jikexueyuan.com/project/java-collection/hashmap.htmlhttp://wiki.jikexueyuan.com/project/java-enhancement/java-twentytwo.htmlhttps://zhuanlan.zhihu.com/p/32997606https://blog.csdn.net/qq_34448345/article/details/79835190https://essviv.github.io/2017/01/25/%E9%9B%86%E5%90%88/java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8BQueue%E7%9A%84%E5%AE%9E%E7%8E%B05/http://welkinbai.coding.me/2017/06/15/jdk-collection/#%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84https://blog.csdn.net/u010887744/article/category/6126950AC java concurrenthttps://blog.csdn.net/qq_34448345/article/details/80087738http://wiki.jikexueyuan.com/project/java-memory-model/basic.htmlhttp://wiki.jikexueyuan.com/project/java-concurrent/introduction.htmlhttp://wiki.jikexueyuan.com/project/java-concurrency/concurrency-multithreading.htmlhttps://blog.csdn.net/column/details/wenniuwuren-jdk.html]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>源码</tag>
        <tag>collections</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 后台线程]]></title>
    <url>%2Fposts%2Fandroid_app_thread_bg_sum.html</url>
    <content type="text"><![CDATA[Android线程的几种方式AsyncTask/HandlerThread/Thread/IntentServicehttps://www.jianshu.com/p/34cffd700f75 AsyncTask单个线程的线程池，一个一个执行，会阻塞后边线程。可以设置 AsyncTask.executeOnExecutor()来同时执行任务。写的时候注意避免内存泄露 HandlerThread实质是一个Thread，不过添加了Looper和MessageQueue，这样就可以使用Handler来进行控制代码执行了。1234567891011121314151617181920212223242526272829303132333435// 创建一个线程，线程名字 : handlerThreadTest mHandlerThread = new HandlerThread(&quot;handlerThreadTest&quot;); mHandlerThread.start(); // Handler 接收消息 final Handler mHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; Log.e(&quot;Test&quot;, &quot;收到 &quot; + msg.obj.toString() + &quot; 在 &quot; + Thread.currentThread().getName()); &#125; &#125;; mTextView = (TextView) findViewById(R.id.text_view); // 主线程发出消息 mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Message msg = new Message(); msg.obj = &quot;第一条信息&quot;; mHandler.sendMessage(msg); Log.e(&quot;Test&quot;, &quot;发出 &quot; + msg.obj.toString() + &quot; 在 &quot; + Thread.currentThread().getName()); &#125; &#125;); // 子线程发出消息 new Thread(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.obj = &quot;第二条信息&quot;; mHandler.sendMessage(msg); Log.e(&quot;Test&quot;, &quot;发出 &quot; + msg.obj.toString() + &quot; 在 &quot; + Thread.currentThread().getName()); &#125; &#125;).start()； 但是最后不要忘记mHandlerThread.quit();否则将一直循环。另外可以在run方法里设置不同优先级android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);同样HandlerThread的构造方法也提供了设置优先级的功能，new HandlerThread(“LightTaskThread”, Process.THREAD_PRIORITY_BACKGROUND);AsyncTask同样设置了优先级THREAD_PRIORITY_BACKGROUND。HandlerThread的默认优先级是Process.THREAD_PRIORITY_DEFAULT,具体值为0。线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。 IntentService使用了HandlerThread使得IntentService可以运行耗时任务，一般使用时结合主线程Handler或者LocalBroadCastManager来通知主界面UI的更新。 ThreadPool线程池线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。2） CachedThreadPool 和ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。 https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/ ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class ThreadPoolTest &#123; private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int BLOCK_POOL_SIZE = 2; private static final int ALIVE_POOL_SIZE = 2; private static ThreadPoolExecutor executor; public static void main(String args[]) &#123; executor = new ThreadPoolExecutor( CORE_POOL_SIZE,// 核心线程数 最小 MAX_POOL_SIZE,// 最大执行线程数 ALIVE_POOL_SIZE,// 空闲线程超时 TimeUnit.SECONDS,// 超时时间单位 // 当线程池达到corePoolSize时，新提交任务将被放入workQueue中， // 等待线程池中任务调度执行 new ArrayBlockingQueue&lt;Runnable&gt;(BLOCK_POOL_SIZE),// 阻塞队列大小 // 线程工厂，为线程池提供创建新线程的功能，它是一个接口， // 只有一个方法：Thread newThread(Runnable r) Executors.defaultThreadFactory(), // 线程池对拒绝任务的处理策略。一般是队列已满或者无法成功执行任务， // 这时ThreadPoolExecutor会调用handler的rejectedExecution // 方法来通知调用者 new ThreadPoolExecutor.AbortPolicy() ); executor.allowCoreThreadTimeOut(true); /* * ThreadPoolExecutor默认有四个拒绝策略： * * 1、ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException * 2、ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行 * 3、ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务 * 4、ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务 */ for (int i = 0; i &lt; 10; i++) &#123; try &#123; executor.execute(new WorkerThread(&quot;线程 --&gt; &quot; + i)); LOG(); &#125; catch (Exception e) &#123; System.out.println(&quot;AbortPolicy...&quot;); &#125; &#125; executor.shutdown(); // 所有任务执行完毕后再次打印日志 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); System.out.println(&quot;\n\n---------执行完毕---------\n&quot;); LOG(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; /** * 打印 Log 信息 */ private static void LOG() &#123; System.out.println(&quot; ==============线程池===============\n&quot; + &quot; 线程池中线程数 : &quot; + executor.getPoolSize() + &quot; 等待执行线程数 : &quot; + executor.getQueue().size() + &quot; 所有的任务数 : &quot; + executor.getTaskCount() + &quot; 执行任务的线程数 : &quot; + executor.getActiveCount() + &quot; 执行完毕的任务数 : &quot; + executor.getCompletedTaskCount() ); &#125; // 模拟线程任务 public static class WorkerThread implements Runnable &#123; private String threadName; public WorkerThread(String threadName) &#123; this.threadName = threadName; &#125; @Override public synchronized void run() &#123; int i = 0; boolean flag = true; try &#123; while (flag) &#123; i++; if (i &gt; 2) flag = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public String getThreadName() &#123; return threadName; &#125; &#125;&#125; 请解释下在单线程模型中Message,Handler,Message Queue,Looper之间的关系。拿主线程来说，主线程启动时会调用Looper.prepare()方法，会初始化一个Looper，放入Threadlocal中，接着调用Looper.loop()不断遍历Message Queue，Handler的创建依赖与当前线程中的Looper，如果当前线程没有Looper则必须调用Looper.prepare()。Handler , sendMessage到MessageQueue，Looper不断从MessageQueue中取出消息，回调handleMessage方法。 Looper Message Queue 和 Handler， HandlerThread源码https://blog.csdn.net/lovedren/article/details/51701477https://blog.csdn.net/charles674611395/article/details/51914659 Android的进程间通信，Liunx操作系统的进程间通信binder(所有android上层几乎都是binder)/socket(zygote-systemserver)Linux机制： 管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制handler线程之间通信 asynctask的原理AsyncTask是对Thread和Handler的组合包装。https://blog.csdn.net/iispring/article/details/50670388https://blog.csdn.net/epubit17/article/details/80342004 Alarm机制Timer TimerTaskhttp://coderlin.coding.me/2016/04/02/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BTimmer-AlarmManager-JobSchedule/&gt; JobSchedulerhttp://blog.csdn.net/bboyfeiyu/article/details/44809395 ELAPSED_REALTIME_WAKEUP和RTC_WAKEUP的区别AlarmManager.ELAPSED_REALTIME_WAKEUP type is used to trigger the alarm since boot time:alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, 600000, pendingIntent);will actually make the alarm go off 10 min after the device boots.There is a timer that starts running when the device boots up to measure the uptime of the device and this is the type that triggers your alarm according to the uptime of the device.Whereas, AlarmManager.RTC_WAKEUP will trigger the alarm according to the time of the clock. For example if you do:long thirtySecondsFromNow = System.currentTimeMillis() + 30 * 1000;alarmManager.set(AlarmManager.RTC_WAKEUP, thirtySecondsFromNow , pendingIntent);this, on the other hand, will trigger the alarm 30 seconds from now.AlarmManager.ELAPSED_REALTIME_WAKEUP type is rarely used compared to AlarmManager.RTC_WAKEUP 来自 http://stackoverflow.com/questions/5938213/android-alarmmanager-rtc-wakeup-vs-elapsed-realtime-wakeup handler和timer的延迟对比Handler vs Timer在我们Android开发过程中，经常需要执行一些短周期的定时任务，这时候有两个选择Timer或者Handler。然而个人认为：Handler在多个方面比Timer更为优秀，更推荐使用。一.易用性 可重复执行 • Handler可以重复执行某个任务。 • Timer若在某个任务执行/取消之后，再次执行则会抛出一个IllegalStateException异常。为了避免这个异常，需要重新创建一个Timer对象。 周期可调整若想要执行一个越来越快的定时任务，Handler可以做到，而Timer则消耗较大。 • Handlerprivate Handler handler = new Handler();int mDelayTime = 1000;private Runnable runnable = new Runnable() {public void run() { update(); if （mDelayTime &gt; 0） {handler.postDelayed(this,mDelayTime); mDelayTime -= 100; }}};handler.postDelayed(runnable,1000);如以上例子，就可以实现对周期的动态调整。 • Timer的scheduleAtFixedRate(TimerTask task, long delay, long period)只能执行固定周期的任务，所以不可以动态地调整周期。若想要动态调整，则需要在执行玩一个定时器任务后，再启动一个新的任务时设置新的时间。 UI界面更新 • Handler：在创建的时候可以指定所在的线程，一般在Activity中构建的，即主线程上，所以可以在回调方法中很方便的更新界面。 • Timer：异步回调，所以必须借助Handler去更新界面，不方便。既然都得用Handler去更新界面了，为何不如把定时的功能也交给Handler去做呢？二.内存占比Timer比Handler更占内存。接下来的Demo例子通过两种方法循环地打印日志，然后通过MAT插件来查看这两个类所需要调用的对象所产生的占比。 Async转sync的方法 异步-&gt;同步You could do this with CountdownLatch, which might be the lightest synchronization primitive in java.util.concurrent:private boolean findPrinter(final Context ctx) { final CountdownLatch latch = new CountdownLatch(1); final boolean[] result = {false};…BluetoothDiscoverer.findPrinters(ctx, new DiscoveryHandler() {…public void discoveryFinished() { result[0] = true; latch.countDown(); }public void discoveryError(String arg0) { result[0] = false; latch.countDown(); }… }// before final return // wait for 10 seconds for the response latch.await(10, TimeUnit.SECONDS);//return the result, it will return false when there is timeout return result[0];}来自 https://stackoverflow.com/questions/20659961/java-synchronous-callback Handler集中形式原理https://blog.csdn.net/reakingf/article/details/52054598Looper其中threadlocal保证一个线程只有一个Looper一个Looper一个MessageQueue不断循环获取msg，从target中取得相应得handler来进行dispatchmsg123456789101112131415161718private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125;public static void loop() &#123; for (;;) &#123; Message msg = queue.next(); // might block msg.target.dispatchMessage(msg); &#125;&#125; 处理顺序Handler.dispatchMessage123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; msg sendEmptyMessageDelayed(what, time)-&gt;sendMessageAtTimemsg.what = what postAtTime(Runnable r, long uptimeMillis)sendMessageDelayed(getPostMessage(r), 0);getPostMessage()m.callback = r enqueue msgmsg.target = 记录不同handler 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; hanlderHandler(Handler.Callback callback)]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LruCache与DiskLruCache]]></title>
    <url>%2Fposts%2Fjava_jdk_base_lru_disk_cache.html</url>
    <content type="text"><![CDATA[LruCache与DiskLruCache文章目录 一 Lru算法 二 LruCache原理分析 2.1 写入缓存 2.2 读取缓存 2.3 删除缓存 三 DiskLruCache原理分析 3.1 写入缓存 3.2 读取缓存 3.3 删除缓存 更多Android开源框架源码分析文章请参见Android open framework analysis。 一 Lru算法在分析LruCache与DiskLruCache之前，我们先来简单的了解下LRU算法的核心原理。 LRU算法可以用一句话来描述，如下所示： LRU是Least Recently Used的缩写，最近最久未使用算法，从它的名字就可以看出，它的核心原则是如果一个数据在最近一段时间没有使用到，那么它在将来被访问到的可能性也很小，则这类数据项会被优先淘汰掉。 LRU算法流程图如下所示： 了解了算法原理，我们来思考一下如果是我们来做，应该如何实现这个算法。从上图可以看出，双向链表是一个好主意。 假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。 好，以上便是整个Lru算法的原理，我们接着来分析LruCache与DiskLruCache的实现。 二 LruCache原理分析理解了Lru算法的原理，我们接着从LruCache的使用入手，逐步分析LruCache的源码实现。 👉 LruCache.java 在分析LruCache的源码实现之前，我们先来看看LruCache的简单使用，如下所示： 12345678910111213141516171819int maxMemorySize = (int) (Runtime.getRuntime().totalMemory() / 1024);int cacheMemorySize = maxMemorySize / 8;LruCache&lt;String, Bitmap&gt; lrucache = new LruCache&lt;String, Bitmap&gt;(cacheMemorySize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return getBitmapSize(value); &#125; @Override protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; super.entryRemoved(evicted, key, oldValue, newValue); &#125; @Override protected Bitmap create(String key) &#123; return super.create(key); &#125;&#125;; 注：getBitmapSize()用来计算图片占内存的大小，具体方法参见附录。 可以发现，在使用LruCache的过程中，需要我们关注的主要有三个方法： sizeOf()：覆写此方法实现自己的一套定义计算entry大小的规则。 V create(K key)：如果key对象缓存被移除了，则调用次方法重建缓存。 entryRemoved(boolean evicted, K key, V oldValue, V newValue) ：当key对应的缓存被删除时回调该方法。 我们来看看这三个方法的默认实现，如下所示： 1234567891011public class LruCache&lt;K, V&gt; &#123; //该方法默认返回1，也就是以entry的数量来计算entry的大小，这通常不符合我们的需求，所以我们一般会覆写此方法。 protected int sizeOf(K key, V value) &#123; return 1; &#125; protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; protected V create(K key) &#123; return null; &#125;&#125; 可以发现entryRemoved()方法为空实现，create()方法也默认返回null。sizeOf()方法默认返回1，也就是以entry的数量来计算entry的大小，这通常不符合我们的需求，所以我们一般会覆写此方法。 我们前面提到，要实现Lru算法，可以利用双向链表。 假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。 LruCache使用的是LinkedHashMap，为什么会选择LinkedHashMap呢？🤔 这跟LinkedHashMap的特性有关，LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。 12345678public class LruCache&lt;K, V&gt; &#123; public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; &#125; 我们来写个小例子验证一下。 12345678910111213141516171819202122Map&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(5, 0.75F, true);map.put(1, 1);map.put(2, 2);map.put(3, 3);map.put(4, 4);map.put(5, 5);Log.d(TAG, "before visit");for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; Log.d(TAG, String.valueOf(entry.getValue()));&#125;//访问3，4两个元素map.get(3);map.get(4);Log.d(TAG, "after visit");for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; Log.d(TAG, String.valueOf(entry.getValue()));&#125; 程序输入Log： 注：在LinkedHashMap中最近被方位的元素会被移动到表尾，LruCache也是从从表尾访问数据，在表头删除数据， 可以发现，最后访问的数据就会被移动最尾端，这是符合我们的预期的。所有在LruCache的构造方法中构造了一个这样的LinkedHashMap。 1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 我们再来看看LruCache是如何进行缓存的写入、获取和删除的。 2.1 写入缓存写入缓存是通过LruCache的put()方法实现的，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class LruCache&lt;K, V&gt; &#123; public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; //加锁，线程安全 synchronized (this) &#123; //插入的数量自增 putCount++; //利用我们提供的sizeOf()方法计算当前项的大小，并增加已有缓存size的大小 size += safeSizeOf(key, value); //插入当前项、 previous = map.put(key, value); //previous如果不为空，则说明该项在原来的链表中以及存在，已有缓存大小size恢复到 //以前的大小 if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; //回调entryRemoved()方法 if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; //调整缓存大小，如果缓存满了，则按照Lru算法删除对应的项。 trimToSize(maxSize); return previous; &#125; public void trimToSize(int maxSize) &#123; //开启死循环，知道缓存不满为止 while (true) &#123; K key; V value; synchronized (this) &#123; //参数检查 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //如果缓存为满，直接返回 if (size &lt;= maxSize) &#123; break; &#125; //返回最近最久未使用的元素，也就是链表的表头元素 Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) &#123; break; &#125; key = toEvict.getKey(); value = toEvict.getValue(); //删除该表头元素 map.remove(key); //减少总缓存大小 size -= safeSizeOf(key, value); //被删除的项的数量自增 evictionCount++; &#125; //回到entryRemoved()方法 entryRemoved(true, key, value, null); &#125; &#125;&#125; 整个插入元素的方法put()实现逻辑是很简单的，如下所示： 插入元素，并相应增加当前缓存的容量。 调用trimToSize()开启一个死循环，不断的从表头删除元素，直到当前缓存的容量小于最大容量为止。 2.2 读取缓存读取缓存是通过LruCache的get()方法实现的，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class LruCache&lt;K, V&gt; &#123; public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; //调用LinkedHashMap的get()方法，注意如果该元素存在，且accessOrder为true，这个方法会 //将该元素移动到表尾 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; // missCount++; &#125; //前面我们就提到过，可以覆写create()方法，当获取不到和key对应的元素时，尝试调用create()方法 //创建建元素，以下就是创建的过程，和put()方法流程相同。 V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue; &#125; &#125;&#125; 获取元素的逻辑如下所示： 调用LinkedHashMap的get()方法，注意如果该元素存在，且accessOrder为true，这个方法会将该元素移动到表尾. 当获取不到和key对应的元素时，尝试调用create()方法创建建元素，以下就是创建的过程，和put()方法流程相同。 2.3 删除缓存删除缓存是通过LruCache的remove()方法实现的，如下所示： 123456789101112131415161718192021222324public class LruCache&lt;K, V&gt; &#123; public final V remove(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V previous; synchronized (this) &#123; //调用对应LinkedHashMap的remove()方法删除对应元素 previous = map.remove(key); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, null); &#125; return previous; &#125;&#125; 删除元素的逻辑就比较简单了，调用对应LinkedHashMap的remove()方法删除对应元素。 三 DiskLruCache原理分析👉 DiskLruCache.java 在分析DiskLruCache的实现原理之前，我们先来写个简单的小例子，从例子出发去分析DiskLruCache的实现原理。 1234567891011121314File directory = getCacheDir();int appVersion = 1;int valueCount = 1;long maxSize = 10 * 1024;DiskLruCache diskLruCache = DiskLruCache.open(directory, appVersion, valueCount, maxSize);DiskLruCache.Editor editor = diskLruCache.edit(String.valueOf(System.currentTimeMillis()));BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(editor.newOutputStream(0));Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.scenery);bitmap.compress(Bitmap.CompressFormat.JPEG, 100, bufferedOutputStream);editor.commit();diskLruCache.flush();diskLruCache.close(); 这个就是DiskLruCache的大致使用流程，我们来看看这个入口方法的实现，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public final class DiskLruCache implements Closeable &#123; public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; if (valueCount &lt;= 0) &#123; throw new IllegalArgumentException("valueCount &lt;= 0"); &#125; File backupFile = new File(directory, JOURNAL_FILE_BACKUP); //如果备份文件存在 if (backupFile.exists()) &#123; File journalFile = new File(directory, JOURNAL_FILE); // 如果journal文件存在，则把备份文件journal.bkp是删了 if (journalFile.exists()) &#123; backupFile.delete(); &#125; else &#123; //如果journal文件不存在，则将备份文件命名为journal renameTo(backupFile, journalFile, false); &#125; &#125; DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); //判断journal文件是否存在 if (cache.journalFile.exists()) &#123; //如果日志文件以及存在 try &#123; //读取journal文件，根据记录中不同的操作类型进行相应的处理。 cache.readJournal(); //计算当前缓存容量的大小 cache.processJournal(); cache.journalWriter = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(cache.journalFile, true), Util.US_ASCII)); return cache; &#125; catch (IOException journalIsCorrupt) &#123; System.out .println("DiskLruCache " + directory + " is corrupt: " + journalIsCorrupt.getMessage() + ", removing"); cache.delete(); &#125; &#125; // Create a new empty cache. //创建新的缓存目录 directory.mkdirs(); cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); //调用新的方法建立新的journal文件 cache.rebuildJournal(); return cache; &#125;&#125; 先来说一下这个入口方法的四个参数的含义： File directory：缓存目录。 int appVersion：应用版本号。 int valueCount：一个key对应的缓存文件的数目，如果我们传入的参数大于1，那么缓存文件后缀就是.0，.1等。 long maxSize：缓存容量上限。 DiskLruCache的构造方法并没有做别的事情，只是简单的将对应成员变量进行初始化，open()方法主要围绕着journal文件的创建与读写而展开的，如下所示： readJournal()：读取journal文件，主要是读取文件头里的信息进行检验，然后调用readJournalLine()逐行去读取，根据读取的内容，执行相应的缓存添加、移除等操作。 rebuildJournal()：重建journal文件，重建journal文件主要是写入文件头（上面提到的journal文件都有的前面五行的内容）。 rocessJournal()：计算当前缓存容量的大小。 我们接着来分析什么是journal文件，以及它的创建与读写流程。 3.1 journal文件的创建在前面分析的open()方法中，主要围绕着journal文件的创建和读写来展开的，那么journal文件是什么呢？🤔 我们如果去打开缓存目录，就会发现除了缓存文件，还会发现一个journal文件，journal文件用来记录缓存的操作记录的，如下所示： 12345678libcore.io.DiskLruCache111DIRTY 1517126350519CLEAN 1517126350519 5325928REMOVE 1517126350519 注：这里的缓存目录是应用的缓存目录/data/data/pckagename/cache，未root的手机可以通过以下命令进入到该目录中或者将该目录整体拷贝出来： 12345678//进入/data/data/pckagename/cache目录adb shellrun-as com.your.packagename cp /data/data/com.your.packagename///将/data/data/pckagename目录拷贝出来adb backup -noapk com.your.packagename 我们来分析下这个文件的内容： 第一行：libcore.io.DiskLruCache，固定字符串。 第二行：1，DiskLruCache源码版本号。 第三行：1，App的版本号，通过open()方法传入进去的。 第四行：1，每个key对应几个文件，一般为1. 第五行：空行 第六行及后续行：缓存操作记录。 第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以下三点： DIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。 当手动调用remove(key)方法的时候也会写入一条REMOVE记录。 READ就是说明有一次读取的记录。 CLEAN的后面还记录了文件的长度，注意可能会一个key对应多个文件，那么就会有多个数字。 这几种操作对应到DiskLruCache源码中，如下所示： 1234private static final String CLEAN = "CLEAN";private static final String DIRTY = "DIRTY";private static final String REMOVE = "REMOVE";private static final String READ = "READ"; 那么构建一个新的journal文件呢？上面我们也说过这是调用rebuildJournal()方法来完成的。 rebuildJournal()1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class DiskLruCache implements Closeable &#123; static final String MAGIC = "libcore.io.DiskLruCache"; private synchronized void rebuildJournal() throws IOException &#123; if (journalWriter != null) &#123; journalWriter.close(); &#125; Writer writer = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII)); try &#123; //写入文件头 writer.write(MAGIC); writer.write("\n"); writer.write(VERSION_1); writer.write("\n"); writer.write(Integer.toString(appVersion)); writer.write("\n"); writer.write(Integer.toString(valueCount)); writer.write("\n"); writer.write("\n"); for (Entry entry : lruEntries.values()) &#123; if (entry.currentEditor != null) &#123; writer.write(DIRTY + ' ' + entry.key + '\n'); &#125; else &#123; writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n'); &#125; &#125; &#125; finally &#123; writer.close(); &#125; if (journalFile.exists()) &#123; renameTo(journalFile, journalFileBackup, true); &#125; renameTo(journalFileTmp, journalFile, false); journalFileBackup.delete(); journalWriter = new BufferedWriter( new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII)); &#125;&#125; 你可以发现，构建一个新的journal文件过程就是写入文件头的过程，文件头内容包含前面我们说的appVersion、valueCount、空行等五行内容。 我们再来看看如何读取journal文件里的内容。 readJournal()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public final class DiskLruCache implements Closeable &#123; private void readJournal() throws IOException &#123; StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII); try &#123; //读取文件头，并进行校验。 String magic = reader.readLine(); String version = reader.readLine(); String appVersionString = reader.readLine(); String valueCountString = reader.readLine(); String blank = reader.readLine(); //检查前五行的内容是否合法 if (!MAGIC.equals(magic) || !VERSION_1.equals(version) || !Integer.toString(appVersion).equals(appVersionString) || !Integer.toString(valueCount).equals(valueCountString) || !"".equals(blank)) &#123; throw new IOException("unexpected journal header: [" + magic + ", " + version + ", " + valueCountString + ", " + blank + "]"); &#125; int lineCount = 0; while (true) &#123; try &#123; //开启死循环，逐行读取journal内容 readJournalLine(reader.readLine()); //文件以及读取的行数 lineCount++; &#125; catch (EOFException endOfJournal) &#123; break; &#125; &#125; //lineCount表示文件总行数，lruEntries.size()表示最终缓存的个数，redundantOpCount //就表示非法缓存记录的个数，这些非法缓存记录会被移除掉。 redundantOpCount = lineCount - lruEntries.size(); &#125; finally &#123; Util.closeQuietly(reader); &#125; &#125; private void readJournalLine(String line) throws IOException &#123; //每行记录都是用空格开分隔的，这里取第一个空格出现的位置 int firstSpace = line.indexOf(' '); //如果没有空格，则说明是非法的记录 if (firstSpace == -1) &#123; throw new IOException("unexpected journal line: " + line); &#125; //第一个空格前面就是CLEAN、READ这些操作类型，接下来针对不同的操作类型进行 //相应的处理 int keyBegin = firstSpace + 1; int secondSpace = line.indexOf(' ', keyBegin); final String key; if (secondSpace == -1) &#123; key = line.substring(keyBegin); //1. 如果该条记录以REMOVE为开头，则执行删除操作。 if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123; lruEntries.remove(key); return; &#125; &#125; else &#123; key = line.substring(keyBegin, secondSpace); &#125; //2. 如果该key不存在，则新建Entry并加入lruEntries。 Entry entry = lruEntries.get(key); if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; //3. 如果该条记录以CLEAN为开头，则初始化entry，并设置entry.readable为true、设置entry.currentEditor为 //null，初始化entry长度。 //CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123; //数组中其实是数字，其实就是文件的大小。因为可以通过valueCount来设置一个key对应的value的个数， //所以文件大小也是有valueCount个 String[] parts = line.substring(secondSpace + 1).split(" "); entry.readable = true; entry.currentEditor = null; entry.setLengths(parts); &#125; //4. 如果该条记录以DIRTY为开头。则设置currentEditor对象。 //DIRTY 335c4c6028171cfddfbaae1a9c313c52 else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123; entry.currentEditor = new Editor(entry); &#125; //5. 如果该条记录以READ为开头，则什么也不做。 else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123; // This work was already done by calling lruEntries.get(). &#125; else &#123; throw new IOException("unexpected journal line: " + line); &#125; &#125; &#125; 新来说一下这个lruEntries是什么，如下所示： 12private final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true); 就跟上面的LruCache一样，它也是一个以访问顺序为序的LinkedHashMap，可以用它来实现Lru算法。 该方法的逻辑就是根据记录中不同的操作类型进行相应的处理，如下所示： 如果该条记录以REMOVE为开头，则执行删除操作。 如果该key不存在，则新建Entry并加入lruEntries。 如果该条记录以CLEAN为开头，则初始化entry，并设置entry.readable为true、设置entry.currentEditor为null，初始化entry长度。 如果该条记录以DIRTY为开头。则设置currentEditor对象。 如果该条记录以READ为开头，则什么也不做。 说了这么多，readJournalLine()方法主要是通过读取journal文件的每一行，然后封装成entry对象，放到了LinkedHashMap集合中。并且根据每一行不同的开头，设置entry的值。也就是说通过读取这个文件，我们把所有的在本地缓存的文件的key都保存到了集合中，这样我们用的时候就可以通过集合来操作了。 processJournal()123456789101112131415161718192021222324252627public final class DiskLruCache implements Closeable &#123; private void processJournal() throws IOException &#123; //删除journal.tmp临时文件 deleteIfExists(journalFileTmp); //变量缓存集合里的所有元素 for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123; Entry entry = i.next(); //如果当前元素entry的currentEditor不为空，则计算该元素的总大小，并添加到总缓存容量size中去 if (entry.currentEditor == null) &#123; for (int t = 0; t &lt; valueCount; t++) &#123; size += entry.lengths[t]; &#125; &#125; //如果当前元素entry的currentEditor不为空，代表该元素时非法缓存记录，该记录以及对应的缓存文件 //都会被删除掉。 else &#123; entry.currentEditor = null; for (int t = 0; t &lt; valueCount; t++) &#123; deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); &#125; i.remove(); &#125; &#125; &#125;&#125; 这里提到了一个非常缓存记录，那么什么是非法缓存记录呢？🤔 DIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。 该方法主要用来计算当前的缓存总容量，并删除非法缓存记录以及该记录对应的文件。 理解了journal文件的创建以及读写流程，我们来看看硬盘缓存的写入、读取和删除的过程。 3.2 写入缓存DiskLruCache缓存的写入是通过edit()方法来完成的，如下所示： 12345678910111213141516171819202122232425262728293031323334public final class DiskLruCache implements Closeable &#123; private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; checkNotClosed(); validateKey(key); //从之前的缓存中读取对应的entry Entry entry = lruEntries.get(key); //当前无法写入磁盘缓存 if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; //如果entry为空，则新建一个entry对象加入到缓存集合中 if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; //currentEditor不为空，表示当前有别的插入操作在执行 else if (entry.currentEditor != null) &#123; return null; // Another edit is in progress. &#125; //为当前创建的entry知道新创建的editor Editor editor = new Editor(entry); entry.currentEditor = editor; //向journal写入一行DIRTY + 空格 + key的记录，表示这个key对应的缓存正在处于被编辑的状态。 journalWriter.write(DIRTY + ' ' + key + '\n'); //刷新文件里的记录 journalWriter.flush(); return editor; &#125;&#125; 这个方法构建了一个Editor对象，它主要做了两件事情： 从集合中找到对应的实例（如果没有创建一个放到集合中），然后创建一个editor，将editor和entry关联起来。 向journal中写入一行操作数据（DITTY 空格 和key拼接的文字），表示这个key当前正处于编辑状态。 我们在前面的DiskLruCache的使用例子中，调用了Editor的newOutputStream()方法创建了一个OutputStream来写入缓存文件。如下所示： 123456789101112131415161718public final class DiskLruCache implements Closeable &#123; public InputStream newInputStream(int index) throws IOException &#123; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; return null; &#125; try &#123; return new FileInputStream(entry.getCleanFile(index)); &#125; catch (FileNotFoundException e) &#123; return null; &#125; &#125; &#125;&#125; 这个方法的形参index就是我们开始在open()方法里传入的valueCount，这个valueCount表示了一个key对应几个value,也就是说一个key对应几个缓存文件。那么现在传入的这个index就表示要缓存的文件时对应的第几个value。 有了输出流，我们在接着调用Editor的commit()方法就可以完成缓存文件的写入了，如下所示： 12345678910111213public final class DiskLruCache implements Closeable &#123; public void commit() throws IOException &#123; //如果通过输出流写入缓存文件出错了就把集合中的缓存移除掉 if (hasErrors) &#123; completeEdit(this, false); remove(entry.key); // The previous entry is stale. &#125; else &#123; //调用completeEdit()方法完成缓存写入。 completeEdit(this, true); &#125; committed = true; &#125;&#125; 可以看到该方法调用DiskLruCache的completeEdit()方法来完成缓存写入，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public final class DiskLruCache implements Closeable &#123; private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; // If this edit is creating the entry for the first time, every index must have a value. if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); &#125; if (!entry.getDirtyFile(i).exists()) &#123; editor.abort(); return; &#125; &#125; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; //获取对象缓存的临时文件 File dirty = entry.getDirtyFile(i); if (success) &#123; //如果临时文件存在，则将其重名为正式的缓存文件 if (dirty.exists()) &#123; File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength; //重新计算缓存的大小 size = size - oldLength + newLength; &#125; &#125; else &#123; //如果写入不成功，则删除掉临时文件。 deleteIfExists(dirty); &#125; &#125; //操作次数自增 redundantOpCount++; //将当前缓存的编辑器置为空 entry.currentEditor = null; if (entry.readable | success) &#123; //缓存已经写入，设置为可读。 entry.readable = true; //向journal写入一行CLEAN开头的记录，表示缓存成功写入到磁盘。 journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n'); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; //如果不成功，则从集合中删除掉这个缓存 lruEntries.remove(entry.key); //向journal文件写入一行REMOVE开头的记录，表示删除了缓存 journalWriter.write(REMOVE + ' ' + entry.key + '\n'); &#125; journalWriter.flush(); //如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次， // 就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件 if (size &gt; maxSize || journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; &#125;&#125; 这个方法一共做了以下几件事情： 如果输出流写入数据成功，就把写入的临时文件重命名为正式的缓存文件 重新设置当前总缓存的大小 向journal文件写入一行CLEAN开头的字符（包括key和文件的大小，文件大小可能存在多个 使用空格分开的） 如果输出流写入失败，就删除掉写入的临时文件，并且把集合中的缓存也删除 向journal文件写入一行REMOVE开头的字符 重新比较当前缓存和最大缓存的大小，如果超过最大缓存或者journal文件的操作大于2000条，就把集合中的缓存删除一部分，直到小于最大缓存，重新建立新的journal文件 到这里，缓存的插入流程就完成了。 3.3 读取缓存读取缓存是由DiskLruCache的get()方法来完成的，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class DiskLruCache implements Closeable &#123; public synchronized Snapshot get(String key) throws IOException &#123; checkNotClosed(); validateKey(key); //获取对应的entry Entry entry = lruEntries.get(key); if (entry == null) &#123; return null; &#125; //如果entry不可读，说明可能在编辑，则返回空。 if (!entry.readable) &#123; return null; &#125; //打开所有缓存文件的输入流，等待被读取。 InputStream[] ins = new InputStream[valueCount]; try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; ins[i] = new FileInputStream(entry.getCleanFile(i)); &#125; &#125; catch (FileNotFoundException e) &#123; // A file must have been deleted manually! for (int i = 0; i &lt; valueCount; i++) &#123; if (ins[i] != null) &#123; Util.closeQuietly(ins[i]); &#125; else &#123; break; &#125; &#125; return null; &#125; redundantOpCount++; //向journal写入一行READ开头的记录，表示执行了一次读取操作 journalWriter.append(READ + ' ' + key + '\n'); //如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次， // 就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件 if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; //返回一个缓存文件快照，包含缓存文件大小，输入流等信息。 return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths); &#125;&#125; 读取操作主要完成了以下几件事情： 获取对应的entry。 打开所有缓存文件的输入流，等待被读取。 向journal写入一行READ开头的记录，表示执行了一次读取操作。 如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件。 返回一个缓存文件快照，包含缓存文件大小，输入流等信息。 该方法最终返回一个缓存文件快照，包含缓存文件大小，输入流等信息。利用这个快照我们就可以读取缓存文件了。 3.4 删除缓存删除缓存是由DiskLruCache的remove()方法来完成的，如下所示： 123456789101112131415161718192021222324252627282930313233343536public final class DiskLruCache implements Closeable &#123; public synchronized boolean remove(String key) throws IOException &#123; checkNotClosed(); validateKey(key); //获取对应的entry Entry entry = lruEntries.get(key); if (entry == null || entry.currentEditor != null) &#123; return false; &#125; //删除对应的缓存文件，并将缓存大小置为0. for (int i = 0; i &lt; valueCount; i++) &#123; File file = entry.getCleanFile(i); if (file.exists() &amp;&amp; !file.delete()) &#123; throw new IOException("failed to delete " + file); &#125; size -= entry.lengths[i]; entry.lengths[i] = 0; &#125; redundantOpCount++; //向journal文件添加一行REMOVE开头的记录，表示执行了一次删除操作。 journalWriter.append(REMOVE + ' ' + key + '\n'); lruEntries.remove(key); //如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次， // 就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件 if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; return true; &#125; &#125; 删除操作主要做了以下几件事情： 获取对应的entry。 删除对应的缓存文件，并将缓存大小置为0. 向journal文件添加一行REMOVE开头的记录，表示执行了一次删除操作。 如果缓存总大小已经超过了设定的最大缓存大小或者操作次数超过了2000次，就开一个线程将集合中的数据删除到小于最大缓存大小为止并重新写journal文件。 好，到这里LrcCache和DiskLruCache的实现原理都讲完了，这两个类在主流的图片框架Fresco、Glide和网络框架Okhttp等都有着广泛的应用，后续的文章后继续分析LrcCache和DiskLruCache在这些框架里的应用。 附录图片占用内存大小的计算Android里面缓存应用最多的场景就是图片缓存了，谁让图片在内存里是个大胖子呢，在做缓存的时候我们经常会去计算图片展内存的大小。 那么如何去获取一张图片占用内存的大小呢？🤔 123456789101112private int getBitmapSize(Bitmap bitmap) &#123; //API 19 if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) &#123; return bitmap.getAllocationByteCount(); &#125; //API 12 if (Build.VERSION.SDK_INT == Build.VERSION_CODES.HONEYCOMB_MR1) &#123; return bitmap.getByteCount(); &#125; // Earlier Version return bitmap.getRowBytes() * bitmap.getHeight();&#125; 那么这三个方法处了版本上的差异，具体有什么区别呢？ getRowBytes()返回的是每行的像素值，乘以高度就是总的像素数，也就是占用内存的大小。 getAllocationByteCount()与getByteCount()的返回值一般情况下都是相等的。只是在图片复用的时候，getAllocationByteCount()返回的是复用图像所占内存的大小，getByteCount()返回的是新解码图片占用内存的大小。 我们来写一个小例子验证一下，如下所示： 123456789101112131415161718192021BitmapFactory.Options options = new BitmapFactory.Options();options.inDensity = 320;options.inTargetDensity = 320;//要实现复用，图像必须是可变的，也就是inMutable为true。options.inMutable = true;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.scenery, options);Log.d(TAG, "bitmap.getAllocationByteCount(): " + String.valueOf(bitmap.getAllocationByteCount()));Log.d(TAG, "bitmap.getByteCount(): " + String.valueOf(bitmap.getByteCount()));Log.d(TAG, "bitmap.getRowBytes() * bitmap.getHeight(): " + String.valueOf(bitmap.getRowBytes() * bitmap.getHeight()));BitmapFactory.Options reuseOptions = new BitmapFactory.Options();reuseOptions.inDensity = 320;reuseOptions.inTargetDensity = 320;//要复用的BitmapreuseOptions.inBitmap = bitmap;//要实现复用，图像必须是可变的，也就是inMutable为true。reuseOptions.inMutable = true;Bitmap reuseBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.scenery_reuse, reuseOptions);Log.d(TAG, "reuseBitmap.getAllocationByteCount(): " + String.valueOf(reuseBitmap.getAllocationByteCount()));Log.d(TAG, "reuseBitmap.getByteCount(): " + String.valueOf(reuseBitmap.getByteCount()));Log.d(TAG, "reuseBitmap.getRowBytes() * reuseBitmap.getHeight(): " + String.valueOf(reuseBitmap.getRowBytes() * reuseBitmap.getHeight())); 运行的log如下所示： 可以发现reuseBitmap的getAllocationByteCount()和getByteCount()返回不一样，getAllocationByteCount()返回的是复用bitmap占用内存的大小，getByteCount()返回的是新的reuseOptions实际解码占用的内存大小。 注意在复用图片的时候，options.inMutable必须设置为true，否则无法进行复用，如下所示： cachelrucache-&gt;linkedHashMap(false) 插入顺序排序fifocache-&gt;linkedHashMap(true) 访问顺序排序 其中有两种比较简单的方法，如下：LRU1234567891011121314151617181920212223242526public class LRU&lt;K,V&gt; extends LinkedHashMap&lt;K, V&gt; implements Map&lt;K, V&gt;&#123; private static final long serialVersionUID = 1L; private static final int maxSize = 0; public LRU(int maxSize) &#123; this.maxSize = maxSize; super(16, 0.75, true); // lru super(16, 0.75, false); // fifo &#125; /** * @description 重写LinkedHashMap中的removeEldestEntry方法，当LRU中元素多余maxSize个时， * 删除最不经常使用的元素 * @param eldest * @return * @see java.util.LinkedHashMap#removeEldestEntry(java.util.Map.Entry) */ @Override protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) &#123; if(size() &gt; maxSize)&#123; return true; &#125; return false; &#125;&#125; 我们可以看到这种方法， 基本完全继承LinkedHashMap，只是复写了removeEldestEntry方法，使得可以在插入元素得时候删除老元素，保持maxSize数量。 那么google得LruCache同样采用类似的方法进行。不过是自己来维护maxSize和while(true)删除老元素，如下：1234567891011121314151617181920212223242526272829194 public void trimToSize(int maxSize) &#123;195 while (true) &#123;196 K key;197 V value;198 synchronized (this) &#123;199 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;200 throw new IllegalStateException(getClass().getName()201 + &quot;.sizeOf() is reporting inconsistent results!&quot;);202 &#125;203204 if (size &lt;= maxSize) &#123;205 break;206 &#125;207208 Map.Entry&lt;K, V&gt; toEvict = map.eldest();209 if (toEvict == null) &#123;210 break;211 &#125;212213 key = toEvict.getKey();214 value = toEvict.getValue();215 map.remove(key);216 size -= safeSizeOf(key, value);217 evictionCount++;218 &#125;219220 entryRemoved(true, key, value, null);221 &#125;222 &#125; 那么LinkedHashMap是怎么维持这样的顺序呢？重新写迭代器，按照after before链表标记进行顺序访问。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private abstract class LinkedHashIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; Entry&lt;K,V&gt; nextEntry = header.after; Entry&lt;K,V&gt; lastReturned = null; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() &#123; // 根据双向列表判断 return nextEntry != header; &#125; public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); LinkedHashMap.this.remove(lastReturned.key); lastReturned = null; expectedModCount = modCount; &#125; Entry&lt;K,V&gt; nextEntry() &#123; // 迭代输出双向链表各节点 if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (nextEntry == header) throw new NoSuchElementException(); Entry&lt;K,V&gt; e = lastReturned = nextEntry; nextEntry = e.after; return e; &#125;&#125;// Key 迭代器，KeySetprivate class KeyIterator extends LinkedHashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125;&#125; // Value 迭代器，Values(Collection)private class ValueIterator extends LinkedHashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125;&#125;// Entry 迭代器，EntrySetprivate class EntryIterator extends LinkedHashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125;&#125; 参考：http://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.htmlhttps://blog.csdn.net/justloveyou_/article/details/71713781#t7http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/util/LruCache.java#164https://blog.csdn.net/huaxun66/article/details/52434528 disklrucache基本使用方法可以参考：https://www.jianshu.com/p/f9cfbea586c2 当写入文件时，如果超过maxSize，那么就新奇一个线程来执行trim得操作，一直保持maxSize大小，移除老元素。那么这个老元素是如何记录得呢？ 同样原理，使用LinkedHashMap来记录是哪一个文件，直接删除对应的文件即可。1234567891011121314151617181920212223242526157 /** This cache uses a single background thread to evict entries. */158 final ThreadPoolExecutor executorService =159 new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());160 private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;Void&gt;() &#123;161 public Void call() throws Exception &#123;162 synchronized (DiskLruCache.this) &#123;163 if (journalWriter == null) &#123;164 return null; // Closed.165 &#125;166 trimToSize();167 if (journalRebuildRequired()) &#123;168 rebuildJournal();169 redundantOpCount = 0;170 &#125;171 &#125;172 return null;173 &#125;174 &#125;;644 private void trimToSize() throws IOException &#123;645 while (size &gt; maxSize) &#123;646 Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();647 remove(toEvict.getKey());648 &#125;649 &#125; 参考：https://www.jianshu.com/p/f9cfbea586c2http://androidxref.com/7.1.2_r36/xref/external/glide/third_party/disklrucache/src/main/java/com/bumptech/glide/disklrucache/DiskLruCache.java#lruEntries guava cache###使用方法：https://blog.csdn.net/u012859681/article/details/75220605#t3https://www.imooc.com/article/28865 原理https://github.com/seaswalker/Spring/blob/master/note/guava-cache.md https://ketao1989.github.io/2014/12/19/Guava-Cache-Guide-And-Implement-Analyse/ https://blog.csdn.net/zhanglao33/article/details/77508834 其他缓存机制redis ehcache等https://tech.meituan.com/cache_about.html]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>lru</tag>
        <tag>disk</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guava Cache原理]]></title>
    <url>%2Fposts%2Fjava_jdk_base_guava_cache.html</url>
    <content type="text"><![CDATA[Guava Cache的使用Guava是Google提供的Java工具框架，包括一些工具类，Java集合框架的扩展，还有更重要的guava cache。 相比Java的HashMap，ConcurrentHashMap，提供更加灵活的配置和功能，比如控制缓存大小，缓存过期时间等，来试试。 版本我使用了Guava最新的版本20.0 Gradle, 1compile(&quot;com.google.guava:guava:20.0&quot;) Cache接口Cache接口，是最顶层的缓存接口，没有结合数据获取功能，看源码，省去一些代码和注释， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface Cache&lt;K, V&gt; &#123; /** * Returns the value associated with &#123;@code key&#125; in this cache, or &#123;@code null&#125; if there is no * cached value for &#123;@code key&#125;. * * @since 11.0 */ @Nullable V getIfPresent(Object key); V get(K key, Callable&lt;? extends V&gt; loader) throws ExecutionException; ImmutableMap&lt;K, V&gt; getAllPresent(Iterable&lt;?&gt; keys); void put(K key, V value); void putAll(Map&lt;? extends K, ? extends V&gt; m); /** * Discards any cached value for key &#123;@code key&#125;. */ void invalidate(Object key); /** * Discards any cached values for keys &#123;@code keys&#125;. * * @since 11.0 */ void invalidateAll(Iterable&lt;?&gt; keys); /** * Discards all entries in the cache. */ void invalidateAll(); /** * Returns the approximate number of entries in this cache. */ long size(); CacheStats stats(); ConcurrentMap&lt;K, V&gt; asMap(); /** * Performs any pending maintenance operations needed by the cache. Exactly which activities are * performed -- if any -- is implementation-dependent. */ void cleanUp();&#125; 测试代码， 12345678910111213141516171819public static void main(String[] args) throws Exception &#123; Cache&lt;String,TradeAccount&gt; cache = CacheBuilder.newBuilder(). expireAfterWrite(5L, TimeUnit.SECONDS). maximumSize(5000L). ticker(Ticker.systemTicker()). build(); TradeAccount account1 = new TradeAccount(); cache.put(&quot;key&quot;, account1); TimeUnit.SECONDS.sleep(6); TradeAccount a1 = cache.getIfPresent(&quot;key&quot;); TradeAccount a2 = cache.getIfPresent(&quot;key2&quot;); a2 = cache.getIfPresent(&quot;key2&quot;); a2 = cache.getIfPresent(&quot;key3&quot;); System.out.println(a1 == account1);&#125; get方法，如果没有数据，需要自己添加一个loader继续callable接口，不够灵活，参数传入不方便。 建议使用getIfPresent方法，通用代码如下， 12345value = cache.getIfPresent(key);if(value == null)&#123; value = someService.retrieveValue(); cache.put(key,value);&#125; LoadingCache接口LoadingCache，继承Cache接口，可以跟数据获取的服务结合使用。 测试代码， 1234567891011121314151617181920212223public static void main(String[] args) throws Exception &#123; ITradeAccountService service = new TradeAccountService(); LoadingCache&lt;String,TradeAccount&gt; cache = CacheBuilder.newBuilder(). expireAfterWrite(5L, TimeUnit.MINUTES). maximumSize(5000L). ticker(Ticker.systemTicker()). build(new CacheLoader&lt;String, TradeAccount&gt;() &#123; @Override public TradeAccount load(String key) throws Exception &#123; return service.getTradeAccountById(key); &#125; &#125;); TradeAccount account1 = new TradeAccount(); cache.put(&quot;key&quot;, account1); TradeAccount a1 = cache.get(&quot;key&quot;); TradeAccount a2 = cache.get(&quot;key2&quot;); a2 = cache.get(&quot;key2&quot;); a2 = cache.get(&quot;key3&quot;); System.out.println(a1 == account1);&#125; 123456789public class TradeAccount &#123; private String id; private String owner; private double balance; ...get/set&#125;public interface ITradeAccountService &#123; TradeAccount getTradeAccountById(String key);&#125; 根据自己的业务的场景，选择使用Cache还是LoadingCache。 缓存加载当缓存不存在时，guava提供了多种方式来加载数据: CacheLoader、Callable、显示插入. CacheLoaderLoadingCache是一种基于CacheLoader的缓存实现. 12345678910111213141516LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder() .maximumSize(1000) .expireAfterWrite(10, TimeUnit.MINUTES) .build( new CacheLoader&lt;Key, Graph&gt;() &#123; public Graph load(Key key) throws AnyException &#123; return createExpensiveGraph(key); &#125; &#125;);...try &#123; return graphs.get(key);&#125; catch (ExecutionException e) &#123; throw new OtherException(e.getCause());&#125; 使用LoadingCache.get(K)方法可以获取缓存中对应的值，如果没有缓存，则会使用CacheLoader原子地加载新值. Callable所有类型的Guava Cache, 不管有没有自动加载功能, 都支持get(K, Callable)方法。get(K, Callable)方法尝试返回缓存中对应的值; 如果值不存在，则使用Callable运算，并把结果加入缓存中。 123456789101112131415Cache&lt;Key, Graph&gt; cache = CacheBuilder.newBuilder() .maximumSize(1000) .build(); // 看，木有CacheLoader...try &#123; cache.get(key, new Callable&lt;Key, Graph&gt;() &#123; @Override public Value call() throws AnyException &#123; // 缓存不存在，就会调用call()方法计算, 并把结果加入缓存 return doThingsTheHardWay(key); &#125; &#125;);&#125; catch (ExecutionException e) &#123; throw new OtherException(e.getCause());&#125; 这种方式简便地实现了”get-if-absent-compute”模式 显式插入使用cache.put(key, value)方法可以直接向缓存中插入值, 该方法会直接覆盖掉给定键之前映射的值. 缓存回收由于guava缓存是将数据存放于内存中，所以确定一定以及肯定没有足够的内存存放所有的数据guava提供了三种基本的缓存回收方式: 基于容量回收、定时回收和基于引用回收。 基于容量回收(Size-based Eviction)构建Cache时，可以通过CacheBuilder.maximumSize(long)来指定缓存的容量.在缓存容量达到指定容量时(maybe达到之前), 会尝试回收最近没有使用或总体上很少使用的缓存项. 另外，可以通过CacheBuilder.weight(Weigher), 来指定权重函数, 权重函数将在缓存创建时计算 12345678910111213LoadingCache&lt;Key, Graph&gt; graphs = CacheBuilder.newBuilder() .maximumWeight(100000) .weigher(new Weigher&lt;Key, Graph&gt;() &#123; public int weigh(Key k, Graph g) &#123; return g.vertices().size(); &#125; &#125;) .build( new CacheLoader&lt;Key, Graph&gt;() &#123; public Graph load(Key key) &#123; // no checked exception return createExpensiveGraph(key); &#125; &#125;); 定时回收(Timed Eviction)CacheBuilder提供两种定时回收的方式： expireAfterAccess(long, TimeUnit): 缓存在给定时间内没有被读/写访问过, 则回收. 回收顺序与基于容量回收的一样 expireAfterWrite(long, TimeUnit): 缓存在给定时间内没有被写访问(创建/覆盖), 则回收. 基于引用回收(Reference-based Eviction)如果使用week references的键/值、soft references的值，则缓存允许被垃圾回收: CacheBuilder.weakKeys() CacheBuilder.weakValues() CacheBuilder.softValues() 显式移除可以通过以下接口，在任何时间清除缓存 Cache.invalidate(key): 单个清除 Cache.invalidateAll(keys): 批量清除 Cache.invalidateAll(): 清除所有缓存项 移除监听器CacheBuilder.removalListener(RemovalListener)添加一个监听器，在缓存项被移除时，进行额外操作. 123456789101112131415RemovalListener&lt;Key, Value&gt; removalListener = new RemovalListener&lt;Key, Value&gt;() &#123; // 缓存项被移除时，RemovalListener会获取移除通知[RemovalNotification] // 其中包含移除原因[RemovalCause]、键和值 public void onRemoval(RemovalNotification&lt;Key, Value&gt; removal) &#123; removal.getKey(); // 被移除的Key removal.getValue(); // 被移除的Value removal.getCause(); // 被移除的原因: EXPLICIT、REPLACED、COLLECTED、EXPIRED、SIZE &#125;&#125;;return CacheBuilder.newBuilder() .expireAfterWrite(2, TimeUnit.MINUTES) .removalListener(removalListener) .build(loader); 用RemovalListeners.asynchronous(RemovalListener, Executor)把监听器装饰为异步操作 缓存清理的时间点使用CacheBuilder构建的缓存，不会“自动”执行清理和回收工作.guava并没有建立独立线程来完成清理工作, 而是在写操作时顺带做少量的维护工作.使用者可以建立自己的独立线程, 来主动清理缓存, 只需要调用Cache.cleanUp()就可以了 刷新LoadingCache.referesh(K) 刷新表示为键加载新值, 可以异步完成刷新和回收不一样，刷新时，缓存仍然可以向其他线程返回旧值，而回收时，读取线程必须等待新值加载完成.如果刷新失败(抛出异常)，缓存将保留旧值 CacheLoader.reload(K, V)可以扩展刷新时的行为CacheBuilder.refreshAfterWrite(long, TimeUnit)可以为缓存增加自动定时刷新功能 其他特性统计CacheBuilder.recordStats() 开启Guava Cache的统计功能。Cache.stats() 返回CacheStats对象 CacheStatus提供如下统计信息:CacheStats.hitRate() 缓存命中率CacheStats.hitCount() 缓存命中数量CacheStats.averageLoadPenalty() 加载新值的平均时间，单位为纳秒CacheStats.evictionCount() 缓存项被回收的总数，不包括显式清除… Map视图cache.asMap() 提供了缓存的ConcurrentMap形式 asMap()包含当前所有加载到缓存的项 asMap().get(key)实质上等同于cache.getIfPresent(key)，而且不会引起缓存项的加载 Cache.asMap().get(Object)方法和Cache.asMap().put(K, V)方法会重置相关缓存项的访问时间 Guava Cache源码分析Guava是Google开源出来的Java常用工具集库,包括集合|缓存|并发|字符串|IO操作等在Java开发过程中经常需要去实现的工具类. 显然,对于这种十分常见的需求,Guava提供了自己的工具类实现.GuavaCache 提供了一般我们使用缓存所需要的几乎所有的功能,主要有: 自动将entry节点加载进缓存结构中; 当缓存的数据已经超过预先设置的最大值时，使用LRU算法移除一些数据； 具备根据entry节点上次被访问或者写入的时间来计算过期机制； 缓存的key被封装在WeakReference引用内; 缓存的value被封装在WeakReference或者SoftReference引用内； 移除entry节点，可以触发监听器通知事件； 统计缓存使用过程中命中率/异常率/未命中率等数据。 此外，Guava Cache其核心数据结构大体上和ConcurrentHashMap一致，具体细节上会有些区别。功能上，ConcurrentMap会一直保存所有添加的元素，直到显式地移除.相对地,Guava Cache为了限制内存占用,通常都设定为自动回收元素.在某些场景下,尽管它不回收元素,也是很有用的,因为它会自动加载缓存. Guava Cache 介绍在介绍Guava Cache使用之前，先需要引入下官方推荐的使用场景： 12345* 愿意消耗一些内存空间来提升速度； * 能够预计某些key会被查询一次以上； * 缓存中存放的数据总量不会超出内存容量(`Guava Cache`是单个应用运行时的本地缓存)。 不管性能，还是可用性来说，Guava Cache绝对是本地缓存类库中首要推荐的工具类。其提供的Builder模式的CacheBuilder生成器来创建缓存的方式，十分方便，并且各个缓存参数的配置设置，类似于函数式编程的写法，也特别棒。 Guava Cache的官方文档地址：http://code.google.com/p/guava-libraries/wiki/CachesExplained. 该文档对Cache有详细的介绍。 Tips：在官方文档中，提到三种方式加载&lt;key,value&gt;到缓存中。分别是: LoadingCache在构建缓存的时候，使用build方法内部调用CacheLoader方法加载数据； 在使用get方法的时候，如果缓存不存在该key或者key过期等，则调用get(K, Callable&lt;V&gt;)方式加载数据； 使用粗暴直接的方式，直接想缓存中put数据。 需要说明的是，如果不能通过key快速计算出value时，则还是不要在初始化的时候直接调用CacheLoader加载数据到缓存中。 2.1 Guava Cache使用示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.Date;import java.util.concurrent.Callable;import java.util.concurrent.TimeUnit;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.common.cache.Cache;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import com.google.common.cache.RemovalListener;import com.google.common.cache.RemovalNotification;/** * @author tao.ke Date: 14-12-20 Time: 下午1:55 * @version \$Id$ */public class CacheSample &#123; private static final Logger logger = LoggerFactory.getLogger(CacheSample.class); // Callable形式的Cache private static final Cache&lt;String, String&gt; CALLABLE_CACHE = CacheBuilder.newBuilder() .expireAfterWrite(1, TimeUnit.SECONDS).maximumSize(1000).recordStats() .removalListener(new RemovalListener&lt;Object, Object&gt;() &#123; @Override public void onRemoval(RemovalNotification&lt;Object, Object&gt; notification) &#123; logger.info(&quot;Remove a map entry which key is &#123;&#125;,value is &#123;&#125;,cause is &#123;&#125;.&quot;, notification.getKey(), notification.getValue(), notification.getCause().name()); &#125; &#125;).build(); // CacheLoader形式的Cache private static final LoadingCache&lt;String, String&gt; LOADER_CACHE = CacheBuilder.newBuilder() .expireAfterAccess(1, TimeUnit.SECONDS).maximumSize(1000).recordStats().build(new CacheLoader&lt;String, String&gt;() &#123; @Override public String load(String key) throws Exception &#123; return key + new Date(); &#125; &#125;); public static void main(String[] args) throws Exception &#123; int times = 4; while (times-- &gt; 0) &#123; Thread.sleep(900); String valueCallable = CALLABLE_CACHE.get(&quot;key&quot;, new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; return &quot;key&quot; + new Date(); &#125; &#125;); logger.info(&quot;Callable Cache -----&gt;&gt;&gt;&gt;&gt; key is &#123;&#125;,value is &#123;&#125;&quot;, &quot;key&quot;, valueCallable); logger.info(&quot;Callable Cache -----&gt;&gt;&gt;&gt;&gt; stat miss:&#123;&#125;,stat hit:&#123;&#125;&quot;,CALLABLE_CACHE.stats().missRate(),CALLABLE_CACHE.stats().hitRate()); String valueLoader = LOADER_CACHE.get(&quot;key&quot;); logger.info(&quot;Loader Cache -----&gt;&gt;&gt;&gt;&gt; key is &#123;&#125;,value is &#123;&#125;&quot;, &quot;key&quot;, valueLoader); logger.info(&quot;Loader Cache -----&gt;&gt;&gt;&gt;&gt; stat miss:&#123;&#125;,stat hit:&#123;&#125;&quot;,LOADER_CACHE.stats().missRate(),LOADER_CACHE.stats().hitRate()); &#125; &#125;&#125; 上述代码，简单的介绍了Guava Cache的使用，给了两种加载构建Cache的方式。在Guava Cache对外提供的方法中， recordStats和removalListener是两个很有趣的接口，可以很好的帮我们完成统计功能和Entry移除引起的监听触发功能。 此外，虽然在Guava Cache对外方法接口中提供了丰富的特性，但是如果我们在实际的代码中不是很有需要的话，建议不要设置这些属性，因为会额外占用内存并且会多一些处理计算工作，不值得。 Guava Cache 分析前置知识Guava Cache就是借鉴Java的ConcurrentHashMap的思想来实现一个本地缓存，但是它内部代码实现的时候，还是有很多非常精彩的设计实现，并且如果对ConcurrentHashMap内部具体实现不是很清楚的话，通过阅读Cache的实现，对ConcurrentHashMap的实现基本上会有个全面的了解。 3.1 Builder模式设计模式之 Builder模式 在Guava中很多地方得到的使用。Builder模式是将一个复杂对象的构造与其对应配置属性表示的分离，也就是可以使用基本相同的构造过程去创建不同的具体对象。 Builder模式典型的结构图如： 1234567Builder：为创建一个Product对象的各个部件制定抽象接口；ConcreteBuilder：具体的建造者，它负责真正的生产；Director：导演, 建造的执行者，它负责发布命令；Product：最终消费的产品 各类之间的交互关系如下图： Builder模式的关键是其中的Director对象并不直接返回对象，而是通过（BuildPartA，BuildPartB，BuildPartC）来一步步进行对象的创建。当然这里Director可以提供一个默认的返回对象的接口（即返回通用的复杂对象的创建，即不指定或者特定唯一指定BuildPart中的参数）。 Tips：在Effective Java第二版中，Josh Bloch在第二章中就提到使用Builder模式处理需要很多参数的构造函数。他不仅展示了Builder的使用，也描述了相这种方法相对使用带很多参数的构造函数带来的好处。 下面给出一个使用Builder模式来构造对象，这种方式优点和不足（代码量增加）非常明显。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.apache.commons.lang3.builder.ToStringBuilder;import org.apache.commons.lang3.builder.ToStringStyle;/** * @author tao.ke Date: 14-12-22 Time: 下午8:57 * @version \$Id$ */public class BuilderPattern &#123; /** * 姓名 */ private String name; /** * 年龄 */ private int age; /** * 性别 */ private Gender gender; public static BuilderPattern newBuilder() &#123; return new BuilderPattern(); &#125; public BuilderPattern setName(String name) &#123; this.name = name; return this; &#125; public BuilderPattern setAge(int age) &#123; this.age = age; return this; &#125; public BuilderPattern setGender(Gender gender) &#123; this.gender = gender; return this; &#125; @Override public String toString() &#123; return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE); &#125; enum Gender &#123; MALE, FEMALE &#125; public static void main(String[] args) &#123; BuilderPattern bp = BuilderPattern.newBuilder().setAge(10).setName(&quot;zhangsan&quot;).setGender(Gender.FEMALE); System.out.println(bp.toString()); &#125;&#125; 3.2 Java对象引用对象引用之前需要先看看对象的访问定位。 当虚拟机执行时，遇到一条new指令时，首先会去检查这个指令在常量池中是否已经存在该类对应的符号引用，并且检查这个符号引用对应的类是否已经被加载，解析和初始化。如果没有，则执行相应的类加载过程。 然后虚拟机为新的对象分配内存。虚拟机根据我们配置的垃圾收集器规则采取不同的分配方式，包括：指针碰撞分配方式和空闲列表分配方式。 内存分配完成之后，开始执行init方法。init方法会按照代码的指定过程来初始化，对一些类属性进行赋值。 然后，我们需要访问这个对象，怎么办？在Java运行时内存区域模型中，线程拥有一个虚拟机栈，这个栈会有一个本地方法表，这个表内部就会存放一个引用地址，如下图所示（HotSpot虚拟机采用这种方式，还有另外一种形式这里不做介绍）： 在JDK 1.2之前，Java中关于引用的定义是：如果reference类型的数据中存储的数值表示的是另外一块内存的起始地址，就说明这块内存称为引用。这种定义表明对象只有两种：被引用的对象和没有被引用的对象。这种方式对于垃圾收集GC来说，效果并不是很好，因为很多对象划为为被引用和非被引用都不是很重要，这种现象就无法划分。垃圾收集的时候，就无法更好更精准的划为可GC的对象。 因此，在JDK 1.2之后，Java对引用的概念进行扩展，有如下四种类型的引用（按强度排序）： 1234567* 强引用(Strong Reference)* 软引用(SoftReference)* 弱引用(WeakReference)* 虚引用(PhantomReference) 强引用：强引用在程序代码中随处可见，十分普遍。比如： Object object = new Object() ，这类引用只要还存在，垃圾收集器就永远不会回收掉这类引用的对象。 软引用：软引用用来描述一些虽然有用但是并不是必须的对象。对于软引用关联的对象，在系统将可能发生内存溢出异常之前，垃圾收集器将会把这些引用的对象进行第二次回收。只有这次垃圾回收还没有足够的内存的时候，才会抛出内存溢出异常。 弱引用：弱引用是一种比软引用强度还要弱的引用，因此这些引用的对象也是非必须的。但是，对于弱引用的对象只能生存到下一次垃圾回收发生之前。当垃圾收集工作开始后，无论当前的内存是否够用，都会把这些弱引用的对象回收掉。 虚引用：虚引用是最弱的一种引用。一个对象是否被虚引用关联，完全不会对其生存时间构成影响，也无法通过虚引用获得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 Notes：关于引用，最典型的使用就是对HashMap的自定义开发，包括JDK内部也存在。 Strong Reference—&gt; HashMap：默认情况下，HashMap使用的引用就是强引用，也就是说垃圾收集的时候，Map中引用的对象不会被GC掉。 Weak Reference—&gt; WeakHashMap：JDK中还有一种基于引用类型实现的HashMap，WeakHashMap。当节点的key不在被使用的时候，该entry就会被自动回收掉。因此，对于一个mapping映射，不能保证接下来的GC不会把这个entry回收掉。 Soft Reference—&gt; SoftHashMap：在JDK中没有提供基于软引用实现的HashMap，原因可能是一般大家都不能期待出现内存溢出，而当出现内存溢出，一点点的软引用GC余下的内存空间，肯定不会起到关键作用。但是，虽然不广泛，在aspectj提供的ClassLoaderRepository类中实现了SoftHashMap，作为一个基于ClassLoader字节码实现的方法，在OOM的时候，显然需要考虑通过GC释放内存空间，并且SoftHashMap在内部是作为缓存使用。 3.3 JMM可见性在Java一些小Tips博文中，简单地介绍了JMM模型，但是Java内存模型涉及了大量的规则内容指令。 什么叫可见性？ 可见性就是，当程序中一个线程修改了某个全局共享变量的值之后，其他使用该值的线程都可以获知，在随后他们读该共享变量的时候，查询的都是最新的改改修改的值。 在上一篇博文中，我们给出了内存模型访问的图。根据图可以了解，一个线程上修改共享变量，这个变量的最新的值不会立刻写入到共享内存中，还是暂时存放在线程本地缓存，然后某一时刻触发写入到共享内存中。可见性就是，当我们对共享变量修改的时候，立刻把新值同步到主内存中，然后该变量被读的时候从主内存获取最新的值确保所有对该变量的读取操作，总是获取最新最近修改的值。 为什么会有可见性问题？ 学过计算机组成原理的同学都知道，在现代CPU结构中，存在多级缓存架构，如下图所示： 同样，在Java虚拟机中分为两种内存： 123&gt; 主内存(Main Memory)：所有线程共享的内存区域，虚拟机内存的一部分。&gt; 工作内存(Working Memory)：线程自己操作的内存区域，线程直接无法访问对方的工作内存区域。 之所以分为两部分内存区域，原因和CPU很类似。为了线程可以快速访问操作变量，当线程全部直接操作共享内存，则会导致大量线程之间竞争等问题出现，影响效率。 关于Java中线程，工作内存，主内存之间的交互关系如下图（深入理解Java虚拟机配图）： 为了保证共享变量可见性，除了上篇博文中介绍的volatile之外，还有synchronized和final关键字。 synchronized：执行synchronized代码块时，在对变量执行unlock操作之前，一定会把此变量写入到主内存中。final：该关键字修饰的变量在构造函数中初始化完成之后（不考虑指针逃逸，变量初始化一半的问题），其他线程就可以看到这个final变量的值，并且由于变量不能修改，所以能确保可见性。 Notes：保证JMM可见性，并不代表确保变量的线程安全性！！！ 3.4 指令重排序重排序通常是编译器或者运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译期重排序和运行期重排序，分别对应编译时和运行时环境。 编译期重排序主要的原因是CPU导致的。在编译期的微指令翻译阶段，许多操作同时执行，并且执行的顺序是乱序的，所以有可能出现一条指令读一个寄存器的同时，另外一条指令正在对这个寄存器进行写操作。此外，翻译之后，就是重排序缓存阶段。不同的微指令在不同的执行单元中同时执行，而且每个执行单元都全速运行。只要当前微指令所需要的数据就绪，而且有空闲的执行单元，微指令就可以立即执行，有时甚至可以跳过前面还未就绪的微指令。通过这种方式，需要长时间运行的操作不会阻塞后面的操作，流水线阻塞带来的损失被极大的减小了。 运行期JVM会对指令进行重排序以提高程序性能，当然其会通过happens-before原则保证顺序执行语义，也就是不会随便对代码指令进行重排序。 借用一个例子说明（来源http://www.infoq.com/cn/articles/java-memory-model-2）： 12345678910111213141516class ReorderExample &#123;int a = 0;boolean flag = false;public void writer() &#123; a = 1; //1 flag = true; //2&#125;Public void reader() &#123; if (flag) &#123; //3 int i = a * a; //4 …… &#125;&#125;&#125; 上述的代码会造成很多的不同结果，由于数据的可见性问题，或者就是重排序。比如重排序后执行顺序如下，则会存在问题。 3.5 锁细化锁粒度细化，是所有保证线程安全的程序方法优化的必经之路。 这两年十分火的用于线程间通信的高性能消息组件，其虽然有很多创新的设计，但是很多优化的基本就是，锁细化，包括核心数据结构 Ringbuffer。剖析Disruptor:为什么会这么快？（一）Ringbuffer的特别之处 此外，在Linux内核2.6之后采用的RCU锁机制，本质上也是锁粒度细化。Linux 2.6内核中新的锁机制–RCU 在Java语言中，最经典的锁细化提高多线程并发性能的案例，就是ConcurrentHashMap，其采用多个segment，每个segment对应一个锁，来分散全局锁带来的性能损失。从而，当我们put某一个entry的时候，在实现的时候，一般只需要拥有某一个segment锁就可以完成。 关于普通的HashTable结构和ConcurrentHashMap结构，借用一张图来说明： 从结构上，可以很显而易见的看出两者的区别。所以，就锁这个层面上，concurrentHashMap就会比HashTable性能好。 3.6 Guava ListenableFuture接口我们强烈地建议你在代码中多使用ListenableFuture来代替JDK的 Future, 因为： 大多数Futures 方法中需要它。 转到ListenableFuture 编程比较容易。 Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和ListenableFuture的扩展方法。 创建ListenableFuture实例 首先需要创建ListeningExecutorService实例，Guava 提供了专门的方法把JDK中提供ExecutorService对象转换为ListeningExecutorService。然后通过submit方法就可以创建一个ListenableFuture实例了。 代码片段如下： 123456789101112131415ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));ListenableFuture explosion = service.submit(new Callable() &#123; public Explosion call() &#123; return pushBigRedButton(); &#125;&#125;);Futures.addCallback(explosion, new FutureCallback() &#123; // we want this handler to run immediately after we push the big red button! public void onSuccess(Explosion explosion) &#123; walkAwayFrom(explosion); &#125; public void onFailure(Throwable thrown) &#123; battleArchNemesis(); // escaped the explosion! &#125;&#125;); 也就是说，对于异步的方法，我可以通过监听器来根据执行结果来判断接下来的处理行为。 ListenableFuture 链式操作 使用ListenableFuture 最重要的理由是它可以进行一系列的复杂链式的异步操作。 一般，使用AsyncFunction来完成链式异步操作。不同的操作可以在不同的Executors中执行，单独的ListenableFuture 可以有多个操作等待。 Tips: AsyncFunction接口常被用于当我们想要异步的执行转换而不造成线程阻塞时，尽管Future.get()方法会在任务没有完成时造成阻塞，但是AsyncFunction接口并不被建议用来异步的执行转换，它常被用于返回Future实例。 下面给出这个链式操作完成一个简单的异步字符串转换操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import com.google.common.util.concurrent.AsyncFunction;import com.google.common.util.concurrent.FutureCallback;import com.google.common.util.concurrent.Futures;import com.google.common.util.concurrent.ListenableFuture;import com.google.common.util.concurrent.ListeningExecutorService;import com.google.common.util.concurrent.MoreExecutors;/** * @author tao.ke Date: 14-12-26 Time: 下午5:28 * @version \$Id$ */public class ListenerFutureChain &#123; private static final ExecutorService executor = Executors.newFixedThreadPool(2); private static final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(executor); public void executeChain() &#123; AsyncFunction&lt;String, String&gt; asyncFunction = new AsyncFunction&lt;String, String&gt;() &#123; @Override public ListenableFuture&lt;String&gt; apply(final String input) throws Exception &#123; ListenableFuture&lt;String&gt; future = executorService.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;STEP1 &gt;&gt;&gt;&quot; + Thread.currentThread().getName()); return input + &quot;|||step 1 ===--===||| &quot;; &#125; &#125;); return future; &#125; &#125;; AsyncFunction&lt;String, String&gt; asyncFunction2 = new AsyncFunction&lt;String, String&gt;() &#123; @Override public ListenableFuture&lt;String&gt; apply(final String input) throws Exception &#123; ListenableFuture&lt;String&gt; future = executorService.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; System.out.println(&quot;STEP2 &gt;&gt;&gt;&quot; + Thread.currentThread().getName()); return input + &quot;|||step 2 ===--===---||| &quot;; &#125; &#125;); return future; &#125; &#125;; ListenableFuture startFuture = executorService.submit(new Callable() &#123; @Override public Object call() throws Exception &#123; System.out.println(&quot;BEGIN &gt;&gt;&gt;&quot; + Thread.currentThread().getName()); return &quot;BEGIN---&gt;&quot;; &#125; &#125;); ListenableFuture future = Futures.transform(startFuture, asyncFunction, executor); ListenableFuture endFuture = Futures.transform(future, asyncFunction2, executor); Futures.addCallback(endFuture, new FutureCallback() &#123; @Override public void onSuccess(Object result) &#123; System.out.println(result); System.out.println(&quot;=======OK=======&quot;); &#125; @Override public void onFailure(Throwable t) &#123; t.printStackTrace(); &#125; &#125;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;========START=======&quot;); System.out.println(&quot;MAIN &gt;&gt;&gt;&quot; + Thread.currentThread().getName()); ListenerFutureChain chain = new ListenerFutureChain(); chain.executeChain(); System.out.println(&quot;========END=======&quot;); executor.shutdown(); // System.exit(0); &#125;&#125; 输出： 12345678========START=======MAIN &gt;&gt;&gt;mainBEGIN &gt;&gt;&gt;pool-2-thread-1========END=======STEP1 &gt;&gt;&gt;pool-2-thread-2STEP2 &gt;&gt;&gt;pool-2-thread-1BEGIN---&gt;|||step 1 ===--===||| |||step 2 ===--===---||| =======OK======= 从输出可以看出，代码是异步完成字符串操作的。 CacheBuilder实现写过Cache的，或者其他一些工具类的同学知道，为了让工具类更灵活，我们需要对外提供大量的参数配置给使用者设置，虽然这带有一些好处，但是由于参数太多，使用者开发构造对象的时候过于繁杂。 上面提到过参数配置过多，可以使用Builder模式。Guava Cache也一样，它为我们提供了CacheBuilder工具类来构造不同配置的Cache实例。但是，和本文上面提到的构造器实现有点不一样，它构造器返回的是另外一个对象，因此，这意味着在实现的时候，对象构造函数需要有Builder参数提供配置属性。 4.1 CacheBuilder构造LocalCache实现首先，我们先看看Cache的构造函数： 1234567891011121314151617181920212223242526272829303132333435/** * 从builder中获取相应的配置参数。 */LocalCache(CacheBuilder&lt;? super K, ? super V&gt; builder, @Nullable CacheLoader&lt;? super K, V&gt; loader) &#123; concurrencyLevel = Math.min(builder.getConcurrencyLevel(), MAX_SEGMENTS); keyStrength = builder.getKeyStrength(); valueStrength = builder.getValueStrength(); keyEquivalence = builder.getKeyEquivalence(); valueEquivalence = builder.getValueEquivalence(); maxWeight = builder.getMaximumWeight(); weigher = builder.getWeigher(); expireAfterAccessNanos = builder.getExpireAfterAccessNanos(); expireAfterWriteNanos = builder.getExpireAfterWriteNanos(); refreshNanos = builder.getRefreshNanos(); removalListener = builder.getRemovalListener(); removalNotificationQueue = (removalListener == NullListener.INSTANCE) ? LocalCache .&lt;RemovalNotification&lt;K, V&gt;&gt; discardingQueue() : new ConcurrentLinkedQueue&lt;RemovalNotification&lt;K, V&gt;&gt;(); ticker = builder.getTicker(recordsTime()); entryFactory = EntryFactory.getFactory(keyStrength, usesAccessEntries(), usesWriteEntries()); globalStatsCounter = builder.getStatsCounterSupplier().get(); defaultLoader = loader; int initialCapacity = Math.min(builder.getInitialCapacity(), MAXIMUM_CAPACITY); if (evictsBySize() &amp;&amp; !customWeigher()) &#123; initialCapacity = Math.min(initialCapacity, (int) maxWeight); &#125; //.......&#125; 从构造函数可以看到，Cache的所有参数配置都是从Builder对象中获取的，Builder完成了作为该模式最典型的应用，多配置参数构建对象。 在Cache中只提供一个构造函数，但是在上面代码示例中，我们演示了两种构建缓存的方式：自动加载；手动加载。那么，一般会存在一个完成两者之间的过渡adapter组件，接下来看看Builder在内部是如何完成创建缓存对象过程的。 OK，你猜到了。在LocalCache中确实提供了两种过渡类，一个是支持自动加载value的LocalLoadingCache 和只能在键值找不到的时候手动调用获取值方法的LocalManualCache。 LocalManualCache实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static class LocalManualCache&lt;K, V&gt; implements Cache&lt;K, V&gt;, Serializable &#123; final LocalCache&lt;K, V&gt; localCache; LocalManualCache(CacheBuilder&lt;? super K, ? super V&gt; builder) &#123; this(new LocalCache&lt;K, V&gt;(builder, null)); &#125; private LocalManualCache(LocalCache&lt;K, V&gt; localCache) &#123; this.localCache = localCache; &#125; // Cache methods @Override @Nullable public V getIfPresent(Object key) &#123; return localCache.getIfPresent(key); &#125; @Override public V get(K key, final Callable&lt;? extends V&gt; valueLoader) throws ExecutionException &#123; checkNotNull(valueLoader); return localCache.get(key, new CacheLoader&lt;Object, V&gt;() &#123; @Override public V load(Object key) throws Exception &#123; return valueLoader.call(); &#125; &#125;); &#125; //...... @Override public CacheStats stats() &#123; SimpleStatsCounter aggregator = new SimpleStatsCounter(); aggregator.incrementBy(localCache.globalStatsCounter); for (Segment&lt;K, V&gt; segment : localCache.segments) &#123; aggregator.incrementBy(segment.statsCounter); &#125; return aggregator.snapshot(); &#125; // Serialization Support private static final long serialVersionUID = 1; Object writeReplace() &#123; return new ManualSerializationProxy&lt;K, V&gt;(localCache); &#125;&#125; 从代码实现看出实际上是一个adapter组件，并且绝大部分实现都是直接调用LocalCache的方法，或者加一些参数判断和聚合。在它核心的构造函数中，就是直接调用LocalCache构造函数，对于loader对象直接设null值。 LocalLoadingCache实现 LocalLoadingCache实现继承了类，其主要对get相关方法做了重写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static class LocalLoadingCache&lt;K, V&gt; extends LocalManualCache&lt;K, V&gt; implements LoadingCache&lt;K, V&gt; &#123; LocalLoadingCache(CacheBuilder&lt;? super K, ? super V&gt; builder, CacheLoader&lt;? super K, V&gt; loader) &#123; super(new LocalCache&lt;K, V&gt;(builder, checkNotNull(loader))); &#125; // LoadingCache methods @Override public V get(K key) throws ExecutionException &#123; return localCache.getOrLoad(key); &#125; @Override public V getUnchecked(K key) &#123; try &#123; return get(key); &#125; catch (ExecutionException e) &#123; throw new UncheckedExecutionException(e.getCause()); &#125; &#125; @Override public ImmutableMap&lt;K, V&gt; getAll(Iterable&lt;? extends K&gt; keys) throws ExecutionException &#123; return localCache.getAll(keys); &#125; @Override public void refresh(K key) &#123; localCache.refresh(key); &#125; @Override public final V apply(K key) &#123; return getUnchecked(key); &#125; // Serialization Support private static final long serialVersionUID = 1; @Override Object writeReplace() &#123; return new LoadingSerializationProxy&lt;K, V&gt;(localCache); &#125; &#125;&#125; 提供了这些adapter类之后，builder类就可以创建LocalCache，如下： 123456789101112 // 获取value可以通过key计算出public &lt;K1 extends K, V1 extends V&gt; LoadingCache&lt;K1, V1&gt; build(CacheLoader&lt;? super K1, V1&gt; loader) &#123; checkWeightWithWeigher(); return new LocalCache.LocalLoadingCache&lt;K1, V1&gt;(this, loader); &#125; // 手动加载 public &lt;K1 extends K, V1 extends V&gt; Cache&lt;K1, V1&gt; build() &#123; checkWeightWithWeigher(); checkNonLoadingCache(); return new LocalCache.LocalManualCache&lt;K1, V1&gt;(this); &#125; 4.2 CacheBuilder参数设置CacheBuilder在为我们提供了构造一个Cache对象时，会构造各个成员对象的初始值（默认值）。了解这些默认值，对于我们分析Cache源码实现时，一些判断条件的设置原因，还是很有用的。 初始参数值设置 在ConcurrentHashMap中，我们知道有个并发水平（CONCURRENCY_LEVEL），这个参数决定了其允许多少个线程并发操作修改该数据结构。这是因为这个参数是最后map使用的segment个数，而每个segment对应一个锁，因此，对于一个map来说，并发环境下，理论上最大可以有segment个数的线程同时安全地操作修改数据结构。那么是不是segment的值可以设置很大呢？显然不是，要记住维护一个锁的成本还是挺高的，此外如果涉及全表操作，那么性能就会非常不好了。 其他一些初始参数值的设置如下所示： 12345678910111213private static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认的初始化Map大小private static final int DEFAULT_CONCURRENCY_LEVEL = 4; // 默认并发水平private static final int DEFAULT_EXPIRATION_NANOS = 0; // 默认超时private static final int DEFAULT_REFRESH_NANOS = 0; // 默认刷新时间static final int UNSET_INT = -1;boolean strictParsing = true;int initialCapacity = UNSET_INT;int concurrencyLevel = UNSET_INT;long maximumSize = UNSET_INT;long maximumWeight = UNSET_INT;long expireAfterWriteNanos = UNSET_INT;long expireAfterAccessNanos = UNSET_INT;long refreshNanos = UNSET_INT; 初始对象引用设置 在Cache中，我们除了超时时间，键值引用属性等设置外，还关注命中统计情况，这就需要统计对象来工作。CacheBuilder提供了初始的null 统计对象和空统计对象。 此外，还会设置到默认的引用类型等设置，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 默认空的缓存命中统计类 */ static final Supplier&lt;? extends StatsCounter&gt; NULL_STATS_COUNTER = Suppliers.ofInstance(new StatsCounter() &#123; //......省略空override @Override public CacheStats snapshot() &#123; return EMPTY_STATS; &#125; &#125;); static final CacheStats EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);// 初始状态的统计对象 /** * 系统实现的简单的缓存状态统计类 */ static final Supplier&lt;StatsCounter&gt; CACHE_STATS_COUNTER = new Supplier&lt;StatsCounter&gt;() &#123; @Override public StatsCounter get() &#123; return new SimpleStatsCounter();//这里构造简单地统计类实现 &#125; &#125;; /** * 自定义的空RemovalListener，监听到移除通知，默认空处理。 */ enum NullListener implements RemovalListener&lt;Object, Object&gt; &#123; INSTANCE; @Override public void onRemoval(RemovalNotification&lt;Object, Object&gt; notification) &#123; &#125; &#125; /** * 默认权重类，任何对象的权重均为1 */ enum OneWeigher implements Weigher&lt;Object, Object&gt; &#123; INSTANCE; @Override public int weigh(Object key, Object value) &#123; return 1; &#125; &#125; static final Ticker NULL_TICKER = new Ticker() &#123; @Override public long read() &#123; return 0; &#125; &#125;; /** * 默认的key等同判断 * @return */ Equivalence&lt;Object&gt; getKeyEquivalence() &#123; return firstNonNull(keyEquivalence, getKeyStrength().defaultEquivalence()); &#125; /** * 默认value的等同判断 * @return */ Equivalence&lt;Object&gt; getValueEquivalence() &#123; return firstNonNull(valueEquivalence, getValueStrength().defaultEquivalence()); &#125; /** * 默认的key引用 * @return */ Strength getKeyStrength() &#123; return firstNonNull(keyStrength, Strength.STRONG); &#125; /** * 默认为Strong 属性的引用 * @return */ Strength getValueStrength() &#123; return firstNonNull(valueStrength, Strength.STRONG); &#125; &lt;K1 extends K, V1 extends V&gt; Weigher&lt;K1, V1&gt; getWeigher() &#123; return (Weigher&lt;K1, V1&gt;) Objects.firstNonNull(weigher, OneWeigher.INSTANCE); &#125; 其中，在我们不设置缓存中键值引用的情况下，默认都是采用强引用及相对应的属性策略来初始化的。此外，在上面代码中还可以看到，统计类SimpleStatsCounter是一个简单的实现。里面主要是简单地缓存累加，此外由于多线程下Long类型的线程非安全性，所以也进行了一下封装，下面给出命中率的实现： 12345678910111213141516171819202122232425262728public static final class SimpleStatsCounter implements StatsCounter &#123; private final LongAddable hitCount = LongAddables.create(); private final LongAddable missCount = LongAddables.create(); private final LongAddable loadSuccessCount = LongAddables.create(); private final LongAddable loadExceptionCount = LongAddables.create(); private final LongAddable totalLoadTime = LongAddables.create(); private final LongAddable evictionCount = LongAddables.create(); public SimpleStatsCounter() &#123;&#125; @Override public void recordHits(int count) &#123; hitCount.add(count); &#125; @Override public CacheStats snapshot() &#123; return new CacheStats( hitCount.sum()); &#125; /** * Increments all counters by the values in &#123;@code other&#125;. */ public void incrementBy(StatsCounter other) &#123; CacheStats otherStats = other.snapshot(); hitCount.add(otherStats.hitCount()); &#125;&#125; 因此，CacheBuilder的一些参数对象等得初始化就完成了。可以看到这些默认的初始化，有两套引用：Null对象和Empty对象，显然Null会更省空间，但我们在创建的时候将决定不使用某特性的时候，就会使用Null来创建，否则使用Empty来完成初始化工作。在分析Cache的时候，写后超时队列和读后超时队列也存在两个版本。 LocalCache实现在设计实现上，LocalCache的并发策略和concurrentHashMap的并发策略是一致的，也是根据分段锁来提高并发能力,分段锁可以很好的保证 并发读写的效率。因此，该map支持非阻塞读和不同段之间并发写。 如果最大的大小指定了，那么基于段来执行操作是最好的。使用页面替换算法来决定当map大小超过指定值时，哪些entries需要被驱赶出去。页面替换算法的数据结构保证Map临时一致性：对一个segment写排序是一致的；但是对map进行更新和读不能直接立刻 反应在数据结构上。 虽然这些数据结构被lock锁保护，但是其结构决定了批量操作可以避免锁竞争出现。在线程之间传播的批量操作导致分摊成本比不强制大小限制的操作要稍微高一点。 此外，LoacalCache使用LRU页面替换算法，是因为该算法简单，并且有很高的命中率，以及O(1)的时间复杂度。需要说明的是， LRU算法是基于页面而不是全局实现的，所以可能在命中率上不如全局LRU算法，但是应该基本相似。 最后，要说明一点，在代码实现上，页面其实就是一个段segment。之所以说page页，是因为在计算机专业课程上，CPU，操作系统，算法上，基本上都介绍过分页导致优化效果的提升。 5.1 总体数据结构LocalCache的数据结构和ConcurrentHashMap一样，都是采用分segment来细化管理HashMap中的节点Entry。借用ConcurrentHashMap的数据结构图来说明Cache的实现： 从图中可以直观看到cache是以segment粒度来控制并发get和put等操作的，接下来首先看我们的LocalCache是如何构造这些segment段的，继续上面初始化localCache构造函数的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 找到大于并发水平的最小2的次方的值，作为segment数量 int segmentShift = 0; int segmentCount = 1; while (segmentCount &lt; concurrencyLevel &amp;&amp; (!evictsBySize() || segmentCount * 20 &lt;= maxWeight)) &#123; ++segmentShift; segmentCount &lt;&lt;= 1; &#125; this.segmentShift = 32 - segmentShift;//位 偏移数 segmentMask = segmentCount - 1;//mask码 this.segments = newSegmentArray(segmentCount);// 构造数据数组，如上图所示 //获取每个segment初始化容量，并且保证大于等于map初始容量 int segmentCapacity = initialCapacity / segmentCount; if (segmentCapacity * segmentCount &lt; initialCapacity) &#123; ++segmentCapacity; &#125; //段Size 必须为2的次数，并且刚刚大于段初始容量 int segmentSize = 1; while (segmentSize &lt; segmentCapacity) &#123; segmentSize &lt;&lt;= 1; &#125; // 权重设置，确保权重和==map权重 if (evictsBySize()) &#123; // Ensure sum of segment max weights = overall max weights long maxSegmentWeight = maxWeight / segmentCount + 1; long remainder = maxWeight % segmentCount; for (int i = 0; i &lt; this.segments.length; ++i) &#123; if (i == remainder) &#123; maxSegmentWeight--; &#125; //构造每个段结构 this.segments[i] = createSegment(segmentSize, maxSegmentWeight, builder.getStatsCounterSupplier().get()); &#125; &#125; else &#123; for (int i = 0; i &lt; this.segments.length; ++i) &#123; //构造每个段结构 this.segments[i] = createSegment(segmentSize, UNSET_INT, builder.getStatsCounterSupplier().get()); &#125; &#125; Notes：基本上都是基于2的次数来设置大小的，显然基于移位操作比普通计算操作速度要快。此外，对于最大权重分配到段权重的设计上，很特殊。为什么呢？为了保证两者能够相等（maxWeight==sumAll(maxSegmentWeight)）,对于remainder前面的segment maxSegmentWeight的值比remainder后面的权重值大1，这样保证最后值相等。 map get 方法 123456789@Override@Nullablepublic V get(@Nullable Object key) &#123; if (key == null) &#123; return null; &#125; int hash = hash(key); return segmentFor(hash).get(key, hash);&#125; Notes：代码很简单，首先check key是否为null，然后计算hash值，定位到对应的segment，执行segment实例拥有的get方法获取对应的value值 map put 方法 1234567@Override public V put(K key, V value) &#123; checkNotNull(key); checkNotNull(value); int hash = hash(key); return segmentFor(hash).put(key, hash, value, false); &#125; Notes：和get方法一样，也是先check值，然后计算key的hash值，然后定位到对应的segment段，执行段实例的put方法，将键值存入map中。 map isEmpty 方法 123456789101112131415161718192021222324@Overridepublic boolean isEmpty() &#123; long sum = 0L; Segment&lt;K, V&gt;[] segments = this.segments; for (int i = 0; i &lt; segments.length; ++i) &#123; if (segments[i].count != 0) &#123; return false; &#125; sum += segments[i].modCount; &#125; if (sum != 0L) &#123; // recheck unless no modifications for (int i = 0; i &lt; segments.length; ++i) &#123; if (segments[i].count != 0) &#123; return false; &#125; sum -= segments[i].modCount; &#125; if (sum != 0L) &#123; return false; &#125; &#125; return true;&#125; Notes：判断Cache是否为空，就是分别判断每个段segment是否都为空，但是由于整体是在并发环境下进行的，也就是说存在对一个segment并发的增加和移除元素的时候，而我们此时正在check其他segment段。 上面这种情况，决定了我们不能够获得任何一个时间点真实段状态的情况。因此，上面的代码引入了sum变量来计算段modCount变更情况。modCount表示改变segment大小size的更新次数，这个在批量读取方法期间保证它们可以看到一致性的快照。需要注意，这里先获取count，该值是volatile，因此modCount通常都可以在不需要一致性控制下，获得当前segment最新的值. 在判断如果在第一次check的时候，发现segment发生了数据结构级别变更，则会进行recheck，就是在每个modCount下，段仍然是空的，则判断该map为空。如果发现这期间数据结构发生变化，则返回非空判断。 map 其他方法 在Cache数据结构中，还有很多方法，和上面列出来的方法一样，其底层核心实现都是依赖segment类实例中实现的对应方法。 此外，在总的数据结构中，还提供了一些根据builder配制制定相应地缓存策略方法。比如： expiresAfterAccess：是否执行访问后超时过期策略； expiresAfterWrite：是否执行写后超时过期策略； usesAccessQueue：根据上面的配置决定是否需要new一个访问队列； usesWriteQueue：根据上面的配置决定是否需要new一个写队列； usesKeyReferences/usesValueReferences：是否需要使用特别的引用策略(非Strong引用). 等等…… 5.2 引用数据结构在介绍Segment数据结构之前，先讲讲Cache中引用的设计。 关于Reference引用的一些说明，在博文的上面已经介绍了，这里就不赘述。在Guava Cache 中，主要使用三种引用类型，分别是：STRONG引用，SOFT引用 ，WEAK引用。和Map不同，在Cache中，使用ReferenceEntry来封装键值对，并且对于值来说，还额外实现了ValueReference引用对象来封装对应Value对象。 ReferenceEntry节点结构 为了支持各种不同类型的引用，以及不同过期策略，这里构造了一个ReferenceEntry节点结构。通过下面的节点数据结构，可以清晰的看到缓存大致操作流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 引用map中一个entry节点。 * * 在map中得entries节点有下面几种状态： * valid：-live：设置了有效的key/value;-loading：加载正在处理中.... * invalid：-expired：时间过期(但是key/value可能仍然设置了)；Collected：key/value部分被垃圾收集了，但是还没有被清除； * -unset：标记为unset，表示等待清除或者重新使用。 * */interface ReferenceEntry&lt;K, V&gt; &#123; /** * 从entry中返回value引用 */ ValueReference&lt;K, V&gt; getValueReference(); /** * 为entry设置value引用 */ void setValueReference(ValueReference&lt;K, V&gt; valueReference); /** * 返回链中下一个entry（解决hash碰撞存在链表） */ @Nullable ReferenceEntry&lt;K, V&gt; getNext(); /** * 返回entry的hash */ int getHash(); /** * 返回entry的key */ @Nullable K getKey(); /* * Used by entries that use access order. Access entries are maintained in a doubly-linked list. New entries are * added at the tail of the list at write time; stale entries are expired from the head of the list. */ /** * 返回该entry最近一次被访问的时间ns */ long getAccessTime(); /** * 设置entry访问时间ns. */ void setAccessTime(long time); /** * 返回访问队列中下一个entry */ ReferenceEntry&lt;K, V&gt; getNextInAccessQueue(); /** * Sets the next entry in the access queue. */ void setNextInAccessQueue(ReferenceEntry&lt;K, V&gt; next); /** * Returns the previous entry in the access queue. */ ReferenceEntry&lt;K, V&gt; getPreviousInAccessQueue(); /** * Sets the previous entry in the access queue. */ void setPreviousInAccessQueue(ReferenceEntry&lt;K, V&gt; previous); // ...... 省略write队列相关方法，和access一样&#125; Notes：从上面代码可以看到除了和Map一样，有key、value、hash和next四个属性之外，还有访问和写更新两个双向链表队列，以及entry的最近访问时间和最近更新时间。显然，多出来的属性就是为了支持缓存必须要有的过期机制。 此外，从上面的代码可以看出cache支持的LRU机制实际上是建立在segment上的，也就是基于页的替换机制。 关于访问队列数据结构，其实质就是一个双向的链表。当节点被访问的时候，这个节点将会移除，然后把这个节点添加到链表的结尾。关于具体实现，将在segment中介绍。 创建不同类型的ReferenceEntry由其枚举工厂类EntryFactory来实现，它根据key的Strength类型、是否使用accessQueue、是否使用writeQueue来决定不同的EntryFactry实例，并通过它创建相应的ReferenceEntry实例 ValueReference结构 同样为了支持Cache中各个不同类型的引用，其对Value类型进行再封装，支持引用。看看其内部数据属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * A reference to a value. */interface ValueReference&lt;K, V&gt; &#123; /** * Returns the value. Does not block or throw exceptions. */ @Nullable V get(); /** * Waits for a value that may still be loading. Unlike get(), this method can block (in the case of * FutureValueReference). * * @throws ExecutionException if the loading thread throws an exception * @throws ExecutionError if the loading thread throws an error */ V waitForValue() throws ExecutionException; /** * Returns the weight of this entry. This is assumed to be static between calls to setValue. */ int getWeight(); /** * Returns the entry associated with this value reference, or &#123;@code null&#125; if this value reference is * independent of any entry. */ @Nullable ReferenceEntry&lt;K, V&gt; getEntry(); /** * 为一个指定的entry创建一个该引用的副本 * &lt;p&gt; * &#123;@code value&#125; may be null only for a loading reference. */ ValueReference&lt;K, V&gt; copyFor(ReferenceQueue&lt;V&gt; queue, @Nullable V value, ReferenceEntry&lt;K, V&gt; entry); /** * 告知一个新的值正在加载中。这个只会关联到加载值引用。 */ void notifyNewValue(@Nullable V newValue); /** * 当一个新的value正在被加载的时候，返回true。不管是否已经有存在的值。这里加锁方法返回的值对于给定的ValueReference实例来说是常量。 * */ boolean isLoading(); /** * 返回true，如果该reference包含一个活跃的值,意味着在cache里仍然有一个值存在。活跃的值包含：cache查找返回的，等待被移除的要被驱赶的值； 非激活的包含：正在加载的值， */ boolean isActive();&#125; Notes：value引用接口对象中包含了不同状态的标记，以及一些加载方法和获取具体value值对象。 为了减少不必须的load加载，在value引用中增加了loading标识和wait方法等待加载获取值。这样，就可以等待上一个调用loader方法获取值，而不是重复去调用loader方法加重系统负担，而且可以更快的获取对应的值。 此外，介绍下ReferenceQueue引用队列，这个队列是JDK提供的，在检测到适当的可到达性更改后，垃圾回收器将已注册的引用对象添加到该队列中。因为Cache使用了各种引用，而通过ReferenceQueue这个“监听器”就可以优雅的实现自动删除那些引用不可达的key了，是不是很吊，哈哈。 在Cache分别实现了基于Strong,Soft，Weak三种形式的ValueReference实现。 这里ValueReference之所以要有对ReferenceEntry的引用是因为在Value因为WeakReference、SoftReference被回收时，需要使用其key将对应的项从Segment段中移除； copyFor()函数的存在是因为在expand(rehash)重新创建节点时，对WeakReference、SoftReference需要重新创建实例（C++中的深度复制思想，就是为了保持对象状态不会相互影响），而对强引用来说，直接使用原来的值即可，这里很好的展示了对彼变化的封装思想； notifiyNewValue只用于LoadingValueReference，它的存在是为了对LoadingValueReference来说能更加及时的得到CacheLoader加载的值。 5.3 Segment 数据结构Segment数据结构，是ConcurrentHashMap的核心实现，也是该结构保证了其算法的高效性。在Guava Cache中也一样，segment数据结构保证了缓存在线程安全的前提下可以高效地更新，插入，获取对应value。 实际上，segment就是一个特殊版本的hash table实现。其内部也是对应一个锁，不同的是，对于get和put操作做了一些优化处理。因此，在代码实现的时候，为了快速开发和利用已有锁特性，直接extends ReentrantLock。 在segment中，其主要的类属性就是一个LoacalCache类型的map变量。关于segment实现说明，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * segments 维护一个entry列表的table，确保一致性状态。所以可以不加锁去读。节点的next field是不可修改的final，因为所有list的增加操作 * 是执行在每个容器的头部。因此，这样子很容易去检查变化，也可以快速遍历。此外，当节点被改变的时候，新的节点将被创建然后替换它们。 由于容器的list一般都比较短（平均长度小于2），所以对于hash * tables来说，可以工作的很好。虽然说读操作因此可以不需要锁进行，但是是依赖 * 使用volatile确保其他线程完成写操作。对于绝大多数目的而言，count变量，跟踪元素的数量，其作为一个volatile变量确保可见性（其内部原理可以参考其他相关博文）。 * 这样一下子变得方便的很多，因为这个变量在很多读操作的时候都会被获取：所有非同步的（unsynchronized）读操作必须首先读取这个count值，并且如果count为0则不会 查找table * 的entries元素；所有的同步（synchronized）操作必须在结构性的改变任务bin容器之后，才会写操作这个count值。 * 这些操作必须在并发读操作看到不一致的数据的时候，不采取任务动作。在map中读操作性质可以更容易实现这个限制。例如：没有操作可以显示出 当table * 增长了，但是threshold值没有更新，所以考虑读的时候不要求原子性。作为一个原则，所有危险的volatile读和写count变量都必须在代码中标记。 */final LocalCache&lt;K, V&gt; map;/** * 该segment区域内所有存活的元素个数 */volatile int count;/** * 改变table大小size的更新次数。这个在批量读取方法期间保证它们可以看到一致性的快照： * 如果modCount在我们遍历段加载大小或者核对containsValue期间被改变了，然后我们会看到一个不一致的状态视图，以至于必须去重试。 * count+modCount 保证内存一致性 * * 感觉这里有点像是版本控制，比如数据库里的version字段来控制数据一致性 */int modCount;/** * 每个段表，使用乐观锁的Array来保存entry The per-segment table. */volatile AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table; // 这里和concurrentHashMap不一致，原因是这边元素是引用，直接使用不会线程安全/** * A queue of elements currently in the map, ordered by write time. Elements are added to the tail of the queue * on write. */@GuardedBy(&quot;Segment.this&quot;)final Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;/** * A queue of elements currently in the map, ordered by access time. Elements are added to the tail of the queue * on access (note that writes count as accesses). */@GuardedBy(&quot;Segment.this&quot;)final Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue; Notes： 在segment实现中，很多地方使用count变量和modCount变量来保持线程安全，从而省掉lock开销。 在本文上面的图中说明了每个segment就是一个节点table，和jdk实现不一致，这里为了GC，内部维护的是一个AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;类型的列表，可以保证安全性。 最后，LocalCache作为一个缓存，其必须具有访问和写超时特性，因为其内部维护了访问队列和写队列，队列中的元素按照访问或者写时间排序，新的元素会被添加到队列尾部。如果，在队列中已经存在了该元素，则会先delete掉，然后再尾部add该节点，新的时间。这也就是为什么，对于LocalCache而言，其LRU是针对segment的，而不是全Cache范围的。 在本文的 5.2节中知道，cache会根据初始化实例时配置来创建多个segment（createSegment），然后该方法最终调用segment类的构造函数创建一个段。对于参数set，就不展示，看看构造方法中其主要操作： 1234567891011121314151617// 构造函数 Segment(LocalCache&lt;K, V&gt; map, int initialCapacity, long maxSegmentWeight, StatsCounter statsCounter) &#123; initTable(newEntryArray(initialCapacity)); &#125; AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newEntryArray(int size) &#123; return new AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt;(size); &#125; void initTable(AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newTable) &#123; this.threshold = newTable.length() * 3 / 4; // 0.75 if (!map.customWeigher() &amp;&amp; this.threshold == maxSegmentWeight) &#123; // prevent spurious expansion before eviction this.threshold++; &#125; this.table = newTable; &#125; OK，这里我们已经构造好了整个localCache对象了，包括其内部每个segment中对应的节点表。这些节点table，决定了最后所有核心操作的具体实现和操作结果。 接下来，需要看看最核心的几个方法。 Tips：本文把这几个方法单独作为几节来说明，这也表示这几个方法的重要性。 5.4 GET方法实现首先，如果我们从一个列表中查找对象，怎么做？ 1231. 列表元素个数是否为0；2. 如果非0，则依次查询列表中元素是否是我们的对象。 然后，如果是考虑超时策略的缓存呢？ 12345671. 缓存列表元素个数是否为0；2. 如果非0，则依次查询列表中元素是否是我们的对象；3. 查看队列中该对象是否已过期，如果过期则考虑其他方式获取。4. 此外，为了线程安全，必须在获取的时候，锁住表不让更新缓存操作。 接下来是，LocalCache的缓存应该怎么做？ 12345678910111. 缓存中元素个数volatile count是否为0；2. 如果非0，则获取我们需要的对象引用【getEntry(key, hash)】；3. 如果对象引用不为null,则获取对应的value值；4. 如果value已经过期或者无效，则判断是否在Loading【scheduleRefresh(e, key, hash, value, now, loader)】,否则，判断是否到了refresh时间;5. 如果设置refresh，则异步刷新查询value，然后等待返回最新value【scheduleRefresh(e, key, hash, value, now, loader)】;6. ok，这里如果value还没有拿到，则查询loader方法获取对应的值(存在加锁)【lockedGetOrLoad(key, hash, loader)】。 上面就是get方法的主要流程，对于其中一些核心的方法进行分析解析： getEntry方法 1234567891011121314151617181920212223242526272829303132333435@NullableReferenceEntry&lt;K, V&gt; getEntry(Object key, int hash) &#123; // hash链表 for (ReferenceEntry&lt;K, V&gt; e = getFirst(hash); e != null; e = e.getNext()) &#123; if (e.getHash() != hash) &#123; continue; &#125; // hash值相同的，接下来找key值也相同的ReferenceEntry K entryKey = e.getKey(); if (entryKey == null) &#123; tryDrainReferenceQueues();//线程安全的清除搜集到的entries，使用lock机制。 continue; &#125; if (map.keyEquivalence.equivalent(key, entryKey)) &#123; return e; &#125; &#125; return null;&#125;/** * AtomicReferenceArray 可以确保原子的更新引用的元素。 * * 为给定的hash值返回第一个entry节点. */ReferenceEntry&lt;K, V&gt; getFirst(int hash) &#123; // 复制到线程安全的数组中，形成一个快照，确保读的时候，数据一致性。只会读取这个域一次。 // 此外，这样子可以提供读对于整个table的影响，因为全局的table并不会锁住。（猜测） AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table; return table.get(hash &amp; (table.length() - 1));&#125; Notes：上面从缓存中直接获取key对应value，是完全没有加锁来完成的。 scheduleRefresh方法 如果配置refresh特性，到了配置的刷新间隔时间，而且节点也没有正在加载，则应该进行refresh操作。refresh操作比较复杂。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 刷新和key关联的value值，除非另一个线程正在做这个。如果在内部刷新了，则返回和key关联的value，否则如果另一个线程正在 * 刷新或者出现error则返回null */ @Nullable V refresh(K key, int hash, CacheLoader&lt;? super K, V&gt; loader, boolean checkTime) &#123; // loadingValueReference表明当前线程开始加载，获取key对于的value引用。 final LoadingValueReference&lt;K, V&gt; loadingValueReference = insertLoadingValueReference(key, hash, checkTime); if (loadingValueReference == null) &#123; return null; &#125; // 如果说本线程启动加载，则开始异步调用，等待future返回get获取一个监听listenableFuture（见本文准备知识部分介绍），然后等待返回value值。loader相关方法随后介绍 ListenableFuture&lt;V&gt; result = loadAsync(key, hash, loadingValueReference, loader); if (result.isDone()) &#123; try &#123; return Uninterruptibles.getUninterruptibly(result); &#125; catch (Throwable t) &#123; // don&apos;t let refresh exceptions propagate; error was already logged &#125; &#125; return null; &#125; /** * 返回一个本线程新插入的LoadingValueReference对象，或者如果一个活跃的value引用已经被加载了，则返回null */ @Nullable LoadingValueReference&lt;K, V&gt; insertLoadingValueReference(final K key, final int hash, boolean checkTime) &#123; ReferenceEntry&lt;K, V&gt; e = null; // 加锁，保证只有一个线程对segment refresh操作 lock(); try &#123; long now = map.ticker.read(); preWriteCleanup(now); // 快照保证 AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table; int index = hash &amp; (table.length() - 1); ReferenceEntry&lt;K, V&gt; first = table.get(index); // 查找一个存在的entry节点，和上面的getEntry方法基本一致。 for (e = first; e != null; e = e.getNext()) &#123; K entryKey = e.getKey(); if (e.getHash() == hash &amp;&amp; entryKey != null &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123; // 如果存在我们想要的节点 ValueReference&lt;K, V&gt; valueReference = e.getValueReference(); if (valueReference.isLoading() || (checkTime &amp;&amp; (now - e.getWriteTime() &lt; map.refreshNanos))) &#123; // 如果loading正在处理，并且发现该节点引用的写时间未超期刷新周期，则返回null return null; &#125; // continue returning old value while loading ++modCount; LoadingValueReference&lt;K, V&gt; loadingValueReference = new LoadingValueReference&lt;K, V&gt;( valueReference);//使用老的值引用 e.setValueReference(loadingValueReference); return loadingValueReference; &#125; &#125; ++modCount; LoadingValueReference&lt;K, V&gt; loadingValueReference = new LoadingValueReference&lt;K, V&gt;(); e = newEntry(key, hash, first);//一个新的节点，存放的hash链头部 e.setValueReference(loadingValueReference); table.set(index, e);// 插入到列表中 return loadingValueReference;//返回新的值引用 &#125; finally &#123; unlock(); postWriteCleanup(); &#125; &#125; lockedGetOrLoad方法 如方法名所见，该方法是加锁加载key对应的值引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 这里开始从我们实现cacheLoader继承类中的load方法获取 key对应的值。 * * 加锁get或者load */ V lockedGetOrLoad(K key, int hash, CacheLoader&lt;? super K, V&gt; loader) throws ExecutionException &#123; ReferenceEntry&lt;K, V&gt; e; ValueReference&lt;K, V&gt; valueReference = null; LoadingValueReference&lt;K, V&gt; loadingValueReference = null; boolean createNewEntry = true; // 确保线程安全，使用加锁来确保加载。当然这个也是针对segment粒度来加的 lock(); try &#123; // re-read ticker once inside the lock long now = map.ticker.read(); preWriteCleanup(now);// 加锁清GC遗留引用数据和超时数据 int newCount = this.count - 1; AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table; int index = hash &amp; (table.length() - 1);// 根据hash和table长度来确定index索引 ReferenceEntry&lt;K, V&gt; first = table.get(index); for (e = first; e != null; e = e.getNext()) &#123; K entryKey = e.getKey(); if (e.getHash() == hash &amp;&amp; entryKey != null &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123; valueReference = e.getValueReference(); if (valueReference.isLoading()) &#123; createNewEntry = false;// 如果正在加载，则返回false，表示不需要新建entry &#125; else &#123; // 对value进行判断处理， V value = valueReference.get(); if (value == null) &#123; // 相关通知操作，GC原因回收了 enqueueNotification(entryKey, hash, valueReference, RemovalCause.COLLECTED); &#125; else if (map.isExpired(e, now)) &#123; // This is a duplicate check, as preWriteCleanup already purged expired // entries, but let&apos;s accomodate an incorrect expiration queue. enqueueNotification(entryKey, hash, valueReference, RemovalCause.EXPIRED); &#125; else &#123; // cache存在value，命中缓存 recordLockedRead(e, now); statsCounter.recordHits(1); // we were concurrent with loading; don&apos;t consider refresh return value; &#125; // 最后写count，保证前面的变量操作，对内存立刻可见 writeQueue.remove(e); accessQueue.remove(e); this.count = newCount; // write-volatile &#125; break; &#125; &#125; // 处理需要新增entry，从load方法获取的逻辑 if (createNewEntry) &#123; loadingValueReference = new LoadingValueReference&lt;K, V&gt;(); if (e == null) &#123; e = newEntry(key, hash, first);// segment神马都没有的时候，新建一个 e.setValueReference(loadingValueReference); table.set(index, e); &#125; else &#123; e.setValueReference(loadingValueReference); &#125; &#125; &#125; finally &#123; unlock(); postWriteCleanup(); &#125; // ok,上面加锁部分建完了新的entry，设置完valueReference if (createNewEntry) &#123; try &#123; // 在entry同步，但检测到递归load则会快速失败。当entry被copy时候可能绕行，但是绝大部分时间会快速失败 synchronized (e) &#123; return loadSync(key, hash, loadingValueReference, loader); &#125; &#125; finally &#123; statsCounter.recordMisses(1);// 处理命中率 &#125; &#125; else &#123; // 如果正在加载，则等待加载完成 // The entry already exists. Wait for loading. return waitForLoadingValue(e, key, valueReference); &#125; &#125; Tips：不管是lockget还是refresh，最后都会调用不同的load方法，只不过refresh使用loadingFuture.addListener方式来异步加载值而已。其最后都会调用getAndRecordStats方法。 12345678910111213141516171819V getAndRecordStats(K key, int hash, LoadingValueReference&lt;K, V&gt; loadingValueReference, ListenableFuture&lt;V&gt; newValue) throws ExecutionException &#123; V value = null; try &#123; value = getUninterruptibly(newValue);// 非中断方式调用future.get方法获取值 if (value == null) &#123; throw new InvalidCacheLoadException(&quot;CacheLoader returned null for key &quot; + key + &quot;.&quot;); &#125; statsCounter.recordLoadSuccess(loadingValueReference.elapsedNanos()); //线程安全地把key和value存放到cache中。 storeLoadedValue(key, hash, loadingValueReference, value); return value; &#125; finally &#123; if (value == null) &#123; statsCounter.recordLoadException(loadingValueReference.elapsedNanos()); removeLoadingValue(key, hash, loadingValueReference); &#125; &#125; &#125; Notes：上面代码会调用storeLoadedValue方法,这个方法和后面的put方法实现很相似.如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 首先，这里是线程安全的。把key和value存放到cache中。 */boolean storeLoadedValue(K key, int hash, LoadingValueReference&lt;K, V&gt; oldValueReference, V newValue) &#123; lock(); try &#123; long now = map.ticker.read(); preWriteCleanup(now);// clean工作 int newCount = this.count + 1; if (newCount &gt; this.threshold) &#123; // 保证大小够用ensure capacity expand(); newCount = this.count + 1;// 扩容之后，count可能会变化 &#125; AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table = this.table; int index = hash &amp; (table.length() - 1); ReferenceEntry&lt;K, V&gt; first = table.get(index); // 如果当前segment中已经存在了该key元素 for (ReferenceEntry&lt;K, V&gt; e = first; e != null; e = e.getNext()) &#123; K entryKey = e.getKey(); // 找到hash链中对应的相等节点,则add操作;但是如果value是活跃的,则先移除 if (e.getHash() == hash &amp;&amp; entryKey != null &amp;&amp; map.keyEquivalence.equivalent(key, entryKey)) &#123; ValueReference&lt;K, V&gt; valueReference = e.getValueReference(); V entryValue = valueReference.get(); // 实现就有value引用的情况下 if (oldValueReference == valueReference || (entryValue == null &amp;&amp; valueReference != UNSET)) &#123; ++modCount; // 首先如果value引用活跃,则让放入等待GC回收队列中,等待被回收. if (oldValueReference.isActive()) &#123; RemovalCause cause = (entryValue == null) ? RemovalCause.COLLECTED : RemovalCause.REPLACED; // 如果监听类配置了,则这里会触发监听方法响应 enqueueNotification(key, hash, oldValueReference, cause); newCount--; &#125; // 更新新的值引用,如上所述,如果有老值,不直接删除,让GC回收. // 这里会操作访问队列和写队列,还有其他对外的抽象监听方法调用等 setValue(e, key, newValue, now); this.count = newCount; // write-volatile,确保modCount能及时写入共享内存中 evictEntries();// 移除操作,put方法也调用. return true; &#125; //那如果value引用已经没有了呢?!也就是value引用已经被回收了,而不只是value值为null // 新建一个value引用就好了呀?为什么返回false呢??? valueReference = new WeightedStrongValueReference&lt;K, V&gt;(newValue, 0); enqueueNotification(key, hash, valueReference, RemovalCause.REPLACED); return false; &#125; &#125; // 如果事先segment数组中没有该key,则新建一个节点entry ++modCount; ReferenceEntry&lt;K, V&gt; newEntry = newEntry(key, hash, first); setValue(newEntry, key, newValue, now); table.set(index, newEntry); this.count = newCount; // write-volatile evictEntries(); return true; &#125; finally &#123; unlock(); postWriteCleanup(); &#125;&#125; 5.5 PUT方法实现和 get方法相比，put方法则相对而言，简单了很多，直接上Guava LocalCache的实现。 1234567891. 加锁，对于更新操作，是需要加锁来确保线程安全的。2. put操作，所以需要确保当前的空间，足够存放；否则需要扩容【expand】3. 查看当前cache中是否已经存在该对象对应的key；3.1. 如果存在，则更新相关的value，并且更新相关的时间参数；3.2. 如果不存在，则创建一个新entry，然后放入table数组中。4. 在上面的一些步骤中，还涉及到移除一些参数。【evictEntries】.当我们put操作的时候, 对于map的segment容量就可能会有变更,这样子就需要调用evict方法,决定是否需要采取移除多余的元素. expand方法 扩展table的大小空间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 如果需要并且没到限制大小，则扩展表table。 * */@GuardedBy(&quot;Segment.this&quot;)void expand() &#123; AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; oldTable = table;// 原子引用 int oldCapacity = oldTable.length(); if (oldCapacity &gt;= MAXIMUM_CAPACITY) &#123;// 无法扩容 return; &#125; /** * 把每个list的nodes分类到新的map中。 因为我们这里使用的是2的指数次扩容，所以在每个bin的元素，要么还是同样的index中待着， * 要么移到2的指数个偏移。我们排除了不必要的节点创建（可以优化场景：因为老的节点们下一个fields不会被改变，所以老的节点可以被重复使用）。 * * 以默认域设置来统计，当我们双倍扩展table时，仅仅只有六分之一的节点需要clone。这些节点将会被GC掉， 在他们不在被任务reader线程（这些线程可能正遍历在table的中间部分）引用的时候。 * */ int newCount = count; AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; newTable = newEntryArray(oldCapacity &lt;&lt; 1); threshold = newTable.length() * 3 / 4; int newMask = newTable.length() - 1; for (int oldIndex = 0; oldIndex &lt; oldCapacity; ++oldIndex) &#123; // 我们必须保证任务对老Map的正在进行的读操作可以处理，所以我们不能每个bin设置null ReferenceEntry&lt;K, V&gt; head = oldTable.get(oldIndex); if (head != null) &#123; ReferenceEntry&lt;K, V&gt; next = head.getNext(); int headIndex = head.getHash() &amp; newMask; // hash链只有一个节点的情况 if (next == null) &#123; newTable.set(headIndex, head); &#125; else &#123; // 这里可以重复使用链表，如注释所述，2的倍数扩展，很多引用hash值还是一样，所以把链表头直接set过去就可以了 ReferenceEntry&lt;K, V&gt; tail = head; int tailIndex = headIndex; for (ReferenceEntry&lt;K, V&gt; e = next; e != null; e = e.getNext()) &#123; int newIndex = e.getHash() &amp; newMask; if (newIndex != tailIndex) &#123; // 如果hash更变了，则引用改变。将需要复制前面的节点 tailIndex = newIndex; tail = e; &#125; &#125; newTable.set(tailIndex, tail); // Clone nodes leading up to the tail. for (ReferenceEntry&lt;K, V&gt; e = head; e != tail; e = e.getNext()) &#123; int newIndex = e.getHash() &amp; newMask; ReferenceEntry&lt;K, V&gt; newNext = newTable.get(newIndex); ReferenceEntry&lt;K, V&gt; newFirst = copyEntry(e, newNext); if (newFirst != null) &#123; // 设置新位置的节点链表 newTable.set(newIndex, newFirst); &#125; else &#123; // 移除节点相关操作 removeCollectedEntry(e); newCount--; &#125; &#125; &#125; &#125; &#125; table = newTable; this.count = newCount;&#125; evictEntries方法 12345678910111213141516171819/** * 如果segment满了，则执行evict操作。这个调用仅仅发生在增加一个新的entry并且增加了count的时候。 */@GuardedBy(&quot;Segment.this&quot;)void evictEntries() &#123; if (!map.evictsBySize()) &#123; // 如果没有设置cache的权重，则不执行evict操作 return; &#125; //清除recencyQueue队列，按照指定的相关顺序来读取entries并且更新驱赶的元数据。 // 把他们加到相关的evict列表 （这表明他们可以被移除出map中，由于被加到了recencyQueue队列中。） drainRecencyQueue(); while (totalWeight &gt; maxSegmentWeight) &#123; // 当总的权重大于设置的最大段权重，才会执行remove操作 ReferenceEntry&lt;K, V&gt; e = getNextEvictable(); if (!removeEntry(e, e.getHash(), RemovalCause.SIZE)) &#123; throw new AssertionError(); &#125; &#125;&#125; Guava Cache扩展Guava的CacheBuilder是一个final对象，不允许继承。但是，其提供看专门用来扩展的接口供重写部分方法。分别为ForwardingCache和ForwardingLoadingCache，对应着Cache类和LoadingCache类。 两个扩展类，采用委托模式和/或装饰模式，提供抽象实现。 委派模式（Delegate）是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A是两个互相没有任何关系的类，B具有和A一模一样的方法和属性；并且调用B中的方法，属性就是调用A中同名的方法和属性。B好像就是一个受A授权委托的中介。第三方的代码不需要知道A的存在，也不需要和A发生直接的联系，通过B就可以直接使用A的功能，这样既能够使用到A的各种公能，又能够很好的将A保护起来了。 Decorator装饰模式是一种结构型模式，它主要是解决：“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。继承为类型引入的静态特质的意思是说以继承的方式使某一类型要获得功能是在编译时。所谓静态，是指在编译时；动态，是指在运行时。 GoF《设计模式》中说道：动态的给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。 两种模式其实很相近。委派模式的最终结果就是达到装饰模式的目的。 简单地来看看ForwardingCache抽象类的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * 一个缓存将所有他的方法调用转到其他cache上。子类需要重写一个或者多个方法来改变背后cache的行为。 * 因此，在该类里面会有一个delegate的成员，负责调用具体的cache类对象方法。 */@Betapublic abstract class ForwardingCache&lt;K, V&gt; extends ForwardingObject implements Cache&lt;K, V&gt; &#123; /** Constructor for use by subclasses. */ protected ForwardingCache() &#123;&#125; @Override protected abstract Cache&lt;K, V&gt; delegate(); /** * @since 11.0 */ @Override @Nullable public V getIfPresent(Object key) &#123; return delegate().getIfPresent(key); &#125; /** * @since 11.0 */ @Override public V get(K key, Callable&lt;? extends V&gt; valueLoader) throws ExecutionException &#123; return delegate().get(key, valueLoader); &#125; /** * @since 11.0 */ @Override public ImmutableMap&lt;K, V&gt; getAllPresent(Iterable&lt;?&gt; keys) &#123; return delegate().getAllPresent(keys); &#125; /** * @since 11.0 */ @Override public void put(K key, V value) &#123; delegate().put(key, value); &#125; /** * @since 12.0 */ @Override public void putAll(Map&lt;? extends K,? extends V&gt; m) &#123; delegate().putAll(m); &#125; @Override public void invalidate(Object key) &#123; delegate().invalidate(key); &#125; /** * @since 11.0 */ @Override public void invalidateAll(Iterable&lt;?&gt; keys) &#123; delegate().invalidateAll(keys); &#125; @Override public void invalidateAll() &#123; delegate().invalidateAll(); &#125; @Override public long size() &#123; return delegate().size(); &#125; @Override public CacheStats stats() &#123; return delegate().stats(); &#125; @Override public ConcurrentMap&lt;K, V&gt; asMap() &#123; return delegate().asMap(); &#125; @Override public void cleanUp() &#123; delegate().cleanUp(); &#125; /** * A simplified version of &#123;@link ForwardingCache&#125; where subclasses can pass in an already * constructed &#123;@link Cache&#125; as the delegete. * * @since 10.0 */ @Beta public abstract static class SimpleForwardingCache&lt;K, V&gt; extends ForwardingCache&lt;K, V&gt; &#123; private final Cache&lt;K, V&gt; delegate; protected SimpleForwardingCache(Cache&lt;K, V&gt; delegate) &#123; this.delegate = Preconditions.checkNotNull(delegate); &#125; @Override protected final Cache&lt;K, V&gt; delegate() &#123; return delegate; &#125; &#125;&#125; Guava Cache 总结Guava Cache的实现,核心数据结构和算法都是和JDK 1.6版本的ConcurrentHashMap一致.因此,如果你熟悉ConcurrentHashMap实现原理,对Cache是很容易 缓存浅析 一 常用的缓存技术1、常见的两种缓存 本地缓存：不需要序列化，速度快，缓存的数量与大小受限于本机内存 分布式缓存：需要序列化，速度相较于本地缓存较慢，但是理论上缓存的数量与大小无限（因为缓存机器可以不断扩展） 2、本地缓存 Google guava cache：当下最好用的本地缓存 Ehcache：spring默认集成的一个缓存，以spring cache的底层缓存实现类形式去操作缓存的话，非常方便，但是欠缺灵活，如果想要灵活使用，还是要单独使用Ehcache Oscache：最经典简单的页面缓存 3、分布式缓存 memcached：分布式缓存的标配 Redis：新一代的分布式缓存，有替代memcached的趋势 3.1、memcached 经典的一致性hash算法 基于slab的内存模型有效防止内存碎片的产生（但同时也需要估计好启动参数，否则会浪费很多的内存） 集群中机器之间互不通信（相较于Jboss cache等集群中机器之间的相互通信的缓存，速度更快&lt;–因为少了同步更新缓存的开销，且更适合于大型分布式系统中使用） 使用方便（这一点是相较于Redis在构建客户端的时候而言的，尽管redis的使用也不困难） 很专一（专做缓存，这一点也是相较于Redis而言的） 3.2、Redis 可以存储复杂的数据结构（5种）strings–&gt;即简单的key-value，就是memcached可以存储的唯一的一种形式，接下来的四种是memcached不能直接存储的四种格式（当然理论上可以先将下面的一些数据结构中的东西封装成对象，然后存入memcached，但是不推荐将大对象存入memcached，因memcached的单一value的最大存储为1M，可能即使采用了压缩算法也不够，即使够，可能存取的效率也不高，而redis的value最大为1G）hashs–&gt;看做hashTablelists–&gt;看做LinkedListsets–&gt;看做hashSet，事实上底层是一个hashTablesorted sets–&gt;底层是一个skipList有两种方式可以对缓存数据进行持久化RDBAOF事件调度发布订阅等 4、集成缓存专指spring cache，spring cache自己继承了ehcache作为了缓存的实现类，我们也可以使用guava cache、memcached、redis自己来实现spring cache的底层。当然，spring cache可以根据实现类来将缓存存在本地还是存在远程机器上。 5、页面缓存在使用jsp的时候，我们会将一些复杂的页面使用O scache进行页面缓存，使用非常简单，就是几个标签的事儿；但是，现在一般的企业，前台都会使用velocity、freemaker这两种模板引擎，本身速度就已经很快了，页面缓存使用的也就很少了。 总结： 在实际生产中，我们通常会使用guava cache做本地缓存+redis做分布式缓存+spring cache就集成缓存（底层使用redis来实现）的形式guava cache使用在更快的获取缓存数据，同时缓存的数据量并不大的情况spring cache集成缓存是为了简单便捷的去使用缓存（以注解的方式即可），使用redis做其实现类是为了可以存更多的数据在机器上redis缓存单独使用是为了弥补spring cache集成缓存的不灵活就我个人而言，如果需要使用分布式缓存，那么首先redis是必选的，因为在实际开发中，我们会缓存各种各样的数据类型，在使用了redis的同时，memcached就完全可以舍弃了，但是现在还有很多公司在同时使用memcached和redis两种缓存。接下来的介绍中，会介绍在分布式情况下guava cache、memcached、redis、spring cache的使用与原理。 参考：https://muyinchen.github.io/2016/11/18/%E7%BC%93%E5%AD%98%E6%B5%85%E6%9E%90%20%E4%B8%80%20%20%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%20/ https://github.com/tiantiangao/guava-study/blob/master/doc/caches.md https://ketao1989.github.io/2014/12/19/Guava-Cache-Guide-And-Implement-Analyse/#21-guava-cache%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B http://blog.51cto.com/jincheng/1827153]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>cache</tag>
        <tag>guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式UML和23种分类解析]]></title>
    <url>%2Fposts%2Fdesign_pattern_uml_23gof_analysis.html</url>
    <content type="text"><![CDATA[设计模式之 UML 类图前言为什么要学习设计模式？ 个人觉得设计模式传授的是一种思想，是一种脱离语言的编程习惯。对于一个没有太多经验的程序员，如何写出 简洁优雅，可复用性高，可扩展性强，高内聚低耦合 的代码至关重要。学习别人的设计模式就是为了在没有经验的情况下写出一手不错的代码，只看不写并不能深刻体验到设计模式的巧妙之处。 设计模式讲的是别人千锤百炼出来的精华，如果有那么一天你再次看设计模式觉得，这些没什么特别的，那么说明你已经走上正轨，你的编程习惯已经向设计模式靠拢了。 这是我学习设计模式的开篇第一章，主要介绍下 UML 类图。在之后的文章我也会介绍设计模式的一些基本原则以及 23 种设计模式，并给出详细的代码说明。 UML 类图学习设计模式必定需要先读懂 UML 类图，下面就谈谈具体 UML 类图中的概念。 首先是关于类本身，下面我以人为例，先看 UML 图： 用 Java 代码可表示为: 12345678910111213141516class Student &#123; private String name; public String getName() &#123; return name; &#125; public void takeExam(Course course) &#123; course.test(); &#125;&#125;class Course &#123; private String courseName; public void test() &#123; // take exam... &#125;&#125; 类名叫做 Student 和 Course + 代表 public 公共，- 代表 private 私有，# 代表 protected 成员变量类型写在前，参数名称写在后 函数传递参数，参数名写在前，类型写在后 函数返回值写在函数签名的后面 两个类之间若存在关系，可使用箭头进行关联，具体关联规则在下文介绍 箭头上的数字代表 1 个学生可以不参加课程，也可以无限制参加各种课程 1 代表一个，0..* 代表 0 个到无限个 在 Java 或其它面向对象设计模式中，类与类之间主要有 6 种关系，他们分别为：依赖，关联，聚合，组合，继承，实现。他们的耦合度依次增强。 1. 依赖 (Dependency)依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。 可以简单的理解为：类 A 使用到了类 B，而这种使用关系具有偶然性，临时性，非常弱的，但是 B 类中的变化会影响到类 A，比如某个学生要用笔写字，学生与笔的关系就是一种依赖关系，如果笔没水了，那学生就不能写字了(B 类的变化会影响类 A) 或者换另一只笔继续写字(临时性体现)。 思考下面这样的场景： 你是一名出租车司机，每天开着公司给你分配的车去载客，而每天出租车可能不同，我只是个司机，公司给我什么车我就开什么车，我使用这个车。 具体 UML 类图表现为： Java 代码： 12345678class Driver &#123; public void drive(Car car) &#123; car.run(); &#125;&#125;class Car &#123; public void run()&#123;&#125;&#125; 依赖关系不一定表现为形参，一共可以有三种表现形式: 123456789101112131415class Driver &#123; //通过形参方式发生依赖关系 public void drive1(Car car) &#123; car.run(); &#125; //通过局部变量发生依赖关系 public void drive2() &#123; Car car = new Car(); car.run(); &#125; //通过静态变量发生依赖关系 public void drive3() &#123; Car.run(); &#125;&#125; 2. 关联 (Association)关联关系的定义为：对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。 它体现的两个类中一种强依赖关系，比如我和我的朋友，这种关系比依赖更强，不存在依赖关系中的偶然性，关系也不是临时的，一般是长期性的。 关联关系分为单向关联和双向关联： 在 Java 中，单向关联表现为：类 A 当中使用了 类 B，其中类 B 是作为类 A 的成员变量。 双向关联表现为: 类 A 当中使用类 B 作为成员变量，同时类 B 中也使用了类 A 作为成员变量。 根据可以上面的例子可以修改为以下的场景： 我是一名老司机，车是我自己的，我拥有这辆车，平时也会用着辆车去载客人。 用 UML 类图表示为: 双向关联的话箭头可以省略。 用 Java 代码表示为： 123456789class Driver &#123; private Car car = new Car(); public void drive() &#123; car.run(); &#125;&#125;class Car &#123; public void run()&#123;&#125;&#125; 依赖和关联区别： 用锤子修了一下桌子，我和锤子之间就是一种依赖，我和我的同事就是一种关联。 依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系。 关联是类之间的一种关系，例如老师教学生，老公和老婆这种关系是非常明显的。依赖是比较陌生，关联是我们已经认识熟悉了。 3.聚合 (Aggregation)聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。 聚合关系中作为成员变量的类一般使用 set 方法赋值。 用 UML 类图表示为： Java 代码: 123456789101112class Driver &#123; private Car car = null; public void drive() &#123; car.run(); &#125; public void setCar(Car c)&#123; car = c; &#125;&#125;class Car &#123; public void run()&#123;&#125;&#125; 4. 组合 (Composition)相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。 对比与聚合关系，我们可以将前面的例子变为下面的场景： 车是一辆私家车，是司机财产的一部分，强调的是人财产的部分性，则相同的代码即可表示聚合关系。 车是司机必须有的财产，要想成为一个司机必须要现有财产，车要是没了，司机也不想活了。而且司机要是不干司机了，这车也就没了。 所以，关联、聚合、组合只能配合语义，结合上下文才能够判断出来，而只给出一段代码让我们判断是关联，聚合，还是组合关系，则是无法判断的。 用 UML 类图表示为: 123456789101112class Driver &#123; private Car car = null; public Driver(Car car) &#123; this.car = car; &#125; public void drive() &#123; car.run(); &#125;&#125;class Car &#123; public void run()&#123;&#125;&#125; 再举一个恰当点的例子： 人和灵魂，身体之间是组合关系，当人的生命周期开始时，必须同时拥有灵魂和肉体，当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。 用 UML 类图表示为 5. 继承 (Generalization)继承表示类与类 (或者接口与接口) 之间的父子关系。在 Java 中，用关键字 extends 表示继承关系。 思考下面的场景： 人是一种高级动物，不仅可以像动物可以吃和睡觉，而且还可以学习。 用 UML 类图表示为: Java 代码表示为: 1234567class Animal &#123; public void eat()&#123;&#125; public void sleep()&#123;&#125;&#125;class People extends Animal &#123; public void study()&#123;&#125;&#125; 6. 实现 (Implementation)表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作, 在 Java 中使用 implements 表示。在 Java 中，如果实现了某个接口，那么就必须实现接口中所有的方法。 比如一个人可以吃饭和学习，那么就可以定义一个人的接口。让具体的人去实现它。 用 UML 类图表示为： Java 代码： 12345678910interface IPeople &#123; public void eat(); public void study();&#125;class People implements IPeople &#123; public void eat()&#123; &#125; public void study()&#123; &#125;&#125; 意图、UML类图创建模式 创建型模式与对象的创建有关。 工厂方法 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 抽象工厂 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 结构型模式处理类或对象的组合。 结构型模式适配器模式 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 桥接模式 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 组合模式 将对象组合成树形结构以表示“部分 -整体”的层次结构。 Composite使得用户对单个对象和组合对象的使用具有一致性。 装饰者模式 动态地给一个对象添加一些额外的职责。就增加功能来说, Decorator模式相比生成子类更为灵活。 门面模式 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 享元模式 运用共享技术有效地支持大量细粒度的对象。 代理模式 为其他对象提供一种代理以控制对这个对象的访问。 行为型模式 行为型模式对类或对象怎样交互和怎样分配职责进行描述。 解释器模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 备忘录模式 在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 观察者模式 定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。 状态模式 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 策略模式 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 #设计模式 #面向对象 #OOP #意图 #UML Android系统编程思想：设计模式关于作者 郭孝星，程序员，吉他手，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的Github提issue或者发邮件至guoxiaoxingse@163.com与我交流。 文章目录 提到设计模式，大家并不陌生，我们之前在分析Android源码的时候也有提及，但都比较零散，不成系统。今天的这篇文章就来系统的总结一下23种 设计模式的模式定义与实现方式，让读者有一个整体上的模式。 什么是设计模式？ 通俗来讲，设计模式就是针对某一种特殊场景而给出的标准解决方案，它是前辈们的经验性总结，也是实现软件工程化的基础，良好的设计模式应用 可以是我们的软件变得更加健壮可维护。 设计模式按照类型划分可以分为三大类，如下所示： 创建型设计模式：如同它的名字那样，它是用来解耦对象的实例化过程。 结构型设计模式：将类和对象按照一定规则组合成一个更加强大的结构体。 行为型设计模式：定义类和对象的交互行为。 23种设计模式划分如下图所示： 注：23种设计模式很多小伙伴都烂熟于心，但是真正编程实践的时候未必会想的起来，这其实是一个潜移默化的过程，在看设计模式的时候，尽量多动手写一写，其中 手写（不借助IDE）的效果最佳，可以加深理解，理解的深了，编程的时候自然就可以想的到去应用。 一 创建型设计模式 创建型设计模式主要用来解耦对象的实例化过程，控制实例的生成。 创建型设计模式一共有六种，如下所示： 1.1 单例模式模式定义 当系统中只需要一个实例或者一个全局访问点的时候可以使用单例模式。 优点：节省系统创建对象的资源，提高了系统效率，提供了统一的访问入口，可以严格控制用户对该对象的访问。 缺点：只有一个对象，积累的职责过重，违背了单一职责原则。构造方法为private，无法继承，扩展性较差。 单例模式的实现由很多种，如下所示： 懒汉式单例 双层校验锁单例 容器单例 静态内部类单例 枚举单例 其中静态内部类单例和枚举单例都是单例模式最佳的实现，但是出于便利性的考量，双层校验锁的实现应用的更为广泛，如下所示： 1234567891011121314151617181920212223public class DoubleCheckSingleton &#123; // volatile关键字保证了：① instance实例对于所有线程都是可见的 ② 禁止了instance // 操作指令重排序。 private volatile static DoubleCheckSingleton instance; private DoubleCheckSingleton() &#123; &#125; public static DoubleCheckSingleton getInstance() &#123; // 第一次校验，防止不必要的同步。 if (instance == null) &#123; // synchronized关键字加锁，保证每次只有一个线程执行对象初始化操作 synchronized (DoubleCheckSingleton.class) &#123; // 第二次校验，进行判空，如果为空则执行初始化 if(instance == null)&#123; instance = new DoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 关于双层校验锁单例为何能实现JVM单例，它的要点在于两次判空和synchronized、volatile关键字，具体原理已经写在上方的注释里，这里 我们单独说一下volatile关键字。 说明我们说到，volatile关键字禁止了instance 操作指令重排序，我们来解释一下，我们知道instance = new DoubleCheckSingleton()这个操作 在汇编指令里大致会做三件事情： 给我们知道instance分配内存。 调用DoubleCheckSingleton()构造方法。 将构造的对象赋值给instance。 但是在真正执行的时候，Java编译器是允许指令乱序执行的（编译优化），所以上述3步的顺序得不到保证，有可能是132，试想一下，如果线程A没有执行第2步，先执行了 第3步，而恰在此时，线程B取走了instance对象，在使用instance对象时就会有问题，双层校验锁单例失败，而volatile关键字可以禁止指令重排序从而解决这个问题。 单例模式的另一个问题就是多进程的情况下的失败问题，因为JVN里的单例是基于一个虚拟机进程的，这个时候通常的做法就是让这个单例支持跨进程调用，这个在 Android里一般用AIDL实现。 1.2 建造者模式模式定义 封装一个复杂对象的构建过程，可以按照流程来构建对象。 优点：它可以将一个复杂对象的构建与表示相分离，同一个构建过程，可以构成出不同的产品，简化了投建逻辑。 缺点：如果构建流程特别复杂，就是导致这个构建系统过于庞大，不利于控制。 建造者模式的实现，也十分简单，如下所示： code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Product &#123; private String board; private String display; private String os; public String getBoard() &#123; return board; &#125; public String getDisplay() &#123; return display; &#125; public String getOs() &#123; return os; &#125; private Product(Builder builder) &#123; // 进行构建 this.board = builder.board; this.display = builder.display; this.os = builder.os; &#125; public static class Builder &#123; // 建造者模式还可以设置默认值 private String board = &quot;default value&quot;; private String display = &quot;default value&quot;; private String os = &quot;default value&quot;; public void setBoard(String board) &#123; this.board = board; &#125; public void setDisplay(String display) &#123; this.display = display; &#125; public void setOs(String os) &#123; this.os = os; &#125; public Product build() &#123; return new Product(this); &#125; &#125;&#125; Android中的应用在Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder， 使用该Builder来构建复杂的AlertDialog对象。简单示例如下 : 1234567891011121314151617181920212223242526//显示基本的AlertDialog private void showDialog(Context context) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.icon); builder.setTitle(&quot;Title&quot;); builder.setMessage(&quot;Message&quot;); builder.setPositiveButton(&quot;Button1&quot;, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle(&quot;点击了对话框上的Button1&quot;); &#125; &#125;); builder.setNeutralButton(&quot;Button2&quot;, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle(&quot;点击了对话框上的Button2&quot;); &#125; &#125;); builder.setNegativeButton(&quot;Button3&quot;, new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle(&quot;点击了对话框上的Button3&quot;); &#125; &#125;); builder.create().show(); // 构建AlertDialog， 并且显示&#125; 结果 : 下面我们看看AlertDialog的相关源码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// AlertDialogpublic class AlertDialog extends Dialog implements DialogInterface &#123; // Controller, 接受Builder成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) &#123; this(context, theme, true); &#125; // 4 : 构造AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) &#123; super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); &#125; // 实际上调用的是mAlert的setTitle方法 @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; // 实际上调用的是mAlert的setCustomTitle方法 public void setCustomTitle(View customTitleView) &#123; mAlert.setCustomTitle(customTitleView); &#125; public void setMessage(CharSequence message) &#123; mAlert.setMessage(message); &#125; // AlertDialog其他的代码省略 // ************ Builder为AlertDialog的内部类 ******************* public static class Builder &#123; // 1 : 存储AlertDialog的各个参数, 例如title, message, icon等. private final AlertController.AlertParams P; // 属性省略 /** * Constructor using a context for this builder and the &#123;@link AlertDialog&#125; it creates. */ public Builder(Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder(Context context, int theme) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; &#125; // Builder的其他代码省略 ...... // 2 : 设置各种参数 public Builder setTitle(CharSequence title) &#123; P.mTitle = title; return this; &#125; public Builder setMessage(CharSequence message) &#123; P.mMessage = message; return this; &#125; public Builder setIcon(int iconId) &#123; P.mIconId = iconId; return this; &#125; public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123; P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; &#125; public Builder setView(View view) &#123; P.mView = view; P.mViewSpacingSpecified = false; return this; &#125; // 3 : 构建AlertDialog, 传递参数 public AlertDialog create() &#123; // 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); // 5 : 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; &#125; &#125; Java应用1.3 原型模式模式定义 当某个对象的数据结构或者构建过程特别复杂，频繁的构建势必会消耗系统性能，这个时候我们采用原型模式对原有的 对象进行克隆，构建新的对象。 优点：直接克隆原有实例生成新的实例，免去了复杂的构建过程，节省了系统资源。 缺点： UML类图 角色介绍 Client : 客户端用户。 Prototype : 抽象类或者接口，声明具备clone能力。 ConcretePrototype : 具体的原型类. 实现原型模式也很简单，主需要声明实现loneable接口，然后覆写Object的clone()方法接口。 code12345678910public class Person implements Cloneable&#123; public int age; public String name; @Override public Person clone() throws CloneNotSupportedException &#123; return (Person) super.clone(); &#125;&#125; 原型模式要注意深拷贝和浅拷贝的问题，Object的clone()方法默认是钱拷贝，即对于引用对象拷贝的地址而不是值，所以要实现 深拷贝，在clone()方法里对于引用对象也有调用一下clone()方法，并且引用对象也要实现Cloneable接口和覆写clone()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.dp.example.builder;package com.dp.example.prototype;import java.util.ArrayList;import java.util.List;/** * 文档类型, 扮演的是ConcretePrototype角色，而cloneable是代表prototype角色 * * @author mrsimple */public class WordDocument implements Cloneable &#123; /** * 文本 */ private String mText; /** * 图片名列表 */ private ArrayList&lt;String&gt;&lt;string&gt; mImages = new ArrayList&lt;String&gt;&lt;string&gt;(); public WordDocument() &#123; System.out.println(&quot;----------- WordDocument构造函数 -----------&quot;); &#125; /** * 克隆对象 */ @Override protected WordDocument clone() &#123; try &#123; WordDocument doc = (WordDocument) super.clone(); doc.mText = this.mText; doc.mImages = this.mImages; return doc; &#125; catch (Exception e) &#123; &#125; return null; &#125; public String getText() &#123; return mText; &#125; public void setText(String mText) &#123; this.mText = mText; &#125; public List&lt;string&gt; getImages() &#123; return mImages; &#125; /** * @param img */ public void addImage(String img) &#123; this.mImages.add(img); &#125; /** * 打印文档内容 */ public void showDocument() &#123; System.out.println(&quot;----------- Word Content Start -----------&quot;); System.out.println(&quot;Text : &quot; + mText); System.out.println(&quot;Images List: &quot;); for (String imgName : mImages) &#123; System.out.println(&quot;image name : &quot; + imgName); &#125; System.out.println(&quot;----------- Word Content End -----------&quot;); &#125;&#125; 通过WordDocument类模拟了word文档中的基本元素，即文字和图片。WordDocument的在该原型模式示例中扮演的角色为ConcretePrototype， 而Cloneable的角色则为Prototype。WordDocument实现了clone方法以实现对象克隆。下面我们看看Client端的使用 : 12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; WordDocument originDoc = new WordDocument(); originDoc.setText(&quot;这是一篇文档&quot;); originDoc.addImage(&quot;图片1&quot;); originDoc.addImage(&quot;图片2&quot;); originDoc.addImage(&quot;图片3&quot;); originDoc.showDocument(); WordDocument doc2 = originDoc.clone(); doc2.showDocument(); doc2.setText(&quot;这是修改过的Doc2文本&quot;); doc2.showDocument(); originDoc.showDocument(); &#125;&#125; 输出结果如下 : 可以看到，doc2是通过originDoc.clone()创建的，并且doc2第一次输出的时候和originDoc输出是一样的。即doc2是originDoc的一份拷贝，他们的内容是一样的，而doc2修改了文本内容以后并不会影响originDoc的文本内容。需要注意的是通过clone拷贝对象的时候并不会执行构造函数！ 浅拷贝和深拷贝将main函数的内容修改为如下 : 123456789101112131415161718public static void main(String[] args) &#123; WordDocument originDoc = new WordDocument(); originDoc.setText(&quot;这是一篇文档&quot;); originDoc.addImage(&quot;图片1&quot;); originDoc.addImage(&quot;图片2&quot;); originDoc.addImage(&quot;图片3&quot;); originDoc.showDocument(); WordDocument doc2 = originDoc.clone(); doc2.showDocument(); doc2.setText(&quot;这是修改过的Doc2文本&quot;); doc2.addImage(&quot;哈哈.jpg&quot;); doc2.showDocument(); originDoc.showDocument();&#125; 输出结果如下 :细心的朋友可能发现了，在doc2添加了一张名为”哈哈.jpg”的照片，但是却也显示在originDoc中？这是怎么回事呢？ 其实学习过C++的朋友都知道，这是因为上文中WordDocument的clone方法中只是简单的进行浅拷贝，引用类型的新对象doc2的mImages只是单纯的指向了this.mImages引用，而并没有进行拷贝。doc2的mImages添加了新的图片，实际上也就是往originDoc里添加了新的图片，所以originDoc里面也有”哈哈.jpg” 。那如何解决这个问题呢？ 那就是采用深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用的形式。示例如下 : 12345678910111213141516 /** * 克隆对象 */ @Override protected WordDocument clone() &#123; try &#123; WordDocument doc = (WordDocument) super.clone(); doc.mText = this.mText;// doc.mImages = this.mImages; doc.mImages = (ArrayList&lt;String&gt;) this.mImages.clone(); return doc; &#125; catch (Exception e) &#123; &#125; return null; &#125; 如上代码所示，将doc.mImages指向this.mImages的一份拷贝， 而不是this.mImages本身，这样在doc2添加图片时并不会影响originDoc，如图所示 : Androi应用Intent在Android源码中，我们以熟悉的Intent来分析源码中的原型模式。简单示例如下 : 123456Uri uri = Uri.parse(&quot;smsto:0800000123&quot;); Intent shareIntent = new Intent(Intent.ACTION_SENDTO, uri); shareIntent.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;); Intent intent = (Intent)shareIntent.clone() ;startActivity(intent); 可以看到，我们通过shareIntent.clone方法拷贝了一个对象intent, 然后执行startActivity(intent)， 随即就进入了短信页面，号码为0800000123,文本内容为The SMS text，即这些内容都与shareIntent一致。 12345678910111213141516171819202122232425262728293031@Overridepublic Object clone() &#123; return new Intent(this);&#125;/** * Copy constructor. */public Intent(Intent o) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; this.mFlags = o.mFlags; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;String&gt;(o.mCategories); &#125; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125;&#125; 可以看到，clone方法实际上在内部调用了new Intent(this); 这就和C++中的拷贝构造函数完全一致了，而且是深拷贝。由于该模式比较简单，就不做太多说明。 接下来我们继续看看三种工厂模式，如下所示： 简单工厂模式：根据传入的参数决定实例化哪个对象。 工厂模式：工厂模式定义了一个创建对象的接口，由子类进行对象的初始化，即工厂模式将子类的初始化推迟到了子类里。 抽象工厂模式：抽象工厂模式和工厂模式很相似，只是它利用接口或者抽象类定义了一个产品族，例如定义一个拨号产品族，只定义功能，不 关心实现，具体实现交由Android、iOS等操作系统自己完成。 1.4 简单工厂模式模式定义 根据传入的参数决定实例化哪个对象。 简单工厂模式是工厂模式的简化版本，无需定义抽象工厂，通常还可以利用反射来生成对象，简化操作，如下所示： 1234567891011121314151617// 简单工厂public class SimpleFactory &#123; public static &lt;T extends AbstractProduct&gt; T create(Class&lt;T&gt; clasz) &#123; AbstractProduct product = null; try &#123; product = (AbstractProduct) Class.forName(clasz.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return (T) product; &#125;&#125; Android中简单工厂模式的应用在Android中我们了解的使用到了简单工厂方法的地方有Bitmap对象的获取、Fragment创建等。接下来我们分开看一下。 Bitmap源码分析 首先来说我们是不能通过new方法来创建Bitmap对象的，因为Bitmap类的构造函数是私有的，只能是通过JNI实例化。 接下来我们随便找个入口开始看，比如： 12Bitmap bmp = BitmapFactory.decodeFile(String pathName);12 我们把源码中的调用关系找出来，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public static Bitmap decodeFile(String pathName) &#123; return decodeFile(pathName, null);&#125;public static Bitmap decodeFile(String pathName, Options opts) &#123; Bitmap bm = null; InputStream stream = null; try &#123; stream = new FileInputStream(pathName); bm = decodeStream(stream, null, opts); &#125; catch (Exception e) &#123; /* do nothing. If the exception happened on open, bm will be null. */ Log.e(&quot;BitmapFactory&quot;, &quot;Unable to decode stream: &quot; + e); &#125; finally &#123; if (stream != null) &#123; try &#123; stream.close(); &#125; catch (IOException e) &#123; // do nothing here &#125; &#125; &#125; return bm;&#125;public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) &#123; // we don&apos;t throw in this case, thus allowing the caller to only check // the cache, and not force the image to be decoded. if (is == null) &#123; return null; &#125; Bitmap bm = null; Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, &quot;decodeBitmap&quot;); try &#123; if (is instanceof AssetManager.AssetInputStream) &#123; final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset(); bm = nativeDecodeAsset(asset, outPadding, opts); &#125; else &#123; bm = decodeStreamInternal(is, outPadding, opts); &#125; if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123; throw new IllegalArgumentException(&quot;Problem decoding into existing bitmap&quot;); &#125; setDensityFromOptions(bm, opts); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS); &#125; return bm;&#125;private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts);/** * Set the newly decoded bitmap&apos;s density based on the Options. */private static void setDensityFromOptions(Bitmap outputBitmap, Options opts) &#123; if (outputBitmap == null || opts == null) return; final int density = opts.inDensity; if (density != 0) &#123; outputBitmap.setDensity(density); final int targetDensity = opts.inTargetDensity; if (targetDensity == 0 || density == targetDensity || density == opts.inScreenDensity) &#123; return; &#125; byte[] np = outputBitmap.getNinePatchChunk(); final boolean isNinePatch = np != null &amp;&amp; NinePatch.isNinePatchChunk(np); if (opts.inScaled || isNinePatch) &#123; outputBitmap.setDensity(targetDensity); &#125; &#125; else if (opts.inBitmap != null) &#123; // bitmap was reused, ensure density is reset outputBitmap.setDensity(Bitmap.getDefaultDensity()); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 我们来分析一下调用过程，可以看到decodeFile(String pathName)调用的是decodeFile(String pathName, Options opts)，在两个参数的decodeFile方法中又去调用了decodeStream(InputStream is, Rect outPadding, Options opts)方法，然后最终调用nativeDecodeAsset或者nativeDecodeStream来构建Bitmap对象，这两个都是native方法(Android中使用Skia库来解析图像 )。再经过setDensityFromOptions方法的一些设置解码密度之类的操作，返回我们要的Bitmap对象。 /*\ Creates Bitmap objects from various sources, including files, streams, and byte-arrays.*/ 看下BitmapFactory的注释我们可以看到，这个工厂支持从不同的资源创建Bitmap对象，包括files, streams, 和byte-arrays，但是调用关系都大同小异。 1.5 工厂模式模式定义 工厂模式定义了一个创建对象的接口，由子类进行对象的初始化，即工厂模式将子类的初始化推迟到了子类里。抽象工厂模式 优点：工厂模式符合开闭原则，当需要增加一个新产品时，只需要增加一个具体产品类和一个具体工厂类，无需修改原有的系统，外界也无需 知道具体的产品类的实现。 缺点：每次增加新产品的时候都会增加产品类和工厂类，势必会让系统越来越庞大。 工厂模式的实现也很简单，就是定义一个抽象类或者接口工厂，在子类工厂中决定实例化具体的类。 12345678910111213141516171819202122232425// 抽象工厂public abstract class AbstractFactory &#123; public abstract AbstractProduct create();&#125;// 具体工厂public class ConcretetFactory extends AbstractFactory&#123; public static AbstractProduct create() &#123; return new ConcreteProductA();// return new ConcreteProductB(); &#125;&#125;// 抽象产品public class AbstractProduct &#123;&#125;// 具体产品Apublic class ConcreteProductA extends AbstractProduct &#123;&#125;// 具体产品Bpublic class ConcreteProductB extends AbstractProduct &#123;&#125; Android源码中的应用工厂方法模式应用很广泛，开发中使用到的数据结构中就隐藏着对工厂方法模式的应用，例如 List、Set，List、Set 继承自 Collection 接口，而 Collection 接口继承于 Iterable 接口： 123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125;123 这意味着 List、Set 接口也会继承 iterator() 方法，下面以 ArrayList 为例进行分析：ArrayList 中 iterator() 方法的实现就是构造并返回一个迭代器对象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; // 迭代器 private class Itr implements Iterator&lt;E&gt; &#123; protected int limit = java.util.ArrayList.this.size; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor &lt; limit; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); int i = cursor; if (i &gt;= limit) throw new NoSuchElementException(); Object[] elementData = java.util.ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); try &#123; java.util.ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; limit--; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; // 代码省略 &#125; // 代码省略&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 其中的 iterator() 方法其实就相当于一个工厂方法，专为 new 对象而生，构造并返回一个具体的迭代器。 1.6 抽象工厂模式模式定义 抽象工厂模式和工厂模式很相似，只是它利用接口或者抽象类定义了一个产品族，例如定义一个拨号产品族，只定义功能，不 关心实现，具体实现交由Android、iOS等操作系统自己完成。 优点： 缺点： 实现如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 抽象产品Apublic abstract class AbstractProductA &#123;&#125;// 抽象产品Bpublic abstract class AbstractProductB &#123;&#125;// 具体产品A1public class ConcreteProductA1 extends AbstractProductA&#123;&#125;// 具体产品A2public class ConcreteProductA2 extends AbstractProductA &#123;&#125;// 具体产品B1public class ConcreteProductB1 extends AbstractProductB &#123;&#125;// 具体产品B2public class ConcreteProductB2 extends AbstractProductB &#123;&#125;// 抽象工厂public abstract class AbstractFactory &#123; public abstract AbstractProductA createProductA(); public abstract AbstractProductB createProductB();&#125;// 具体工厂public class ConcreteFactory extends AbstractFactory &#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductA1(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductB1(); &#125;&#125; 二 结构型设计模式通过继承和对象组合实现结构型模式，其中继承实现的是类结构型模式，对象组合实现的是对象结构型模式。注意优先使用对象组合，而不是类继承。 2.1 适配器模式模式定义 适配器模式可以将一个类的接口，转换成客户端期望的另一个接口，让两个原本不兼容的接口可以无缝对接。 优点： 缺点： 123456789101112131415161718192021// 目标接口public interface TargetInterface &#123; int getFive();&#125;// 被适配对象public class Adaptee &#123; public int getTen() &#123; return 10; &#125;&#125;// 适配器public class Adapter extends Adaptee implements TargetInterface &#123; @Override public int getFive() &#123; return 5; &#125;&#125; 适配器的类图表示适配器模式又分两种，1. 类适配器模式；2. 对象适配器。如图一，图二所示。 图一 类适配器模式 Android ListView 中的 Adapter 模式由于不同的 ListView 所要呈现的视图也是不同的，为了应对这些不同，就需要通过一个适配器来实现隔离和适配。我们可以通过一个继承自 BaseAdapter 类来实现自己的类。 1234567891011121314151617181920212223242526272829303132333435363738394041ListView mListView = (ListView) findViewById(listView_id);mListView.setAdapter(new MyAdapter(context, mdData));public class MyAdapter extends BaseAdapter &#123; private LayoutInflater mInflater; private List&lt;String&gt; mData; public MyAdapter(Context context, List&lt;String&gt; data) &#123; this.mInflater = LayoutInflater.from(context); mData = data; &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public String getItem(int positon) &#123; return mData.get(positon); &#125; @Override public long getItemId(int position) &#123; return pos; &#125; //解析、设置、缓存 convertView 以及相关内容 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; // Item View 的复用 if (convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.my_listview_item, null); holder.title = (TextView) convertView.findViewById(R.id.title); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.title.setText(mData.get(position)); return convertView; &#125;&#125; 增加一个 Adapter 层来应对变化，将 ListView 需要的接口抽象到 Adapter 对象中，这样只要用户实现了 Adapter 的接口， ListView 就可以按照用户设定的显示效果、数量、数据来显示特定的 Item View。通过代理数据集来告知ListView 数据的个数（ getCount方法 ）以及每个数据 （ getItem方法 ），最重要的是要解决 Item View 的输出。Item View 千变万化，但终究它都是 View 类型， Adapter 统一将 Item View 输出为 View （ getView方法 ），这样就很好的应对了 Item View 的可变性。 2.2 组合模式模式定义 将对象组成树形结构以表示整体-部分的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 应用场景 表示对象部分-整体的层次结构。 从一个整体中能够独立出部分模块或者功能的场景。 Android具体实现代码View.java 123public class View ....&#123; //此处省略无关代码...&#125; ViewGroup.java 12345678910111213141516171819public abstract class ViewGroup extends View ...&#123; //增加子节点 public void addView(View child, int index) &#123; &#125; //删除子节点 public void removeView(View view) &#123; &#125; //查找子节点 public View getChildAt(int index) &#123; try &#123; return mChildren[index]; &#125; catch (IndexOutOfBoundsException ex) &#123; return null; &#125; &#125;&#125; 2.3 装饰模式模式定义 动态的为对象增加一些额外的功能。 应用场景 需要透明且动态的扩展类的功能时。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 抽象组件类public abstract class AbstractComponent &#123; protected abstract void operation();&#125;// 具体组件类public class ConcreteComponent extends AbstractComponent &#123; @Override protected void operation() &#123; &#125;&#125;// 抽象装饰类public abstract class AbstractDecorator extends AbstractComponent &#123; private AbstractComponent mComponent; public AbstractDecorator(AbstractComponent component) &#123; mComponent = component; &#125; @Override protected void operation() &#123; mComponent.operation(); &#125;&#125;// 具体装饰类public class ConcreteDecorator extends AbstractDecorator &#123; public ConcreteDecorator(AbstractComponent component) &#123; super(component); &#125; @Override protected void operation() &#123; operationA(); super.operation(); operationB(); &#125; private void operationA() &#123; &#125; private void operationB() &#123; &#125;&#125; Android源码中的模式实现Android源码中的装饰模式其实我们经常接触，但并不一定有过真正的了解，Context类在Android中被称为“上帝对象”，它本质是一个抽象类，其在我们装饰模式中就相当于抽象组件，而在其内部定义了大量的抽象方法，比如我们经常会用到的startActivity方法，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */public abstract class Context &#123; // 省略代码 /** * Same as &#123;@link #startActivity(Intent, Bundle)&#125; with no options * specified. * * @param intent The description of the activity to start. * * @throws ActivityNotFoundException &amp;nbsp; * * @see #startActivity(Intent, Bundle) * @see PackageManager#resolveActivity */ public abstract void startActivity(Intent intent); /** * Launch a new activity. You will not receive any information about when * the activity exits. * * &lt;p&gt;Note that if this method is being called from outside of an * &#123;@link android.app.Activity&#125; Context, then the Intent must include * the &#123;@link Intent#FLAG_ACTIVITY_NEW_TASK&#125; launch flag. This is because, * without being started from an existing Activity, there is no existing * task in which to place the new activity and thus it needs to be placed * in its own separate task. * * &lt;p&gt;This method throws &#123;@link ActivityNotFoundException&#125; * if there was no Activity found to run the given Intent. * * @param intent The description of the activity to start. * @param options Additional options for how the Activity should be started. * May be null if there are no options. See &#123;@link android.app.ActivityOptions&#125; * for how to build the Bundle supplied here; there are no supported definitions * for building it manually. * * @throws ActivityNotFoundException &amp;nbsp; * * @see #startActivity(Intent) * @see PackageManager#resolveActivity */ public abstract void startActivity(Intent intent, @Nullable Bundle options); // 省略代码&#125; Context真正的实现类是ContextImpl，ContextImpl继承自Context抽象类，并实现了Context中的抽象方法，具体代码如下： 123456789101112131415161718192021222324252627282930/** * Common implementation of Context API, which provides the base * context object for Activity and other application components. */class ContextImpl extends Context &#123; // 代码省略 @Override public void startActivity(Intent intent) &#123; warnIfCallingFromSystemProcess(); startActivity(intent, null); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; warnIfCallingFromSystemProcess(); if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; throw new AndroidRuntimeException( &quot;Calling startActivity() from outside of an Activity &quot; + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot; + &quot; Is this really what you want?&quot;); &#125; mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, (Activity)null, intent, -1, options); &#125; // 代码省略&#125; 这里ContextImpl就相当于组件具体实现类，那么谁来承担装饰者的身份呢？我们知道Activity从类层次上来说本质是一个Context，如果大家留意过其代码会发现Activity并非直接继承于Context，而是继承于ContextThemeWrapper，如下代码所示： 12345678public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback &#123; // 代码省略 &#125; 而这个ContextThemeWrapper又继承了ContextWrapper： 1234567/** * A ContextWrapper that allows you to modify the theme from what is in the * wrapped context. */public class ContextThemeWrapper extends ContextWrapper &#123; // 代码省略&#125; 最终这个ContextWrapper才继承于Context，为什么类层次会这么复杂？其实这里就是一个典型的装饰模式，ContextWrapper就是我们要找的装饰者，在ContextWrapper中有一个Context的引用： 1234567891011121314/** * Proxying implementation of Context that simply delegates all of its calls to * another Context. Can be subclassed to modify behavior without changing * the original Context. */public class ContextWrapper extends Context &#123; Context mBase; public ContextWrapper(Context base) &#123; mBase = base; &#125; // 代码省略&#125; 到目前为止已经有点装饰模式的样子了，不过好像还缺点什么，没错，一个来自于抽象组件的方法，这里我们还是先看startActivity，在ContextWrapper中同样有一个startActivity方法： 123456789101112131415161718192021/** * Proxying implementation of Context that simply delegates all of its calls to * another Context. Can be subclassed to modify behavior without changing * the original Context. */public class ContextWrapper extends Context &#123; // 代码省略 @Override public void startActivity(Intent intent) &#123; mBase.startActivity(intent); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; mBase.startActivity(intent, options); &#125; // 代码省略&#125; 这里可以看出ContextWrapper中的startActivity方法也仅仅是简单地调用了具体组件实现类ContextImpl中的对应方法而已，实质上ContextWrapper中所有的方法都仅仅是调用了ContextImpl中的方法，对Context具体的包装拓展则由ContextWrapper的具体子类完成，比如我们的Activity、Service和Application。 2.4 外观模式模式定义 要求一个字系统的外部与其内部的通信都通过一个统一的而对象进行。 应用场景 子系统在迭代的过程中可以会不断变化，甚至被替代掉，给一个统一的访问接口，避免子系统的改变影响到外部的调用者。 当需要构建层次结构型的系统时，为各层子系统提供访问的接口进行通信，避免直接产生依赖。 code简单实现的介绍 电视遥控器是现实生活中一个比较好的外观模式的运用，遥控器可以控制电源的开源、声音的调整、频道的切换等。这个遥控器就是我们这里说的外观或者门面，而电源、声音、频道切换系统就是我们的子系统。遥控器统一对这些子模块的控制，我想你没有用过多个遥控器来分别控制电源开关、声音控制等功能。下面我们就来简单模拟一下这个系统。 实现源码 TvController.java 1234567891011121314151617181920212223242526272829public class TvController &#123; private PowerSystem mPowerSystem = new PowerSystem(); private VoiceSystem mVoiceSystem = new VoiceSystem(); private ChannelSystem mChannelSystem = new ChannelSystem(); public void powerOn() &#123; mPowerSystem.powerOn(); &#125; public void powerOff() &#123; mPowerSystem.powerOff(); &#125; public void turnUp() &#123; mVoiceSystem.turnUp(); &#125; public void turnDown() &#123; mVoiceSystem.turnDown(); &#125; public void nextChannel() &#123; mChannelSystem.next(); &#125; public void prevChannel() &#123; mChannelSystem.prev(); &#125;&#125; PowerSystem.java 123456789101112/** * 电源控制系统 */ class PowerSystem &#123; public void powerOn() &#123; System.out.println(&quot;开机&quot;); &#125; public void powerOff() &#123; System.out.println(&quot;关机&quot;); &#125;&#125; VoiceSystem.java 123456789101112/** * 声音控制系统 */class VoiceSystem &#123; public void turnUp() &#123; System.out.println(&quot;音量增大&quot;); &#125; public void turnDown() &#123; System.out.println(&quot;音量减小&quot;); &#125;&#125; ChannelSystem.java 123456789101112/** * 频道控制系统 */class ChannelSystem &#123; public void next() &#123; System.out.println(&quot;下一频道&quot;); &#125; public void prev() &#123; System.out.println(&quot;上一频道&quot;); &#125;&#125; 测试代码 : 1234567891011121314151617181920212223242526272829public class TvController &#123; private PowerSystem mPowerSystem = new PowerSystem(); private VoiceSystem mVoiceSystem = new VoiceSystem(); private ChannelSystem mChannelSystem = new ChannelSystem(); public void powerOn() &#123; mPowerSystem.powerOn(); &#125; public void powerOff() &#123; mPowerSystem.powerOff(); &#125; public void turnUp() &#123; mVoiceSystem.turnUp(); &#125; public void turnDown() &#123; mVoiceSystem.turnDown(); &#125; public void nextChannel() &#123; mChannelSystem.next(); &#125; public void prevChannel() &#123; mChannelSystem.prev(); &#125;&#125; 输出结果： 1234开机下一频道音量增大关机 上面的TvController封装了对电源、声音、频道切换的操作，为用户提供了一个统一的接口。使得用户控制电视机更加的方便、更易于使用。 Android应用-context封装在开发过程中，Context是最重要的一个类型。它封装了很多重要的操作，比如startActivity()、sendBroadcast()等，几乎是开发者对应用操作的统一入口。Context是一个抽象类，它只是定义了抽象接口，真正的实现在ContextImpl类中。它就是今天我们要分析的外观类。 在应用启动时，首先会fork一个子进程，并且调用ActivityThread.main方法启动该进程。ActivityThread又会构建Application对象，然后和Activity、ContextImpl关联起来，然后再调用Activity的onCreate、onStart、onResume函数使Activity运行起来。我们看看下面的相关代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128private final void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // 代码省略 // 1、创建并且加载Activity，调用其onCreate函数 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; // 2、调用Activity的onResume方法，使Activity变得可见 handleResumeActivity(r.token, false, r.isForward); &#125; &#125; private final Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;); // 代码省略 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); // 1、创建Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; // 2、创建Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; // ***** 构建ContextImpl ****** ContextImpl appContext = new ContextImpl(); appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity); // 获取Activity的title CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mConfiguration); // 3、Activity与context, Application关联起来 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstance, r.lastNonConfigurationChildInstances, config); // 代码省略 // 4、回调Activity的onCreate方法 mInstrumentation.callActivityOnCreate(activity, r.state); // 代码省略 &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; &#125; return activity; &#125; final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123; unscheduleGcIdler(); // 1、最终调用Activity的onResume方法 ActivityClientRecord r = performResumeActivity(token, clearHide); // 代码省略 // 2、这里是重点，在这里使DecorView变得可见 if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; // 获取Window，即PhoneWindow类型 r.window = r.activity.getWindow(); // 3、获取Window的顶级视图，并且使它可见 View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 4、获取WindowManager ViewManager wm = a.getWindowManager(); // 5、构建LayoutParams参数 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; // 6、将DecorView添加到WindowManager中，最终的操作是通过WindowManagerService的addView来操作 wm.addView(decor, l); &#125; &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; &#125; // 代码省略 &#125; public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null &amp;&amp; !r.activity.mFinished) &#123; try &#123; // 代码省略 // 执行onResume r.activity.performResume(); // 代码省略 &#125; catch (Exception e) &#123; &#125; &#125; return r; &#125; Activity启动之后，Android给我们提供了操作系统服务的统一入口，也就是Activity本身。这些工作并不是Activity自己实现的，而是将操作委托给Activity父类ContextThemeWrapper的mBase对象，这个对象的实现类就是ContextImpl ( 也就是performLaunchActivity方法中构建的ContextImpl )。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class ContextImpl extends Context &#123; private final static String TAG = &quot;ApplicationContext&quot;; private final static boolean DEBUG = false; private final static boolean DEBUG_ICONS = false; private static final Object sSync = new Object(); private static AlarmManager sAlarmManager; private static PowerManager sPowerManager; private static ConnectivityManager sConnectivityManager; private AudioManager mAudioManager; LoadedApk mPackageInfo; private Resources mResources; private PackageManager mPackageManager; private NotificationManager mNotificationManager = null; private ActivityManager mActivityManager = null; // 代码省略 @Override public void sendBroadcast(Intent intent) &#123; String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false); &#125; catch (RemoteException e) &#123; &#125; &#125; @Override public void startActivity(Intent intent) &#123; if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; throw new AndroidRuntimeException( &quot;Calling startActivity() from outside of an Activity &quot; + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot; + &quot; Is this really what you want?&quot;); &#125; mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1); &#125; @Override public ComponentName startService(Intent service) &#123; try &#123; ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver())); if (cn != null &amp;&amp; cn.getPackageName().equals(&quot;!&quot;)) &#123; throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); &#125; return cn; &#125; catch (RemoteException e) &#123; return null; &#125; &#125; @Override public String getPackageName() &#123; if (mPackageInfo != null) &#123; return mPackageInfo.getPackageName(); &#125; throw new RuntimeException(&quot;Not supported in system context&quot;); &#125;&#125; 可以看到，ContextImpl内部有很多xxxManager类的对象，也就是我们上文所说的各种子系统的角色。ContextImpl内部封装了一些系统级别的操作，有的子系统功能虽然没有实现，但是也提供了访问该子系统的接口，比如获取ActivityManager的getActivityManager方法。 比如我们要启动一个Activity的时候，我们调用的是startActivity方法，这个功能的内部实现实际上是Instrumentation完成的。ContextImpl封装了这个功能，使得用户根本不需要知晓Instrumentation相关的信息，直接使用startActivity即可完成相应的工作。其他的子系统功能也是类似的实现，比如启动Service和发送广播内部使用的是ActivityManagerNative等。ContextImpl的结构图如下 : 外观模式非常的简单，只是封装了子系统的操作，并且暴露接口让用户使用，避免了用户需要与多个子系统进行交互，降低了系统的耦合度、复杂度。如果没有外观模式的封装，那么用户就必须知道各个子系统的相关细节，子系统之间的交互必然造成纠缠不清的关系，影响系统的稳定性、复杂度。 2.5 桥接模式模式定义 将抽象部分和实现部分相互分离，使它们可以独立变化。 应用场景 如果一个系统需要在抽象部分和实现部分增加更多的灵活性，避免两种变化的时候相互影响。 如果不希望使用继承而增加系统的复杂度，可以考虑使用桥接模式。 一个类存在两个独立变化的纬度，且这两个纬度都希望进行扩展。 Android 源码中的桥接模式桥接模式在 Android 源码中应用广泛，比较典型的有 Adapter 与 AdapterView 的桥接，Window 与 WindowManager 的桥接模式。 Adapter 与 AdapterView 的桥接 Window 与 WindowManager 的桥接 通过以上两 UML 类图应该能明显的看出来桥接模式的影子。 2.6 享元模式模式定义 使用共享对象可以有效的支持大量的细粒度对象。 应用场景 系统中存在着大量的相似对象。 细粒度的对象都具有较接近的外部状态，而且内部状态与外部环境无关。 需要缓冲池的场景。 Android 源码中的享元模式在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 mHandler.obtainMessage() 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？ 1234567891011121314Handler mHandler = new Handler();public void do() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //do sth Message message = mHandler.obtainMessage(); message.what = 1; message.obj = result; mHandler.sendMessage(message); &#125; &#125;);&#125; 1234//Handler.otainMessage()方法public final Message obtainMessage()&#123; return Message.obtain(this);&#125; 可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。 先看看 Message 类部分源码 1234567891011121314151617181920212223242526272829// sometimes we store linked lists of these thingsMessage next;private static final Object sPoolSync = new Object();//作为锁对象private static Message sPool;//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针private static int sPoolSize = 0;//private static final int MAX_POOL_SIZE = 50;//「对象池」中的最大数量public static Message obtain(Handler h) &#123; Message m = obtain();//调用 obtain 方法获取 message 对象 m.target = h;//指定 message 的目标对象 return m;&#125;//从消息对象池中取出一个 Message 对象，如果没有就创建一个public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // 清空 in-use flag sPoolSize--; return m; &#125; &#125; return new Message();//消息池中没有可复用的 Message 就创建一个新的 Message&#125; 至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。 但是 Message 对象是如何被回收到「对象池」中的呢？ 从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？ 在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。 123456789101112131415161718192021222324252627282930313233343536public void recycle() &#123; if (isInUse()) &#123;//判断消息是否还在使用 if (gCheckRecycle) &#123;//如果消息处在使用状态时被 gc 回收，就抛出异常 throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;); &#125; return;//直接返回，取消回收操作 &#125; recycleUnchecked();//调用回收方法&#125;/** * 回收一个可能还在使用的对象 */void recycleUnchecked() &#123; // 只要该对象还在回收对象池中，就标记该对象为正在使用状态。 // 清空其他状态 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; //回收消息到消息池中 synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125;&#125; recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked 方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。 小结 Message 通过在内部构建一个链表来维护一个被会受到 Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。 此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。 想进一步了解 Android 消息机制的同学可参考Android 消息机制解析。 2.7 代理模式模式定义 为其他对象提供一个代理以提供对这个对象的访问。 应用场景 当无法或者不想直接访问某个对象时，可以通过一个代理对象进行访问。 UML类图 角色介绍 抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。 目标对象角色：定义了代理对象所代表的目标对象。 代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。 code：代理模式按照代理类运行前是否存在还可以分为静态代理和动态代理，如下所示： 静态代理 1234567891011121314151617181920212223242526272829// 被代理接口，定义要实现的功能。public interface Subject &#123; void visit();&#125;// 被代理类，完成实际的功能。public class ConcreteSubject implements Subject &#123; @Override public void visit() &#123; System.out.println(&quot;visit&quot;); &#125;&#125;// 静态代理类，与被代理类实现同一套接口public class StaticProxy implements Subject &#123; private Subject mSubject; public StaticProxy(Subject subject) &#123; mSubject = subject; &#125; @Override public void visit() &#123; mSubject.visit(); &#125;&#125; 动态代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 被代理接口，定义要实现的功能。public interface Subject &#123; void visit();&#125;// 被代理类，完成实际的功能。public class ConcreteSubject implements Subject &#123; @Override public void visit() &#123; System.out.println(&quot;visit&quot;); &#125;&#125;// 动态代理类，实现InvocationHandler接口。public class DynamicProxy implements InvocationHandler &#123; private Subject mSubject; public DynamicProxy(Subject subject) &#123; mSubject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;函数执行前自定义操作&quot;); // 调用被代理类的方法时会调用该方法 method.invoke(mSubject, args); System.out.println(&quot;函数执行后自定义操作&quot;); return null; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Subject subject = new ConcreteSubject(); DynamicProxy proxy = new DynamicProxy(subject); // 动态生成代理类 Subject proxySubject = (Subject) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader() , subject.getClass().getInterfaces() , proxy); proxySubject.visit(); &#125;&#125; Android代理模式-Binder直观来说，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。 为了更好地说明Binder，这里我们先手动实现了一个Binder。为了使得逻辑更清晰，这里简化一下，我们来模拟一个银行系统，这个银行提供的功能只有一个：即查询余额，只有传递一个int的id过来，银行就会将你的余额设置为id*10，满足下大家的发财梦。 先定义一个Binder接口 123456789101112131415package com.ryg.design.manualbinder;import android.os.IBinder;import android.os.IInterface;import android.os.RemoteException;public interface IBank extends IInterface &#123; static final String DESCRIPTOR = &quot;com.ryg.design.manualbinder.IBank&quot;; static final int TRANSACTION_queryMoney = (IBinder.FIRST_CALL_TRANSACTION + 0); public long queryMoney(int uid) throws RemoteException;&#125; 2.创建一个Binder并实现这个上述接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.ryg.design.manualbinder;import android.os.Binder;import android.os.IBinder;import android.os.Parcel;import android.os.RemoteException;public class BankImpl extends Binder implements IBank &#123; public BankImpl() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static IBank asInterface(IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof IBank))) &#123; return ((IBank) iin); &#125; return new BankImpl.Proxy(obj); &#125; @Override public IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_queryMoney: &#123; data.enforceInterface(DESCRIPTOR); int uid = data.readInt(); long result = this.queryMoney(uid); reply.writeNoException(); reply.writeLong(result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; @Override public long queryMoney(int uid) throws RemoteException &#123; return uid * 10l; &#125; private static class Proxy implements IBank &#123; private IBinder mRemote; Proxy(IBinder remote) &#123; mRemote = remote; &#125; @Override public IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public long queryMoney(int uid) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); long result; try &#123; data.writeInterfaceToken(DESCRIPTOR); data.writeInt(uid); mRemote.transact(TRANSACTION_queryMoney, data, reply, 0); reply.readException(); result = reply.readLong(); &#125; finally &#123; reply.recycle(); data.recycle(); &#125; return result; &#125; &#125;&#125; ok，到此为止，我们的Binder就完成了，这里只要创建服务端和客户端，二者就能通过我们的Binder来通信了。这里就不做这个示例了，我们的目的是分析代理模式在Binder中的使用。 我们看上述Binder的实现中，有一个叫做“Proxy”的类，它的构造方法如下： 123Proxy(IBinder remote) &#123; mRemote = remote;&#125; Proxy类接收一个IBinder参数，这个参数实际上就是服务端Service中的onBind方法返回的Binder对象在客户端重新打包后的结果，因为客户端无法直接通过这个打包的Binder和服务端通信，因此客户端必须借助Proxy类来和服务端通信，这里Proxy的作用就是代理的作用，客户端所有的请求全部通过Proxy来代理，具体工作流程为：Proxy接收到客户端的请求后，会将客户端的请求参数打包到Parcel对象中，然后将Parcel对象通过它内部持有的Ibinder对象传送到服务端，服务端接收数据、执行方法后返回结果给客户端的Proxy，Proxy解析数据后返回给客户端的真正调用者。很显然，上述所分析的就是典型的代理模式。至于Binder如何传输数据，这涉及到很底层的知识，这个很难搞懂，但是数据传输的核心思想是共享内存。 三 行为型设计模式 3.1 模板模式模式定义 定义一个操作的算法框架，而将具体实现延迟到子类中进行，使得子类在不改变整体算法框架的基础上，可以自定义算法实现。 应用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要复杂的算法可以把核心算法设计为模板方法，具体细节则由子类实现 重构代码时，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 Android应用-Activity/AsyncTask 启动一个Activity过程非常复杂，如果让开发者每次自己去调用启动Activity过程无疑是一场噩梦。好在启动Activity大部分代码时不同的，但是有很多地方需要开发者定制。也就是说，整体算法框架是相同的，但是将一些步骤延迟到子类中，比如Activity的onCreate、onStart等等。这样子类不用改变整体启动Activity过程即可重定义某些具体的操作了~ Android 中 AsyncTask 的几个回调可以看作模板 在Android中，使用了模板方法且为我们熟知的一个典型类就是AsyncTask了，关于AsyncTask的更详细的分析请移步Android中AsyncTask的使用与源码分析，我们这里只分析在该类中使用的模板方法模式。 在使用AsyncTask时，我们都有知道耗时的方法要放在doInBackground(Params… params)中，在doInBackground之前如果还想做一些类似初始化的操作可以写在onPreExecute方法中，当doInBackground方法执行完成后，会执行onPostExecute方法，而我们只需要构建AsyncTask对象，然后执行execute方法即可。我们可以看到，它整个执行过程其实是一个框架，具体的实现都需要子类来完成。而且它执行的算法框架是固定的，调用execute后会依次执行onPreExecute,doInBackground,onPostExecute,当然你也可以通过onProgressUpdate来更新进度。我们可以简单的理解为如下图的模式 : 下面我们看源码，首先我们看执行异步任务的入口, 即execute方法 : 123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; 可以看到execute方法(为final类型的方法)调用了executeOnExecutor方法，在该方法中会判断该任务的状态，如果不是PENDING状态则抛出异常，这也解释了为什么AsyncTask只能被执行一次，因此如果该任务已经被执行过的话那么它的状态就会变成FINISHED。继续往下看，我们看到在executeOnExecutor方法中首先执行了onPreExecute方法，并且该方法执行在UI线程。然后将params参数传递给了mWorker对象的mParams字段，然后执行了exec.execute(mFuture)方法。 mWorker和mFuture又是什么呢？其实mWorker只是实现了Callable接口，并添加了一个参数数组字段，关于Callable和FutureTask的资料请参考Java中的Runnable、Callable、Future、FutureTask的区别与示例，我们挨个来分析吧，跟踪代码我们可以看到，这两个字段都是在构造函数中初始化。 12345678910111213141516171819202122232425262728293031public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); return postResult(doInBackground(mParams)); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; final Result result = get(); postResultIfNotInvoked(result); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; catch (Throwable t) &#123; throw new RuntimeException(&quot;An error occured while executing &quot; + &quot;doInBackground()&quot;, t); &#125; &#125; &#125;; &#125; 简单的说就是mFuture就包装了这个mWorker对象，会调用mWorker对象的call方法，并且将之返回给调用者。关于AsyncTask的更详细的分析请移步Android中AsyncTask的使用与源码分析，我们这里只分析模板方法模式。总之，call方法会在子线程中调用，而在call方法中又调用了doInBackground方法，因此doInBackground会执行在子线程。doInBackground会返回结果，最终通过postResult投递给UI线程。 我们再看看postResult的实现 : 123456789101112131415161718192021222324252627282930313233private Result postResult(Result result) &#123; Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 可以看到，postResult就是把一个消息( msg.what == MESSAGE_POST_RESULT)发送给sHandler，sHandler类型为InternalHandler类型，当InternalHandler接到MESSAGE_POST_RESULT类型的消息时就会调用result.mTask.finish(result.mData[0])方法。我们可以看到result为AsyncTaskResult类型，源码如下 : 12345678910@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)private static class AsyncTaskResult&lt;Data&gt; &#123; final AsyncTask mTask; final Data[] mData; AsyncTaskResult(AsyncTask task, Data... data) &#123; mTask = task; mData = data; &#125;&#125; 可以看到mTask就是AsyncTask对象，调用AsyncTask对象的finish方法时又调用了onPostExecute，这个时候整个执行过程就完成了。 总之，execute方法内部封装了onPreExecute, doInBackground, onPostExecute这个算法框架，用户可以根据自己的需求来在覆写这几个方法，使得用户可以很方便的使用异步任务来完成耗时操作，又可以通过onPostExecute来完成更新UI线程的工作。另一个比较好的模板方法示例就是Activity的声明周期函数，例如Activity从onCreate、onStart、onResume这些程式化的执行模板，这就是一个Activity的模板方法。 Java应用： java.io.InputStream, java.io.OutputStream, java.io.Reader 和 java.io.Writer 的所有非抽象方法. java.util.AbstractList, java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法. javax.servlet.http.HttpServlet, 所有 doXXX() 方法默认发送 HTTP 405 &quot;Method Not Allowed&quot; 错误到响应中. 你可以任意实现这些方法. Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.dp.example.templatemethod;/** * 抽象的Computer * @author mrsimple * */public abstract class AbstractComputer &#123; protected void powerOn() &#123; System.out.println("开启电源"); &#125; protected void checkHardware() &#123; System.out.println("硬件检查"); &#125; protected void loadOS() &#123; System.out.println("载入操作系统"); &#125; protected void login() &#123; System.out.println("小白的电脑无验证，直接进入系统"); &#125; /** * 模板-启动电脑方法, 步骤固定为开启电源、系统检查、加载操作系统、用户登录。该方法为final， 防止算法框架被覆写. */ public final void startUp() &#123; System.out.println("------ 开机 START ------"); powerOn(); checkHardware(); loadOS(); login(); System.out.println("------ 开机 END ------"); &#125;&#125;package com.dp.example.templatemethod;/** * 码农的计算机 * * @author mrsimple */public class CoderComputer extends AbstractComputer &#123; @Override protected void login() &#123; System.out.println("码农只需要进行用户和密码验证就可以了"); &#125;&#125;package com.dp.example.templatemethod;/** * 军用计算机 * * @author mrsimple */public class MilitaryComputer extends AbstractComputer &#123; @Override protected void checkHardware() &#123; super.checkHardware(); System.out.println("检查硬件防火墙"); &#125; @Override protected void login() &#123; System.out.println("进行指纹之别等复杂的用户验证"); &#125;&#125;package com.dp.example.templatemethod;public class Test &#123; public static void main(String[] args) &#123; AbstractComputer comp = new CoderComputer(); comp.startUp(); comp = new MilitaryComputer(); comp.startUp(); &#125;&#125; 3.2 解释器模式模式定义 给定一个语音，定义它的文法的一种表示，并定义一个解释器。 应用场景 如果某个简单的语音需要解释执行并且可以将该语言中的语句表示为一个抽象语法树时可以使用解释器模式。 在某些特定领域不断出现的问题是，可以将该领域的问题转船为一种语法规则下的语句，然后构建解释器来解释该语句。 Android应用PackageParser是对AndroidManifest.xml配置文件进行读取的，具体原理参考：解析AndroidManifest原理 这个用到的地方也不少，其一就是Android的四大组件需要在AndroidManifest.xml中定义，其实AndroidManifest.xml就定义了，等标签（语句）的属性以及其子标签，规定了具体的使用（语法），通过PackageManagerService（解释器）进行解析。PackageParser 3.3 策略模式模式定义 策略模式定义了一系列算法，并将算法封装起来可以互相替换，策略模式让算法与使用它的客户端解耦，可以独立变化。 应用场景 针对同一类型的问题有多种处理方式，仅仅是具体的行为有差别时。 需要安全的封装多种同一类型的操作时。 出现同一抽象类的多个字类，而又需要使用if-else来选择子类时。 UML类图 角色介绍 Context：用来操作策略的上下文环境。 Strategy : 策略的抽象。 ConcreteStrategyA、ConcreteStrategyB : 具体的策略实现。 策略模式的实现也非常简单，依赖于接口或者抽象类，如下所示： 123456789101112131415161718192021222324252627282930// 策略接口，定义功能。public interface IStrategy &#123; void method();&#125;// 策略Apublic class StrategyA implements IStrategy &#123; @Override public void method() &#123; &#125;&#125;// 策略Bpublic class StrategyB implements IStrategy &#123; @Override public void method() &#123; &#125;&#125;// 设置策略-&gt;执行public class Client&#123; IStrategy strategy; public void setStrategy(IStrategy strategy) &#123; this.strategy = strategy; &#125; public void execute()&#123; strategy.method(); &#125;&#125; Android源码对应实现动画里面的插值器Interpolator利用了策略模式, 利用Interpolator策略的抽象, LinearInterpolator,CycleInterpolator等插值器为具体的实现策略, 通过注入不同的插值器实现不同的动态效果. 看一下大概的类图 /imgs/UML_Animation.png) 动画中的TimeInterpolator时间插值器, 它的作用是根据时间流逝的百分比计算出当前属性值改变的百分比, 内置的插值器有如下几种 线性插值器(LinearInterpolator)用于匀速动画 加速减速插值器(AccelerateDecelerateInterpolator):起始时动画加速, 结尾时动画减速 减速插值器(DecelerateInterpolator): 用于随着时间的推移动画越来越慢. 动画中的TypeEvalutor类型估值器: 根据当前属性改变的百分比来计算改变后的属性值. 内置的类型估值器有如下几种 整型估值器(IntEvalutor) 浮点型估值器(FloatEvalutor) Color估值器(ArgbEvalutor) 接下来就开始回忆一下从一个动画开始后, 代码究竟做了什么? 对于源码的起始点入口就是调用View的startAnimation() 12345678910public void startAnimation(Animation animation) &#123; // 1.初始化动画的开始时间 animation.setStartTime(Animation.START_ON_FIRST_FRAME); // 2.对View设置动画 setAnimation(animation); // 3.刷新父类缓存 invalidateParentCaches(); // 4.刷新View本身及子View invalidate(true);&#125; 这里首先设置了动画的起始时间, 然后将该动画设置到View中, 最后再向ViewGroup请求刷新视图, 随后ViewGroup会调用dispatchDraw()方法对这个View所在的区域进行重绘. 其实对于某一个View的重绘最终是调用其ViewGroup的drawChild(...)方法. 跟入一下 1234567891011121314151617181920protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; // 简单的转发 return child.draw(canvas, this, drawingTime);&#125;boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; // .... // 查看是否需要清除动画信息 final int flags = parent.mGroupFlags; // 省略无关代码 // 获取设置的动画信息 final Animation a = getAnimation(); if (a != null) &#123; // 绘制动画 more = drawAnimation(parent, drawingTime, a, scalingRequired); //... &#125; &#125; 父类会调用子类的draw方法, 其中会先判断是否设置了清除动画的标记, 然后再获取该View动画信息, 如果设置了动画, 就会调用View#drawAnimation()方法. 12345678910111213141516171819202122232425262728293031323334353637383940private boolean drawAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired) &#123; Transformation invalidationTransform; final int flags = parent.mGroupFlags; final boolean initialized = a.isInitialized(); // 1. 判断动画是否已经初始化过 if (!initialized) &#123; a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight()); a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop); if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler); // 如果设置了动画的监听, 则触发对应的回调 onAnimationStart(); &#125; // 获取Transformation对象, 存储动画的信息 final Transformation t = parent.getChildTransformation(); // 2. 调用Animation#getTransformation, 通过计算获取动画的相关值 boolean more = a.getTransformation(drawingTime, t, 1f); if (more) &#123; // 3. 根据具体实现, 判断当前动画类型是否需要进行调整位置大小, 然后刷新不同的区域 if (!a.willChangeBounds()) &#123; // ... &#125; else &#123; // 获取重绘区域 a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region, invalidationTransform); parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION; // 更新计算有效区域 final int left = mLeft + (int) region.left; final int top = mTop + (int) region.top; // 进行区域更新 parent.invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f)); &#125; &#125; return more;&#125; drawAnimation中主要操作是动画的初始化, 动画操作, 界面刷新. 动画的回调监听onStart()会在动画进行初始化的时候调用, 动画的具体实现是通过Animation#getTransformation()方法.这个方法主要获取了缩放系数和调用Animation.getTransformation(long, Transformation)来计算和应用动画效果. 123456789101112131415161718192021222324252627282930public boolean getTransformation(long currentTime, Transformation outTransformation) &#123; //... float normalizedTime; // 1.计算当前时间的流逝百分比 if (duration != 0) &#123; normalizedTime = ((float) (currentTime - (mStartTime + startOffset))) / (float) duration; &#125; else &#123; // time is a step-change with a zero duration normalizedTime = currentTime &lt; mStartTime ? 0.0f : 1.0f; &#125; // 动画是否完成标记 final boolean expired = normalizedTime &gt;= 1.0f; mMore = !expired; if ((normalizedTime &gt;= 0.0f || mFillBefore) &amp;&amp; (normalizedTime &lt;= 1.0f || mFillAfter)) &#123; // 2.通过插值器获取动画执行百分比 , 这里获取的方法就是通过策略模式 final float interpolatedTime = mInterpolator.getInterpolation(normalizedTime); // 3.应用动画效果 applyTransformation(interpolatedTime, outTransformation); &#125; // 4. 如果动画执行完毕, 那么触发动画完成的回调或者执行重复动画等操作 // ... if (!mMore &amp;&amp; mOneMoreTime) &#123; mOneMoreTime = false; return true; &#125; return mMore;&#125; 这段代码, 先计算已经流逝的的时间百分比, 然后再通过具体的插值器重新计算这个百分比, 也就是上面的第二步. 而具体是哪一个插值器是通过之前说的策略模式来实现的. 第3步调用了applyTransformation, 这个方法在基类Animation中是空实现, 可以在子类查看实现如ScaleAnimation,AlphaAnimation等查看. 当这个方法内部主要通过矩阵来实现动画. 当这个方法执行完毕之后, View的属性也就发生了变化, 不断地重复这个过程, 动画就随之产生. Java应用 3.4 状态模式模式定义 允许一个对象在内部状态改变时改变它的行为。 应用场景 一个对象的行为取决于它的状态，并且它在运行时根据状态改变它的行为。 代码中包含大量与对象状态相关的判断语句。 状态模式的核心是根据不同的状态对应不同的操作，如下所示： 123456789101112131415161718192021222324252627282930313233// 操作接口public interface TVState &#123; void nextChannel(); void lastChannel();&#125;// 开机状态public class PowerOnState implements TVState &#123; @Override public void nextChannel() &#123; // next channel &#125; @Override public void lastChannel() &#123; // last channel &#125;&#125;// 关机状态public class PowerOffChannel implements TVState &#123; @Override public void nextChannel() &#123; // do nothing &#125; @Override public void lastChannel() &#123; // do nothing &#125;&#125; Android应用-StateMachine机制http://blog.csdn.net/maybe_windleave/article/details/9881991 http://blog.csdn.net/lilian0118/article/details/21974229 在我们的应用开发中也可以使用源码中的StateMachine类，只要从源码中把StateMachine和State类拷贝到我们的工程目录就可以使用了，对于其 import 的一些类，在我们的开发环境中也全都有，不用担心。 如果你对状态机有那么一丝丝的了解，那么学习 StateMachine 类最好的资料就是它的注释了，解释的一清二楚。 简单使用阐述 Android 中的状态机是一个分层的消息处理机制，每一层都会有一到多个节点，而状态机的消息就是在这些节点之间流转处理，如下结构所示： 12345678// 状态机分层结构 mP0 / \ mP1 mS0 / \ mS2 mS1 / \ \ mS3 mS4 mS5 ---&gt; initial state 初始节点 而节点就是State类，它实现了IState接口，除了enter、exit方法外，还有processMessage方法，表示用来处理节点的消息。若返回HANDLED则表示消息处理完成，若返回NOT_HANDLED则表示消息没有处理。 构造状态机 在我们使用 StateMachine 之前，要构造好所需的状态分层结构。通过addState方法来向状态机中添加节点，例如如下的状态结构，mS1 和 mS2 节点有公共的父节点 mP1，同时还有一个孤立的节点 mP2。 123456789// 状态分层结构设定 mP1 mP2 / \mS2 mS1// 构造状态机结构代码addState(mP1); addState(mS1, mP1); addState(mS2, mP1);addState(mP2); addState方法添加节点时，还能指定其父节点添加。 当我们构造完了状态机时，还需要指定其中一个节点为启动点，消息从启动点开始处理，通过setInitialState方法来指定启动点，最后通过start方法启动状态机。 状态机消息处理 当构造完想要的状态机结构时，就是对状态机内部消息流转的处理了。 当start状态机时，状态机的第一个动作就是调用节点的enter方法，不过，它调用的是指定的启动点的最远的父节点的enter方法，然后再是次一级的父节点的enter方法，最后才是启动点的enter方法，就如同上面的结构所示，先调用 mP1 点，然后才是 mS1 点的方法，此时 mS1 节点就是状态机的当前对外的点。由此可见，当启动点进入 enter状态时，它的父节点，直至最顶层的父节点都进入了enter状态了。 状态机中的每个节点都 0 个或 1 个父节点，当子节点不能处理当前消息时，它可以通过返回NOT_HANDLED将当前消息传递给其父节点来处理。如果一个消息从未被处理过，那么unhandledMessage方法将会被调用给最后一次机会来处理该消息。 除此之外，节点还可以通过transitionTo方法将当前节点转移至另外一个新的节点。 1234567 mP0 / \ mP1 mS0 / \ mS2 mS1 / \ \mS3 mS4 mS5 ---&gt; initial state 例如，当 mS5 处理消息，想要将当前节点转移至 mS4 时，那么它会先找到 mS5 和 mS4 最近的公有父节点 mP1。然后，除了这个最近的公有父节点 mP1 以及它的上层节点外，mS5 进入enter状态时启动的那些父节点都会退出调用exit方法。最后再由 mP1 节点下的节点调用enter方法直到新节点 mS4 调用了enter方法。 也就是说，从 mS5 到 mS4 状态的转变，先是 mS5、mS1 调用了exit方法，再是 mS2、mS4 调用了enter方法，这就是状态机中节点发生状态转移时的调用过程。 除此之外，节点还可以调用deferMessage和sendMessageAtFroneOfQueue方法。deferMessage方法使得消息存储在消息队列中，当状态转移到新节点时才会处理，而sendMessageAtFrontOfQueue方法则是将消息放置到消息队列的头部。 当状态机的所有消息都完成时，可以调用transitionToHaltingState方法来将状态机处理停止状态。此时，状态机将转移到HaltingState停止状态，并调用halting方法。随后收到的所有消息都只是会调用haltedProcessMessage方法来处理了。 若想要完全的停止状态机，则可以使用quit或者quitNow方法来处理。 以上就是状态机对于消息处理的过程，长篇的文字说明还是不如代码来的直观，这里就不贴完整的代码了，参考代码的连接如下：GithubGist 链接地址 状态机实现原理分析 如果我们在初始化状态机时只是传递了一个名字，而没有传递 Looper 或者 Handler 之类的消息循环，那么状态机默认就是启用其内部的一个线程HandlerThread。 1234567891011protected StateMachine(String name) &#123; mSmThread = new HandlerThread(name); // 创建 HandlerThread 线程 mSmThread.start(); Looper looper = mSmThread.getLooper(); initStateMachine(name, looper); &#125; // 将消息循环 Looper 与 Handler 进行绑定private void initStateMachine(String name, Looper looper) &#123; mName = name; mSmHandler = new SmHandler(looper, this); &#125; 构造状态及时，在其内部开启了一个线程，并将其消息循环 Looer 传递给了 SmHandler 对象，而SmHandler对象就是状态机中最主要的用来派发消息事件和切换状态的了，它派发的消息都是在 HandlerThread 线程进行处理的。 同时，SmHandler 内部有两个数组，用来保存状态机中的链式状态关系，分别是mStateStack和mTempStateStack变量。当状态机完成启动时，就会通过上面来个变量来保存节点信息。 而状态机的消息处理，内部也是通过 SmHandler 来处理转发的。 具体的实现，建议参考这篇文章：http://blog.csdn.net/yangwen123/article/details/10591451 讲的实在太详细了，拜读了多遍也不敢说写的能比它更清楚。 3.5 观察者模式模式定义 定义对象间一对多的依赖关系，每当这个对象发生改变时，其他对象都能收到通知并更新自己。 应用场景 关联行为场景 事件多级触发场景 跨系统的消息交换场景，例如消息队列，事件总线的处理机制。 观察者模式的实现如下所示： 1234567891011121314151617181920212223242526272829303132333435// 监听接口，通知被监听对象发生改变public interface Listener &#123; void change();&#125;// 被监听者public class Observable &#123; private Listener mListener; // 设置监听器 public void setListener(Listener listener) &#123; mListener = listener; &#125; public void onChange() &#123; // 通知对象发生改变 mListener.change(); &#125;&#125;// 监听者public class Observer &#123; public void setup() &#123; Observable observable = new Observable(); observable.setListener(new Listener() &#123; @Override public void change() &#123; // TODO 监听的对象发生改变 &#125; &#125;); &#125;&#125; 实际应用 android应用 我们看看ListView的适配器，有个函数notifyDataSetChanged()函数，这个函数其实就是通知ListView的每个Item，数据源发生了变化，请各位Item重新刷新一下。 jdk应用 java.util.Observer/java.util.Observable (在现实世界中很少使用) java.util.EventListener 的所有实现 (几乎所有的Swing都是这样) javax.servlet.http.HttpSessionBindingListener javax.servlet.http.HttpSessionAttributeListener javax.faces.event.PhaseListener 1 JDK源码中的观察者模式​ 不管是在《大话设计模式》，还是GoF的《设计模式》，还是别的关于设计模式的经典书籍，抑或是在各类技术博客，大家可以轻易地找到关于观察者模式的定义和示例。因此观察者模式的概念和基本使用不是本文的讨论重点。重点是，观察者模式的使用是如此的广泛，以至于JDK源码中已为该模式提供java.util.Observable基类和java.util.Observers接口。 ​ JDK中的观察者模式的使用如图所示：Student类实现Observer接口，通过addObserver方法注册到Teacher的观察者列表中去；而Teacher类继承自Observable基类，当Teacher发布消息（publishMessage)时调用notifyObservers()方法，遍历观察者列表中的所有Student，调用他们的update方法；于是Teacher中的message传递到了每个Student中。 ​ JDK中的Observable基类和Observer接口为我们的简单使用观察者模式提供了方便，但它有一个非常明显的缺点：为了使用观察者模式，需要让Teacher继承Observable这个基类，但是Teacher可能已经继承了Person类，而Java又是单继承，不能同时再继承Observable类。解决这个矛盾的思路有两种：一是自定义观察者模式，将add、delete、notify等方法写进Teacher类；二是使用代理模式，在Teacher中维护一个Observable类的对象，并且实现同名的方法，类似如下代码。 12345678910111213public void addObserver(Observer observer)&#123; mObservable.addObserver(observer);&#125;此处不展开讨论了，Android源码中的观察者就是采用类似第二种思路的方法。 2 Android源码中的观察者模式​ 其实翻看Android源码，发现Android并没有使用JDK的Observable基类和Observer接口。Instead，Android定义了一个android.database.Observable抽象类，其中T是Oberver type。Observable抽象类中只有registerObserver、unregisterObserver和unregisterAll三个抽象方法，notify的操作需要子类自己定义。与JDK中Observer接口相对应的是DataSetObserver抽象类，里面有onChanged和onValidated两个抽象方法。notify方法、DataSetObserver类、onChanged方法，是不是想到了什么东西？对，setDataSetChanged()！是不是很熟悉？ 2.1 ListView源码中的观察者模式​ 在使用ListView时，数据改变后，我们会手动去调用ListView对应的adapter的setDataSetChanged()方法来通知ListView更新UI。换一种说法，ListView的UI是观察者，ListView对应的adapter中的数据是被观察者，ListView通过注册一个观察者到adapter中，以实现监听adapter的数据变化的目的。经过刨祖坟一般的Ctrl+鼠标左键之后，画出如下UML类图。图中可以看到，ListView注册到adapter中的观察者叫AdapterDataSetObserver，定义在ListView的父类AbsListview中。它又继承自AbsListView的父类AdapterView类中的同名AdapterDataSetObserver。AdapterView.AdapterDataSetObserver最终继承自DataSetObserver抽象类。 ​ 那当数据发生改变，要更新 UI 的时候怎么办呢？ Android 的做法是，在 Adapter 中添加一个『老板』对象，让 Adapter 拥有『老板』的所有权利。然后在 ListView 中，添加一个『员工』对象（继承 DataSetObserver，在重写父类方法时，更新 UI）。另外在 ListView 的 setAdapter 方法中，将『员工』和『老板』绑定起来，实现『老板』和『员工』的雇佣关系。最后开发者就可以调用 Adapter 的方法notifyDataSetChanged()，让『老板』命令『员工』干活了！ 接下来我们看一下代码实现。 BaseAdapter.Java： 拥有DataSetObservable对象，就是说Adapter是『老板』的上司，拥有『老板』的所有权利。 123456789101112131415public abstract class BaseAdapter &#123; private final DataSetObservable mDataSetObservable = new DataSetObservable(); public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer); &#125; public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer); &#125; public void notifyDataSetChanged() &#123; mDataSetObservable.notifyChanged(); &#125; public void notifyDataSetInvalidated() &#123; mDataSetObservable.notifyInvalidated(); &#125;&#125; ListView.Java：setAdapter()方法中，将 AdapterDataSetObserver 注册到 Adapter 的DataSetObservable中，实现『老板』和『员工』的雇佣关系。 1234567891011public class ListView &#123; ...代码省略 @Override public void setAdapter(ListAdapter adapter) &#123; ...代码省略 mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); ...代码省略 &#125; ...代码省略&#125; AdapterDataSetObserver 继承了 DataSetObserver，重写父类函数时，进行更新界面的操作。 2.2 RecyclerView中的观察者模式​ 由于最近使用RecyclerView代替ListView，所以把RecyclerView中的观察者模式的实现源码也挖出来了. 3.6 备忘录模式模式定义 在不破坏封装的前提下，保存一个对象的内部状态，并在该对象之外保存这个状态，以便可以将该对象恢复到保存时的状态。 应用场景 需要保存某个对象在某一时刻的状态。 外界向访问对象的状态，但是又不想直接暴露接口给外部，这时候可以将对象状态保存下来，间接的暴露给外部。 实际应用 Activity的onSaveInstanceState和onRestoreInstanceState就是用到了备忘录模式，分别用于保存和恢复。 jdk源码中应用 java.util.Date ( setter 方法就是这么做的, Date 内部通过长整型long表示) java.io.Serializable的所有实现 javax.faces.component.StateHolder的所有实现 3.7 中介者模式模式定义 中介者模式定义了一系列对象间的交互方式，使得这些对象像话作用而又不耦合在一起。 应用场景 当对象间有很多的交互操作，而且一个对象的行为依赖于其他对象时，可以利用中介者模式解决紧耦合的问题。 Android应用中介者模式的意图为：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式的结构图如下： ​ 在 ANDROID系统中keyguard的功能实现采用了中介者模式，用来中介keyguard相关的请求，包括查询keyguard的状态，影响keyguard应当显示和复位的电源管理事件，以及当keyguard显示时对窗口管理的通知事件和来自keyguard视图本身的关于keyguard是否成功unlocked的事件等。相关UML类图如下： ​ ​ 其中KeyguardViewMediator作为中介者角色，与电源管理、用户管理、报警管理、声音管理、状态条管理、KeyguardViewManager、KeyguardDisplayManager、KeyguardUpdateMonitor等服务或对象交互， 读取相关状态，执行和触发keyguard事件相关的功能等 ，而KeyguardViewManager、KeyguardHostView、KeyguardUpdateMonitor类通过相关回调向KeyguardViewMediator传送Keyguard视图本身和keyguard有关状态更新方面的事件， 另外KeyguardService服务也是通过KeyguardViewMediator查询keyguard的状态 并通过IKeyguardService接口对外提供keyguard的状态信息。 3.8 命令模式模式定义 将一个请求封装成一个对象，可以将不同的请求参数化，可以对请求就行排队、日志记录以及撤销等操作。 应用场景 需要抽象待执行的动作，然后以参数的形式提供出来。 在不同的时刻，指定和排列请求。 需要支持撤销操作。 需要支持日志功能，这样当系统崩溃时，可以重做一遍。 需要支持事务操作。 命令模式的实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 接收命令public class Receiver &#123; public void action() &#123; // TODO 真正执行命令具体逻辑 &#125;&#125;// 抽象命令public interface AbstractCommand &#123; // 执行命令 void command();&#125;// 具体命令public class ConcreteCommand implements AbstractCommand &#123; private Receiver mReceiver; public ConcreteCommand(Receiver receiver) &#123; mReceiver = receiver; &#125; @Override public void command() &#123; mReceiver.action(); &#125;&#125;// 调用者public class Invoker &#123; private AbstractCommand mCommmand; public Invoker(AbstractCommand command) &#123; mCommmand = command; &#125; public void invoke() &#123; mCommmand.command(); &#125;&#125; Android源码中的模式实现Command接口中定义了一个execute方法，客户端通过Invoker调用命令操作再来调用Recriver执行命令；把对Receiver的操作请求封装在具体的命令中，使得命令发起者和命令接收者解耦。 以Android中大家常见的Runnable为例：客户端只需要new Thread(new Runnable(){}).start()就开始执行一系列相关的请求，这些请求大部分都是实现Runnable接口的匿名类。 【O_o 模式就在我们身边~】 命令接口Runnable接口定义如下： 1234567891011121314package java.lang;/** * Represents a command that can be executed. Often used to run code in a * different &#123;@link Thread&#125;. */public interface Runnable &#123; /** * Starts executing the active part of the class&apos; code. This method is * called when a thread is started that has been created with a class which * implements &#123;@code Runnable&#125;. */ public void run();&#125; 调用者Thread源码如下（省略部分代码）： Tips：命令模式在这里本来不需要继承Runnable接口，但为了方便性等，继承了Runnable接口实现了run方法，这个run是Thread自身的运行run的方法，而不是命令Runnable的run。 1234567891011121314151617181920212223public class Thread implements Runnable &#123; //省略部分无关代码... /* some of these are accessed directly by the VM; do not rename them */ volatile VMThread vmThread; volatile ThreadGroup group; volatile boolean daemon; volatile String name; volatile int priority; volatile long stackSize; Runnable target; private static int count = 0; public synchronized void start() &#123; if (hasBeenStarted) &#123; throw new IllegalThreadStateException(&quot;Thread already started.&quot;); // TODO Externalize? &#125; hasBeenStarted = true; VMThread.create(this, stackSize); &#125; //省略部分代码...&#125; 上面可以看到执行start()方法的时候实际执行了VMThread.create(this, stackSize)方法；create是VMThread的本地方法，其JNI实现在 android/dalvik/vm/native/java_lang_VMThread.cpp 中的 Dalvik_java_lang_VMThread_create方法，如下： 123456789static void Dalvik_java_lang_VMThread_create(const u4* args, JValue* pResult)&#123; Object* threadObj = (Object*) args[0]; s8 stackSize = GET_ARG_LONG(args, 1); /* copying collector will pin threadObj for us since it was an argument */ dvmCreateInterpThread(threadObj, (int) stackSize); RETURN_VOID();&#125; 而dvmCreateInterpThread的实现在Thread.app中，如下： 123456789101112131415161718192021222324252627282930bool dvmCreateInterpThread(Object* threadObj, int reqStackSize)&#123; Thread* self = dvmThreadSelf(); Thread* newThread = allocThread(stackSize); newThread-&gt;threadObj = threadObj; Object* vmThreadObj = dvmAllocObject(gDvm.classJavaLangVMThread, ALLOC_DEFAULT); dvmSetFieldInt(vmThreadObj, gDvm.offJavaLangVMThread_vmData, (u4)newThread); dvmSetFieldObject(threadObj, gDvm.offJavaLangThread_vmThread, vmThreadObj); pthread_t threadHandle; int cc = pthread_create(&amp;threadHandle, &amp;threadAttr, interpThreadStart, newThread); dvmLockThreadList(self); assert(newThread-&gt;status == THREAD_STARTING); newThread-&gt;status = THREAD_VMWAIT; pthread_cond_broadcast(&amp;gDvm.threadStartCond); dvmUnlockThreadList(); &#125;static Thread* allocThread(int interpStackSize)&#123; Thread* thread; thread = (Thread*) calloc(1, sizeof(Thread)); thread-&gt;status = THREAD_INITIALIZING;&#125; 这里是底层代码，简单介绍下就行了： 第4行通过调用 allocThread 创建一个名为newThread的dalvik Thread并设置一些属性，第5行设置其成员变量threadObj为传入的Android Thread，这样dalvik Thread就与Android Thread对象关联起来了；第7行然后创建一个名为vmThreadObj的VMThread对象，设置其成员变量vmData为前面创建的newThread，设置 Android Thread threadObj的成员变量vmThread为这个vmThreadObj，这样Android Thread通过VMThread的成员变量vmData就和dalvik Thread关联起来了。 接下来在12行通过pthread_create创建pthread线程，并让这个线程start，这样就会进入该线程的thread entry运行，下来我们来看新线程的thread entry方法 interpThreadStart，同样只列出关键的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//pthread entry function for threads started from interpreted code.static void* interpThreadStart(void* arg)&#123; Thread* self = (Thread*) arg; std::string threadName(dvmGetThreadName(self)); setThreadName(threadName.c_str()); //Finish initializing the Thread struct. dvmLockThreadList(self); prepareThread(self); while (self-&gt;status != THREAD_VMWAIT) pthread_cond_wait(&amp;gDvm.threadStartCond, &amp;gDvm.threadListLock); dvmUnlockThreadList(); /* * Add a JNI context. */ self-&gt;jniEnv = dvmCreateJNIEnv(self); //修改状态为THREAD_RUNNING dvmChangeStatus(self, THREAD_RUNNING); //执行run方法 Method* run = self-&gt;threadObj-&gt;clazz-&gt;vtable[gDvm.voffJavaLangThread_run]; JValue unused; ALOGV(&quot;threadid=%d: calling run()&quot;, self-&gt;threadId); assert(strcmp(run-&gt;name, &quot;run&quot;) == 0); dvmCallMethod(self, run, self-&gt;threadObj, &amp;unused); ALOGV(&quot;threadid=%d: exiting&quot;, self-&gt;threadId); //移出线程并释放资源 dvmDetachCurrentThread(); return NULL;&#125;//Finish initialization of a Thread struct.static bool prepareThread(Thread* thread)&#123; assignThreadId(thread); thread-&gt;handle = pthread_self(); thread-&gt;systemTid = dvmGetSysThreadId(); setThreadSelf(thread); return true;&#125;//Explore our sense of self. Stuffs the thread pointer into TLS.static void setThreadSelf(Thread* thread)&#123; int cc; cc = pthread_setspecific(gDvm.pthreadKeySelf, thread);&#125; 在新线程的interpThreadStart方法中，首先设置线程的名字，然后调用prepareThread设置线程id以及其它一些属性，其中调用了setThreadSelf将新dalvik Thread自身保存在TLS中，这样之后就能通过dvmThreadSelf方法从TLS中获取它。然后在29行处修改状态为THREAD_RUNNING，并在36行调用对应Android Thread的run()方法，其中调用了Runnable的run方法，运行我们自己的代码。 绕这么深才执行到我们的run方法，累不累？ v_v 12345678910/** * Calls the &lt;code&gt;run()&lt;/code&gt; method of the Runnable object the receiver * holds. If no Runnable is set, does nothing. * @see Thread#start */public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 到此我们已经完成一次命令调用，至于底层run调用完毕后续执行代码，读者可以自行跟进看看~~~ 3.9 访问者模式模式定义 封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。 应用场景 对象结构比较稳定，但是需要在对象结构的基础上定义新的操作。 需要对同一个类的不同对象执行不不同的操作，但是不希望增加操作的时候改变这些类。 Android源码对应实现APT的注解. 简单记录一下. 首先编译器将代码抽象成一个代码元素的树, 然后在编译时对整棵树进行遍历访问, 每个元素都有一个accept()接收访问者的访问, 每个访问者中都有对应的visit()函数, 例如visitType()函数就是对类型元素的访问, 在每个visit函数中对不同的类型进行不同的处理, 这样就达到了差异处理效果, 同时将数据结构与数据操作分离, 使得每个类型的职责单一, 易于升级维护. JDK还特意预留了visitUnknown()接口应对Java语言后续发展可能添加的元素类型问题, 灵活的将访问者模式的缺点化解. https://blog.csdn.net/xxxzhi/article/details/51747513 编译时注解依赖于APT(Annotation Processing Tools)实现，在编译器会自己生成相关的java类。 注解可以指定作用于哪种元素上， 比如： PackageElement，包元素 TypeElement，类型元素 ExecutableElement，可执行元素 VariableElement，变量元素 TypeParameterElement，类型参数元素 Element基类里面有一个accept(ElementVisitor&lt;R,p&gt; v,P p)方法 ElementVisitor里面又根据不同的元素类型重载很很多visit方法。 比如类型元素访问者 里面是visitType(TypeElement e,P p)方法，然后里面做了这种类型元素需要的操作。 3.10 责任链模式模式定义 将请求的发送者和接收者进行解耦，使得多个对象都有机会处理该请求，将这些对象串成一条链，并沿着这条链子处理请求，直到有对象处理它为止。 应用场景 多个对象可以处理同一个请求，但是具体由哪个对象处理在运行时动态决定。 在请求处理者不明确的情况下向多个对象中的一个提交请求。 需要动态指定一组对象的处理请求。 责任链模式的实现主要在于处理器的迭代，要么使用循环迭代，要么使用链表后继，如下所示： 123456789101112131415161718192021222324252627282930313233// 处理器，定位行为和下一个处理器public abstract class Handler &#123; protected Handler next; public abstract void handleRequest(String condition);&#125;// 处理器1public class Handler1 extends Handler &#123; @Override public void handleRequest(String condition) &#123; if (TextUtils.equals(condition, &quot;Handler1&quot;)) &#123; // process request &#125; else &#123; // next handler next.handleRequest(condition); &#125; &#125;&#125;// 处理器2public class Handler2 extends Handler &#123; @Override public void handleRequest(String condition) &#123; if (TextUtils.equals(condition, &quot;Handler2&quot;)) &#123; // process request &#125; else &#123; // next handler next.handleRequest(condition); &#125; &#125;&#125; Android应用-事件分发 https://www.jianshu.com/p/e99b5e8bd67b 3.11 迭代器模式模式定义 提供一个方法顺序访问一个容器内的元素，而又不暴露该对象的内部表示。 应用场景 遍历一个容器时。 UML类图 角色介绍 迭代器接口Iterator：该接口必须定义实现迭代功能的最小定义方法集比如提供hasNext()和next()方法。 迭代器实现类：迭代器接口Iterator的实现类。可以根据具体情况加以实现。 容器接口：定义基本功能以及提供类似Iterator iterator()的方法。 容器实现类：容器接口的实现类。必须实现Iterator iterator()方法。 Android应用一个集合想要实现Iterator很是很简单的,需要注意的是每次需要重新生成一个Iterator来进行遍历.且遍历过程是单方向的,HashMap是通过一个类似HashIterator来实现的,我们为了解释简单,这里只是研究ArrayList(此处以Android L源码为例,其他版本略有不同) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayListIterator();&#125;private class ArrayListIterator implements Iterator&lt;E&gt; &#123; /** Number of elements remaining in this iteration */ private int remaining = size; /** Index of element that remove() would remove, or -1 if no such elt */ private int removalIndex = -1; /** The expected modCount value */ private int expectedModCount = modCount; public boolean hasNext() &#123; return remaining != 0; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; ArrayList&lt;E&gt; ourList = ArrayList.this; int rem = remaining; if (ourList.modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; if (rem == 0) &#123; throw new NoSuchElementException(); &#125; remaining = rem - 1; return (E) ourList.array[removalIndex = ourList.size - rem]; &#125; public void remove() &#123; Object[] a = array; int removalIdx = removalIndex; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; if (removalIdx &lt; 0) &#123; throw new IllegalStateException(); &#125; System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining); a[--size] = null; // Prevent memory leak removalIndex = -1; expectedModCount = ++modCount; &#125;&#125; java中的写法一般都是通过iterator()来生成Iterator,保证iterator()每次生成新的实例 remaining初始化使用整个list的size大小,removalIndex表示remove掉的位置,modCount在集合大小发生变化的时候后都会进行一次modCount++操作,避免数据不一致,前面我写的例子这方面没有写,请务必注意这点 hasNext方法中,因为remaining是一个size-&gt;0的变化过程,这样只需要判断非0就可以得知当前遍历的是否还有未完成的元素 next,第一次调用的时候返回array[0]的元素,这个过程中removalIndex会被设置成当前array的index remove的实现是直接操作的内存中的数据,是能够直接删掉元素的,不展开了 三种模式关系1．创建型模式创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。 社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是： 简单工厂模式（Simple Factory） 工厂方法模式（Factory Method） 抽象工厂模式（Abstract Factory） 创建者模式（Builder） 原型模式（Prototype） 单例模式（Singleton） 简单工厂模式不是GoF总结出来的23种设计模式之一 2．结构型模式结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。 在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是： 外观模式/门面模式（Facade门面模式） 适配器模式（Adapter） 代理模式（Proxy） 装饰模式（Decorator） 桥梁模式/桥接模式（Bridge） 组合模式（Composite） 享元模式（Flyweight） 3．行为型模式行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。1. 行为类模式使用继承机制在类间分派行为。2. 行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。 在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是： 模板方法模式（Template Method） 观察者模式（Observer） 状态模式（State） 策略模式（Strategy） 职责链模式（Chain of Responsibility） 命令模式（Command） 访问者模式（Visitor） 调停者模式（Mediator） 备忘录模式（Memento） 迭代器模式（Iterator） 解释器模式（Interpreter） 三者之间的区别和联系 创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。 创建型模式为其他两种模式使用提供了环境。 结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。 行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。 的 创建型模式Creational Pattern 结构型模式Structural Patterns 行为型模式Behavioral Pattern 概念 创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑 结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）封装性（适配器，桥接） 行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为型模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式1.行为模式使用继承机制在类间分派行为2.行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。 类 Factory Method Adapter(类) Interpreter Template Method 对象 Abstract Factory Adapter(对象) Chain of Responsibility Builder Bridge Command Prototype Composite Iterator Singleton Decorator Mediator Facade Memento Flyweight Observer Proxy State Strategy Visitor 设计原则 开闭原则： 对扩展开放，对修改关闭 里氏转换原则： 子类继承父类，单独完全可以运行 依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型 接口隔离原则： 每一个接口应该是一种角色 合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分 迪米特原则： 一个对象应对其他对象有尽可能少的了解 Android 源码中设计模式下面我们简要的介绍一下设计模式在 Android 源码中的应用工厂方法模式： 接口 Iterable 中的 iterator 就是一个工厂方法， Activity 中的 onCreate 也可以看作是工厂方法抽象工厂模式： MediaPlayerFactory 是一个抽象工厂单例模式： 单例模式的应用非常广泛， Application 就是单例的， WindowManagerService 、 ActivityService 等系统级的 Service 也是单例的，具体可见 单例模式建造者模式 ：建造者模式在图片加载库中使用非常普遍，例如 Picasso 、 Glide 、UniversalImageLoader 中都有建造者模式的身影。在 Android 源码中 AlertDialog 中应用了建造者模式，详见 设计模式之 Builder 模式原型模式：原型模式就是实现接口 Cloneable ，这个太多了。。。适配器模式：这个不用说了， AbsListView 和 RecyclerView 都使用了适配器模式。详见：设计模式之适配器模式装饰器模式：Context 、 ContextImpl 、 ContextWrapper 、ContextThemeWrapper代理模式： AIDL ，ActivityProxy（其实这也是 AIDL ）外观模式：Context 作为 Android 系统中的上帝类，封装了很多功能，这也是外观模式的应用桥接模式：Adapter 与 AdapterView 的桥接，Window 与 WindowManager 的桥接 详见：设计模式之桥接模式组合模式： View 、 ViewGroup享元模式：Message 中的 MessagePool 是用链表实现的。策略模式：动画中的 InterPolator 和 TypeEvaluator 。详见Android 动画分析模板方法模式: 模板模式的应用非常广泛， Android 中 AsyncTask 的几个回调可以看作模板。观察者模式： AbsListView 和 RecyclerView 都使用了观察者模式，详见设计模式之观察者模式迭代子模式： 这个不用说了，在 JDK 中的集合类都是迭代子模式。责任链模式： View 中对于事件的分发处理可以看作是责任链模式。详见利用责任链模式实现加载不同来源的数据命令模式： Android 事件的底层 NotifyArgs 就是一个命令对象。备忘录模式： Android 的状态保存， onSaveInstanceState 、 onRestoreInstaceState状态模式： WIFI 管理访问者模式： Java 注解 APT中介者模式： KeyGuard 功能的实现解释器模式： PackageParser 中有解释器模式的影子 Java设计模式:JDK中的应用创建型模式抽象工厂模式(通过创建的方法返回工厂本身, 可以依次创建另一个抽象/接口类型)javax.xml.parsers.DocumentBuilderFactory#newInstance()javax.xml.transform.TransformerFactory#newInstance()javax.xml.xpath.XPathFactory#newInstance()生成器模式(通过创建的方法返回实例本身)java.lang.StringBuilder#append() (非同步的)java.lang.StringBuffer#append() (支持同步)java.nio.ByteBuffer#put() (与之相同的有: CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer 和 DoubleBuffer)javax.swing.GroupLayout.Group#addComponent()java.lang.Appendabled 的所有实现工厂模式(通过创建的方法返回一个抽象/接口类型的实现)java.util.Calendar#getInstance()java.util.ResourceBundle#getBundle()java.text.NumberFormat#getInstance()java.nio.charset.Charset#forName()java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (按协议返回单例对象)原型模式(通过创建的方法返回一个包含相同属性的不同实例)java.lang.Object#clone() (类必须实现 java.lang.Cloneable)单例模式(通过创建的方法在任何时间都返回一个相同实例(通常是它本身))java.lang.Runtime#getRuntime()java.awt.Desktop#getDesktop() 结构型模式适配器模式(接收不同抽象或接口类型的一个实例, 并返回一个装饰或重写了该实例的本身/其他的抽象/接口类型的指定实现)java.util.Arrays#asList()java.io.InputStreamReader(InputStream) (返回一个Reader)java.io.OutputStreamWriter(OutputStream) (返回一个Writer)javax.xml.bind.annotation.adapters.XmlAdapter#marshal() 和 #unmarshal()桥接模式(接收不同抽象或接口类型的一个实例, 并返回一个委托或使用了该实例的本身/其他的抽象/接口类型的指定实现)一时之间没有想到. 一个虚构的例子: new LinkedHashMap(LinkedHashSet, List)返回一个不可变的链式map, 并且不会克隆内部元素而是直接使用他们. java.util.Collections#newSetFromMap() 和 singletonXXX()方法是有些接近这个模式的.组合模式(通过行为式的方法接收一个相同的抽象或接口类型的实例转换为一个树状结构)java.awt.Container#add(Component) (几乎所有Swing都是这样)javax.faces.component.UIComponent#getChildren() (几乎所有JSF UI都是这样)装饰器模式(通过创建的方法接收一个相同的抽象或接口类型的实例, 并添加附加的行为)java.io.InputStream, OutputStream, Reader 和 Writer的子类拥有一个持有相同类型的实例构造器.java.util.Collections, checkedXXX(), synchronizedXXX() 和 unmodifiableXXX().javax.servlet.http.HttpServletRequestWrapper 和 HttpServletResponseWrapper门面模式(通过行为式的方法实现, 该方法内部使用不同的独立的抽象或接口类型的实例)javax.faces.context.FacesContext, 它内部之间使用 LifeCycle, ViewHandler, NavigationHandler 和很多无需最终能够用户关心的抽象/接口类型(可通过注入覆写).javax.faces.context.ExternalContext, 它内部使用ServletContext, HttpSession, HttpServletRequest, HttpServletResponse等.享元模式(通过创建的方法返回一个缓存的实例, 有一些”多例”的思想)java.lang.Integer#valueOf(int) (类似的还包括: Boolean, Byte, Character, Short 和 Long)代理模式(通过创建的方法返回指定的抽象或接口类型的实现, 该实现依次委托或使用了指定抽象或接口类型的不同实现)java.lang.reflect.Proxyjava.rmi.*下所有API. 行为型模式责任链模式(通过行为方法(间接地)在一个队列中调用另一个相同抽象/接口类型的相同方法)java.util.logging.Logger#log()javax.servlet.Filter#doFilter()命令模式(一个抽象/接口类型内的行为方法中, 调用一个不同的象/接口类型的实现的方法, 该实现已经在其创建过程中被命令实现封装)java.lang.Runnable的所有实现javax.swing.Action的所有实现解释器模式(行为方法返回一个有结构的并且与被提供的实例/类型不同的实例/类型; 注意parsing/formatting不是这个模式的组成部分, 而是用来确定该模式以及如何应用模式)java.util.Patternjava.text.Normalizerjava.text.Format的所有子类javax.el.ELResolver的所有子类迭代器模式(行为方法按顺序的自一个队列中返回不同类型的实例)java.util.Iterator的所有实现 (除此以外, 还有 java.util.Scanner!).java.util.Enumeration的所有实现中介者模式(行为方法接收一个不同抽象/接口类型的实例(通常使用命令模式), 该实例委托或使用了指定实例)java.util.Timer (所有 scheduleXXX() 方法)java.util.concurrent.Executor#execute()java.util.concurrent.ExecutorService (invokeXXX() 和 submit() 方法)java.util.concurrent.ScheduledExecutorService (所有 scheduleXXX() 方法)java.lang.reflect.Method#invoke()备忘录模式(行为方法内部改变了整个实例的状态)java.util.Date ( setter 方法就是这么做的, Date 内部通过长整型long表示)java.io.Serializable的所有实现javax.faces.component.StateHolder的所有实现观察者或发布/订阅模式(行为方法在另一个抽象/接口类型的实例上调用方法, 并取决于自身状态)java.util.Observer/java.util.Observable (在现实世界中很少使用)java.util.EventListener 的所有实现 (几乎所有的Swing都是这样)javax.servlet.http.HttpSessionBindingListenerjavax.servlet.http.HttpSessionAttributeListenerjavax.faces.event.PhaseListener状态模式(行为方法通过外部可控的实例状态改变它的行为)javax.faces.lifecycle.LifeCycle#execute() (通过FacesServlet控制, 行为取决于当前JSF生命周期的阶段(状态)策略模式(行为方法内一个抽象/接口类型调用不同抽象/接口类型的不同实现内的方法, 该实现以方法参数型式被传进策略实现内)java.util.Comparator#compare(), 在Collections#sort()中执行.javax.servlet.http.HttpServlet, service() 和所有 doXXX() 方法接收 HttpServletRequest, HttpServletResponse, 并且实现者必须处理它们(而不是作为实例变量持有它们)javax.servlet.Filter#doFilter()模板模式(行为方法已拥有一个被抽象类型定义的”默认”行为)java.io.InputStream, java.io.OutputStream, java.io.Reader 和 java.io.Writer 的所有非抽象方法.java.util.AbstractList, java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法.javax.servlet.http.HttpServlet, 所有 doXXX() 方法默认发送 HTTP 405 “Method Not Allowed” 错误到响应中. 你可以任意实现这些方法.访问者模式(两个不同的抽象/接口类型中包含互相接收对方抽象/接口类型的方法; 实际调用的是另一个类型的方法和它上面的其他执行所需求的策略)javax.lang.model.element.AnnotationValue 和 AnnotationValueVisitorjavax.lang.model.element.Element 和 ElementVisitorjavax.lang.model.type.TypeMirror 和 TypeVisitor 参考UML： https://zhuanlan.zhihu.com/p/24576502 精简uml图： http://jayfeng.com/2016/04/02/%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%86%E7%B1%BB%E3%80%81%E6%84%8F%E5%9B%BE%E3%80%81UML%E7%B1%BB%E5%9B%BE/ https://blog.csdn.net/sfdev/article/details/2845488 设计模式： http://linbinghe.com/2017/1646c9f3.html https://github.com/suzeyu1992/repo/tree/master/project/design-pattern https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/tree/master/design_patterns https://www.kancloud.cn/longxuan/my-designpattern/117488 https://github.com/jiayisheji/blog/issues/2 https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/README.md https://www.cnblogs.com/happykoukou/p/5382649.html https://pgzxc.github.io/2017/12/24/Android%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ https://github.com/guoxiaoxing/android-open-source-project-analysis/blob/master/doc/Android%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AF%87/02Android%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md https://github.com/quanke/design-pattern-java https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/README.md https://clarkdo.js.org/design%20patterns%20stories/2014/10/20/46/]]></content>
      <categories>
        <category>02DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>汇总</tag>
        <tag>分析精华</tag>
        <tag>DesignPattern</tag>
        <tag>uml</tag>
        <tag>23dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 8简明指南]]></title>
    <url>%2Fposts%2Fjava_jdk_base_thread_lock.html</url>
    <content type="text"><![CDATA[Java8简明指南 欢迎来到Java8简明指南。本教程将一步一步指导你通过所有新语言特性。由短而简单的代码示例,带你了解如何使用默认接口方法,lambda表达式,方法引用和可重复注解。本文的最后你会熟悉最新的API的变化如Stream,Fcuntional,Map API扩展和新的日期API。 接口的默认方法在Java8中，利用default关键字使我们能够添加非抽象方法实现的接口。此功能也被称为扩展方法，这里是我们的第一个例子： 1234567interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; 除了接口抽象方法calculate，还定义了默认方法sqrt的返回值。具体类实现抽象方法calculate。默认的方法sqrt可以开箱即用。 123456789Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 该公式被实现为匿名对象。这段代码是相当长的：非常详细的一个计算：6行代码完成这样一个简单的计算。正如我们将在下一节中看到的，Java8有一个更好的方法来实现单方法对象。 Lambda表达式让我们以一个简单的例子来开始，在以前的版本中对字符串进行排序： 12345678List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); 静态的集合类方法Collections.sort，为比较器的给定列表中的元素排序。你会发现自己经常创建匿名比较器并将它们传递给方法。 Java8支持更短的语法而不总是创建匿名对象， Lambda表达式： 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 正如你可以看到的代码更容易阅读。但它甚至更短： 1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 一行方法的方法体可以跳过{}和参数类型，使它变得更短： 1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Java编译器知道参数类型，所以你可以跳过它们，接下来让我们深入了解lambda表达式。 函数式接口(Functional Interfaces)如何适应Java lambda表达式类型系统？每个lambda由一个指定的接口对应于一个给定的类型。所谓的函数式接口必须包含一个确切的一个抽象方法声明。该类型将匹配这个抽象方法每个lambda表达式。因为默认的方法是不抽象的，你可以自由添加默认的方法到你的函数式接口。 我们可以使用任意的接口为lambda表达式，只要接口只包含一个抽象方法。确保你的接口满足要求，你应该添加@FunctionalInterface注解。当你尝试在接口上添加第二个抽象方法声明时，编译器会注意到这个注释并抛出一个编译器错误。 举例： 1234@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125; 123Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(&quot;123&quot;);System.out.println(converted); // 123 记住，有@FunctionalInterface注解的也是有效的代码。 方法和构造函数引用上面的例子代码可以进一步简化，利用静态方法引用： 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(&quot;123&quot;);System.out.println(converted); // 123 Java使您可以通过::关键字调用引用的方法或构造函数。上面的示例演示了如何引用静态方法。但我们也可以参考对象方法： 12345class Something &#123; String startsWith(String s) &#123; return String.valueOf(s.charAt(0)); &#125;&#125; 1234Something something = new Something();Converter&lt;String, String&gt; converter = something::startsWith;String converted = converter.convert(&quot;Java&quot;);System.out.println(converted); // &quot;J&quot; 让我们来看看如何使用::关键字调用构造函数。首先，我们定义一个Person类并且提供不同的构造函数： 1234567891011class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来，我们指定一个Person的工厂接口，用于创建Person： 123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125; 然后我们通过构造函数引用来把所有东西拼到一起，而不是手动实现工厂： 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;); 我们通过Person::new创建一个人的引用，Java编译器会自动选择正确的构造函数匹配PersonFactory.create的返回。 Lambda作用域从lambda表达式访问外部变量的作用域是匿名对象非常相似。您可以从本地外部范围以及实例字段和静态变量中访问final变量。 访问局部变量我们可以从lambda表达式的外部范围读取final变量： 123final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3 但不同的匿名对象变量num没有被声明为final，下面的代码也有效： 123int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);stringConverter.convert(2); // 3 然而num必须是隐含的final常量。以下代码不编译： 123int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);num = 3; 在lambda表达式里修改num也是不允许的。 访问字段和静态变量与局部变量不同，我们在lambda表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。 12345678910111213141516class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 访问默认接口方法记得第一节的formula例子吗？接口Formula定义了一个默认的方法可以从每个公式实例访问包括匿名对象， 这并没有Lambda表达式的工作。 默认方法不能在lambda表达式访问。以下代码不编译： 1Formula formula = (a) -&gt; sqrt( a * 100); 内置函数式接口(Built-in Functional Interfaces)JDK1.8的API包含许多内置的函数式接口。其中有些是众所周知的，从旧版本中而来，如Comparator或者Runnable。使现有的接口通过@FunctionalInterface注解支持Lambda。 但是Java8 API也添加了新功能接口,使你的开发更简单。其中一些接口是众所周知的Google Guava库。即使你熟悉这个库也应该密切关注这些接口是如何延长一些有用的扩展方法。 Predicates(谓词)Predicates是一个返回布尔类型的函数。这就是谓词函数，输入一个对象，返回true或者false。 在Google Guava中，定义了Predicate接口，该接口包含一个带有泛型参数的方法： 1apply(T input): boolean 12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0; predicate.test(&quot;foo&quot;); // truepredicate.negate().test(&quot;foo&quot;); // false Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull; Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Functions(函数)Functions接受一个参数，并产生一个结果。默认方法可以将多个函数串在一起（compse, andThen） 1234Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);backToString.apply(&quot;123&quot;); // &quot;123&quot; Suppliers(生产者)Suppliers产生一个给定的泛型类型的结果。与Functional不同的是Suppliers不接受输入参数。 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Consumers(消费者)Consumers代表在一个单一的输入参数上执行操作。 12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;)); Comparators(比较器)Comparators在旧版本Java中是众所周知的。Java8增加了各种默认方法的接口。 1234567Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0 Optionals(可选项)Optionals是没有函数的接口，取而代之的是防止NullPointerException异常。这是下一节的一个重要概念，所以让我们看看如何结合Optionals工作。 Optional is a simple container for a value which may be null or non-null. Think of a method which may return a non-null result but sometimes return nothing. Instead of returning null you return an Optional in Java 8. Optional是一个简单的容器，这个值可能是空的或者非空的。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional。 1234567Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);optional.isPresent(); // trueoptional.get(); // &quot;bam&quot;optional.orElse(&quot;fallback&quot;); // &quot;bam&quot;optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // &quot;b&quot; Streams(管道)一个java.util.Stream代表一个序列的元素在其中的一个或多个可以执行的操作。流操作是中间或终端。当终端操作返回某一类型的结果时，中间操作返回流，这样就可以将多个方法调用在一行中。流是一个源产生的，例如java.util.Collection像列表或设置（不支持map）。流操作可以被执行的顺序或并行。 让我们先看一下数据流如何工作。首先，我们创建一个字符串列表的数据： 123456789List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add(&quot;ddd2&quot;);stringCollection.add(&quot;aaa2&quot;);stringCollection.add(&quot;bbb1&quot;);stringCollection.add(&quot;aaa1&quot;);stringCollection.add(&quot;bbb3&quot;);stringCollection.add(&quot;ccc&quot;);stringCollection.add(&quot;bbb2&quot;);stringCollection.add(&quot;ddd1&quot;); 在Java8中Collections类的功能已经有所增强，你可用调用Collection.stream()或Collection.parallelStream()。 下面的章节解释最常见的流操作。 FilterFilter接受一个predicate来过滤流的所有元素。这个中间操作能够调用另一个流的操作（Foreach）的结果。ForEach接受一个消费者为每个元素执行过滤流。它是void，所以我们不能称之为另一个流操作。 123456stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);// &quot;aaa2&quot;, &quot;aaa1&quot; SortedSorted是一个中间操作，能够返回一个排过序的流对象的视图。这些元素按自然顺序排序，除非你经过一个自定义比较器（实现Comparator接口）。 1234567stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);// &quot;aaa1&quot;, &quot;aaa2&quot; 要记住，排序只会创建一个流的排序视图，而不处理支持集合的排序。原来string集合中的元素顺序是没有改变的。 12System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Mapmap是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素对应到另外一个对象上。下面的例子将每个字符串转换成一个大写字符串，但也可以使用map将每个对象转换为另一种类型。所得到的流的泛型类型取决于您传递给map方法的泛型类型。 1234567stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot; Match可以使用各种匹配操作来检查某个谓词是否匹配流。所有这些操作都是终止操作，返回一个布尔结果。 1234567891011121314151617181920boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));System.out.println(noneStartsWithZ); // true CountCount是一个终止操作返回流中的元素的数目，返回long类型。 1234567long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;b&quot;)) .count();System.out.println(startsWithB); // 3 Reduce该终止操作能够通过某一个方法，对元素进行削减操作。该操作的结果会放在一个Optional变量里返回。 12345678Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);reduced.ifPresent(System.out::println);// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot; Parallel Streams如上所述的数据流可以是连续的或平行的。在一个单独的线程上进行操作，同时在多个线程上执行并行操作。 下面的例子演示了如何使用并行流很容易的提高性能。 首先，我们创建一个大的元素列表： 123456int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; 现在我们测量一下流对这个集合进行排序消耗的时间。 Sequential Sort1234567891011long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));// sequential sort took: 899 ms Parallel Sort1234567891011long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));// parallel sort took: 472 ms 你可以看到这两段代码片段几乎是相同的，但并行排序大致是50%的差距。唯一的不同就是把stream()改成了parallelStream()。 Map正如前面所说的Map不支持流操作，现在的Map支持各种新的实用的方法和常见的任务。 1234567Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, &quot;val&quot; + i);&#125;map.forEach((id, val) -&gt; System.out.println(val)); 上面的代码应该是不解自明的：putIfAbsent避免我们将null写入；forEach接受一个消费者对象，从而将操作实施到每一个map中的值上。 这个例子演示了如何利用函数判断或获取Map中的数据： 1234567891011map.computeIfPresent(3, (num, val) -&gt; val + num);map.get(3); // val33map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -&gt; &quot;bam&quot;);map.get(3); // val33 接下来，我们将学习如何删除一一个给定的键的条目，只有当它当前映射到给定值： 12345map.remove(3, &quot;val3&quot;);map.get(3); // val33map.remove(3, &quot;val33&quot;);map.get(3); // null 另一种实用的方法： 1map.getOrDefault(42, &quot;not found&quot;); // not found Map合并条目是非常容易的： 12345map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9concat 合并操作先看map中是否没有特定的key/value存在，如果是，则把key/value存入map，否则merging函数就会被调用，对现有的数值进行修改。 Date APIJava8 包含一个新的日期和时间API，在java.time包下。新的日期API与Joda Time库可以媲美，但它们是不一样的。下面的例子涵盖了这个新的API最重要的部分。 ClockClock提供访问当前日期和时间。Clock是对当前时区敏感的，可以用来代替System.currentTimeMillis()来获取当前的毫秒值。当前时间线上的时刻可以用Instance类来表示。Instance可以用来创建java.util.Date格式的对象。 12345Clock clock = Clock.systemDefaultZone();long millis = clock.millis();Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones时区是由ZoneId表示，通过静态工厂方法可以很容易地访问。时区还定义了一个偏移量，用来转换当前时刻与目标时刻。 12345678910System.out.println(ZoneId.getAvailableZoneIds());// prints all available timezone idsZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] LocalTimeLocalTime代表没有时区的时间，例如晚上10点或17:30:15。下面的例子会用上面的例子定义的时区创建两个本地时间对象。然后我们比较两个时间并计算小时和分钟的差异。 12345678910LocalTime now1 = LocalTime.now(zone1);LocalTime now2 = LocalTime.now(zone2);System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 LocalDateLocalDate代表一个唯一的日期，如2014-03-11。它是不可变的,完全模拟本地时间工作。此示例演示如何通过添加或减去天数,月数，年来计算新的日期。记住每一个操作都会返回一个新的实例。 1234567LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2);LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 将字符串解析为LocalDate: 1234567DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);System.out.println(xmas); // 2014-12-24 LocalDateTimeLocalDateTime代表日期时间。它结合了日期和时间见上面的部分为一个实例。LocalDateTime是不可变的,类似于本地时间和LocalDate工作。我们可以从一个日期时间获取某些字段的方法: 12345678910LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 随着一个时区可以转换为一个即时的附加信息。Instance可以被转换为日期型转化为指定格式的java.util.Date。 123456Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式日期时间对象就像格式化日期对象或者格式化时间对象，除了使用预定义的格式以外，我们还可以创建自定义的格式化对象，然后匹配我们自定义的格式。 1234567DateTimeFormatter formatter = DateTimeFormatter .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 不像java.text.NumberFormat，新的DateTimeFormatter是不可变的，线程安全的。 Annotations(注解)在Java8中注解是可以重复的，让我们深入到一个示例中。 首先，我们定义了一个包装的注解，它拥有一个返回值为数组类型的方法Hint： 12345678@interface Hints &#123; Hint[] value();&#125;@Repeatable(Hints.class)@interface Hint &#123; String value();&#125; Java8使我们能够使用相同类型的多个注解，通过@Repeatable声明注解。 变体1：使用注解容器（老方法）12@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)class Person &#123;&#125; 变体2：使用可重复注解（新方法）123@Hint(&quot;hint1&quot;)@Hint(&quot;hint2&quot;)class Person &#123;&#125; 使用变体2隐式编译器隐式地设置了@Hints注解。这对于通过反射来读取注解信息是非常重要的。 12345678Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // nullHints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2 虽然在Person中从未定义@Hints注解，它仍然可读通过getAnnotation(Hints.class)读取。并且，getAnnotationsByType方法会更方便，因为它赋予了所有@Hints注解标注的方法直接的访问权限。 12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125; 参考： https://github.com/biezhi/java-bible/blob/master/java8/java8-guide.md]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>stream</tag>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android intent和启动模式]]></title>
    <url>%2Fposts%2Fandroid_app_intent_start_mode.html</url>
    <content type="text"><![CDATA[taskAffinity、launchmode、Intent.FLAG_ACTIVITY_XXX 有关的堆栈和back键返回等http://www.voidcn.com/blog/fengniuma/article/p-3214732.htmlhttps://blog.piasy.com/2017/01/16/Android-Basics-Task-and-LaunchModehttp://blog.csdn.net/scnuxisan225/article/details/44930321http://blog.csdn.net/tuhuolong/article/details/8844936 taskAffinity解释：taskAffinity 标示以该Activity为root的所在task的名字。属性值推荐用.开头。可以通过给所有activity设置taskAffinity。 ***也可以单独设置activity 的taskAffinity 如果或都没有设置taskAffinity，则系统默认赋值为应用程序包名。也就是说taskAffinity要么是自己定义的值，要么去应用程序包名。值得注意的是，如果launcher activity使用默认taskAffinity，通过launcher activity启动的一个activity B，【B配置了taskAffinity属性，并且没有设置启动新的task, 那么其实B的taskAffinity就失效了】，因为task的名字是由root activity的taskAffinity决定的。taskAffinity结合singleTask和SingleIntance和FLAG_ACTIVITY_NEW_TASK 一起使用会产生效果，单独的task只存在一个activity，该task上的activity清除等。 LaunchmodeStandard singleTop singleTask singleInstance主要有这几种模式。其中standard模式比较简单，直接在当前栈启动一个新的activity，而不管之前是否存在相同activity实例。其中singleTop模式也比较简单，直接在当前栈查找是否存在该activity实例，如果存在直接调用onNewIntent方法，如果不存在那么直接创建改Activity。 不关注TaskAffinity。其中singleTask模式较为麻烦，先寻找名字为taskAffnity指定的task，如果该task存在这个activity，那么清楚之上的所有activity，然后调用OnNewIntent方法。如果不存在该task，那么创建task，创建activity。其中singleIntance模式，要求Activity实例独占task，所以先寻找是否存在该Activity，存在那么直接调用onNewIntent，如果不存在，那么创建该task和activity。 如果从该activity调用其他Activity那么会切换到其他task栈上，因为该activity独占task。Intent.FLAG_ACTIVITY_XXXFLAG_ACTIVITY_NEW_TASK 配合FLAG_ACTIVITY_CLEAR_TOP的时候，才会和“singleTask”行为一致–在已经存在目标activity的情况下，清除上层全部Activity.FLAG_ACTIVITY_SINGLE_TOP = singleTopFLAG_ACTIVITY_CLEAR_TOP + FLAG_ACTIVITY_NEW_TASK = singleTask ActivityRecord、TaskRecord、ActivityStack之间的关系ActivityStackSupervisor.mActivityDisplays-&gt; ActivityDisplay.mStacks -&gt; ActivityStack.mTaskHistory -&gt; TaskRecord.mActivities -&gt; ActivityRecord简单来说就是一下类的关系图，ActivityStackSupervisor与ActivityDisplay都是系统唯一，ActivityDisplay负责管理很多ActivityStack，ActivityDisplay主要有Home Stack和App Stack这两个栈；一个ActivityStack负责管理很多TaskRecord，一个TaskRecord又包含很多ActivityRecord。一个activityRecord包含ProcessRecord app //跑在哪个进程 TaskRecord task //跑在哪个task ActivityInfo info // Activity信息 int mActivityType //Activity类型 ActivityState state //Activity状态 ApplicationInfo appInfo //跑在哪个apphttp://gityuan.com/2017/06/11/activity_record/http://blog.csdn.net/itachi85/article/details/77542286http://blog.csdn.net/kebelzc24/article/details/53747506http://duanqz.github.io/2016-02-01-Activity-Maintenance#activitystack Intent-filter action category Data scheme匹配规则http://blog.csdn.net/iispring/article/details/48481793 intent匹配https://developer.android.com/guide/components/intents-filters.html?hl=zh-cn#Resolution PendingIntent如果Intent对象的Action是相同的，Data也是相同的，Categories也是相同的，Components也是相同的，Flags也是相同的），并且之前获取的PendingIntent对象还有效的话，那么该进程获取到的PendingItent对象将获得同一个对象的引用，可以通过cancel()方法来从系统中移除它。PendingIntent对象由系统持有，因此不能通过设置不同的Extra来生成不同的PendingIntent对象，系统只通过刚才在上面提到的几个要素来判断PendingIntent对象是否是相同的。PendingIntent有以下flag：FLAG_CANCEL_CURRENT:如果当前系统中已经存在一个相同的PendingIntent对象，那么就将先将已有的PendingIntent取消，然后重新生成一个PendingIntent对象。FLAG_NO_CREATE:如果当前系统中不存在相同的PendingIntent对象，系统将不会创建该PendingIntent对象而是直接返回null。FLAG_ONE_SHOT:该PendingIntent只作用一次。FLAG_UPDATE_CURRENT:如果系统中已存在该PendingIntent对象，那么系统将保留该PendingIntent对象，但是会使用新的Intent来更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras。创建PendingIntent方式：PendingIntent.getActivity (context, requestCode, broadIntent, flags)PendingIntent.getBroadcast(context,requestCode, broadIntent, flags)PendingIntent.getService (context, requestCode, broadIntent, flags)API文档里虽然未使用requestCode参数，但实际上是通过该参数来区别不同的Intent的http://blog.csdn.net/yangwen123/article/details/8019739https://my.oschina.net/youranhongcha/blog/196933 Launch Mode先来说说在ActivityInfo.java中定义了4类Launch Mode： LAUNCH_MULTIPLE(standard)：最常见的情形，每次启动Activity都是创建新的Activity;LAUNCH_SINGLE_TOP: 当Task顶部存在同一个Activity则不再重新创建；其余情况同上；LAUNCH_SINGLE_TASK：当Task栈存在同一个Activity(不在task顶部)，则不重新创建，而移除该Activity上面其他的Activity；其余情况同上；LAUNCH_SINGLE_INSTANCE：每个Task只有一个Activity.再来说说几个常见的flag含义： FLAG_ACTIVITY_NEW_TASK：将Activity放入一个新启动的Task；FLAG_ACTIVITY_CLEAR_TASK：启动Activity时，将目标Activity关联的Task清除，再启动新Task，将该Activity放入该Task。该flags跟FLAG_ACTIVITY_NEW_TASK配合使用。FLAG_ACTIVITY_CLEAR_TOP：启动非栈顶Activity时，先清除该Activity之上的Activity。例如Task已有A、B、C3个Activity，启动A，则清除B，C。类似于SingleTop。最后再说说：设置FLAG_ACTIVITY_NEW_TASK的几个情况： 调用者并不是Activity context；调用者activity带有single instance；目标activity带有single instance或者single task；调用者处于finishing状态；]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>binder</tag>
        <tag>intent</tag>
        <tag>启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android binder原理]]></title>
    <url>%2Fposts%2Fandroid_app_binder_sumup.html</url>
    <content type="text"><![CDATA[Binder实现原理用法总结：http://gityuan.com/2015/11/22/binder-use/http://gityuan.com/2015/11/23/binder-aidl/http://qiangbo.space/2017-01-15/AndroidAnatomy_Binder_Driver/主要思路是: aidl两端：服务端stub端，实现aidl接口，通过onTransact接收数据。继承binder，实现aidl接口，是一个binder对象。注册到ServiceManager中，或者通过serviceConnected获取。 客户端proxy端，实现aidl接口，通过mRemote.transact传送数据。通过ServiceManager获取binder对象，然后asInterface活的aidl接口，即可通过Proxy transact调用相关方法。 asInterface:new com.yuanhh.appbinderdemo.IRemoteService.Stub.Proxy(obj); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.yuanhh.appbinderdemo;public interface IRemoteService extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.yuanhh.appbinderdemo.IRemoteService &#123; private static final java.lang.String DESCRIPTOR = &quot;com.yuanhh.appbinderdemo.IRemoteService&quot;; /** * Stub构造函数 */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * 将IBinder 转换为IRemoteService interface */ public static com.yuanhh.appbinderdemo.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.yuanhh.appbinderdemo.IRemoteService))) &#123; return ((com.yuanhh.appbinderdemo.IRemoteService) iin); &#125; return new com.yuanhh.appbinderdemo.IRemoteService.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getPid: &#123; data.enforceInterface(DESCRIPTOR); int _result = this.getPid(); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_getMyData: &#123; data.enforceInterface(DESCRIPTOR); com.yuanhh.appbinderdemo.MyData _result = this.getMyData(); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.yuanhh.appbinderdemo.IRemoteService &#123; private android.os.IBinder mRemote; /** * Proxy构造函数 */ Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int getPid() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public com.yuanhh.appbinderdemo.MyData getMyData() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.yuanhh.appbinderdemo.MyData _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getMyData, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.yuanhh.appbinderdemo.MyData.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_getPid = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getMyData = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public int getPid() throws android.os.RemoteException; public com.yuanhh.appbinderdemo.MyData getMyData() throws android.os.RemoteException;&#125; binder die处理思路比较简单之间直接在客户端注册相应callback即可。IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient()https://blog.csdn.net/lea_fy/article/details/52987004具体机制可以参考：http://gityuan.com/2016/10/03/binder_linktodeath/]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ui组件总结]]></title>
    <url>%2Fposts%2Fandroid_app_ui_sum.html</url>
    <content type="text"><![CDATA[Service onStartCommand返回参数说明方法onStartCommand()的返回值为int类型，主要的作用是当Service进程被意外kill掉时，Service服务下一步要做哪些行为，主要有3种值。START_STICKY：Service被异外终止时不调用onDestroy()回调，并且终止后自动重启Service服务，只执行Service对象的onCreate()生命周期方法。START_NOT_STICKY：Service被异外终止时不调用onDestroy()回调，并且不自动重启服务。START_REDELIVER_INTENT：Service被异外终止时不调用onDestroy()回调，并且终止后自动重启Service服务，还要执行Service对象的onCreate()和onStartCommand()生命周期方法，并且从Intent中能取到值。http://book.51cto.com/art/201211/363296.htm Service stopSelf一直知道stopself是停掉Service的方法，但是却不知道什么时候停止。以为调用了stopself就会马上停止，实际上我错了.在onStartCommond方法里面调用stopself方法时，不会马上停止，而是onStartCommond方法执行结束才会停止。还有一点，调用stopself方法之后，service会执行onDestory方法。另外，如果onStartCommond中启动一个线程，调用stopself，线程也不会被杀死。来自 http://blog.csdn.net/hello0370/article/details/46781523 当调用finish方法时，onCreate方法会继续执行，之后调用onDestory方法。最后，总结一下，Service的stopself方法的功能是，当完成所有功能之后，将service停掉，而不是等着系统回收。同样finish方法，是当系统执行完onCreate方法之后，调用onDestory方法销毁Activity。 ACTION_CANCEL 请简述Android事件传递机制， ACTION_CANCEL事件何时触发？关于第一个问题，不做任何解释。关于ACTION_CANCEL何时被触发，系统文档有这么一种使用场景：在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。意思是当滑动的时候就会触发，不知道大家搞没搞过微信的长按录音，有一种状态是“松开手指，取消发送”，这时候就会触发ACTION_CANCEL。 简述Android的View绘制流程，Android的wrap_content是如何计算的https://blog.csdn.net/qinjuning/article/details/7110211 绘制流程的三个步骤，即：1、 measure过程 — 测量过程2、 layout 过程 — 布局过程3、 draw 过程 — 绘制过程https://blog.csdn.net/qinjuning/article/details/8051811https://blog.csdn.net/qinjuning/article/details/8074262https://www.cnblogs.com/duanweishi/p/4301742.html bundle的数据结构，如何存储，既然有了Intent.putExtra，为啥还要用bundle。bundle的内部结构其实是Map，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口。 Binder 线程池Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。 LocalBroadcastmanager使用首先获取LocalBroadcastManager实例：LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this);然后通过函数 registerReceiver方法来注册监听器：lbm.registerReceiver(new BroadcastReceiver(){ @Override public void onReceive(Context arg0, Intent arg1) { // TODO Auto-generated method stub }}, new IntentFilter(“com.android.action.PRIVATE_BROADCAST”));最后调用sendBroadcast方法发送广播：Intent intent=new Intent(“com.android.action.PRIVATE_BROADCAST”);intent.putExtra(KEY, SENSITIVE_DATA);lbm.sendBroadcast(intent); Sticky broadcast首先点击next Activity从代码中可以看到receiver已经注册，但Log无输出，这是当然的了~~~因为没有广播发出自然就不会有人响应了。按back后退到上图下面分别点击send broadcast 和 send stickybroadcast按钮，随便点击几次，此时对应的receiver并没有注册，所以是不会有人响应这两条广播的。然后点击next activity，当打开新的activity后对应的receiver被注册，此时从日志中就能看出已经收到了send stickybroadcast发出的广播，但没有send broadcast发出的广播。这就是sendStickyBroadcast的特别之处，它将发出的广播保存起来，一旦发现有人注册这条广播，则立即能接收到。日志打印为： action = com.android.action.sticky.broadcastand count = 4从上面的日志信息可以看出sendStickyBroadcast只保留最后一条广播，并且一直保留下去，这样即使已经处理了这条广播但当再一次注册这条广播后依然可以收到它。如果你只想处理一遍，removeStickyBroadcast方法可以帮你，处理完了后就将它删除吧。http://blog.csdn.net/yihua0607/article/details/6890805 要知道区别首先需要看一下Android Developers Reference， 它可是我们最好的老师了，sendBroadcast 大家应该都会用了我就不赘述了，下面来看看sendStickyBroadcastgoogle官方的解释是：Perform a sendBroadcast(Intent) that is “sticky,” meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value ofregisterReceiver(BroadcastReceiver, IntentFilter). In all other ways, this behaves the same as sendBroadcast(Intent).You must hold the BROADCAST_STICKY permission in order to use this API. If you do not hold that permission,SecurityException will be thrown.大概的意思是说： 发出的广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。 Activity生命周期http://www.cnblogs.com/zyw-205520/p/3313268.htmlhttps://developer.android.com/guide/components/activities/activity-lifecycle.html#tba HOME键的执行顺序：onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume BACK键的顺序： onPause-&gt;onStop-&gt;onDestroy-&gt;onCreate-&gt;onStart-&gt;onResume onPause不要做太耗时的工作 情形一、一个单独的Activity的正常的生命过程是这样的：onCreate-&gt;onStart-&gt;onPause-&gt;onStop-&gt;onDestroy。例如：运行一个Activity，进行了一些简单操作（不涉及页面的跳转等），然后按返回键结束 情形二、有两个Activity（a和b），一开始显示a，然后由a启动b，然后在由b回到a，这时候a的生命过程应该是怎么样的呢（a被b完全遮盖）？a经历的过程为onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onRestart-&gt;onStart-&gt;onResume。这个过程说明了图中，如果Activity完全被其他界面遮挡时，进入后台，并没有完全销毁,而是停留在onStop状态，当再次进入a时，onRestart-&gt;onStart-&gt;onResume，又重新恢复 情形三、基本情形同二一样，不过此时a被b部分遮盖（比如给b添加个对话框主题 android:theme=”@android:style/Theme.Dialog”）， a经历的过程是：onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onResume， 所以当Activity被部分遮挡时，Activity进入onPause，并没有进入onStop，从Activity2返回后，执行了onResume 情形四、 打开程序，启动a，点击a，启动AlertDialog，按返回键从AlertDialog返回。a经历的过程是：onCreate-&gt;onStart-&gt;onResume，当启动和退出Dialog时，Activity的状态始终未变，可见，Dialog实际上属于Acitivity内部的界面，不会影响Acitivty的生命周期。 OnNewIntent执行时机： OnNewIntent被调用的前提是:ActivityA已经启动过,处于当前应用的Activity堆栈中; 当ActivityA的LaunchMode为SingleTop时，如果ActivityA在栈顶,且现在要再启动ActivityA，这时会调用onNewIntent()方法 。 当ActivityA的LaunchMode为SingleInstance,SingleTask时,如果已经ActivityA已经在堆栈中，那么此时会调用onNewIntent()方法 当ActivityA的LaunchMode为Standard时，由于每次启动ActivityA都是启动新的实例，和原来启动的没关系，所以不会调用原来ActivityA的onNewIntent方法 Activity模式 启动模式允许开发者定义一个activity的新实例如何与当前的Task关联。可以定义使用俩种方法来定义。 如果Activity A开启Activity B, Activity B就可以在它的manifest文件中定义它与当前的task如何关联，Activity A也可以要求activity B应该如何与当前的task关联。如果两个activity都定义了Activity B应该如何与一个task关联，Activity A的要求（在intent中定义的）将会覆盖Activity B中要求（在manifest文件中定义的）。 注意：一些在manifest中的登录模式在intent中不再可用，同样地，一些在intent中定义的标志也可能没有在manifest中未定义。 Using the manifest file 当在manifest文件中声明activity时，可以指定这个activity开启时如何与当前task关联。 标签的launchMode属性可以设置为四种不同的模式： ​ “standard”（默认模式） ​ “singleTop” ​ “singleTask” ​ “singleInstance” ​ 这几种模式的区别体现以下四点上： ​ 1）当这个activity被激活的时候，会放入哪个任务栈。 ​ 对于“standard”和“singleTop”模式，这个新被激活的activity会放入和之前的activity相同的任务栈中――除非Intent对象包含FLAG_ACTIVITY_NEW_TASK标志。 ​ “singleTask”并不会每次都新启动一个task。如果已经存在一个task与新activity亲和度（taskAffinity）一样，则activity将启动到该task。如果不是，才启动一个新task。同一个application里面，每个activity的taskAffinity默认都是一样的。 ​ “singleInstance”模式则表示这个新被激活的activity会重新开启一个任务栈，并作为这个新的任务栈的唯一的activity。 ​ 2）是否可以存在这个activity类型的多个实例。 ​ 对于“standard”和“singleTop”模式，可以有多个实例，并且这些实例可以属于不同的任务栈，每个任务栈也可以包含有这个activity类型的多个实例。 “singleTop&quot;要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。 “singleTask”和”singleInstance”则限制只生成一个实例。 **3）包含此activity的任务栈是否可以包含其它的activity。** ​ “singleInstance”模式表示包含此activity的任务栈不可以包含其它的activity。若此activity启动了另一个activity组件，那么无论那个activity组件的启动模式是什么或是Intent对象中是否包含了FLAG_ACTIVITY_NEW_TASK标志，它都会被放入另外的任务栈。在其它方面“singleInstance”模式和“singleTask”模式是一样的。 ​ 其余三种启动模式则允许包含此activity的任务栈包含其它的activity。 ​ 4）是否每次都生成新实例 ​ 对于默认的“standard”模式，每当响应一个Intent对象，都会创建一个这种activity类型的新的实例。即每一个activity实例处理一个intent。 ​ 对于“singleTop”模式，只有当这个activity的实例当前处于任务栈的栈顶位置，则它会被重复利用来处理新到达的intent对象。否则就和“standard”模式的行为一样。 ​ “singleInstance”是其所在栈的唯一activity，它会每次都被重用。 ​ 对于“singleTask”模式的acitvity，在其上面可能存在其它的activity组件，所以它的位置并不是栈顶，在这种情况下，intent对象会被丢弃。（虽然会被丢弃，但是这个intent对象会使这个任务栈切换到前台） ​ 注意： ​ 当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 若为了处理一个新到达的intent对象而创建了一个activity实例，则用户按下“BACK”键就会退到之前的那个activity。但若这个新到达的intent对象是由一个已经存在的activity组件来处理的，那么用户按下“BACK” 键就不会回退到处理这个新intent对象之前的状态了。 Using Intent flags 当开启一个activity时，可以通过在intent中包含标志来修改activity的默认的与当前task的关联，然后将该intent传递给startActivity().可以修改的默认的标志为： FLAG_ACTIVITY_NEW_TASK在一个新的task中开启一个activity。如果包含该activity的task已经运行，该task就回到前台，activity通过onNewIntent()接受处理该intent。这是与”singleTask”登录模式相同的行为。 FLAG_ACTIVITY_SINGLE_TOP如果要被开启的activity是当前的activity（在返回栈的顶部），已经存在的实例通过onNewIntent()接收一个调用，然后处理该intent，而非重新创建一个新的实例。这与”singleTop”登录模式有相同的行为。 FLAG_ACTIVITY_CLEAR_TOP如果要被开启的activity已经在当前的task中运行，系统不会生成该activity的一个新的实例，在该栈顶部的所有其他的activity会被销毁，这个intent通过 onNewIntent()被传递给该重新运行的activity的实例（现在在栈顶部）。manifest中没有相对应的属性。FLAG_ACTIVITY_CLEAR_TOP经常和FLAG_ACTIVITY_NEW_TASK一起使用.当一起使用时，这些标志可以确定一个存在的activity在另一个task中的位置，并且将其放置于可以响应intent的位置（FLAG_ACTIVITY_NEW_TASK确定该activity，然后FLAG_ACTIVITY_CLEAR_TOP销毁顶部其他的activity）。如果指定的activity的登录模式是”standard”，也会被从栈中移除，一个新的实例也会被登录到它的位置来处理到来的intent。那是因为当登录模式为 “standard”时，一个新的实例总是被创建 注意： 其实以上的解释一起用非常复杂，比如一般系统默认activity是 standard，但当我activity代码设置为FLAG_ACTIVITY_NEW_TASK时仍然还是生成新的activity，当设置FLAG_ACTIVITY_CLEAR_TOP 时也是生成新的activity，当FLAG_ACTIVITY_CLEAR_TOP和FLAG_ACTIVITY_NEW_TASK时也是生成新的activity，或许这句好是经典“登录模式为 “standard”时，一个新的实例总是被创建”，以下的两种方式是我经常用的。 参考： Activity的启动模式 按back键处理流程我们在使用安卓手机时候，常常会用到back（返回）键来退出当前正在使用的Activity。这个事件的主要流程可以概括为两个步骤。 InputReader，InputDispatcher对输入事件的分发处理，包括调用PhoneWindowManager的interceptKeyBeforeDispatching和View，ViewGroup的dispatchTouchEvent等方法。2.事件分发到该Activity后，Activity方法调用finish方法退出，销毁Activity。众多第三方软件常常设置连续两次按下back键退出应用程序的功能，或者是在各浏览器APP中返回上一页浏览过的网页的功能，就是通过重写这一步骤中涉及的方法而实现的。本文分析的是第二步流程，第1步过程将在随后《android输入事件分发机制》一文中进行探讨。由于大部分Activity不会重写onBackPressed()方法，因此它们在接受到back键输入事件后，最终会辗转调用到父类Activity.Java的onBackPressed()方法。http://blog.csdn.net/jakioneplus/article/details/50034653 Android事件分发机制Activity ViewGroup ViewView是所有ViewGroup TextView LinearLayout等的基类LinearLayout/RelativeLayout还有一些可以包含多个TextView、Button等的组装均继承自ViewGroup，因此也是一个viewAndroid事件分发主要是从Activity到ViewGroup到具体某个View响应的过程，事件都是以MotionEvent.ACTION_DOWN事件开始、UP事件结束，中间有无数的MOVE事件。主要是dispatchTouchEvent onTouchEvent onInterceptTouchEvent之间的传递和拦截处理。基本思路是从Activity-&gt;ViewGroup-&gt;View的dispatchTouchEvent一直往下执行，如果有一个返回false那么直接向上返回onTouchEvent执行，如果返回true那么直接消费掉结束，如果不返回那么继续下一层dispatchTouchEvent； 如果到最后一层dispatchTouchEvent还没有返回，那么执行onTouchEvent依次往上执行，如果onTouchEvent返回true，那么就消费掉结束，否则一直向上执行onTouchEvent，到最上层结束。https://www.jianshu.com/p/38015afcdb58查看解析步骤：https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png?imageMogr2/auto-orient/ startActivity流程http://gityuan.com/2016/03/12/start-activity/启动流程：点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；system_server进程接收到请求后，向zygote进程发送创建进程的请求；Zygote进程fork出新的子进程，即App进程；App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续计划再进一步讲解生命周期过程与系统是如何交互，以及UI渲染过程，敬请期待。 ListView原理学习与优化总结 ListVeiw: 用来展示列表的View。 适配器 : 用来把数据映射到ListView上 他首先用getCount（）函数得到要绘制的这个列表的长度，然后开始绘制第一行，怎么绘制呢？调用getView()函数 。ListView 针对每个item，要求 adapter “返回一个视图” (getView)，也就是说ListView在开始绘制的时候，系统首先调用getCount（）函数，根据他的返回值得到ListView的长度，然后根据这个长度，调用getView（）一行一行的绘制ListView的每一项 如果你有几千几万甚至更多的选项(item)时，其中只有可见的项目存在内存（内存内存哦，说的优化就是说在内存中的优化！！！）中，其他的在Recycler中 ListView先请求一个type1视图(getView)然后请求其他可见的项目。convertView在getView中是空(null)的 当item1滚出屏幕，并且一个新的项目从屏幕低端上来时，ListView再请求一个type1视图。convertView此时不是空值了，它的值是item1。你只需设定新的数据然后返回convertView，不必重新创建一个视图 1234567891011121314public View getView(int position, View convertView, ViewGroup parent) &#123; System.out.println("getView " + position + " " + convertView); ViewHolder holder = null; if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.item1, null); holder = new ViewHolder(); holder.textView = (TextView)convertView.findViewById(R.id.text); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder)convertView.getTag(); &#125; holder.textView.setText(mData.get(position)); return convertView; &#125; https://blog.csdn.net/hhq163/article/details/8132723 ListView真正意义上的优化: ViewHolder Tag 必不可少，这个不多说！ 如果自定义Item中有涉及到图片等等的，一定要狠狠的处理图片，图片占的内存是ListView项中最恶心的，处理图片的方法大致有以下几种：2.1：不要直接拿个路径就去循环decodeFile();这是找死….用Option保存图片大小、不要加载图片到内存去;2.2: 拿到的图片一定要经过边界压缩2.3:在ListView中取图片时也不要直接拿个路径去取图片，而是以WeakReference（使用WeakReference代替强引用。比如可以使 用WeakReference mContextRef）、SoftReference、WeakHashMap等的来存储图片信息，是图片信息不是图片哦！2.4:在getView中做图片转换时，产生的中间变量一定及时释放，用以下形式： 尽量避免在BaseAdapter中使用static 来定义全局静态变量，我以为这个没影响 ，这个影响很大，static是Java中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用static修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（比如Context的情况最多），这时就要尽量避免使用了.. 如果为了满足需求下必须使用Context的话：Context尽量使用Application Context，因为Application的Context的生命周期比较长，引用它不会出现内存泄露的问题 尽量避免在ListView适配器中使用线程，因为线程产生内存泄露的主要原因在于线程生命周期的不可控制 HashMap put和get操作当使用HashMap的put方法的时候,有两个问题要解决： 1、长度为16的数组中，元素存储在哪个位置2、如果key出现hash冲突,如何解决 第一个问题,HashMap 是使用下面的算法来计算元素的存放位置的。 12int hash = hash(key);int i = indexFor(hash, table.length);12 首先先hash,之后结合数组的长度进行一个&amp;操作得到得到数组的下标。 第二个问题 则利用Entry类的next变量来实现链表,把最新的元素放到链表头,旧的数据则被最新的元素的next变量引用着。举个例子,假设元素Entry&lt;&quot;1&quot;,&quot;1&quot;&gt;通过hash算法算出存到下标为0的位置上,后面又添加一个Entry&lt;&quot;2&quot;,&quot;2&quot;&gt;,假设Entry&lt;&quot;2&quot;,&quot;2&quot;&gt;通过hash算法算出也需要存到下标为0的数组中,那么此时链表是下面这个样子的: Entry&lt;”2”,”2”&gt; –&gt; Entry&lt;”1”,”1”&gt; 也即是说,当key出现hash冲突的时候,链表中的第一个元素都是后面最新添加进来的那个,之前的则被next变量引用着。虽然这里是插入的动作,但是由于使用了链表,所以无需像数组的插入那样,进行数组拷贝。 HashMap get操作 这个操作的原理就比较简单,只需要根据key的hashcode算出元素在数组中的下标,之后遍历Entry对象链表,直到找到元素为止。 12345678int hash = (key == null) ? 0 : hash(key);for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != null;e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e;&#125;123456789 这里有两个注意点:1、这里利用key的hashcode方法和equals方法,所以在使用HashMap的时候,如果使用对象作为key,最好覆写key的hashcode和equals方法不然可能出put到HashMap的时候,成功了,但是get的时候却没有找到数据2、如果key hash冲突太多,会造成链表过长,在链表中查找元素的时候,会比较慢 shareprefscommit是同步 apply是异步 可以多进程访问，但会出现冲突，需要采用进程冲突机制，比如使用一个service进行保存 onMeasure的过程四个模式应用场景：**singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。之前打开过的页面，打开之前的页面就ok，不再新建。 singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。 这四种模式中的Standard模式是最普通的一种，没有什么特别注意。而SingleInstance模式是整个系统的单例模式，在我们的应用中一般不会应用到。所以，这里就具体解说 SingleTop 和 SingleTask模式的运用场景： 1. SingleTask模式的运用场景最常见的应用场景就是保持我们应用开启后仅仅有一个Activity的实例。最典型的样例就是应用中展示的主页（Home页）。 假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用SingleTask模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。 2. SingleTop模式的运用场景假设你在当前的Activity中又要启动同类型的Activity，此时建议将此类型Activity的启动模式指定为SingleTop，能够降低Activity的创建，节省内存！ 自定义控件有哪几种实现方式？在实现自定义控件时需要重写哪几个构造方法？ 组合控件，继承已有控件改写功能，继承view自己实现。 需要重写onMeasure、onDraw、onLayout；自定义ViewGroup如果不使用现成的LayoutParams还需要重写getDefaultLayoutParamas等方法。 MultidexMultidex了解吗？它是用来解决什么问题的？一个工程有10W个方法，分几个dex文件？每个dex文件的方法数是多少？ Multidex用来解决单个dex文件方法数65535上限导致打包不成功的问题。一个10w方法的app打包应该有两个dex文件。其中一个方法数达到上限，另一个为100000-65535=34465。 https://www.cnblogs.com/butterfly-clover/p/5161150.html multidex和热修复：https://blog.csdn.net/hp910315/article/details/51681710 multidex分包技术定制https://neyoufan.github.io/2017/01/20/android/Multidex%E5%8A%A0%E9%80%9F/ https://tech.meituan.com/mt_android_auto_split_dex.html]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ui</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬虫-反爬虫解析]]></title>
    <url>%2Fposts%2Fjava_web_scrapy_crawler.html</url>
    <content type="text"><![CDATA[爬虫入门文章https://zhuanlan.zhihu.com/p/24669128https://zhuanlan.zhihu.com/p/24769534https://zhuanlan.zhihu.com/p/25200262https://zhuanlan.zhihu.com/p/26257790 userAgent 和 动态IP设置http://lawtech0902.com/2017/06/11/scrapy-useragent-proxyip/https://zhuanlan.zhihu.com/p/29733174https://github.com/hellysmile/fake-useragent 延迟和禁止cookieshttps://blkstone.github.io/2016/03/02/crawler-anti-anti-cheat/ PhantomJs 和 selenium 处理Ajaxhttps://my.oschina.net/lewisgong/blog/872257https://chaycao.github.io/2016/08/19/Scrapy-Selenium-Phantomjs/ 页面解析 Beautiful xpath css.https://cuiqingcai.com/1319.html pythonlxml安装https://pypi.org/project/lxml/#filespip install lxml-4.2.1-cp27-cp27m-win_amd64.whlhttps://blog.csdn.net/g1apassz/article/details/46574963https://blog.csdn.net/acingdreamer/article/details/53348649 pip升级pip install –upgrade pip requirements.txt的创建及使用https://blog.csdn.net/orangleliu/article/details/60958525 python path 引用https://blog.csdn.net/tony_wong/article/details/18044273 Scrapy安装错误：Microsoft Visual C++ 14.0 is required…https://blog.csdn.net/nima1994/article/details/74931621?locationNum=10&amp;fps=1 Scrapy shellhttps://blog.csdn.net/laoyang360/article/details/52809927Scrapy运行ImportError: No module named win32api错误https://blog.csdn.net/u013687632/article/details/57075514 xpathhttps://blog.csdn.net/manongpengzai/article/details/77109600 python loghttps://blog.csdn.net/chosen0ne/article/details/7319306 scrapy link extratorhttps://www.jianshu.com/p/ff9125650697 启动爬虫进入项目的根目录，执行下列命令启动spider:scrapy crawl dmoz]]></content>
      <categories>
        <category>12Java_web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>爬虫</tag>
        <tag>反反爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android签名机制解析v1/v2及渠道打包应用]]></title>
    <url>%2Fposts%2Fandroid_security_signature_v1_v2.html</url>
    <content type="text"><![CDATA[签名机制https://source.android.com/security/apksigning/http://zzqhost.com/2017/06/17/Android%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/ V1签名机制https://blog.csdn.net/asmcvc/article/details/9311827https://blog.csdn.net/asmcvc/article/details/9312021https://www.cnblogs.com/plokmju/p/8482993.htmlhttps://cloud.tencent.com/developer/article/1006237 V1签名机制比较简单，主要设计三个文件，分别是自签名的证书CERT.RSA， MANIFEST.MF和CERT.SF，首先对每一个文件进行sha1并进行base64编码，生成MANIFEST.MF文件，然后对MANIFEST.MF这个文件进行sha1和base64，然后对MANIFEST.MF每一个条目进行sha1和base64，其中CERT.RSA包含签名者公钥，是一种pkcs7,p7b的格式，可以直接在windows改名字就可以看到了。校验也比较简单，首先校验CERT.RSA中的自签名证书，然后校验CERT.SF，证明文件MANIFEST.MF是正确的，然后对每一个文件进行校验，看是否被篡改，就结束。那么这里有天生的缺陷，没有对META-INF下的其他文件进行校验，也没有对ZIP包其他字段进行校验，那么可以利用 Zip 格式的特点，修改Comment Length和File Comment两个字段，不会对ZIP文件造成破坏，比如写个渠道信息。 V1签名机制存在的问题Apk包在安装的时候，是按照从(3)到(1)的顺序依次校验的，先用公钥还原签名信息，然后和.SF文件中的信息比对，然后用同样的摘要算法对.MF文件里面的每一个条目计算对应的摘要信息，然后比对.MF文件是否一致。 在这个过程中，我们发现有两点： (1) 在校验的过程中需要解压，因为.MF文件的摘要信息是基于原始未压缩文件内容，因此在校验的时候就需要解压出原始数据，而这个解压操作无疑是耗时操作。 (2) apk包的完整性校验不够强。这里可以看到如果我们在apk签名后，如果对apk包中没有涉及到原始文件内容的数据块做改变那么这层校验机制就会失效（如直接通过二进制改变apk包的无关数据块如核心中央目录注释字段写一些无关注释，然后用zipalign工具对齐，则apk包还是可以正常安装的，这样就绕过了v1层的校验机制） V2签名机制https://tech.meituan.com/android-apk-v2-signature-scheme.html V2签名机制，是一种增强的ZIP包签名机制，先分析下格式如下整个APK（ZIP文件格式）会被分为以下四个区块：Contents of ZIP entries（from offset 0 until the start of APK Signing Block）APK Signing BlockZIP Central DirectoryZIP End of Central Directory那么v2签名能够对除了apk signing block以外的所有部分进行校验，如果有问题，那么就不能安装apk，相对v1来说更为安全。Apk signing block字段是可以进行更改的，不受签名约束，这部分格式如下，可以通过在id-value中多添加一些信息对，而不会改变apk的签名信息，以此实现渠道信息的添加。@+0 8 这个Block的长度（本字段的长度不计算在内）@+8 n 一组ID-value@-24 8 这个Block的长度（和第一个字段一样值）@-16 16 魔数 “APK Sig Block 42” 多渠道打包：https://www.jianshu.com/p/332525b09a88http://zzqhost.com/2017/06/18/Android%E6%89%93%E6%B8%A0%E9%81%93%E5%8C%85%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/http://yifeiyuan.me/2017/01/16/muitl-channel-pkg-compare/https://github.com/GavinCT/AndroidMultiChannelBuildTool zip渠道打包 v1 META-INFhttps://github.com/mcxiaoke/packer-ng-plugin packer v1 v2https://github.com/Meituan-Dianping/walle walle v2签名 多渠道打包的方案，也是基于v1和v2签名的一些固有特性来进行的。主要有code/manifest硬编码，productFlavors, zip meta-inf， zip comment注释， v2 apk signing block修改的几种方式。 Flavors在AndroidManifest.xml中配置一个meta-data： 然后在app/build.gradle里配置productFlavors： productFlavors { def path = “channels.txt” file(path).eachLine { channel -&gt; “$channel” { manifestPlaceholders = [CHANNEL_NAME: channel] } }}PS：channels.txt 是渠道列表文件，每一行代表一个渠道，这样方便管理。打包方法使用 ./gradlew assembleRelease命令，就可以打出多渠道的包了。 原理该种方式的打包原理是利用了 Gradle 的flavors功能来实现的，渠道的获取是通过如下代码方式获取。ApplicationInfo appInfo = cxt.getPackageManager().getApplicationInfo(cxt.getPackageName(), PackageManager.GET_META_DATA);String channel = String.valueOf(appInfo.metaData.get(“UMENG_CHANNEL”));优缺点优点：简单，易懂，没什么门槛，也不需要依赖其他工具与插件。Gradle强大的flavor功能，可以实现不同渠道拥有不同的代码实现，可以给渠道做定制包。扩展性强大，没有兼容性问题。缺点：打包速度极慢，因为每个渠道包都是从“0到1”，渠道一多，打包时间以小时为单位。PS：我们 App 几百个渠道，用这种方式打包需要2多个小时，怎么受得了？。 所以，该方式适合渠道不多的时候使用，或者不同渠道需要使用不同的代码。 Wiki https://ctf-wiki.github.io/ctf-wiki/]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安全</tag>
        <tag>v1签名</tag>
        <tag>v2签名</tag>
        <tag>证书</tag>
        <tag>渠道打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端主流框架简单解析]]></title>
    <url>%2Fposts%2Fjava_web_front_end_analysis.html</url>
    <content type="text"><![CDATA[#Angularhttp://www.runoob.com/angularjs/angularjs-tutorial.html #Reacthttp://www.runoob.com/react/react-tutorial.html #Vuehttp://www.runoob.com/vue2/vue-tutorial.html #Amaze ui #Bootstraphttp://www.runoob.com/bootstrap/bootstrap-tutorial.html zheng admin ui]]></content>
      <categories>
        <category>12Java_web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>框架</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web主流框架简单解析]]></title>
    <url>%2Fposts%2Fjava_web_framework_library_analysis.html</url>
    <content type="text"><![CDATA[springmvc mybatishttps://github.com/liyifeng1994/ssm dubbo zoopkeeperhttp://www.cnblogs.com/c9999/p/6019307.htmlhttp://blog.csdn.net/congcong68/article/details/41113239 mongo dbhttp://www.runoob.com/mongodb/nosql.htmlhttp://blog.csdn.net/congcong68/article/details/44277469http://blog.csdn.net/congcong68/article/details/44545253 ehcache redis memcachedhttp://calvin1978.blogcn.com/articles/lru.html RabbitMq、ActiveMq、ZeroMq、kafkahttp://blog.csdn.net/linsongbin1/article/details/47781187 Activemqhttp://blog.csdn.net/jiuqiyuliang/article/details/48758203http://www.cnblogs.com/jaycekon/p/ActiveMq.html jstorm stormhttp://www.cnblogs.com/xymqx/p/4389574.htmlhttp://blog.csdn.net/jianghuxiaojin/article/details/51550248https://my.oschina.net/132722/blog/284511 Druid 数据库连接池https://github.com/alibaba/druid/wiki/%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95 Apache Shirohttp://www.infoq.com/cn/articles/apache-shirohttps://www.gitbook.com/book/holynull/-spring-mvc-apache-shiro-/detailshttp://www.cnblogs.com/java-class/p/5475373.html mybatisPageHelperhttp://www.cnblogs.com/softidea/p/5271868.html ZooKeeperhttps://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/ Solr &amp; Elasticsearchsolrhttps://my.oschina.net/cloudcoder/blog/305024https://my.oschina.net/ZKXTtiumph/blog/664820http://blog.csdn.net/lr131425/article/details/75959230 EBhttp://www.ruanyifeng.com/blog/2017/08/elasticsearch.html Quartz分布式定时任务https://www.cnblogs.com/aaronfeng/p/5537177.html Protobuf &amp; jsonhttps://www.ibm.com/developerworks/cn/linux/l-cn-gpb/ fastdfshttp://www.cnblogs.com/mafly/p/fastdfs.htmlhttp://www.ityouknow.com/fastdfs/2018/01/06/distributed-file-system-fastdfs.html FluentValidatorhttps://my.oschina.net/rockfate/blog/794295http://neoremind.com/2016/02/java%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E9%AA%8C%E8%AF%81%E6%A1%86%E6%9E%B6fluent-validator/ AliOSS &amp; Qiniu &amp; QcloudCOShttps://www.aliyun.com/product/oss/http://www.qiniu.com/ https://www.qcloud.com/product/cos]]></content>
      <categories>
        <category>12Java_web</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据获取分析与机器学习]]></title>
    <url>%2Fposts%2Fbooks_recommand_data_analysis_ai_deeplearn.html</url>
    <content type="text"></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>data_analysis</tag>
        <tag>ai_deeplearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统安全]]></title>
    <url>%2Fposts%2Fandroid_security_system_security.html</url>
    <content type="text"><![CDATA[系统安全https://source.android.google.cn/security/overview/kernel-security android安全机制如下： 系统和内核安全在操作系统级别，Android 平台不仅提供 Linux 内核的安全功能，而且还提供安全的进程间通信 (IPC) 机制，以便在不同进程中运行的应用之间安全通信。操作系统级别的这些安全功能旨在确保即使是原生代码也要受应用沙盒的限制。无论相应代码是自带应用行为导致的结果，还是利用应用漏洞导致的结果，系统都能防止违规应用危害其他应用、Android 系统或设备本身。要了解您可以采取哪些措施来增强设备的内核安全性，请参阅内核配置。要了解必需的设置，请参阅 Android 兼容性定义文档 (CDD)。 Linux 安全Android 平台的基础是 Linux 内核。Linux 内核多年来得到了非常广泛的应用，在千百万对安全敏感的环境中都有它的身影。在历经无数攻击以及成千上万的开发者的不断研究和修复之后，Linux 已成为许多公司和安全专业人士信任的一款既稳定又安全的内核。 作为移动计算环境的基础，Linux 内核为 Android 提供了一些关键的安全功能，其中包括： 基于用户的权限模式 进程隔离用于实现安全 IPC 的可扩展机制能够移除内核中不必要的和可能不安全的部分作为一种多用户操作系统，Linux 内核的一个基本安全目标是将用户资源彼此隔离开来。Linux 的安全理念是防范用户资源之间相互侵扰。因此，Linux 可以： 防止用户 A 读取用户 B 的文件确保用户 A 不会占用用户 B 的内存确保用户 A 不会占用用户 B 的 CPU 资源确保用户 A 不会占用用户 B 的设备（例如，电话、GPS、蓝牙） 应用沙盒Android 平台利用基于用户的 Linux 保护机制来识别和隔离应用资源。Android 系统会为每个 Android 应用分配一个独一无二的用户 ID (UID)，并使它们以这个用户身份在单独的进程中运行。这种方法与其他操作系统（包括传统的 Linux 配置）采用的方法不同。在其他操作系统中，多个应用会以相同的用户权限运行。 这样就设置了一个内核级应用沙盒。内核会在进程级别利用标准的 Linux 机制（例如，分配给应用的用户 ID 和组 ID）实现应用和系统之间的安全防护。默认情况下，应用不能彼此交互，而且应用对操作系统的访问权限会受到限制。如果应用 A（一个单独的应用）尝试执行恶意操作，例如在没有权限的情况下读取应用 B 的数据或拨打电话，操作系统会阻止此类操作，因为应用 A 没有适当的用户权限。这一沙盒机制非常简单，可审核，并且基于已有数十年历史的 UNIX 风格的进程用户隔离和文件权限机制。 由于应用沙盒位于内核层面，因此该安全模型的保护范围扩展到了原生代码和操作系统应用。位于更高层面的所有软件（例如，操作系统库、应用框架、应用运行时环境和所有应用）都会在应用沙盒中运行。在某些平台上，为了执行安全防护机制，会限制开发者只能使用特定的开发框架、API 或语言。在 Android 上，并没有为此而限制开发者必须如何编写应用，在这方面，原生代码与解释型代码一样安全。 在某些操作系统中，一个应用中的内存异常可能会破坏位于同一内存空间中的其他应用的内存数据，进而导致设备的安全性荡然无存。在 Android 中，由于所有应用及其资源都在操作系统级别的沙盒内，因此，即使出现内存数据损坏，也只能在相应应用的环境内执行代码，而且只能以操作系统确立的权限执行代码。 与所有安全功能一样，应用沙盒并不是坚不可摧的。不过，要在经过适当配置的设备上攻破应用沙盒这道防线，必须要先攻破 Linux 内核的安全功能。 系统分区和安全模式系统分区包含 Android 的内核，以及操作系统库、应用运行时、应用框架和应用。该分区设为了只读分区。当用户将设备启动到安全模式时，第三方应用可由设备所有者手动启动，但不会默认启动。 文件系统权限在 UNIX 风格的环境中，文件系统权限可确保一个用户不能更改或读取另一个用户的文件。在 Android 中，每个应用都以自己的用户身份运行。除非开发者明确地与其他应用共享文件，否则一个应用不能读取或更改另一个应用创建的文件。 安全增强型 LinuxAndroid 使用安全增强型 Linux (SELinux) 来实施访问控制策略并针对进程建立强制访问控制 (mac) 机制。如需详细信息，请参阅 Android 中的安全增强型 Linux。https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/143.htmlhttps://source.android.google.cn/security/selinux/ 验证启动Android 6.0 及更高版本支持验证启动功能和 device-mapper-verity。验证启动功能旨在保证设备软件（从硬件信任根直到系统分区）的完整性。在启动过程中，无论是在哪个阶段，都会在进入下一个阶段之前以加密形式先验证下一个阶段的完整性和正确性。 Android 7.0 及更高版本支持严格强制执行的验证启动，这意味着遭到入侵的设备将无法启动。 如需更多详细信息，请参阅验证启动。 加密算法库 KeyChain/KeyStore/JCA/BC/BoringSSL/KeyMaster/TEEAndroid 提供了一系列加密 API 供应用使用，其中包括标准和常用加密基元（例如，AES、RSA、DSA 和 SHA）的实现。此外，Android 还提供了适用于更高级别协议（例如，SSL 和 HTTPS）的 API。 Android 4.0 中引入了 KeyChain 类，以便应用使用系统凭据存储空间来存储私钥和证书链。 获取设备的 Root 权限默认情况下，在 Android 上，只有内核和一小部分核心应用能够以 Root 权限运行。Android 不会阻止具有 Root 权限的用户或应用修改操作系统、内核或任何其他应用。一般来说，Root 对所有应用和所有应用数据拥有完整访问权限。如果用户在 Android 设备上更改权限来向应用授予 Root 访问权限，那么在面对恶意应用以及潜在应用缺陷时，安全风险会更大。 能够修改自己的 Android 设备对于使用 Android 平台的开发者来说非常重要。在许多 Android 设备上，用户都可以解锁引导加载程序，以便安装替代操作系统。这些替代操作系统可能会允许所有者获得 Root 访问权限，以便他们调试应用和系统组件，或者使用 Android API 未提供给应用的功能。 在某些设备上，能够亲手控制设备并拥有 USB 数据线的用户可以安装能够向其提供 Root 权限的新操作系统。为了保护所有现有用户数据免遭入侵，引导加载程序解锁机制要求引导加载程序在解锁期间清空所有现有用户数据。利用内核错误或安全漏洞获得 Root 访问权限后，可以绕过这种保护机制。 使用存储在设备上的密钥对数据进行加密的做法并不能防止 Root 用户访问应用数据。应用可以使用存储在设备之外的密钥（例如，存储在服务器上的密钥，或用户密码）进行加密，从而添加一道数据保护屏障。在没有密钥的情况下，这种方法可以提供临时保护，但应用迟早要获取密钥来进行解密，此时 Root 用户也就可以取得相应密钥了。 一种更强大的防止 Root 用户获取数据的方式是使用硬件解决方案。OEM 可以选择实现可限制特定类型的内容的访问权限的硬件解决方案，例如，适用于视频播放的 DRM 解决方案或适用于 Google 电子钱包的 NFC 相关可信存储空间。 如果设备丢失或被盗，Android 设备上的全文件系统加密功能会用设备密码来保护加密密钥，这样一来，修改启动加载程序或操作系统的做法将不足以在没有用户设备密码的情况下访问用户数据。 用户安全功能 文件系统加密Android 3.0 及更高版本提供全文件系统加密功能，因此所有用户数据都可以在内核中进行加密。 Android 5.0 及更高版本支持全盘加密。全盘加密功能旨在用一个密钥（由用户的设备密码加以保护）来保护设备的整个用户数据分区。在启动时，用户必须先提供其凭据，然后才能访问磁盘的任何部分。 Android 7.0 及更高版本支持文件级加密。采用文件级加密时，可以使用不同的密钥对不同的文件进行加密，并且可以对这些文件进行单独解密。 如需详细了解如何实现文件系统加密，请参阅加密部分。 密码保护Android 可以配置为先验证用户提供的密码，然后再提供对设备的访问权限。除了防止未经授权使用设备外，该密码还可以保护用于进行全文件系统加密的加密密钥。 设备管理员可以要求使用密码和/或设置密码复杂度规则。 设备管理Android 2.2 及更高版本提供 Android Device Administration API，该 API 在系统级别提供设备管理功能。例如，内置的 Android 电子邮件应用可以使用该 API 来改善 Exchange 支持。在此情况下，Exchange 管理员可以跨设备强制执行密码政策（字母数字密码或数字 PIN 码都算作密码）。管理员还可以远程清除（即恢复出厂默认设置）丢失或被盗手机上的数据。 除了 Android 系统自带的应用，提供设备管理解决方案的第三方也可使用该 API。如需详细了解该 API，请参阅设备管理。 身份验证 指纹 gatekeeper 生物识别解锁模式 冒名攻击 欺骗攻击指纹 不适用 指纹 + 指纹模具脸部 试图看上去像是用户的脸部 高分辨率照片、乳胶（或其他高质量）面罩语音 试图听起来像是用户的声音 录音虹膜 不适用 高分辨率照片 + 隐形眼镜 文件加密 文件级加密 全盘加密 TrustZone-TEE参考开源的opteehttp://blog.csdn.net/shuaifengyun/article/details/73716352 InSE芯片系统芯片系统COS，之前实验室做过相关的自主研发芯片，C51 CPU集成了小型的COS系统，不支持applet。熟悉基本原理。]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Android系统安全</tag>
        <tag>书记推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android查缺补漏-安全权限]]></title>
    <url>%2Fposts%2Fandroid_review_security_permissions.html</url>
    <content type="text"><![CDATA[Binder实现原理用法总结：http://gityuan.com/2015/11/22/binder-use/http://gityuan.com/2015/11/23/binder-aidl/主要思路是: aidl两端：服务端stub端，实现aidl接口，通过onTransact接收数据。客户端proxy端，实现aidl接口，通过mRemote.transact传送数据。 asInterface:new com.yuanhh.appbinderdemo.IRemoteService.Stub.Proxy(obj); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.yuanhh.appbinderdemo;public interface IRemoteService extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.yuanhh.appbinderdemo.IRemoteService &#123; private static final java.lang.String DESCRIPTOR = &quot;com.yuanhh.appbinderdemo.IRemoteService&quot;; /** * Stub构造函数 */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * 将IBinder 转换为IRemoteService interface */ public static com.yuanhh.appbinderdemo.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.yuanhh.appbinderdemo.IRemoteService))) &#123; return ((com.yuanhh.appbinderdemo.IRemoteService) iin); &#125; return new com.yuanhh.appbinderdemo.IRemoteService.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getPid: &#123; data.enforceInterface(DESCRIPTOR); int _result = this.getPid(); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_getMyData: &#123; data.enforceInterface(DESCRIPTOR); com.yuanhh.appbinderdemo.MyData _result = this.getMyData(); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.yuanhh.appbinderdemo.IRemoteService &#123; private android.os.IBinder mRemote; /** * Proxy构造函数 */ Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int getPid() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public com.yuanhh.appbinderdemo.MyData getMyData() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.yuanhh.appbinderdemo.MyData _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getMyData, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.yuanhh.appbinderdemo.MyData.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_getPid = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getMyData = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public int getPid() throws android.os.RemoteException; public com.yuanhh.appbinderdemo.MyData getMyData() throws android.os.RemoteException;&#125; binder die处理思路比较简单之间直接在客户端注册相应callback即可。IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient()https://blog.csdn.net/lea_fy/article/details/52987004具体机制可以参考：http://gityuan.com/2016/10/03/binder_linktodeath/ provider权限http://blog.csdn.net/flowingflying/article/details/17412609&gt;全局权限 uri权限 全局Uri granting权限传递 Intent intent = new Intent(this,ReadProvider.class);intent.setClassName(“com.example.propermissiongrant”, “com.example.propermissiongrant.MainActivity”);intent.setData(Uri.parse(“content://xxx.xxx.flowingflying.propermission.PrivProvider/world/1”));intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); //传递权限startActivity(intent);部分uri权限传递 android:exported说明Activity 是否可由其他应用的组件启动 —“true”表示可以，“false”表示不可以。若为“false”，则 Activity 只能由同一应用的组件或使用同一用户 ID 的不同应用启动。 默认值取决于 Activity 是否包含 Intent 过滤器。没有任何过滤器意味着 Activity 只能通过指定其确切的类名称进行调用。 这意味着 Activity 专供应用内部使用（因为其他应用不知晓其类名称）。 因此，在这种情况下，默认值为“false”。另一方面，至少存在一个过滤器意味着 Activity 专供外部使用，因此默认值为“true”。 该属性并非限制 Activity 对其他应用开放度的唯一手段。 您还可以利用权限来限制哪些外部实体可以调用 Activity（请参阅 permission 属性）。 https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#exported Broadcast权限https://www.cnblogs.com/whoislcj/p/5497409.htmlhttps://blog.csdn.net/javensun/article/details/7334230 在Android应用开发中，有时会遇到以下两种情况 一些敏感的广播并不想让第三方的应用收到 ； 要限制自己的Receiver接收某广播来源，避免被恶意的同样的ACTION的广播所干扰。 在这些场景下就需要用到广播的权限限制。 第一种场景： 谁有权收我的广播在这种情况下，可以在自己应用发广播时添加参数声明Receiver所需的权限。首先，在Androidmanifest.xml中定义新的权限RECV_XXX，例如： 1. &lt;permission android:name = &quot;com.android.permission.RECV_XXX&quot;/&gt; 然后，在Sender app发送广播时将此权限作为参数传入，如下： 1. sendBroadcast(&quot;com.android.XXX_ACTION&quot;, &quot;com.android.permission.RECV_XXX&quot;); 这样做之后就使得只有具有RECV_XXX权限的Receiver才能接收此广播要接收该广播，在Receiver应用的AndroidManifest.xml中要添加对应的RECV_XXX权限。例如： 1. &lt;uses-permission android:name=&quot;com.android.permission.RECV_XXX&quot;&gt;&lt;/uses-permission&gt; 第二种场景： 谁有权给我发广播？在这种情况下，需要在Receiver app的 tag中声明一下Sender app应该具有的权限。首先同上，在AndroidManifest.xml中定义新的权限SEND_XXX，例如： 1. &lt;permission android:name=&quot;com.android.SEND_XXX&quot;/&gt; 然后，在Receiver app的Androidmanifest.xml中的tag里添加权限SEND_XXX的声明，如下： 1. &lt;receiver android:name=&quot;.XXXReceiver&quot; 2. android:permission=&quot;com.android.permission.SEND_XXX&quot;&gt; 3. &lt;intent-filter&gt; 4. &lt;action android:name=&quot;com.android.XXX_ACTION&quot; /&gt; 5. &lt;/intent-filter&gt; 6. &lt;/receiver&gt; 这样一来，该Receiver便只能接收来自具有该SEND_XXX权限的应用发出的广播。要发送这种广播，需要在Sender app的AndroidManifest.xml中也声明使用该权限即可，如下： 1. &lt;uses-permission android:name=&quot;com.android.permission.SEND_XXX&quot;&gt;&lt;/uses-permission&gt; 如此，可以用来对广播的来源与去处进行简单的控制。同样，对Activity 和 ContentProvider的访问权限控制也类似。 Protected-broadcast只有系统应用才能发送。• Process.SYSTEM_UID• Process.PHONE_UID• Process.SHELL_UID• Process.BLUETOOTH_UID• or 0• 其他应用不能发送 参考：https://crashpost.wordpress.com/2014/01/11/android-protected-broadcasts/http://blog.csdn.net/u013553529/article/details/78409382 Android存储https://bboyfeiyu.gitbooks.io/android-tech-frontier/content/others/%E6%B8%85%E6%99%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/readme.htmlhttps://github.com/Blankj/AndroidStandardDevelophttps://github.com/googlesamples/android-architecturehttp://kernel.meizu.com/android-m-external-storage.htmlhttp://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/0923/1557.htmlhttp://blog.csdn.net/liuxu0703/article/details/53897702http://blog.csdn.net/qq_23940659/article/details/50639787 相信很多新手对于Android的一些系统默认路径不太了解，在这里以5.1的Nexus5为例来介绍一下，希望对新手有点帮助，当然我也是新手啦。Environment.getDataDirectory().getPath()=/dataEnvironment.getDownloadCacheDirectory().getPath()=/cacheEnvironment.getExternalStorageDirectory()=/storage/emulated/0 /sdcard/ /storage/self/primary /mnt/user/0/primaryEnvironment.getRootDirectory().getPath()=/system//警报的铃声Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_ALARMS).getPath()=/storage/emulated/0/Alarms//相机拍摄的图片和视频保存的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).getPath()=/storage/emulated/0/DCIM//下载文件保存的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath()=/storage/emulated/0/Download//电影保存的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES).getPath()=/storage/emulated/0/Movies//音乐保存的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC).getPath()=/storage/emulated/0/Music//通知音保存的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_NOTIFICATIONS).getPath()=/storage/emulated/0/Notifications//下载的图片保存的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getPath()=/storage/emulated/0/Pictures//用于保存podcast（博客）的音频文件Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PODCASTS).getPath()=/storage/emulated/0/Podcasts//保存铃声的位置Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_RINGTONES).getPath()=/storage/emulated/0/Ringtones]]></content>
      <categories>
        <category>21Android_review</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安全</tag>
        <tag>查缺补漏</tag>
        <tag>权限</tag>
        <tag>broadcast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码阅读汇总]]></title>
    <url>%2Fposts%2Fsource_read_list.html</url>
    <content type="text"><![CDATA[设计模式源码http://welkinbai.coding.me/2017/06/04/design-pattern-1/#%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fhttp://welkinbai.coding.me/2017/01/18/anti-pattern/#%E4%B8%89%E3%80%81%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E8%A1%A5%E5%85%85 三个工厂模式差异https://blog.csdn.net/lqw05/article/details/51909449http://blog.onlycatch.com/post/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%EF%BC%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB 算法源码http://welkinbai.coding.me/2017/06/15/jdk-collection/#%E5%85%B3%E7%B3%BB%E7%BB%93%E6%9E%84https://blog.csdn.net/u010887744/article/category/6126950 Android 源码framework源码阅读android常用框架源码Java系列源码Jdk源码JavaWeb框架源码JVM源码os源码Linux kernel源码TrustZone源码]]></content>
      <categories>
        <category>000源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android应用安全]]></title>
    <url>%2Fposts%2Fandroid_security_android_security.html</url>
    <content type="text"><![CDATA[Android应用安全Android应用安全攻击面看安全 https://blog.csdn.net/u010651541/article/details/53142252http://colbert337.github.io/2015/08/24/android-attack-surface/ 安全开发生命周期https://www.cnblogs.com/shilxfly/p/7196875.html 安全设计 威胁建模 安全开发 安全编码 安全测试 代码审计 安全风险评估Risk AssessmentAndroid安全基础 java/c/cpp/vm asm android framework基础 xpose框架/插件/热修复原理 dex/Odex格式基础/dalvik和art虚拟机 IDA、GDB、JEB逆向工具 Android签名机制 v1签名 v2签名 应用多渠道发布 Android加固原理 应用加固应用加固http://jiagu.360.cn/1101141392.php?dtid=1101141786&amp;did=1101262105https://jaq.alibaba.com/community/art/show?articleid=1127http://www.520monkey.com/archives/1118http://secwiki.neu.edu.cn/wiki/images/1/1e/%E8%B0%88%E8%B0%88%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%8A%A0%E5%9B%BA_LBE.pdfhttps://chaman.gitbooks.io/techblog/Android/apk-enchance/apk-enchance.html 加固方案对比： https://www.niwoxuexi.com/blog/android/article/233.htmldex全量加固：https://juejin.im/entry/5a5c55426fb9a01c9f5b65edhttps://blog.csdn.net/jiangwei0910410003/article/details/48415225/ Android中apk加固完善篇之内存加载dex方案实现原理(不落地方式加载dex)http://www.10tiao.com/html/465/201606/2649229971/1.html so加固 代码资源混淆机制 Android逆向 apktool和jadx xposed hook机制frida/Xposed 脱壳zjdroid native hook cydia substrace 静态逆向 动态调试smali ida调试so Android网络协议安全Android数据安全Android重要的CVE分析重要的安全博客http://blogs.360.cn/360mobile/http://jaq.alibaba.com/?spm=a313e.7837752.1000000.1.44ff69b1P4qoomhttp://www.freebuf.com/articles/terminalhttp://www.cnblogs.com/2014asm/http://www.droidsec.cn/https://www.anquanke.com/#https://blog.flanker017.me/https://security.tencent.com/index.php/bloghttps://blog.csdn.net/u010651541 攻击-漏洞挖掘原理和机制业界通用的安全思想实践]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安全</tag>
        <tag>应用安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android查缺补漏-流行框架]]></title>
    <url>%2Fposts%2Fandroid_review_frame_library.html</url>
    <content type="text"><![CDATA[Andriod流行框架速查https://www.ctolib.com/cheatsheets-Android-ch.html 推荐 Team 可使用如下优秀轮子：• Retrofit • RxAndroid • OkHttp • Glide/Fresco • Gson/Fastjson • EventBus/AndroidEventBus • GreenDao • Dagger2（选用） • Tinker（选用） 来自 https://github.com/Blankj/AndroidStandardDevelop 缓存方案服务重试机制超时,重试,熔断,限流 n^2重试 1,2,4,6,8… 不断超时重试。http://wtoutiao.com/p/534r4HP.htmlhttp://www.sczyh30.com/posts/Microservice/circuit-breaker-pattern/http://www.cnblogs.com/yangecnu/p/Introduce-Circuit-Breaker-Pattern.html 图解Android应用的后台任务和提醒https://blog.csdn.net/qq284565035/article/details/51705341简单来说就是： 小于60s直接用handler AlarmManager 休眠唤醒 精准唤醒 重复唤醒 JobScheduler 网络请求处理心路历程http://www.jianshu.com/p/3141d4e46240 StateMachine机制http://blog.csdn.net/maybe_windleave/article/details/9881991http://blog.csdn.net/lilian0118/article/details/21974229 上传100M大文件如果有个100M大的文件，需要上传至服务器中，而服务器form表单最大只能上传2M，可以用什么方法。上传文件用的都是POST方式，POST方式对大小没什么限制。回到题目，可以说假设每次真的只能上传2M，那么可能我们只能把文件截断，然后分别上传了。 上传大文件，可以分块上传，与文件分块下载方法基本类似，使用RandomAcessFile来进行划分文件组装文件即可。使用Post方法上传文件。基本过程如下：https://blog.csdn.net/leiyaqiang/article/details/68491521 12345678910111213141516171819202122232425262728//普通字符串数据 private void writeStringParams() throws Exception &#123; Set&lt;String&gt; keySet = textParams.keySet(); for (Iterator&lt;String&gt; it = keySet.iterator(); it.hasNext();) &#123; String name = it.next(); String value = textParams.get(name); ds.writeBytes(&quot;--&quot; + boundary + &quot;\r\n&quot;); ds.writeBytes(&quot;Content-Disposition: form-data; name=\&quot;&quot; + name + &quot;\&quot;\r\n&quot;); ds.writeBytes(&quot;\r\n&quot;); ds.writeBytes(encode(value) + &quot;\r\n&quot;); &#125; &#125; //文件数据 private void writeFileParams() throws Exception &#123; Set&lt;String&gt; keySet = fileparams.keySet(); for (Iterator&lt;String&gt; it = keySet.iterator(); it.hasNext();) &#123; String name = it.next(); File value = fileparams.get(name); ds.writeBytes(&quot;--&quot; + boundary + &quot;\r\n&quot;); ds.writeBytes(&quot;Content-Disposition: form-data; name=\&quot;&quot; + name + &quot;\&quot;; filename=\&quot;&quot; + encode(value.getName()) + &quot;\&quot;\r\n&quot;); ds.writeBytes(&quot;Content-Type: &quot; + getContentType(value) + &quot;\r\n&quot;); ds.writeBytes(&quot;\r\n&quot;); ds.write(getBytes(value)); ds.writeBytes(&quot;\r\n&quot;); &#125; &#125;]]></content>
      <categories>
        <category>21Android_review</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>查缺补漏</tag>
        <tag>流程框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android查缺补漏-线程]]></title>
    <url>%2Fposts%2Fandroid_review_thread.html</url>
    <content type="text"><![CDATA[Android线程的几种方式AsyncTask/HandlerThread/Thread/IntentServicehttps://www.jianshu.com/p/34cffd700f75 AsyncTask单个线程的线程池，一个一个执行，会阻塞后边线程。可以设置 AsyncTask.executeOnExecutor()来同时执行任务。写的时候注意避免内存泄露 HandlerThread实质是一个Thread，不过添加了Looper和MessageQueue，这样就可以使用Handler来进行控制代码执行了。1234567891011121314151617181920212223242526272829303132333435// 创建一个线程，线程名字 : handlerThreadTest mHandlerThread = new HandlerThread(&quot;handlerThreadTest&quot;); mHandlerThread.start(); // Handler 接收消息 final Handler mHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; Log.e(&quot;Test&quot;, &quot;收到 &quot; + msg.obj.toString() + &quot; 在 &quot; + Thread.currentThread().getName()); &#125; &#125;; mTextView = (TextView) findViewById(R.id.text_view); // 主线程发出消息 mTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Message msg = new Message(); msg.obj = &quot;第一条信息&quot;; mHandler.sendMessage(msg); Log.e(&quot;Test&quot;, &quot;发出 &quot; + msg.obj.toString() + &quot; 在 &quot; + Thread.currentThread().getName()); &#125; &#125;); // 子线程发出消息 new Thread(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); msg.obj = &quot;第二条信息&quot;; mHandler.sendMessage(msg); Log.e(&quot;Test&quot;, &quot;发出 &quot; + msg.obj.toString() + &quot; 在 &quot; + Thread.currentThread().getName()); &#125; &#125;).start()； 但是最后不要忘记mHandlerThread.quit();否则将一直循环。另外可以在run方法里设置不同优先级android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);同样HandlerThread的构造方法也提供了设置优先级的功能，new HandlerThread(“LightTaskThread”, Process.THREAD_PRIORITY_BACKGROUND);AsyncTask同样设置了优先级THREAD_PRIORITY_BACKGROUND。HandlerThread的默认优先级是Process.THREAD_PRIORITY_DEFAULT,具体值为0。线程的优先级的取值范围为-20到19。优先级高的获得的CPU资源更多，反之则越少。-20代表优先级最高，19最低。0位于中间位置，但是作为工作线程的HandlerThread没有必要设置这么高的优先级，因而需要我们降低其优先级。THREAD_PRIORITY_DEFAULT，默认的线程优先级，值为0。THREAD_PRIORITY_LOWEST，最低的线程级别，值为19。THREAD_PRIORITY_BACKGROUND 后台线程建议设置这个优先级，值为10。THREAD_PRIORITY_MORE_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微优先，值为-1。THREAD_PRIORITY_LESS_FAVORABLE 相对THREAD_PRIORITY_DEFAULT稍微落后一些，值为1。 IntentService使用了HandlerThread使得IntentService可以运行耗时任务，一般使用时结合主线程Handler或者LocalBroadCastManager来通知主界面UI的更新。 ThreadPool线程池线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下：1） FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。2） CachedThreadPool 和ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。 ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class ThreadPoolTest &#123; private static final int CORE_POOL_SIZE = 5; private static final int MAX_POOL_SIZE = 10; private static final int BLOCK_POOL_SIZE = 2; private static final int ALIVE_POOL_SIZE = 2; private static ThreadPoolExecutor executor; public static void main(String args[]) &#123; executor = new ThreadPoolExecutor( CORE_POOL_SIZE,// 核心线程数 最小 MAX_POOL_SIZE,// 最大执行线程数 ALIVE_POOL_SIZE,// 空闲线程超时 TimeUnit.SECONDS,// 超时时间单位 // 当线程池达到corePoolSize时，新提交任务将被放入workQueue中， // 等待线程池中任务调度执行 new ArrayBlockingQueue&lt;Runnable&gt;(BLOCK_POOL_SIZE),// 阻塞队列大小 // 线程工厂，为线程池提供创建新线程的功能，它是一个接口， // 只有一个方法：Thread newThread(Runnable r) Executors.defaultThreadFactory(), // 线程池对拒绝任务的处理策略。一般是队列已满或者无法成功执行任务， // 这时ThreadPoolExecutor会调用handler的rejectedExecution // 方法来通知调用者 new ThreadPoolExecutor.AbortPolicy() ); executor.allowCoreThreadTimeOut(true); /* * ThreadPoolExecutor默认有四个拒绝策略： * * 1、ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException * 2、ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行 * 3、ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务 * 4、ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务 */ for (int i = 0; i &lt; 10; i++) &#123; try &#123; executor.execute(new WorkerThread(&quot;线程 --&gt; &quot; + i)); LOG(); &#125; catch (Exception e) &#123; System.out.println(&quot;AbortPolicy...&quot;); &#125; &#125; executor.shutdown(); // 所有任务执行完毕后再次打印日志 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); System.out.println(&quot;\n\n---------执行完毕---------\n&quot;); LOG(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; /** * 打印 Log 信息 */ private static void LOG() &#123; System.out.println(&quot; ==============线程池===============\n&quot; + &quot; 线程池中线程数 : &quot; + executor.getPoolSize() + &quot; 等待执行线程数 : &quot; + executor.getQueue().size() + &quot; 所有的任务数 : &quot; + executor.getTaskCount() + &quot; 执行任务的线程数 : &quot; + executor.getActiveCount() + &quot; 执行完毕的任务数 : &quot; + executor.getCompletedTaskCount() ); &#125; // 模拟线程任务 public static class WorkerThread implements Runnable &#123; private String threadName; public WorkerThread(String threadName) &#123; this.threadName = threadName; &#125; @Override public synchronized void run() &#123; int i = 0; boolean flag = true; try &#123; while (flag) &#123; i++; if (i &gt; 2) flag = false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public String getThreadName() &#123; return threadName; &#125; &#125;&#125; 请解释下在单线程模型中Message,Handler,Message Queue,Looper之间的关系。拿主线程来说，主线程启动时会调用Looper.prepare()方法，会初始化一个Looper，放入Threadlocal中，接着调用Looper.loop()不断遍历Message Queue，Handler的创建依赖与当前线程中的Looper，如果当前线程没有Looper则必须调用Looper.prepare()。Handler , sendMessage到MessageQueue，Looper不断从MessageQueue中取出消息，回调handleMessage方法。 Looper Message Queue 和 Handler， HandlerThread源码https://blog.csdn.net/lovedren/article/details/51701477https://blog.csdn.net/charles674611395/article/details/51914659 Android的进程间通信，Liunx操作系统的进程间通信binder(所有android上层几乎都是binder)/socket(zygote-systemserver)Linux机制： 管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制handler线程之间通信 asynctask的原理AsyncTask是对Thread和Handler的组合包装。https://blog.csdn.net/iispring/article/details/50670388https://blog.csdn.net/epubit17/article/details/80342004 Alarm机制Timer TimerTaskhttp://coderlin.coding.me/2016/04/02/Android-%E5%88%9D%E6%AD%A5%E4%B9%8BTimmer-AlarmManager-JobSchedule/&gt; JobSchedulerhttp://blog.csdn.net/bboyfeiyu/article/details/44809395 ELAPSED_REALTIME_WAKEUP和RTC_WAKEUP的区别AlarmManager.ELAPSED_REALTIME_WAKEUP type is used to trigger the alarm since boot time:alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, 600000, pendingIntent);will actually make the alarm go off 10 min after the device boots.There is a timer that starts running when the device boots up to measure the uptime of the device and this is the type that triggers your alarm according to the uptime of the device.Whereas, AlarmManager.RTC_WAKEUP will trigger the alarm according to the time of the clock. For example if you do:long thirtySecondsFromNow = System.currentTimeMillis() + 30 * 1000;alarmManager.set(AlarmManager.RTC_WAKEUP, thirtySecondsFromNow , pendingIntent);this, on the other hand, will trigger the alarm 30 seconds from now.AlarmManager.ELAPSED_REALTIME_WAKEUP type is rarely used compared to AlarmManager.RTC_WAKEUP 来自 http://stackoverflow.com/questions/5938213/android-alarmmanager-rtc-wakeup-vs-elapsed-realtime-wakeup handler和timer的延迟对比Handler vs Timer在我们Android开发过程中，经常需要执行一些短周期的定时任务，这时候有两个选择Timer或者Handler。然而个人认为：Handler在多个方面比Timer更为优秀，更推荐使用。一.易用性 可重复执行 • Handler可以重复执行某个任务。 • Timer若在某个任务执行/取消之后，再次执行则会抛出一个IllegalStateException异常。为了避免这个异常，需要重新创建一个Timer对象。 周期可调整若想要执行一个越来越快的定时任务，Handler可以做到，而Timer则消耗较大。 • Handlerprivate Handler handler = new Handler();int mDelayTime = 1000;private Runnable runnable = new Runnable() {public void run() { update(); if （mDelayTime &gt; 0） {handler.postDelayed(this,mDelayTime); mDelayTime -= 100; }}};handler.postDelayed(runnable,1000);如以上例子，就可以实现对周期的动态调整。 • Timer的scheduleAtFixedRate(TimerTask task, long delay, long period)只能执行固定周期的任务，所以不可以动态地调整周期。若想要动态调整，则需要在执行玩一个定时器任务后，再启动一个新的任务时设置新的时间。 UI界面更新 • Handler：在创建的时候可以指定所在的线程，一般在Activity中构建的，即主线程上，所以可以在回调方法中很方便的更新界面。 • Timer：异步回调，所以必须借助Handler去更新界面，不方便。既然都得用Handler去更新界面了，为何不如把定时的功能也交给Handler去做呢？二.内存占比Timer比Handler更占内存。接下来的Demo例子通过两种方法循环地打印日志，然后通过MAT插件来查看这两个类所需要调用的对象所产生的占比。 Async转sync的方法 异步-&gt;同步You could do this with CountdownLatch, which might be the lightest synchronization primitive in java.util.concurrent:private boolean findPrinter(final Context ctx) { final CountdownLatch latch = new CountdownLatch(1); final boolean[] result = {false};…BluetoothDiscoverer.findPrinters(ctx, new DiscoveryHandler() {…public void discoveryFinished() { result[0] = true; latch.countDown(); }public void discoveryError(String arg0) { result[0] = false; latch.countDown(); }… }// before final return // wait for 10 seconds for the response latch.await(10, TimeUnit.SECONDS);//return the result, it will return false when there is timeout return result[0];}来自 https://stackoverflow.com/questions/20659961/java-synchronous-callback Handler集中形式原理https://blog.csdn.net/reakingf/article/details/52054598Looper其中threadlocal保证一个线程只有一个Looper一个Looper一个MessageQueue不断循环获取msg，从target中取得相应得handler来进行dispatchmsg123456789101112131415161718private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125;public static void loop() &#123; for (;;) &#123; Message msg = queue.next(); // might block msg.target.dispatchMessage(msg); &#125;&#125; 处理顺序Handler.dispatchMessage123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; msg sendEmptyMessageDelayed(what, time)-&gt;sendMessageAtTimemsg.what = what postAtTime(Runnable r, long uptimeMillis)sendMessageDelayed(getPostMessage(r), 0);getPostMessage()m.callback = r enqueue msgmsg.target = 记录不同handler 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; hanlderHandler(Handler.Callback callback)]]></content>
      <categories>
        <category>21Android_review</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
        <tag>查缺补漏</tag>
        <tag>AsyncTask</tag>
        <tag>HandlerThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统安全书籍推荐]]></title>
    <url>%2Fposts%2Fandroid_security_cs_book_recommand.html</url>
    <content type="text"><![CDATA[#书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 #Linux内核ORANGE’S：一个操作系统的实现Linux内核设计与实现_第三版Linux内核设计的艺术Linux内核完全注释V3.0书签版30天自制操作系统.川合秀实 #系统安全原理篇计算机安全原理与实践黑客攻防技术宝典.系统实战篇.第二版.pdf黑客之道：漏洞发的艺术.Jon.Erickson.扫描版黑客调试技术揭密.美.Kaspersky.扫描版.pdf0day安全：软件漏洞分析技术（第2版）Shellcoder编程揭秘老码识途 从机器码到框架的系统观逆向修炼之路]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>安全</tag>
        <tag>计算机系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全白皮书]]></title>
    <url>%2Fposts%2Fandroid_security_white_paper.html</url>
    <content type="text"><![CDATA[安全安全是相对于攻击来说的，一定程序上避免了恶意攻击就可以说是安全的。那么安全级别如何得以尽可能的增强，防止99%作恶的人的攻击破解，提高安全感？ Android应用安全 Android应用安全安全要点checklisthttps://source.android.google.cn/security/overview/app-securityhttps://developer.android.com/training/articles/security-tips?hl=zh-cn#top_of_page Android安全与逆向http://www.520monkey.com/archives/category/%E5%AE%89%E5%85%A8%E5%92%8C%E9%80%86%E5%90%91/page/8 Android系统安全Linux 安全基于用户的权限模式文件系统权限安全增强型 Linux验证启动加密算法库 KeyChain/KeyStore/JCA/BC/BoringSSL/KeyMaster/TEE用户安全功能身份验证生物识别解锁TrustZone-TEEInSE芯片系统 安全产品设备证书，IFFA/FIDO签名机制病毒查杀 安全协议从我们身边常见的安全区块链口令认证Oauth手机解锁屏指纹 安全攻防Wifi破解wifi入侵服务器入侵无线攻击经典CVE漏洞收集CVE-2017-8890http://www.freebuf.com/articles/terminal/160041.html经典病毒查找，确认系统安全性发布伪造APK，获取流量或用户点击社会工程学]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安全</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统安全书籍]]></title>
    <url>%2Fposts%2Fandroid_security_system_books_recommand.html</url>
    <content type="text"><![CDATA[#书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 #Android系统安全ANDROID安全架构深究Android安全攻防权威指南Android安全攻防实战 (南非)keith makan, 崔孝晨;武晓音(译)Android安全技术揭秘与防范Android软件安全与逆向分析_带书签 Android系统基础Android的设计与实现卷1深入理解Android卷1邓凡平深入理解Android卷2_邓凡平深入理解Android卷3_邓凡平Android技术内幕.系统卷Android系统级深入开发.移植与调试Android深度探索（卷2）系统应用源代码分析与ROM定制拨云见日-基于android的内核与系统架构源码分析Android底层开发技术实战详解 内核、移植和驱动 Android源码设计模式解析与实战Android：Wi-Fi NFC和GPSAndroid系统原理及开发要点详解(韩超,梁泉)ANDROID框架揭秘(带完整书签高清扫描版) Linux内核ORANGE’S：一个操作系统的实现Linux内核设计与实现_第三版Linux内核设计的艺术Linux内核完全注释V3.0书签版30天自制操作系统.川合秀实]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍推荐</tag>
        <tag>安全</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统源码解读]]></title>
    <url>%2Fposts%2Fandroid_system_source_code_read.html</url>
    <content type="text"><![CDATA[源码解读系列http://gityuan.com/android/ binder 进程间通信方式对比 servicemanager是独立进程吗 binder是字符设备驱动，那么共享的策略是什么 contextactivityservicebroadcastamspms权限签名view绘制view事件传递binder原理view动画https://blog.csdn.net/qq_23547831/article/details/50696046]]></content>
      <categories>
        <category>10Android_System</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统</tag>
        <tag>源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见密码算法原理]]></title>
    <url>%2Fposts%2Fandroid_security_crypto_algo.html</url>
    <content type="text"><![CDATA[PBKDF2是什么？PBKDF2(Password-Based Key Derivation Function)是一个用来导出密钥的函数，用来生成加密的密码，增加破解的难度，类似bcrypt/scrypt等，可以用来进行密码或者口令的加密存储。主要是盐值+pwd，经过多轮HMAC算法的计算，产生的密文。PBKDF2函数的定义DK = PBKDF2(PRF, Password, Salt, c, dkLen)• PRF是一个伪随机函数，例如HASH_HMAC函数，它会输出长度为hLen的结果。• Password是用来生成密钥的原文密码。• Salt是一个加密用的盐值。• c是进行重复计算的次数。• dkLen是期望得到的密钥的长度。• DK是最后产生的密钥。https://segmentfault.com/a/1190000004261009 DH和ECDH算法下面我们以Alice和Bob为例叙述Diffie-Hellman密钥交换的原理。1,Diffie-Hellman交换过程中涉及到的所有参与者定义一个组，在这个组中定义一个大质数p，底数g。2,Diffie-Hellman密钥交换是一个两部分的过程，Alice和Bob都需要一个私有的数字a，b。下面是DH交换的过程图：本图片来自wiki下面我们进行一个实例1.爱丽丝与鲍伯协定使用p=23以及g=5.2.爱丽丝选择一个秘密整数a=6, 计算A = g^a mod p并发送给鲍伯。 A = 5^6 mod 23 = 8.3.鲍伯选择一个秘密整数b=15, 计算B = g^b mod p并发送给爱丽丝。 B = 5^15 mod 23 = 19.4.爱丽丝计算s = B a mod p 19^6 mod 23 = 2.5.鲍伯计算s = A b mod p 8^15 mod 23 = 2. ECDH密钥交换：ECDH: ECC算法和DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。交换双方可以在不共享任何秘密的情况下协商出一个密钥。ECC是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点P，一个整数k，求解Q=kP很容易；给定一个点P、Q，知道Q=kP，求整数k确是一个难题。ECDH即建立在此数学难题之上。密钥磋商过程：假设密钥交换双方为Alice、Bob，其有共享曲线参数（椭圆曲线E、阶N、基点G）。1) Alice生成随机整数a，计算A=aG。 #生成Alice公钥2) Bob生成随机整数b，计算B=bG。 #生产Bob公钥3) Alice将A传递给Bob。A的传递可以公开，即攻击者可以获取A。 由于椭圆曲线的离散对数问题是难题，所以攻击者不可以通过A、G计算出a。4) Bob将B传递给Alice。同理，B的传递可以公开。5) Bob收到Alice传递的A，计算Q =bA #Bob通过自己的私钥和Alice的公钥得到对称密钥Q6) Alice收到Bob传递的B，计算Q`=aB #Alice通过自己的私钥和Bob的公钥得到对称密钥Q’Alice、Bob双方即得Q=bA=b(aG)=(ba)G=(ab)G=a(bG)=aB=Q’ (交换律和结合律)，即双方得到一致的密钥Q。 目前Openssl里面的ECC算法的套件支持是ECDSA/ECDH。在国密的SSL套件中，可以使用ECDSA/ECC(密钥加密传输)，ECDSA/ECDH(密钥磋商)两种套件 来自 http://www.cnblogs.com/fishou/p/4206451.html SHA家族的对比https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F RSA算法的理解 I saw different key sizes for RSA algorithm (512, 1024,… [bits] for example) but, is this the length of public key or the length of private key or both are equal in length?It’s the length of the modulus used to compute the RSA key pair. The public key is made of the modulus and the public exponent, while the private key is made of the modulus and the private exponent.but the online tools for generating RSA key pairs have different lengths output!The first picture shows public and private key in PEM format, encoded in Base64 (and not modulus and exponents of the key, which instead are shown in the second picture).The content of the RSA private key is as follows:—–BEGIN RSA PRIVATE KEY—–RSAPrivateKey ::= SEQUENCE { version Version, modulus INTEGER, – n publicExponent INTEGER, – e privateExponent INTEGER, – d prime1 INTEGER, – p prime2 INTEGER, – q exponent1 INTEGER, – d mod (p-1) exponent2 INTEGER, – d mod (q-1) coefficient INTEGER, – (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL}—–END RSA PRIVATE KEY—–while a RSA public key contains only the following data:—–BEGIN RSA PUBLIC KEY—–RSAPublicKey ::= SEQUENCE { modulus INTEGER, – n publicExponent INTEGER – e}—–END RSA PUBLIC KEY—–and this explains why the private key block is larger.Note that a more standard format for non-RSA public keys is—–BEGIN PUBLIC KEY—–PublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier, PublicKey BIT STRING}AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL}—–END PUBLIC KEY—–More info here.BTW, since you just posted a screenshot of the private key I strongly hope it was just for tests :) 密钥的长度C:\herong&gt;java RsaKeyGenerator 128p: 17902136406704537069q: 17902136406704537077m: 320486487924256034368552058949822333168Modulus: 320486487924256034404356331763231407313Key size: 128Public key: 138184930940463531660820083778072069237Private key: 173448309040289888328993883042709949325C:\herong&gt;java RsaKeyGenerator 256p: 248658744261550238073459677814507557459q: 248658744261550238073459677814507557527m: 618311710977310434529034534762836648859088873902738200302650613…Modulus: 618311710977310434529034534762836648864062048787969205064…Key size: 256Public key: 394190853336940694532345943348534965939075733405768734…Private key: 21429568381701961014089098585280129682302896350728470… https://security.stackexchange.com/questions/90169/rsa-public-key-and-private-key-lengthshttps://stackoverflow.com/questions/2921508/trying-to-understand-java-rsa-key-size&gt; http://www.herongyang.com/Cryptography/RSA-BigInteger-Keys-Generated-by-RsaKeyGenerator-java.html update和doFinalupdate() adds data to the Cipher’s internal buffer, then returns all currently completely encoded blocks. If there are any encoded blocks left over, they remain in the Cipher’s buffer until the next call, or a call to doFinal(). This means that if you call update() with a four byte array to encrypt, and the buffer size is eight bytes, you will not receive encoded data on the return (you’ll get a null instead). If your next call to update() passes five bytes of data in, you will get an 8 byte (the block size) array back, containing the four bytes passed in on the previous call, the first four bytes from the current call – the remaining byte from the current call is left in the Cipher’s buffer.doFinal() on the other hand is much simpler: it encrypts the passed data, pads it out to the necessary length, and then returns it. The Cipher is essentially stateless. 来自 https://segmentfault.com/a/1190000006931511 DH算法的中间人攻击在最初的描述中，迪菲－赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，因此它很容易受到中间人攻击。 一个中间人在信道的中央进行两次迪菲－赫尔曼密钥交换，一次和Alice另一次和Bob，就能够成功的向Alice假装自己是Bob，反之亦然。而攻击者可以解密（读取和存储）任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。 优缺点：1、 仅当需要时才生成密钥，减小了将密钥存储很长一段时间而致使遭受攻击的机会。2、 除对全局参数的约定外，密钥交换不需要事先存在的基础结构。然而，该技术也存在许多不足：1、 没有提供双方身份的任何信息。2、 它是计算密集性的，因此容易遭受阻塞性攻击，即对手请求大量的密钥。受攻击者花费了相对多的计算资源来求解无用的幂系数而不是在做真正的工作。3、 没办法防止重演攻击。4、 容易遭受中间人的攻击。第三方C在和A通信时扮演B；和B通信时扮演A。A和B都与C协商了一个密钥，然后C就可以监听和传递通信量。中间人的攻击按如下进行：（1） B在给A的报文中发送他的公开密钥。（2） C截获并解析该报文。C将B的公开密钥保存下来并给A发送报文，该报文具有B的用户ID但使用C的公开密钥YC，仍按照好像是来自B的样子被发送出去。A收到C的报文后，将YC和B的用户ID存储在一块。类似地，C使用YC向B发送好像来自A的报文。（3） B基于私有密钥XB和YC计算秘密密钥K1。A基于私有密钥XA和YC计算秘密密钥K2。C使用私有密钥XC和YB计算K1，并使用XC和YA计算K2。（4） 从现在开始，C就可以转发A发给B的报文或转发B发给A的报文，在途中根据需要修改它们的密文。使得A和B都不知道他们在和C共享通信。]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>密码算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统]]></title>
    <url>%2Fposts%2Fandroid_system_sum.html</url>
    <content type="text"><![CDATA[Frameworkhttp://gityuan.com/android/http://weishu.me/archives/http://androidxref.com/ 深入理解常见类 四大组件 Handler/MessageQueue/Looper Binder 深入理解几个过程 系统启动系列 Android进程系列 图形系统系列 深入理解AMS、PMS、WMS几个关键的服务 系统服务篇 深入理解系统稳定性和内存工具等 系统稳定性系列 内存&amp;&amp;存储篇 工具篇 JVM/Dalvik/ART虚拟机目前从两本书入手，主要包含class/dex文件格式，内存分布，垃圾回收，类加载等方面。 深入理解JVM虚拟机 深入解析Android虚拟机 dalvik/art Linux主要从推荐的几本书入手了解，阅读源码linux 0.1，逐步深入理解每个模块。之前做过linux内核驱动，写过linux qt程序，发布过so国密算法加密库。 TrustZone-TEE参考开源的opteehttp://blog.csdn.net/shuaifengyun/article/details/73716352 InSE芯片系统芯片系统COS，之前实验室做过相关的自主研发芯片，C51 CPU集成了小型的COS系统，不支持applet。]]></content>
      <categories>
        <category>10Android_System</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android框架技术汇总]]></title>
    <url>%2Fposts%2Fandroid_app_library_tech_sumup.html</url>
    <content type="text"><![CDATA[分层架构 MVC MVVM MVPhttps://developer.android.com/topic/libraries/architecture/guide.htmlhttps://github.com/googlesamples/android-architecturehttps://github.com/googlesamples/android-architecture-components 组件化 模块化 容器化 Atlas smallhttps://yq.aliyun.com/articles/7239 依赖注入 Dagger2https://toutiao.io/posts/5a3fp5/preview AOP面向切面编程 Aspectjhttp://blog.csdn.net/xwh_1230/article/details/78213160http://blog.csdn.net/xwh_1230/article/details/78225258 事件驱动 EventBus otto EventPosterhttp://blog.csdn.net/android2me/article/details/66973037 RxJava数据异步http://blog.csdn.net/caihongdao123/article/details/51897793https://www.jianshu.com/p/5e93c9101dc5 Http Restful请求框架Retrofithttps://segmentfault.com/a/1190000005638577 框架列表https://www.ctolib.com/cheatsheets-Android-ch.html 常用的Utilhttps://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/README-CN.md Android开源项目源码解析https://github.com/android-cn/android-open-project-analysis]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>框架技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链]]></title>
    <url>%2Fposts%2Fbooks_recommand_blockchain.html</url>
    <content type="text"></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android最佳实践]]></title>
    <url>%2Fposts%2Fandroid_app_best_practise.html</url>
    <content type="text"><![CDATA[##Android版本差异https://developer.android.com/about/versions/oreo/index.html 持久化存储方式https://segmentfault.com/a/1190000008949310 缓存图片缓存https://binglumeng.github.io/2017/03/21/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98LruCache%E5%92%8CDiskLruCache%E4%BD%BF%E7%94%A8/https://www.kancloud.cn/digest/android222/138556https://www.jianshu.com/p/97455f080065 长连接https://blog.csdn.net/carson_ho/article/details/79522975 Android产品研发问题https://blog.csdn.net/qq_23547831/article/details/51645787 Android后台优化https://developer.android.com/guide/background/index.htmlhttps://developer.android.com/topic/performance/background-optimization.htmlAlarmManagerhttps://juejin.im/entry/588628e8128fe10065eb62a9Broadcasthttps://www.jianshu.com/p/f01faada90da 保持设备唤醒https://developer.android.com/training/scheduling/index.html 进程保活https://segmentfault.com/a/1190000006251859https://github.com/xingda920813/HelloDaemonhttps://blog.csdn.net/xiangzhihong8/article/details/77919053https://blog.csdn.net/AndrExpert/article/details/75045678http://www.infoq.com/cn/articles/wechat-android-background-keep-alivehttps://juejin.im/entry/58acf391ac502e007e9a0a11 Android45678区别和改进 App层https://www.zhihu.com/question/29639050https://blog.csdn.net/qq_14859923/article/details/78257904http://www.jensondev.me/2017/07/26/Android%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%8C%BA%E5%88%AB/https://blog.csdn.net/huang_rong12/article/details/51252186 进程什么时候销毁http://www.cnblogs.com/lesliefang/p/5379212.html Android优化checklisthttps://aeli.gitbooks.io/android-training-course/performance/memory.html]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能-内存泄漏]]></title>
    <url>%2Fposts%2Fandroid_app_perfermance_oom.html</url>
    <content type="text"><![CDATA[泄漏原因： 单例造成的内存泄漏 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.context = context; &#125; public static AppManager getInstance(Context context) &#123; if (instance != null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 非静态内部类(匿名类等)创建静态实例造成的内存泄漏 Handler/Thread/AsyncTas等可以使用静态内部类+弱引用避免泄漏 123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null)&#123; mResource = new TestResource(); &#125; //... &#125; class TestResource &#123; //... &#125;&#125; 资源未关闭造成的内存泄漏 对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap, 属性动画或循环动画等资源，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，从而造成内存泄漏。其中Bitmap使用不当,bitmap对象使用的内存较大，当我们不再使用Bitmap对象的时候一定要执行recycler方法，这里需要指出的是当我们在代码中执行recycler方法，Bitmap并不会被立即释放掉，其只是通知虚拟机该Bitmap可以被recycler了。 集合容器中的内存泄露我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。解决方法：在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。 静态变量持有的应用view持有context的 https://blog.csdn.net/north1989/article/details/51999920https://blog.csdn.net/u013495603/article/details/50696170https://blog.csdn.net/mxm691292118/article/details/51020023]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍推荐</tag>
        <tag>oom</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能-ANR]]></title>
    <url>%2Fposts%2Fandroid_app_perfermance_anr.html</url>
    <content type="text"><![CDATA[ANR基本分析定位方法ANR分析主要是Input、Broadcast、Service三种ANR， 对应的时间主要有以下几种：其中后台时间相对长一些，broadcast可以达到60s，但是前台一般最高10s，后台service是20s。类型 前台 后台Input 8s 8sForground Broadcast 10s 20sBackground Broadcast 10s 60sService 10s 20s 定位问题思路是，首先查看anr的进程，类型，cpu占用，iowait等指标activity、broadcast、还是service，是前台还是后台。cpu占用是否过高，iowait是否正常，是否是由于整机问题影响 查看线程调用栈，main主线程是由于什么原因导致的anr， 等锁lock，是否死锁？ 是否binder卡住了？ 是否no focus windows可能是由于进程被杀，搜索是否有window change查看界面切换的影响？wait和notifiy导致的死锁，查看相关代码？其他卡住的地方File、database、sharepreference可以怀疑文件系统等。 引起ANR问题的根本原因，总的来说可以归纳为两类： • 应用进程自身引起的，例如：主线程阻塞、挂起、死循环应用进程的其他线程的CPU占用率高，使得主线程无法抢占到CPU时间片 • 其他进程间接引起的，例如：当前应用进程进行进程间通信请求其他进程，其他进程的操作长时间没有反馈其他进程的CPU占用率高，使得当前应用进程无法抢占到CPU时间片分析ANR问题时，以上述可能的几种原因为线索，通过分析各种日志信息，大多数情况下你就可以很容易找到问题所在了。http://www.cnblogs.com/zl1991/p/5947157.html 稳定性 ANR原理分析 http://rayleeya.iteye.com/blog/1955652 稳定性问题 http://gityuan.com/2016/06/19/stability_summary/ ANR超时源码解析 http://gityuan.com/2016/07/02/android-anr/ ANR信息收集 http://gityuan.com/2016/12/02/app-not-response/ ANR input http://gityuan.com/2017/01/01/input-anr/ anr处理思路ANR原因Application Not Responding 三种类型，主线程事件长时间无法执行 KeyDispatchTimeout(input)1static final int KEY_DISPATCHING_TIMEOUT = 5*1000; BroadcastTimeout(broadcast) 12static final int BROADCAST_FG_TIMEOUT = 10*1000; static final int BROADCAST_BG_TIMEOUT = 60*1000; ServiceTimeout(service) 12static final int SERVICE_TIMEOUT = (20*1000);static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10; 查看日志 ANR存储路径 /data/anr/ dropbox存储路径 /data/system/dropbox/ tombstones存储路径 /data/tombstones Process: com.android.contacts 进程名字Flags: 0x38d8be4d 应用安装标志，预装还是安装等Package: com.android.contacts v24 (1.2) (报名和版本号)Foreground: Yes (anr在前台还是后台)Activity: com.android.contacts/com.mediatek.contacts.list.ContactListMultiChoiceActivitySubject: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: 0. Wait queue length: 1.) （ANR类型信息）Build: D-171117V33:user/release-keys CPU usage from 74494ms to 0ms ago (2019-11-09 21:32:06.966 to 2019-11-09 21:33:21.460): 104% 323/mobile_log_d: 17% user + 86% kernel / faults: 2622 minor 56% 1041/system_server: 41% user + 14% kernel / faults: 30698 minor 36 major 34% 1408/com.android.phone: 28% user + 6% kernel / faults: 17027 minor 35 major 15% 5541/android.process.acore: 13% user + 2.3% kernel / faults: 10865 minor 49 major 10% 248/servicemanager: 4.4% user + 6.5% kernel / faults: 63 minor 10% 249/surfaceflinger: 5.1% user + 5.6% kernel / faults: 1645 minor 1 major 8.6% 215/logd: 2.7% user + 5.8% kernel / faults: 310 minor 11 major 5.6% 1848/com.android.contacts: 4.4% user + 1.1% kernel / faults: 9569 minor 677 major 3.7% 1155/com.android.systemui: 2.9% user + 0.7% kernel / faults: 12145 minor 50 major98% TOTAL: 54% user + 42% kernel + 0.1% iowait + 0% softirq单进程信息读取/proc//task//stat，utime，stime两次相差/两次采样周期的系统uptime；进程差值时间56% 1041/system_server: 41% user + 14% kernel / faults: 30698 minor 36 majorcpu占用信息 进程信息: 用户态时间执行比 + kernel执行时间比 / 发生page faults的次数，一个minor，一个是major总TOTAL信息读取/proc/stat信息 http://www.linuxhowtos.org/System/procstat.htm98% TOTAL: 54% user + 42% kernel + 0.1% iowait + 0% softirquser: normal processes executing in user modenice: niced processes executing in user modesystem: processes executing in kernel modeidle: twiddling thumbsiowait: waiting for I/O to completeirq: servicing interruptssoftirq: servicing softirqs ANR分析套路http://maoao530.github.io/2017/02/21/anr-analyse/https://blog.csdn.net/sinat_34157462/article/details/78651870https://blog.csdn.net/wei_lei/article/details/70311702http://www.cnblogs.com/purediy/p/3225060.html trace日志和logcat日志要结合起来看。 trace中的ANR原因，进程号，时间，首个调用栈等信息非常关键。 logcat日志中一方面查找对应时间的日志，检查应用的行为，检查具体导致SIG:3发出的原因。 ANR in XXX也是一个关键字，可以在logcat日志中检索。不过这句日志打印的时间通常要比ANR发生的时间晚一些。找到这部分log后，应该顺着向前继续查找ANR发生的日志。 线程状态，锁，binder等。 查看main线程调用栈，确认ANR栈类型，不同栈类型问题分析方法有所差异等锁Binder对端wait栈java标准接口NativePollOnce ANR时间点确认：logcat里搜索“anr in”，或者在log_events里直接搜索anr。请注意logcat搜到的anr in时间很可能比anr时间滞后几秒。这么做是为了确认我们anr的时间范围。之前讲过了各种类型的anr时间。结合我们可以知道我们重点要关注的是什么时间段。例如后台广播在后台anr。那么我们重点关注日志范围是 （ANR时间-60秒）~ ANR时间查看kmsgcat-log。确认线程是否D状态、是否多个线程Block可以搜索卡住的线程是否被hungtask打印，hungtask发现D状态会主动触发打印 crash处理思路]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍推荐</tag>
        <tag>anr</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能分析与优化]]></title>
    <url>%2Fposts%2Fandroid_app_perfermance_oom.html</url>
    <content type="text"><![CDATA[性能指标 流畅更快 1- 稳定**更稳** ```Crash， ANR 节省更省 内存，CPU，安装包大小，存储，功耗电量，网络 https://github.com/openthos/openthos/wiki/understand-androidhttps://www.kancloud.cn/kancloud/android-performance/53238https://developer.android.com/topic/performance/index.htmlhttps://developer.android.com/studio/profile/index.html 流畅性启动速度https://developer.android.com/topic/performance/launch-time.htmlhttps://juejin.im/post/5874bff0128fe1006b443fa0 页面响应速度优化https://www.zhihu.com/question/47702122http://www.cnblogs.com/lzl-sml/p/5223704.html UI渲染显示速度提升https://blog.csdn.net/yanbober/article/details/48394201 稳定性 稳定性问题 http://gityuan.com/2016/06/19/stability_summary/ ANR分析策略 http://rayleeya.iteye.com/blog/1955652 anr google https://developer.android.com/topic/performance/vitals/anr.html#fix_the_problems ANR超时源码解析 http://gityuan.com/2016/07/02/android-anr/ ANR信息收集 http://gityuan.com/2016/12/02/app-not-response/ ANR input http://gityuan.com/2017/01/01/input-anr/ app crash http://gityuan.com/2016/06/24/app-crash/ native crash http://gityu an.com/2016/06/25/android-native-crash/ 稳定性分析及工具 Android Profile 工具集 https://developer.android.com/studio/profile/index.html Device Monitor工具集 https://developer.android.com/studio/profile/monitor.html#usage 性能优化 http://rayleeya.iteye.com/blog/1961005 traceviewhttp://gityuan.com/2017/07/11/android_debug/https://bxbxbai.github.io/2014/10/25/use-trace-view/https://developer.android.com/studio/profile/traceview.html#overviewhttps://blog.csdn.net/innost/article/details/9008691https://blog.csdn.net/u011240877/article/details/54347396#2%E4%BD%BF%E7%94%A8-android-studio-%E7%94%9F%E6%88%90-trace-%E6%96%87%E4%BB%B6 systracehttp://gityuan.com/2016/01/17/systrace/https://developer.android.com/studio/command-line/systrace.html dumpsyshttp://gityuan.com/2015/08/22/tool-dumpsys/https://developer.android.com/studio/command-line/dumpsys.html dmtracedumphttps://developer.android.com/studio/command-line/dmtracedump.html Android Device Monitor Android Device Monitor is a standalone tool that provides a UI for several Android app debugging and analysis tools.However, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher. The table below helps you decide which developer tools you should use. Android Device Monitor component What you should use Dalvik Debug Monitor Server (DDMS)This tool is deprecated. Instead, use Android Profiler in Android Studio 3.0 and higher to profile your app’s CPU, memory, and network usage.If you want to perform other debugging tasks, such as sending commands to a connected device to set up port-forwarding, transfer files, or take screenshots, then use the Android Debug Bridge (adb), Android Emulator, Device File Explorer, or Debugger window. TraceviewIf you want to inspect existing .trace files, or ones you’ve captured by instrumenting your app with the Debug class, keep using Traceview.If you want to record new method traces and inspect realtime CPU usage of your app’s processes, use Android Studio’s CPU profiler. SystraceIf you need to inspect native system processes and address UI jank caused by dropped frames, use systrace from the command line.Otherwise, use Android Studio’s CPU profiler to profile your app’s processes. Tracer for OpenGL ES Use the Graphics API Debugger. Hierarchy ViewerIf you want to inspect your app’s view hierarchy at runtime, use Layout Inspector. If you want to profile the rendering speed of your app’s layout, use Window.OnFrameMetricsAvailableListener as described in this blog post. Pixel Perfect Use Layout Inspector. ANR分析套路http://maoao530.github.io/2017/02/21/anr-analyse/https://blog.csdn.net/sinat_34157462/article/details/78651870https://blog.csdn.net/wei_lei/article/details/70311702http://www.cnblogs.com/purediy/p/3225060.html crash - 内存泄露OutOfMemoryErrorhttps://www.jianshu.com/u/b8dad3885e05http://rayleeya.iteye.com/blog/1956059http://www.voidcn.com/article/p-txoxuyet-bqt.htmlhttps://juejin.im/entry/59f7ea06f265da43143ffee4http://blog.csdn.net/qyf2010qyf/article/details/52852000 ##节省性 减少apk安装包大小https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure避免使用枚举https://zhuanlan.zhihu.com/p/25865835http://www.10tiao.com/html/330/201704/2653578978/2.htmlhttps://blog.csdn.net/hp910315/article/details/48975655https://blog.csdn.net/my_truelove/article/details/70519234 减少过渡后台，android后台优化https://developer.android.com/training/best-background.html 减少view绘制过度https://blog.csdn.net/qq_19711823/article/details/65627790https://www.jianshu.com/p/2cc6d5842986https://blog.csdn.net/yanbober/article/details/48394201https://yq.aliyun.com/articles/82572 减少流量消耗https://developer.android.com/topic/performance/vitals/bg-network-usage.html#detect_the_problemhttps://developer.android.com/training/basics/network-ops/data-saver.html#monitor-changes 减少电量消耗https://developer.android.com/topic/performance/power/index.html 减少内存占用https://developer.android.com/topic/performance/memory.html#codehttps://developer.android.com/topic/performance/memory-overview.html 性能优化的建议https://blog.csdn.net/carson_ho/article/details/79708444https://juejin.im/post/5a0d30e151882546d71ee49ehttps://www.ctolib.com/docs/sfile/notes-master/Android-Java/AndroidPerformancePatterns.htmlhttps://github.com/Piasy/notes/blob/master/Android-Java/AndroidPerformancePatterns.mdhttps://www.jianshu.com/u/fdb392adfbedhttps://segmentfault.com/a/1190000012413613https://zhuanlan.zhihu.com/p/26364608 Android优化checklist]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍推荐</tag>
        <tag>内存泄漏</tag>
        <tag>性能分析</tag>
        <tag>性能指标</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssl证书校验机制]]></title>
    <url>%2Fposts%2Fandroid_security_ssl_verify.html</url>
    <content type="text"><![CDATA[2.3 SSL证书校验机制 Https2.3.1 简单解释典型的场景是现在我们常用的 HTTPS 机制。HTTPS 实际上是利用了 Transport LayerSecurity/Secure Socket Layer（TLS/SSL）来实现可靠的传输。TLS 为 SSL 的升级版本，目前广泛应用的为 TLS 1.0，对应到 SSL 3.1 版本。建立安全连接的具体步骤如下：• 客户端浏览器发送信息到服务器，包括随机数 R1，支持的加密算法类型、协议版本、压缩算法等。注意该过程为明文。• 服务端返回信息，包括随机数 R2、选定加密算法类型、协议版本，以及服务器证书。注意该过程为明文。• 浏览器检查带有该网站公钥的证书。该证书需要由第三方CA 来签发，浏览器和操作系统会预置权威CA 的根证书。如果证书被篡改作假（中间人攻击），很容易通过 CA 的证书验证出来。• 如果证书没问题，则用证书中公钥加密随机数 R3，发送给服务器。此时，只有客户端和服务器都拥有 R1、R2 和 R3 信息，基于 R1、R2 和 R3，生成对称的会话密钥（如 AES算法）。后续通信都通过对称加密进行保护。 https://www.cnblogs.com/Anker/p/6082966.html2.3.2 SSL具体协议分析协议具体内容解释如下： client_hello（1）支持的协议版本，比如TLS 1.0（2）支持的加密算法(Cipher Specs)（3）客户端生成的随机数1(Challenge)，稍后用于生成”对话密钥”。 server_hello（1） 确认使用的协议版本（2） 服务器生成的随机数2，稍后用于生成”对话密钥”（3） session id（4） 确认使用的加密算法Certificate 服务器证书server_key_exchange如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步。certificate_request 要求客户端提供证书，包括（1）客户端可以提供的证书类型（2）服务器接受的证书distinguished name列表，可以是root CA或者subordinate CA。如果服务器配置了trust keystore, 这里会列出所有在trust keystore中的证书的distinguished name。server_hello_doneserver hello结束 certificate客户端证书client_key_exchange包含premaster secret。客户端生成第三个随机数。如果是采用RSA算法，会生成一个48字节随机数，然后用server的公钥加密之后再放入报文中；如果是DH算法，这里发送的就是客户端的DH参数，之后服务器和客户端根据DH算法，各自计算出相同的premaster secret。certificate_verify发送使用客户端证书给到这一步为止收到和发送的所有握手消息签名结果。change_cipher_spec客户端通知服务器开始使用加密方式发送报文。客户端使用上面的3个随机数client random, server random, premaster secret, 计算出48字节的master secret, 这个就是对称加密算法的密钥。finished客户端发送第一个加密报文。使用HMAC算法计算收到和发送的所有握手消息的摘要，然后通过RFC5246中定义的一个伪函数PRF计算出结果，加密后发送。 4.服务器发送给客户端服务器端发送change_cipher_spec和finished消息。到这里握手结束。 双向认证协议抓包数据如下： 2.3.3 基本校验机制 2.3.4 参考wireshark抓包分析和中间人攻击应用[具体协议wireshark原理] http://blog.csdn.net/fw0124/article/details/40983787[中间人攻击-看证书重要性(Man-in-the-middle attack)] http://www.freebuf.com/sectool/48016.html http://www.freebuf.com/sectool/48016.htmlhttps://g2ex.github.io/2015/05/18/Man-in-the-Middle-Attack/http://sec.chinabyte.com/221/13821221.shtmlhttps://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/58.html 3.2 SSL/HttpsUrlConnection流程与证书校验3.2.1 一个完整的应用 // Load CAs from an InputStream// (could be from a resource or ByteArrayInputStream or …)CertificateFactory cf = CertificateFactory.getInstance(“X.509”);// From https://www.washington.edu/itconnect/security/ca/load-der.crtInputStream caInput = new BufferedInputStream(new FileInputStream(“load-der.crt”));Certificate ca;try { ca = cf.generateCertificate(caInput); System.out.println(“ca=” + ((X509Certificate) ca).getSubjectDN());} finally { caInput.close();} // Create a KeyStore containing our trusted CAsString keyStoreType = KeyStore.getDefaultType();KeyStore keyStore = KeyStore.getInstance(keyStoreType);keyStore.load(null, null);keyStore.setCertificateEntry(“ca”, ca); // Create a TrustManager that trusts the CAs in our KeyStoreString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);tmf.init(keyStore); // Create an SSLContext that uses our TrustManagerSSLContext context = SSLContext.getInstance(“TLS”);context.init(null, tmf.getTrustManagers(), null); // Tell the URLConnection to use a SocketFactory from our SSLContextURL url = new URL(“https://certs.cac.washington.edu/CAtest/&quot;);HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setSSLSocketFactory(context.getSocketFactory());InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 3.2.2 JSSE相关类简要说明 SSL/TLS的Java实现—JSSE请参考： http://blog.csdn.net/fw0124/article/details/40889167http://www.aneasystone.com/archives/2016/04/java-and-https.html写的太好抄一遍来使用SSL/TLS协议通信，客户端和服务器端都可能要设置用于证实自己身份的安全证书，并且还要设置信任对方的哪些安全证书。按照理论上，一共需要准备四个文件，两个keystore文件和两个truststore文件。通信双方分别拥有一个keystore和一个truststore，keystore用于存放自己的密钥和公钥，truststore用于存放所有需要信任方的公钥。当然为了方便可以直接使用keystore替代truststore（免去证书导来导去），因为对方的keystore包含了自己需要的信任公钥。在用JSSE实现SSL通信过程中主要会遇到以下类和接口，由于过程中涉及到加解密、密钥生成等运算的框架和实现，所以也会间接用到JCE包的一些类。如图为JSSE接口的主要类图： ① 通信核心类——SSLSocket和SSLServerSocket。对于使用过socket进行通信开发的朋友比较好理解，它们对应的就是Socket与ServerSocket，只是表示实现了SSL协议的Socket和ServerSocket，同时它们也是Socket与ServerSocket的子类。SSLSocket负责的事情包括设置加密套件、管理SSL会话、处理握手结束时间、设置客户端模式或服务器模式。② 客户端与服务器端Socket工厂——SSLSocketFactory和SSLServerSocketFactory。在设计模式中工厂模式是专门用于生产出需要的实例，这里也是把SSLSocket、SSLServerSocket对象创建的工作交给这两个工厂类。③ SSL会话——SSLSession。安全通信握手过程需要一个会话，为了提高通信的效率，SSL协议允许多个SSLSocket共享同一个SSL会话，在同一个会话中，只有第一个打开的SSLSocket需要进行SSL握手，负责生成密钥及交换密钥，其余SSLSocket都共享密钥信息。④ SSL上下文——SSLContext。它是对整个SSL/TLS协议的封装，表示了安全套接字协议的实现。主要负责设置安全通信过程中的各种信息，例如跟证书相关的信息。并且负责构建SSLSocketFactory、SSLServerSocketFactory和SSLEngine等工厂类。⑤ SSL非阻塞引擎——SSLEngine。假如你要进行NIO通信，那么将使用这个类，它让通过过程支持非阻塞的安全通信。⑥ 密钥管理器——KeyManager。此接口负责选择用于证实自己身份的安全证书，发给通信另一方。KeyManager对象由KeyManagerFactory工厂类生成。⑦ 信任管理器——TrustManager。此接口负责判断决定是否信任对方的安全证书，TrustManager对象由TrustManagerFactory工厂类生成。 SSL握手简单https协议利用SSL协议验证通信双方（客户端、服务器端）的身份、协商加密算法与密钥。Android中HttpsConnection类实现了https协议。SSLSocket相关类实现了SSL协议。HttpsConnection只需通过SocketFactory以及Socket提供的抽象接口就可以启动SSL握手过程。主要由SSLSocket、OpenSSLSocketImpl、SSLParameters、SSLSession、OpenSSLSocketFactoryImpl、OpenSSLSessionImpl、SSLSessionContext实现SSL协议。HttpsConnection使用系统提供的默认工厂SSLSocketFactoryImpl创建OpenSSLSocketImpl。OpenSSLSocketImpl通过JNI调用openSSL库提供的api进行握手。注意握手信息是在SocketImpl对象上传输的。SSLSession类封装了SSL会话信息，它存储了SSL握手的结果。最后SSLSessionContext相当与SSLSession的缓存池。这些类之间的关系如下图所示：图3 SSLSocket类图 类之间的调用顺序如下： 图4 SSLSocket 时序图3.2.3 Android HttpsUrlConnection流程图解主要流程如下： URL. openConnection-&gt; streamHandler.openConnection -&gt; setupStreamHandler-&gt; HttpsHandler -&gt; OkHttpClient open -&gt; HttpsURLConnectionImpl-&gt; DelegatingHttpsURLConnection TrustManagerFactory (TrustManagerFactoryImpl engineGetTrustManagers) -&gt; init (AndroidCAStore default) -&gt; getTrustManagers -&gt; TrustManagerImpl TrustManagerImpl checkTrustedTrustManagerImpl checkTrustedRecursiveTrustManagerImplTest testLearnIntermediate TrustManagerImpl findAllTrustAnchorsByIssuerAndSignatureTrustManagerImpl findAllIssuers TrustedCertificateStore findCertTrustedCertificateStore hash NativeCrypto.X509_NAME_hash_old SSLContext init (null, tmf.getTrustManagers(), null);getInstance -&gt; SSLContextSpi -&gt; OpenSSLContextImpl -&gt; DefaultSSLContextImpl-&gt; OpenSSLSocketFactoryImpl -&gt; OpenSSLSocketImpl verifyCertificateChain-&gt; SSLParametersImpl setCertificateValidation-&gt; Platform -&gt; TrustManagerImpl 接上 这里需要额外说明的是：在执行nativeconnect函数时，已经在openSSL库中执行了握手过程。但openSSL库中不会进行任何验证，因为验证模式被设置为SSL_VERIFY_NONE。因此，Android中身份验证是由checkServerTrusted函数实现的。其中TrustManagerImpl checkTrusted是验证的主要流程checkServerTrusted –&gt; checkTrusted -&gt; checkTrustedRecursive If the current certificate in the chain is self-signed verify the chain as is. Try building a chain via any trust anchors that issued the current certificate. If we were unable to find additional trusted issuers, verify the current chain. Use the certificates provided by the peer to grow the chain. Finally try the cached intermediates to handle server that failed to send them. We were unable to build a valid chain, throw the last error encountered. If no errors were encountered above then verifyChain was never called because it was Android系统使用openSSL库来交换证书、协商加密算法，但认证服务器段身份并非由openSSL库完成。Android系统将自己的证书、私钥存储在密钥仓库中。.在进行openSSL握手之前，将私钥以及证书放入SSL_CTX变量中。握手结束后，Android系统从SSLSession中取出服务器的证书，利用可信密钥仓库来检验该证书是否可信。相关类以及类之间的关系如下图所示：图 5 cetificate 类图 3.2.4 证书校验证书校验算法简单说明如下：参考《公钥基础设施(pki)_实现和管理电子安全.pdf》一书证书验证过程主要包含：证书路径生成和证书路径验证两个步骤，其中具体的验证流程参考代码，还有一些很复杂的交叉证书验证的流程，请参考PKI相关的书籍。https://en.wikipedia.org/wiki/X.509https://en.wikipedia.org/wiki/Certification_path_validation_algorithmhttp://www.oasis-pki.org/pdfs/Understanding_Path_construction-DS2.pdfhttps://www.ietf.org/rfc/rfc5280.txthttp://itmyhome.com/java-api/java/security/cert/CertPathBuilder.htmlhttp://www.beansoft.biz/weblogic/docs92/security/certpath.htmlhttps://www.entrust.com/wp-content/uploads/2013/05/pathvalidation_wp.pdf3.2.5 SSL证书使用的建议参考Wiki案例：Android HttpsSSL证书安全与预制浅析.doc 中间证书如果安全套接字层 (SSL) 证书是在本地生成，那么必须从认证中心 (CA) 获取根 (root.cer) 证书以及任何中间 (intermediate.cer) 证书，然后将这些证书添加到 HTTP Server 密钥库。安装根证书和中间证书会创建信任链，从而使客户机和服务器之间的 SSL 握手能够正常工作。 中间证书有两种方式验证：• 原理上浏览器预置或缓存这种方法也存在• 客户端自动解析下载(大多数客户端并不支持解析下载，会直接返回错误)• 配置服务器直接把中间证书传给客户端 (一般采用这种方式，配置服务器即可)服务器配置方式参考： https://whatsmychaincert.com/如Apache配置方式：SSLEngine onSSLCertificateKeyFile /path/to/example.com.keySSLCertificateFile /path/to/example.com.crtSSLCertificateChainFile /path/to/example.com.chain.crt 参考：https://www.myssl.cn/tools/downloadchain.htmlhttps://www.myssl.cn/home/article42.htmlhttp://professor.blog.51cto.com/996189/1596985]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>证书</tag>
        <tag>ssl</tag>
        <tag>verify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKCS标准解析]]></title>
    <url>%2Fposts%2Fandroid_security_pkcs_standard.html</url>
    <content type="text"><![CDATA[PKCS标准 Public-Key Cryptography StandardsRSA主导标准，RSA信息安全公司旗下的RSA实验室为了发扬公开密钥技术的使用，1990年开始便发展了一系列的公开密钥密码编译标准。只不过，虽然该标准具有相当大的象征性，也被信息界的产业所认同；但是，若RSA公司认为有必要，这些标准的内容仍然可能会更动。所幸，这些变动并不大；此外，这几年RSA公司也与其他组织（比较知名的有IETF、PKIX）将标准的制定通过standards track程序来达成。 1) PKCS#1：RSA加密标准。PKCS#1定义了RSA公钥函数的基本格式标准，特别是数字签名。它定义了数字签名如何计算，包括待签名数据和签名本身的格式；它也定义了PSA公/私钥的语法2) PKCS#2：涉及了RSA的消息摘要加密，这已被并入PKCS#1中。3) PKCS#3：Diffie-Hellman密钥协议标准。PKCS#3描述了一种实现Diffie- Hellman密钥协议的方法。4) PKCS#4：最初是规定RSA密钥语法的，现已经被包含进PKCS#1中。5) PKCS#5：基于口令的加密标准。PKCS#5描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。PKCS#5可以用于加密私钥，以便于密钥的安全传输（这在PKCS#8中描述）。6) PKCS#6：扩展证书语法标准。PKCS#6定义了提供附加实体信息的X.509证书属性扩展的语法（当PKCS#6第一次发布时，X.509还不支持扩展。这些扩展因此被包括在X.509中）。7) PKCS#7：密码消息语法标准。PKCS#7为使用密码算法的数据规定了通用语法，比如数字签名和数字信封。PKCS#7提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。8) PKCS#8：私钥信息语法标准。PKCS#8定义了私钥信息语法和加密私钥语法，其中私钥加密使用了PKCS#5标准。9) PKCS#9：可选属性类型。PKCS#9定义了PKCS#6扩展证书、PKCS#7数字签名消息、PKCS#8私钥信息和PKCS#10证书签名请求中要用到的可选属性类型。已定义的证书属性包括E-mail地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（counter signature）、质询口令字和扩展证书属性。10) PKCS#10：证书请求语法标准。PKCS#10定义了证书请求的语法。证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名（证书管理协议中的PKIX证书请求消息就是一个PKCS#10）。11) PKCS#11：密码令牌接口标准。PKCS#11或“Cryptoki”为拥有密码信息（如加密密钥和证书）和执行密码学函数的单用户设备定义了一个应用程序接口（API）。智能卡就是实现Cryptoki的典型设备。注意：Cryptoki定义了密码函数接口，但并未指明设备具体如何实现这些函数。而且Cryptoki只说明了密码接口，并未定义对设备来说可能有用的其他接口，如访问设备的文件系统接口。12) PKCS#12：个人信息交换语法标准。PKCS#12定义了个人身份信息（包括私钥、证书、各种秘密和扩展字段）的格式。PKCS#12有助于传输证书及对应的私钥，于是用户可以在不同设备间移动他们的个人身份信息。13) PDCS#13：椭圆曲线密码标准。PKCS#13标准当前正在完善之中。它包括椭圆曲线参数的生成和验证、密钥生成和验证、数字签名和公钥加密，还有密钥协定，以及参数、密钥和方案标识的ASN.1语法。14) PKCS#14：伪随机数产生标准。PKCS#14标准当前正在完善之中。为什么随机数生成也需要建立自己的标准呢？PKI中用到的许多基本的密码学函数，如密钥生成和Diffie-Hellman共享密钥协商，都需要使用随机数。然而，如果“随机数”不是随机的，而是取自一个可预测的取值集合，那么密码学函数就不再是绝对安全了，因为它的取值被限于一个缩小了的值域中。因此，安全伪随机数的生成对于PKI的安全极为关键。15) PKCS#15：密码令牌信息语法标准。PKCS#15通过定义令牌上存储的密码对象的通用格式来增进密码令牌的互操作性。在实现PKCS#15的设备上存储的数据对于使用该设备的所有应用程序来说都是一样的，尽管实际上在内部实现时可能所用的格式不同。PKCS#15的实现扮演了翻译家的角色，它在卡的内部格式与应用程序支持的数据格式间进行转换。 PKCS #1RSA Cryptography Standard[1]See RFC 3447. Defines the mathematical properties and format of RSA public and private keys (ASN.1-encoded in clear-text), and the basic algorithms and encoding/padding schemes for performing RSA encryption, decryption, and producing and verifying signatures. PKCS #2 - Withdrawn No longer active as of 2010. Covered RSA encryption of message digests; subsequently merged into PKCS #1. PKCS #3 1.4 Diffie–Hellman Key Agreement Standard[2]A cryptographic protocol that allows two parties that have no prior knowledge of each other to jointly establish a shared secret key over an insecure communications channel. PKCS #4 - Withdrawn No longer active as of 2010. Covered RSA key syntax; subsequently merged into PKCS #1.PKCS #5 2.0 Password-based Encryption Standard[3]See RFC 2898 and PBKDF2. PKCS #6 1.5 Extended-Certificate Syntax Standard[4]Defines extensions to the old v1 X.509 certificate specification. Obsoleted by v3 of the same. PKCS #7 1.5 Cryptographic Message Syntax Standard[5]See RFC 2315. Used to sign and/or encrypt messages under a PKI. Used also for certificate dissemination (for instance as a response to a PKCS #10 message). Formed the basis for S/MIME, which is as of 2010 based on RFC 5652, an updated Cryptographic Message Syntax Standard (CMS). Often used for single sign-on. PKCS #81.2 Private-Key Information Syntax Standard[6]See RFC 5958. Used to carry private certificate keypairs (encrypted or unencrypted).PKCS #9 2.0 Selected Attribute Types[7]See RFC 2985. Defines selected attribute types for use in PKCS #6 extended certificates, PKCS #7 digitally signed messages, PKCS #8 private-key information, and PKCS #10 certificate-signing requests.PKCS #10 1.7 Certification Request Standard[8]See RFC 2986. Format of messages sent to a certification authority to request certification of a public key. See certificate signing request. PKCS #112.40 Cryptographic Token Interface[9]Also known as “Cryptoki”. An API defining a generic interface to cryptographic tokens (see also hardware security module). Often used in single sign-on, public-key cryptography and disk encryption[10] systems. RSA Security has turned over further development of the PKCS #11 standard to the OASIS PKCS 11 Technical Committee. PKCS #121.1 Personal Information Exchange Syntax Standard[11]See RFC 7292. Defines a file format commonly used to store private keys with accompanying public key certificates, protected with a password-based symmetric key. PFX is a predecessor to PKCS #12.This container format can contain multiple embedded objects, such as multiple certificates. Usually protected/encrypted with a password. Usable as a format for the Java key store and to establish client authentication certificates in Mozilla Firefox. Usable by Apache Tomcat. PKCS #13 – Elliptic Curve Cryptography Standard(Apparently abandoned, only reference is a proposal from 1998.)[12] PKCS #14 – Pseudo-random Number Generation(Apparently abandoned, no documents exist.) PKCS #15 1.1 Cryptographic Token Information Format Standard[13]Defines a standard allowing users of cryptographic tokens to identify themselves to applications, independent of the application’s Cryptoki implementation (PKCS #11) or other API. RSA has relinquished IC-card-related parts of this standard to ISO/IEC 7816-15.[14] 参考：https://apj.emc.com/emc-plus/rsa-labs/standards-initiatives/public-key-cryptography-standards.htmhttps://en.wikipedia.org/wiki/PKCShttps://zh.wikipedia.org/wiki/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A0%87%E5%87%86]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>PKCS标准解析</tag>
        <tag>pkcs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中间件-插件化和热补丁等]]></title>
    <url>%2Fposts%2Fandroid_app_plugin_hotfix.html</url>
    <content type="text"><![CDATA[应用在Google市场上架之前会经过安全扫描，包含病毒的应用无法上架。目前安卓应用可以通过下载并动态加载dex/jar/elf/的方式，进行升级，以达到以下目的：问题修复，版本升级等。这都是热补丁的正常使用方式。除此之外，个别恶意应用利用热补丁技术，故意使上架检测版本和实际运行版本不一致，恶意绕过上架检测机制。 提供的动态加载接口有Dexclassloader、Desfile.loadDex、System.load、System.loadlibrary，它们底层在虚拟机的实现接口是openDexFileNative和JVM_NativeLoad，分别用于加载dex/jar和so格式的文件，应用通过调用这些接口实现动态加载。 那么热补丁插件的实现方式大概有以下几种： ##Android中间件 ###插件化http://weishu.me/2016/01/28/understand-plugin-framework-overview/https://github.com/wangwangheng/BestBlogReprinted_AndroidNotes/tree/master/%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91/weishu%E7%B3%BB%E5%88%97http://blog.csdn.net/ganyao939543405/article/details/76146760https://cloud.tencent.com/developer/article/1038868http://www.10tiao.com/html/227/201703/2650239063/1.htmlhttps://github.com/tiann/understand-plugin-frameworkhttp://www.10tiao.com/html/227/201703/2650239063/1.htmlhttps://github.com/prife/VirtualAppDoc ###热修复http://www.androidchina.net/6213.htmlhttps://github.com/Tencent/tinker/wikihttps://www.cnblogs.com/popfisher/p/8543973.html深入探索Android热修复技术原理 by 阿里 pdfAndFix原理 https://blog.csdn.net/jiangwei0910410003/article/details/53099390 ###Hook框架http://www.snowdream.tech/2016/09/02/android-install-xposed-framework/https://jaq.alibaba.com/community/art/show?articleid=809 ##VirtualXposed 和epichttps://github.com/android-hacker/VirtualXposedhttps://github.com/tiann/epichttp://weishu.me/2017/12/02/non-root-xposed/ classLoader的问题https://blog.csdn.net/xiangzhihong8/article/details/52880327http://weishu.me/2016/04/05/understand-plugin-framework-classloader/ 插件的原理https://github.com/wangwangheng/BestBlogReprinted_AndroidNotes/blob/master/%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91/weishu%E7%B3%BB%E5%88%97/1.Android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E6%A6%82%E8%A6%81.md首先要明白静态代理/动态代理/hook原理机制，静态代理在程序运行前，代理类的.class文件就已经存在了。动态代理类：在程序运行时，运用JDK本身反射机制动态创建而成，如果复杂可能要用cglib；创建出来的对象都集成的相同的接口。动态代理主要设计以下几个方法123456789101112131415161718192021Shopping women = new ShoppingImpl();// 正常购物System.out.println(Arrays.toString(women.doShopping(100)));// 招代理women = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(), women.getClass().getInterfaces(), new ShoppingHandler(women));System.out.println(Arrays.toString(women.doShopping(100)));public class ShoppingHandler implements InvocationHandler &#123; Object base; public ShoppingHandler(Object base) &#123; this.base = base; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (&quot;doShopping&quot;.equals(method.getName())) &#123; System.out.println(String.format(&quot;花了%s块钱&quot;, readCost)); Object[] things = (Object[]) method.invoke(base, readCost); &#125; else if &#123;&#125; &#125;&#125; 但是hook相当于直接改变已有类的静态成员或者单例，hook常用发射的方法，来替换成员达到修改相关类的效果。如下方法：12345678910111213141516171819public static void attachContext() throws Exception&#123; // 先获取到当前的ActivityThread对象 Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;); currentActivityThreadMethod.setAccessible(true); //currentActivityThread是一个static函数所以可以直接invoke，不需要带实例参数 Object currentActivityThread = currentActivityThreadMethod.invoke(null); // 拿到原始的 mInstrumentation字段 Field mInstrumentationField = activityThreadClass.getDeclaredField(&quot;mInstrumentation&quot;); mInstrumentationField.setAccessible(true); Instrumentation mInstrumentation = (Instrumentation) mInstrumentationField.get(currentActivityThread); // 创建代理对象 Instrumentation evilInstrumentation = new EvilInstrumentation(mInstrumentation); // 偷梁换柱 mInstrumentationField.set(currentActivityThread, evilInstrumentation);&#125; binder的hook，可以通过ServiceManager修改掉相关的其中的sCache这个变量即可，然后填相关service。12345678910111213141516171819202122final String CLIPBOARD_SERVICE = &quot;clipboard&quot;;// 下面这一段的意思实际就是: ServiceManager.getService(&quot;clipboard&quot;);// 只不过 ServiceManager这个类是@hide的Class&lt;?&gt; serviceManager = Class.forName(&quot;android.os.ServiceManager&quot;);Method getService = serviceManager.getDeclaredMethod(&quot;getService&quot;, String.class);// ServiceManager里面管理的原始的Clipboard Binder对象// 一般来说这是一个Binder代理对象IBinder rawBinder = (IBinder) getService.invoke(null, CLIPBOARD_SERVICE);// Hook 掉这个Binder代理对象的 queryLocalInterface 方法// 然后在 queryLocalInterface 返回一个IInterface对象, hook掉我们感兴趣的方法即可.IBinder hookedBinder = (IBinder) Proxy.newProxyInstance(serviceManager.getClassLoader(), new Class&lt;?&gt;[] &#123; IBinder.class &#125;, new BinderProxyHookHandler(rawBinder));// 把这个hook过的Binder代理对象放进ServiceManager的cache里面// 以后查询的时候 会优先查询缓存里面的Binder, 这样就会使用被我们修改过的Binder了Field cacheField = serviceManager.getDeclaredField(&quot;sCache&quot;);cacheField.setAccessible(true);Map&lt;String, IBinder&gt; cache = (Map) cacheField.get(null);cache.put(CLIPBOARD_SERVICE, hookedBinder); binder的ams hook也是通过类似的方法，替换掉了ActivityManagerNative的gDefault变量来替换。1234567891011121314151617181920212223Class&lt;?&gt; activityManagerNativeClass = Class.forName(&quot;android.app.ActivityManagerNative&quot;);// 获取 gDefault 这个字段, 想办法替换它Field gDefaultField = activityManagerNativeClass.getDeclaredField(&quot;gDefault&quot;);gDefaultField.setAccessible(true);Object gDefault = gDefaultField.get(null);// 4.x以上的gDefault是一个 android.util.Singleton对象; 我们取出这个单例里面的字段Class&lt;?&gt; singleton = Class.forName(&quot;android.util.Singleton&quot;);Field mInstanceField = singleton.getDeclaredField(&quot;mInstance&quot;);mInstanceField.setAccessible(true);// ActivityManagerNative 的gDefault对象里面原始的 IActivityManager对象Object rawIActivityManager = mInstanceField.get(gDefault);// 创建一个这个对象的代理对象, 然后替换这个字段, 让我们的代理对象帮忙干活Class&lt;?&gt; iActivityManagerInterface = Class.forName(&quot;android.app.IActivityManager&quot;);Object proxy = Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class&lt;?&gt;[] &#123; iActivityManagerInterface &#125;, new IActivityManagerHandler(rawIActivityManager)); mInstanceField.set(gDefault, proxy); 热修复和冷修复的原理动态加载某一个dex或者jar包，替换有问题的类或者方法或者变量，以达到热修复的功能。热修复行不通的情况下，那么就要等待重新启动，冷启动修复对应的dex的方法或类。那么如何替换呢？目前有两种方式，参考sophix，热修复第一种方法是底层替换原理，直接替换调ARTMethod结构体，需要适配每一个版本，比较复杂。另外一种是类加载冷启动的多dex全量替换方式，替换dexElements这个dex文件的list使得虚拟机能优先加载修复过的类，从而达到修复效果。 There are three injection points for a given method: before, after, replace.123456789101112131415161718192021222324252627282930313233343536Example 1: Attach a piece of code before and after all occurrences of Activity.onCreate(Bundle). // Target class, method with parameter types, followed by the hook callback (XC_MethodHook). DexposedBridge.findAndHookMethod(Activity.class, &quot;onCreate&quot;, Bundle.class, new XC_MethodHook() &#123; // To be invoked before Activity.onCreate(). @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; // &quot;thisObject&quot; keeps the reference to the instance of target class. Activity instance = (Activity) param.thisObject; // The array args include all the parameters. Bundle bundle = (Bundle) param.args[0]; Intent intent = new Intent(); // XposedHelpers provide useful utility methods. XposedHelpers.setObjectField(param.thisObject, &quot;mIntent&quot;, intent); // Calling setResult() will bypass the original method body use the result as method return value directly. if (bundle.containsKey(&quot;return&quot;)) param.setResult(null); &#125; // To be invoked after Activity.onCreate() @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; XposedHelpers.callMethod(param.thisObject, &quot;sampleMethod&quot;, 2); &#125; &#125;);Example 2: Replace the original body of the target method. DexposedBridge.findAndHookMethod(Activity.class, &quot;onCreate&quot;, Bundle.class, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable &#123; // Re-writing the method logic outside the original method context is a bit tricky but still viable. ... &#125; &#125;);]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍推荐</tag>
        <tag>Plugin</tag>
        <tag>hotfix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NetworkSecurityConfig证书配置]]></title>
    <url>%2Fposts%2Fandroid_security_NetworkSecurityConfig_settings.html</url>
    <content type="text"><![CDATA[SecurityConfig证书配置 NetworkSecurityConfig SecurityConfig此API是24版本的新特性，面向之前的版本并不适用，请适用自验证方式进行自定义验证 添加application安全配置文件&lt;application android:networkSecurityConfig=&quot;@xml/network_security_config&quot; /&gt; 配置network_security_config.xml标签和继承关系 12345678910&lt;network-security-config&gt; &lt;base-config /&gt; &lt;!--0 或 1 个--&gt; &lt;domain-config&gt; &lt;!--任意数量--&gt; &lt;domain /&gt; &lt;!--1 个或多个 --&gt; &lt;trust-anchors /&gt; &lt;!--0 或 1 个--&gt; &lt;pin-set /&gt; &lt;!--0 或 1 个--&gt; &lt;domain-config /&gt; &lt;!--任意数量的已嵌套--&gt; &lt;/domain-config&gt; &lt;debug-overrides /&gt; &lt;!--0 或 1 个 --&gt;&lt;/network-security-config&gt; 匹配策略及标签解析先进行域名匹配，匹配到domain-config(domain-config必须包含至少一个domain标签)，则执行相关的trust-anchors和pin-set策略(覆盖上层策略)，如果没有找到trust-anchors等策略就向上一级找，找到终止，使用找到的trust-anchors策略。 查找策略，内部的domain-config =&gt; domain-config =&gt; base-config =&gt; platform默认方式 (target sdk &gt; 23 system; 23 or lower: system or user).如果域名没有匹配到domain-config那么使用上一级策略。 是按照 domain 元素的定义连接到特定目的地的配置。 仅对domain元素匹配到的域名生效。如果目的地不在 domain-config 涵盖范围内的所有连接所使用的默认配置。如果未在特定条目中设置值，将使用通用条目中的值。例如，未在 domain-config 中设置的值将从父级 domain-config（如果已嵌套）或者 base-config（如果未嵌套）中获取。未在 base-config 中设置的值将使用平台默认值。如果找到执行相关trust-anchors和pin-set策略。 includeSubdomainsincludeSubdomains1234如果为 &quot;true&quot;，此域规则将与域及所有子域（包括子域的子域）匹配。否则，该规则仅适用于精确匹配项。expiration=&quot;2018-01-01&quot;```&lt;pin-set expiration=&quot;2018-01-01&quot;&gt; 设置pin策略失效时间，失效后将不再进行该pin策略的检查。这有助于防止尚未更新的应用出现连接性问题。不过，设置固定的到期时间可能会绕过证书固定。设置的日期一定要保证这个时间之前证书CA和公钥不会发生变化，如果发生变化那么将认证失败。假如设置的日期早于CA有效期，那么这个日期之后pin策略将失效。 digest=”SHA-256”1&lt;pin digest=&quot;SHA-256&quot;&gt;7HIpactkIAq2Y49orFOOQKurWxmmSFZhBCoQYcRhJ3Y=&lt;/pin&gt; PEM Base64编码，使用如下命令获取Base64加密的Sha256的公钥，可以用server本身证书或中间CA或根CA，一个验证通过即可openssl x509 -in GeoTrust_G3.cer -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64 overridePins=[“true” | “false”]1&lt;certificates src=[&quot;system&quot; | &quot;user&quot; | &quot;raw resource&quot;] overridePins=[&quot;true&quot; | &quot;false&quot;] /&gt; 针对certificates标签生效，指定此来源的 CA 是否绕过证书固定。如果为 “true”，则不对此来源的 CA 签署的证书链执行证书固定。这对于调试 CA 或测试对应用的安全流量进行中间人攻击 (MiTM) 非常有用。默认值为 “false”，除非在 debug-overrides 元素中另外指定（在这种情况下，默认值为 “true”） cleartextTrafficPermitted=”false”cleartextTrafficPermitted12例如，应用可能需要确保与 secure.example.com 的所有连接始终通过 HTTPS 完成，以防止来自恶意网络的敏感流量。res/xml/network_security_config.xml： &lt;?xml version=”1.0” encoding=”utf-8”?&gt; secure.example.com `更多请参考Google专业测试用例，详细可参考如下APK：frameworks/base/tests/ NetworkSecurityConfigTest测试APK]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安全</tag>
        <tag>NetworkSecurityConfig</tag>
        <tag>证书配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度理解Android技术总结]]></title>
    <url>%2Fposts%2Fandroid_app_tech_summup.html</url>
    <content type="text"><![CDATA[#深度理解Android技术总结 ##Android基础 ###开发文档https://developer.android.com/guide/index.html?hl=zh-cn ###阿里巴巴Android开发规范https://github.com/Blankj/AndroidStandardDevelop ###框架层知识点分层架构 MVC MVVM MVPhttps://developer.android.com/topic/libraries/architecture/guide.htmlhttps://github.com/googlesamples/android-architecturehttps://github.com/googlesamples/android-architecture-components组件化 模块化 容器化 Atlas smallhttps://yq.aliyun.com/articles/7239依赖注入 Dagger2https://toutiao.io/posts/5a3fp5/previewAOP面向切面编程 Aspectjhttp://blog.csdn.net/xwh_1230/article/details/78213160http://blog.csdn.net/xwh_1230/article/details/78225258事件驱动 EventBus otto EventPosterhttp://blog.csdn.net/android2me/article/details/66973037RxJava数据异步http://blog.csdn.net/caihongdao123/article/details/51897793https://www.jianshu.com/p/5e93c9101dc5Http Restful请求框架Retrofithttps://segmentfault.com/a/1190000005638577框架列表https://www.ctolib.com/cheatsheets-Android-ch.html常用的Utilhttps://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/README-CN.mdAndroid开源项目源码解析https://github.com/android-cn/android-open-project-analysis Android中间件###插件化http://blog.csdn.net/ganyao939543405/article/details/76146760 ###热修复https://github.com/Tencent/tinker/wiki ###Hook框架http://www.snowdream.tech/2016/09/02/android-install-xposed-framework/https://jaq.alibaba.com/community/art/show?articleid=809 ##VirtualXposed 和epichttps://github.com/android-hacker/VirtualXposedhttps://github.com/tiann/epichttp://weishu.me/2017/12/02/non-root-xposed/ Android性能优化性能指标 流畅更快 1- 稳定**更稳** ```Crash， ANR 节省更省 内存，CPU，安装包大小，存储，功耗电量，网络 https://github.com/openthos/openthos/wiki/understand-androidhttps://www.kancloud.cn/kancloud/android-performance/53238https://developer.android.com/topic/performance/index.htmlhttps://developer.android.com/studio/profile/index.html 流畅性启动速度https://developer.android.com/topic/performance/launch-time.htmlhttps://juejin.im/post/5874bff0128fe1006b443fa0 页面响应速度优化https://www.zhihu.com/question/47702122http://www.cnblogs.com/lzl-sml/p/5223704.html UI渲染显示速度提升https://blog.csdn.net/yanbober/article/details/48394201 稳定性 稳定性问题 http://gityuan.com/2016/06/19/stability_summary/ ANR分析策略 http://rayleeya.iteye.com/blog/1955652 anr google https://developer.android.com/topic/performance/vitals/anr.html#fix_the_problems ANR超时源码解析 http://gityuan.com/2016/07/02/android-anr/ ANR信息收集 http://gityuan.com/2016/12/02/app-not-response/ ANR input http://gityuan.com/2017/01/01/input-anr/ app crash http://gityuan.com/2016/06/24/app-crash/ native crash http://gityu an.com/2016/06/25/android-native-crash/ 稳定性分析及工具 Android Profile 工具集 https://developer.android.com/studio/profile/index.html Device Monitor工具集 https://developer.android.com/studio/profile/monitor.html#usage 性能优化 http://rayleeya.iteye.com/blog/1961005 traceviewhttp://gityuan.com/2017/07/11/android_debug/https://bxbxbai.github.io/2014/10/25/use-trace-view/https://developer.android.com/studio/profile/traceview.html#overviewhttps://blog.csdn.net/innost/article/details/9008691https://blog.csdn.net/u011240877/article/details/54347396#2%E4%BD%BF%E7%94%A8-android-studio-%E7%94%9F%E6%88%90-trace-%E6%96%87%E4%BB%B6 systracehttp://gityuan.com/2016/01/17/systrace/https://developer.android.com/studio/command-line/systrace.html dumpsyshttp://gityuan.com/2015/08/22/tool-dumpsys/https://developer.android.com/studio/command-line/dumpsys.html dmtracedumphttps://developer.android.com/studio/command-line/dmtracedump.html Android Device Monitor Android Device Monitor is a standalone tool that provides a UI for several Android app debugging and analysis tools.However, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher. The table below helps you decide which developer tools you should use. Android Device Monitor component What you should use Dalvik Debug Monitor Server (DDMS)This tool is deprecated. Instead, use Android Profiler in Android Studio 3.0 and higher to profile your app’s CPU, memory, and network usage.If you want to perform other debugging tasks, such as sending commands to a connected device to set up port-forwarding, transfer files, or take screenshots, then use the Android Debug Bridge (adb), Android Emulator, Device File Explorer, or Debugger window. TraceviewIf you want to inspect existing .trace files, or ones you’ve captured by instrumenting your app with the Debug class, keep using Traceview.If you want to record new method traces and inspect realtime CPU usage of your app’s processes, use Android Studio’s CPU profiler. SystraceIf you need to inspect native system processes and address UI jank caused by dropped frames, use systrace from the command line.Otherwise, use Android Studio’s CPU profiler to profile your app’s processes. Tracer for OpenGL ES Use the Graphics API Debugger. Hierarchy ViewerIf you want to inspect your app’s view hierarchy at runtime, use Layout Inspector. If you want to profile the rendering speed of your app’s layout, use Window.OnFrameMetricsAvailableListener as described in this blog post. Pixel Perfect Use Layout Inspector. ANR分析套路http://maoao530.github.io/2017/02/21/anr-analyse/https://blog.csdn.net/sinat_34157462/article/details/78651870https://blog.csdn.net/wei_lei/article/details/70311702http://www.cnblogs.com/purediy/p/3225060.html crash - 内存泄露OutOfMemoryErrorhttps://www.jianshu.com/u/b8dad3885e05http://rayleeya.iteye.com/blog/1956059http://www.voidcn.com/article/p-txoxuyet-bqt.htmlhttps://juejin.im/entry/59f7ea06f265da43143ffee4http://blog.csdn.net/qyf2010qyf/article/details/52852000 ###节省性 减少apk安装包大小https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure避免使用枚举https://zhuanlan.zhihu.com/p/25865835http://www.10tiao.com/html/330/201704/2653578978/2.htmlhttps://blog.csdn.net/hp910315/article/details/48975655https://blog.csdn.net/my_truelove/article/details/70519234 减少过渡后台，android后台优化https://developer.android.com/training/best-background.html 减少view绘制过度https://blog.csdn.net/qq_19711823/article/details/65627790https://www.jianshu.com/p/2cc6d5842986https://blog.csdn.net/yanbober/article/details/48394201https://yq.aliyun.com/articles/82572 减少流量消耗https://developer.android.com/topic/performance/vitals/bg-network-usage.html#detect_the_problemhttps://developer.android.com/training/basics/network-ops/data-saver.html#monitor-changes 减少电量消耗https://developer.android.com/topic/performance/power/index.html 减少内存占用https://developer.android.com/topic/performance/memory.html#codehttps://developer.android.com/topic/performance/memory-overview.html 性能优化的建议https://blog.csdn.net/carson_ho/article/details/79708444https://juejin.im/post/5a0d30e151882546d71ee49ehttps://www.ctolib.com/docs/sfile/notes-master/Android-Java/AndroidPerformancePatterns.htmlhttps://github.com/Piasy/notes/blob/master/Android-Java/AndroidPerformancePatterns.mdhttps://www.jianshu.com/u/fdb392adfbedhttps://segmentfault.com/a/1190000012413613https://zhuanlan.zhihu.com/p/26364608 Android优化checklisthttps://aeli.gitbooks.io/android-training-course/performance/performance-tips.html]]></content>
      <categories>
        <category>10Android_App</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>书籍推荐</tag>
        <tag>APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android证书应用]]></title>
    <url>%2Fposts%2Fandroid_security_certificate_apps.html</url>
    <content type="text"><![CDATA[Android Settings中主要有凭据存储管理、VPN和WIFI应用等应用到证书的知识。 凭据存储(系统TAB/用户TAB)和用户凭据区别Setting中的显示 受信任凭据-系统TAB显示/system/etc/security/cacerts/ 下的根Root证书文件，system分区只读，不可更改 受信任凭据-用户TAB显示TrustCertificateStore默认路径的CA证书文件，默认路径本来是/data/misc/keychain/cacerts-added，在ActivityThread.main起来的时候改为用户相关/data/misc/user/0/// Make sure TrustedCertificateStore looks in the right place for CA certificatesfinal File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());TrustedCertificateStore.setDefaultUserDirectory(configDir); 用户凭据显示/data/misc/keystore/user_0/下，1000开头的所有证书文件。包含有用户导入的X509和PKCS格式包含有用户导入的X509证书，作为系统证书的补充KeyChain API，使得用户可以安全导入自己的证书，包含两种格式X.509(PEM or ASN.1 DER encoded)/PKCS#12，安装过程提示Wlan或VPN/APP两个选项，如下：1)如果选择WLAN，那么只有Wifi可用此证书，且不会在用户凭据和受信任的凭据里边显示。2)如果选择VPN/APP，那么第三方应用均可请求使用该证书，且会根据证书类型，选择安全的具体位置，比如CER/DER这种格式会在用户凭据和受信任凭据同时添加显示，PKCS12只会用户凭据里显示。第三方应用可以调用KeyChain接口获取PrivateKey进行签名等操作，还可以使用证书/PublicKey进行加密等操作，但第一次调用接口使用证书需要弹窗验证权限，具体使用依据程序需要，可以用于HTTPS/Email等客户端验证查看/data/misc/keystore/user_0目录文件如下：1000_CACERT_1231000_CACERT_123061000_USRPKEY_My+PKey+PChain1010_CACERT_123061010_USRCERT_xxx_WPA_EAPIEEE8021X_TLS_NULL1010_USRPKEY_xxx_WPA_EAPIEEE8021X_TLS_NULL1010_USRPKEY_My+PKey+PChain此目录均为android.security.Keystore接口导入，可加密可不加密存储。文件可分为三类：1000 对system可见，上层可以通过KeyChain接口请求用户授权访问1010 对wifi可见, 其他不可见other_uid 只对本身应用可见，system等不可见其中主要又可分为CACERT、USRPKEY、USRCERT这三种类别。 VPN应用VPN的关键技术参数VPN产品的关键技术参数包括：支持那些标准（PPTP，L2TP，IPsec，MSLP，SOCK5），支持那些加密算法；最大加密强度是多少；是否支持公钥体系PKI），及IKE密钥管理等。 VPN分类IPSEC/XauthBackground PPTP 是一个基于 PPP 的很基本的协议。PPTP 是微软 Windows 平台第一个支持的 VPN 协议。PPTP 标准并没有实际描述加密和授权特性，并且依赖于 PPP 协议的隧道来实现安全功能。 L2TP 是一个在 IETF RFC 3193 中被正式标准化的高级协议。推荐在需要安全加密的地方用来替代 PPTP。 OpenVPN 是一个高级的开源 VPN 解决方案，由 “OpenVPN technologies” 支持，并且已经成为开源网络领域里的事实标准。OpenVPN 使用成熟的 SSL/TLS 加密协议。Data Encryption PPP 负载是使用微软点对点协议（Microsoft’s Point-to-Point Encryption protocol，MPPE）加密。MPPE 实现了 RSA RC4 加密算法，并使用最长 128 位密钥。 L2TP 负载使用标准的 IPSec 协议加密。在 RFC 4835 中指定了使用 3DES 或 AES 加密算法作为保密方式。 OpenVPN 使用 OpenSSL 库来提供加密。OpenSSL 支持好几种不同的加密算法，如：3DES，AES，RC5 等。Setup / Configuration Windows 所有版本和大多数其他操作系统包括移动平台都内建了对 PPTP 的支持。PPTP 只需要一个用户名和密码，以及一个服务器地址，所以安装和配置相当简单。 从 2000/XP 起的所有 Windows 平台和 Mac OS X 10.3+ 都内建了 L2TP/IPSec 的支持。大多数现代的移动平台比如 iPhone 和 Android 也有内建的客户端。 OpenVPN 不包含在任何操作系统中，需要安装客户端软件，但安装也是相当简单，基本上 5 分钟可以完成。Speed 由于使用 128 位密钥，加密开销相比 OpenVPN 使用 256位密钥要小，所以速度感觉稍快一点，但这个差异微不足道。 L2TP/IPSec 将数据封装两次，所以相比其他竞争者效率稍低，速度也慢一些。 当使用默认的 UDP 模式，OpenVPN 的表现是最佳的。Ports PPTP 使用 TCP 1723 端口和 GRE（协议 47）。通过限制 GRE 协议，PPTP 可以轻易地被封锁。 L2TP/IPSec 使用 UDP 500 端口用来初始化密钥交换，使用协议 50 用来传输 IPSec 加密的数据（ ESP ），使用 UDP 1701 端口用来初始化 L2TP 的配置，还使用 UDP 4500 端口来穿过 NAT。L2TP/IPSec 相比 OpenVPN 容易封锁，因为它依赖于固定的协议和端口。 OpenVPN 可以很容易的配置为使用任何端口运行，也可以使用 UDP 或 TCP 协议。为了顺利穿越限制性的防火墙，可以将 OpenVPN 配置成使用 TCP 443 端口，因为这样就无法和标准的 HTTPS 无法区分，从而极难被封锁。Stability / Compatibility PPTP 不如 OpenVPN 可靠，也不能像 OpenVPN 那样在不稳定网络中快速恢复。另外还有部分同 GRE 协议和一些路由器的兼容性问题。 L2TP/IPSec 比 OpenVPN 更复杂，为了使在 NAT 路由器下的设备可靠地使用，配置可以会更加困难。但是，只要服务器和客户端都支持 NAT 穿越，那么就没什么问题了。 无论是无线网络、蜂窝网络，还是丢包和拥塞经常发生的不可靠网络，OpenVPN 都非常稳定、快速。对于那些相当不可以的连接，OpenVPN 有一个 TCP 模式可以使用，但是要牺牲一点速度，因为将 TCP 封装在 TCP 时效率不高。Security weaknesses 微软实现的 PPTP 有一个严重的安全问题（serious security vulnerabilities）。对于词典攻击来说 MSCHAP-v2 是很脆弱的，并且 RC4 算法也会遭到“位翻转攻击（ bit-flipping attack ）”。如果保密是重要的，微软也强烈建议升级到 IPSec。 IPSec 没有明显的漏洞，当和安全加密算法如 AES 一起使用时，被认为是很安全的。 OpenVPN 也没有明显漏洞，当和安全加密算法如 AES 一起使用时，也被认为是相当安全的。Client compatibility • Windows• Mac OS X• Linux• Apple iOS• Android• DD-WRT WindowsAndroid • • Windows• Mac OS X• LinuxConclusion 由于主要的安全漏洞，除了兼容性以外没有好的理由选择使用 PPTP。如果你的设备既不支持 L2TP/IPSec 又不支持 OpenVPN，那么 PPTP 是一个合理的选择。如果关心快速安装和简易配置，那么 L2TP/IPSec 值得考虑。 L2TP/IPSec 是优秀的，但相比 OpenVPN 的高效和杰出的稳定性要落后一点。如果你使用运行 iOS 或 Android 的移动设备，那么这就是最佳的选择，因为 OpenVPN 目前还不支持这些平台。另外，如果需要快速安装，L2TP/IPSec 也是一个较佳的选择。 对于所有的 Windows, Mac OS X 以及 Linux 桌面用户来说，OpenVPN 是最好的选择。OpenVPN 速度快，并且安全可信。但劣势是缺乏对移动设备的支持，另外还需要安装第三方客户端。 参考资料：https://liweitianux.wordpress.com/2011/04/30/pptp-l2tp-openvpn/http://www.cnblogs.com/haitao-fan/archive/2012/05/30/2526142.htmlhttps://linux.cn/article-3407-1.html 主要概述PPTP(Point-to-Point Tunneling Protocol (PPTP))PPTP使用传输控制协议（TCP）创建控制通道来发送控制命令，以及利用通用路由封装（GRE）通道来封装点对点协议（PPP）数据包以发送数据微软点对点协议（PPP）协议堆栈中，提供了各种标准的身份验证与加密机制来支持PPTP.可以搭配PAP、CHAP、MS-CHAP v1/v2或EAP-TLS来进行身份验证。也可以搭配微软点对点加密（MPPE）或IPSec的加密机制来提高安全性 L2TP(Layer Two Tunneling Protocol)IPSec PSK、IPSec RSA整个L2TP数据包，包括有效附载（payload）及标头（header），皆是用用户数据报协议（UDP）来发送。L2TP本身并不提供加密和认证，但常用IPsec来确保L2TP的安全及完整性，两种协议的组合一般被称为L2TP/IPsecPPTP和 L2TP都是OSI第二层的VPN，也是较早期的VPN协议，在IPsec出现前是最主要的VPN类型，今天使用仍然相当广泛，典型地是使用两台托管的Windows 2000服务器作为VPN网关。前者是微软在1996年制定，后者则由CISCO汇同微软在PPTP和L2F的基础上制定。第二层协议对ＰＰＰ协议本身并没有做任何修改，只是将用户的 PPP帧基于GRE封装成IP报文。PPTP和L2TF均具有简单易行的优点，但是它们的可扩展性都不好。更重要的是，它们都没有提供内在的安全机制，它们不能支持企业和企业的外部客户以及供应商之间会话的保密性需求，因此它们不支持用来连接企业内部网和企业的外部客户及供应商的企业外部网Extranet的概念。Extranet需要对隧道进行加密并需要相应的密钥管理机制。PPTP和L2TP限制同时最多只能连接255个用户。端点用户需要在连接前手工建立加密信道。认证和加密受到限制，没有强加密和认证支持。安全程度差，是PPTP/L2TF简易型VPN最大的弱点。PPTP和L2TP最适合用于客户端远程访问虚拟专用网，作为安全要求高的企业信息，使用PPTP/L2TP与明文传送的差别不大。PPTP/L2TP不适合于向Ipv6的转移。 IPSECXauth PSK、Xauth RSA、Hybrid RSAIPsec协议工作在OSI模型的第三层，使其在单独使用时适于保护基于TCP或UDP的协议（如安全套接子层（SSL）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，SSL/TLS依靠更高层的TCP（OSI的第四层）来管理可靠性和分片。IPSec是IETF(Internet Engineer Task Force)完善的安全标准，它把几种安全技术结合在一起形成一个较为完整的体系，通过对数据加密、认证、完整性检查来保证数据传输的可靠性、私有性和保密性。IPSec由IP认证头AH(Authentication Header)、IP安全载荷封载ESP(Encapsulated Security Payload)和密钥管理协议组成。是目前支持最广泛的VPN协议。IPSec协议是一个范围广泛、开放的虚拟专用网安全协议。IPSec适应向IP v6迁移，它提供所有在网络层上的数据保护，提供透明的安全通信。IPSec用密码技术从三个方面来保证数据的安全。即：认证：用于对主机和端点进行身份鉴别。完整性检查：用于保证数据在通过网络传输时没有被修改。加密：加密IP地址和数据以保证私有性。IPsec是完全意义上的VPN，能直接与PKI、CA设备密切协同完成认证功能。IPSec的缺占是需要固定范围的IP地址，因此在动态分配IP地址时不太适合于IPSec。（图腾VPN是目前不多的部分支持动态IP的VPN网关技术）；除了TCP/IP协议外，IPSec不支持其他协议。除了包过滤之外，它没有指定其他访问控制方法。另外，微软在windows中没有集成对IPSec的支持，因此，windows客户端需要专门的软件或硬件的支持。IPSec最适合可信的网关到网关之间的虚拟专用网，即企业广域网(Extranet)的构建。SSTPSSL/TLS VPN配置文件由系统创建并由KeyStore进行加密存储，如下：配置文件解密后 包含：名称/Type/IP/用户名/密码////用户证书/CA证书/ 等内容Type: 1 = L2TP/IPSECType: 0= PPTPType: 4= IPSec Xauth 证书使用：At runtime, the framework retrieves the client certifcate (w inListing 9-8) and the CA certifcate (u in Listing 9-8) from the system keystore and passes them to racoon via the control socket.运行时，framework按照配置文件将证书从系统keystore中抽取出来，通过socket传递给racoon守护进程。 The private key blob is never directly passed to the racoon daemon, only its alias (vpnclient). 私钥文件不传递给racoon，而是用到的时候直接由keystore进行加解密操作，从而保证私钥安全性。 PPTP和L2TP守护进程：PPTP和L2TP隧道实现，包含PPP守护进程mtpd、和PPPoPNS和PPPoLAC内核驱动。IPSec实现，包含内置IPSec内核支持和racoon IKE守护进程。Init.rc中可以看到两个守护进程的声明： 系统设置启动VPN后，通过套接字发送控制命令，IP地址网络掩码等，两个守护进程负责根据参数创建隧道，完成接口配置，写入并处理/data/misc/vpn/state文件，调用系统ConnectivityService配置路由服务器等，然后发送给netd(root权限运行)，开始修改内核包过滤和路由表。 VPN对Android SDK开放的APIVPNService和VPNService.Builder这种方法最好的实现是OpenVPN的实现，参考OpenVPN 参考：https://developer.android.com/reference/android/net/VpnService.htmlhttps://developer.android.com/reference/android/net/VpnService.Builder.html WLan应用WiFi分类WiFi无线电分类：Wi-Fi可分为五代。[6]由于ISM频段中的2.4GHz频段被广泛使用，例如微波炉、蓝牙，它们会干扰WiFi，令速度减慢，5GHz干扰则较小。双频路由器可同时使用2.4GHz和5GHz，设备则只能使用某一个频段。第一代802.11，1997年制定，只使用2.4GHz，最快2Mbit/s第二代802.11b，1999年制定，只使用2.4GHz，最快11Mbit/s，正逐渐淘汰第三代802.11g/a，2007收录，分别使用2.4GHz和5GHz，最快54Mbit/s 802.11i，安全和鉴权（Authentication）方面的补充。第四代802.11n，2008以后，可使用2.4GHz或5GHz，20和40MHz信道宽度下最快72和150Mbit/s第五代802.11ac，2011年后，只使用5GHz Wifi认证分类：WEP 口令即可WPA/WPA2 PSK 口令即可802.1 EAP PEAPTLSTTLSPWDSIMAKA PEAP认证，通过SSL连接，只认证服务端TLS双向认证，需要签发X.509客户端证书私钥，可以撤销禁止网络访问TTLS不需要认证客户端PWD预共享秘钥WAPI PSK 口令即可WAPI CERT AS证书/用户证书 其中WiFi Protected Access (WPA) 和 WiFi Protected Access II(WPA) 是主流协议，均支持PSK预共享密钥模式，也成为Personal个人模式。PSK模式缺点：需要预共享口令，用户增加无法扩展，需要撤销某设备的访问，必须要修改共享的口令凭据，还要同步修改其他设备的配置，不能区分用户和设备，难以计费和进行灵活的访问控制。 WPA和WPA2进行扩展EAP(Extensible Authentication Protocol)，如图其中一种需要证书认证的方式： Supplicant: 无线设备手机等Authenticator: 网络的网关，AP无线接入点。负责验证客户端身份Authentication：Radius服务器，验证客户端凭据并根据预先预置的访问策略决定是否授予访问权限 EAP是一种支持不同认证类型的认证框架。再认证开始之前，客户端和认证服务器需要协商一种同时支持的认证协议 TLS/TTLS/PWD等 WIFI框架内核层：WLAN适配内核驱动模块 ko原声守护进程：wpa_supplicant,1010 与WPA认证器进行密钥协商，并且控制与WIFI驱动关联硬件抽象层HAL：libhardware_legacy原声库，通过套接字发送命令给wpa_supplicant系统服务：WifiService和公开接口WifiManager (WifiStateMachine)系统UI:系统设置进行控制、SystemUI连接状态栏WiFi上层接口配置：http://www.cnblogs.com/wotakuc/archive/2013/03/22/2975886.html WiFI配置文件/data/misc/wifi/wpa_supplicant.conf0660 文件所有者system 文件组wifi只有系统应用和wifi守护进程可以对文件进行读取和修改，第三方不可以读取和修改。 包含SSID标识Key_mgmt网络认证协议Psk 预共享密钥 另外有Identity身份Passwork密码ca_cert证书，守护进程调用IKeyStoreService原生服务远程接口，根据URI获取证书Phase2阶段二认证协议 另外还有Client_cert 用户证书Engine_id 引擎IDKeyid 用户密钥ID Alias别名 配置文件中所有需要预共享口令密码的都是以明文进行存储，但用户私钥用keystore进行存储于硬件或软实现加密存储。 其中证书文件从Settings里边导入，如果选择Wifi形式导入，那么密钥所有者就是wifi用户1010，而且只有以wifi用户运行的系统组件，才可以访问到该密钥。 参考资料：https://zh.wikipedia.org/wiki/IEEE_802.11http://www.howtogeek.com/167783/htg-explains-the-difference-between-wep-wpa-and-wpa2-wireless-encryption-and-why-it-matters/http://m.8p8p.net/ztnews/03xrzw212ooxtwpzuz1x2z1x.htmlhttp://bbs.ruijie.com.cn/thread-2559-1-1.html 设备管理DPM (Android for work)设备管理跟证书相关的接口Public interface for managing policies enforced on a device. Most clients of this class must be registered with the system as a device administrator. Additionally, a device administrator may be registered as either a profile or device owner. A given method is accessible to all device administrators unless the documentation for that method specifies that it is restricted to either device or profile owners. Any application calling an api may only pass as an argument a device administrator component it owns. Otherwise, a SecurityException will be thrown. installCaCertboolean installCaCert (ComponentName admin, byte[] certBuffer) Installs the given certificate as a user CA. 可以使用system|signature签名级别的android.permission.MANGE_CA_CETIFICATES权限来安装证书，安装后位于/data/misc/user/0/cacerts-addedSecurityExceptionif admin is not null and not a device or profile owner. installKeyPairboolean installKeyPair (ComponentName admin, PrivateKey privKey, Certificate[] certs, String alias, boolean requestAccess) Called by a device or profile owner, or delegated certificate installer, to install a certificate chain and corresponding private key for the leaf certificate. All apps within the profile will be able to access the certificate chain and use the private key, given direct user approval.The caller of this API may grant itself access to the certificate and private key immediately, without user approval. It is a best practice not to request this unless strictly necessary since it opens up additional security vulnerabilities.SecurityExceptionif admin is not null and not a device or profile owner. 参考资料：https://developer.android.com/reference/android/app/admin/DevicePolicyManager.htmlhttps://developer.android.com/guide/topics/admin/device-admin.htmlhttps://developer.android.com/reference/android/app/admin/DeviceAdminReceiver.htmlhttps://www.ncsc.gov.uk/guidance/android-end-user-device-security 证书存储 KeyStore/Keymaster]]></content>
      <categories>
        <category>11Android_Security</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>安全</tag>
        <tag>wifi certificate</tag>
        <tag>vpn certificate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM类加载]]></title>
    <url>%2Fposts%2Fjvm_art_jvm_class_load.html</url>
    <content type="text"><![CDATA[JVM类结构类加载类执行 类加载的五个过程：加载、验证、准备、解析、初始化。 加载: 根据全限定名来获取定义类的二进制字节流,然后将该字节流所代表的静态结构转化为方法区的运行时数据结构,最后在生成一个代表该类的Class对象,作为方法区这些数据的访问入口. 验证:主要时为了确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.包含四个阶段的验证过程: 文件格式验证:保证输入的字节流能够正确地解析并存储在方法区之内,格式上符合描述一个java类型信息的要求 元数据验证:字节码语义信息的验证,以保证描述的信息符合java语言规范.验证点有:这个类是否有父类等. 字节码验证:主要是进行数据流和控制流分析,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为. 符号引用验证:对符号引用转化为直接引用过程的验证. 准备:为类变量分配内存并设置变量的初始值,这些内存在方法区进行分配. 解析:将虚拟机常量池中的符号引用转化为直接引用的过程.解析主要是针对类或接口、字段、类方法、类接口方法四类. 初始化:执行静态变量的赋值操作以及静态代码块,完成初识化.初始化过程保证了父类中定义的初始化优先于子类的初始化.但接口不需要执行父类的初始化. JVM类加载时机 何时开始类的初始化什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。 创建类的实例 访问类的静态变量(除常量【被final修辞的静态变量】原因:常量一种特殊的变量，因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变量(constant variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变final域的值那么每一块用到那个域的代码都需要重新编译。 访问类的静态方法 反射如(Class.forName(“my.xyz.Test”)) 当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化 虚拟机启动时，定义了main()方法的那个类先初始化以上情况称为称对一个类进行“主动引用”，除此种情况之外，均有且仅有这几种情况不会触发类的初始化，称为“被动引用”接口的加载过程与类的加载过程稍有不同。接口中不能使用static{}块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。 被动引用例子 子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。。对于静态字段，只有直接定义这个字段的类才会被初始化. 通过数组定义来引用类，不会触发类的初始化SubClass[] sca = new SubClass[10];// 被动引用2 访问类的常量，不会初始化类 具体可参考 https://www.cnblogs.com/javaee6/p/3714716.html JVM 加载 class 文件的原理机制JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的 .class 文件中的数据读入到内存中，通常是创建一个字节数组读入 .class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后 JVM 对类进行初始化，包括： 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类； 如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：启动类加载器（BootStrap）、扩展加载器（Extension）、应用程序加载器（Application）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明： Bootstrap：启动类加载器，一般用本地代码实现，负责加载JVM基础核心类库。加载存放在&lt;JAVA_HOME&gt;/lib目录中的类库（如rt.jar）； Extension ClassLoader：扩展加载器， 负责加载&lt;JAVA_HOME&gt;/lib/ext目录中的 ，或被java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap； Application ClassLoader：应用程序加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。 缺点: 双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码时，双亲委派模型无法满足要求。 因为Bootstrap加载器无法找到永不代码类。 为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文件类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。 Dubbo的SPI也是采用这种机制实现。 双亲委派模型除了顶层的启动类加载器外,其余的类加载器都应当有自己的父类加载器.顺序依次是: Bootstrap ClassLoader: 启动类加载器,加载java_home/lib中的类 Extension ClassLoader: 扩展类加载器,加载java_home/lib/ext目录下的类库 Application ClassLoader: 应用程序类加载器,加载用户类路径上指定类库. 双亲委派模型的工作原理是:如果一个类加载器受到了类加载请求,它首先不会自己去尝试加载这个类,而把这个请求委派给父类加载器去完成,每一层次的类加载器都是如此,因此所有的加载请求最终都应该传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成加载请求时,加载器才尝试自己加载.这种方式保证了Oject类(JDK 核心类)在各个加载器加载环境中都是同一个类. 分派：静态分派与动态分派。多态性特征的一些最基本的体现. 静态类型是编译期可知的,动态类型是在运行时可知.Human h =new Man(); Human是静态类型,Man时动态类型. 所有依赖于静态类型定位方法执行版本的分派动作称作静态分派,最典型的应用是方法重载.静态分派发生在编译阶段。 动态分派是根据动态类型来确定执行的版本,所以只有到运行时才能确定具体的执行方法版本.典型的代表时重写.其过程如下: 首先找到操作数栈栈顶的第一个元素所执向对象的实际类型,记做C. 如果在类型C中找到和常量中的描述符和简单名称都相符的方法,则进行范围权限校验.如果通过则返回该方法的直接引用,否则抛出IllegalAccessError异常. 否则按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程. 如果始终没有找到就抛出AbstractMethodError异常. 方法的接受者和方法的参数统称方法宗量,根据分配基于多少中宗量可以分为单分派和多分派.java是静态多分派,动态分派属于单分派. 动态分派的实现: 动态分派时非常频繁的动作,而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法,因此出于性能的考虑,在方法区中建立一个虚方法表,用来保存各个方法的实际入口地址.如果某个方法的子类中没有被重写,那么子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的.都是指向父类的实现入口,如果子类中重写了这个方法,子类方法表中的地址将会被替换为指向子类实现版本的入口地址.虚方法表在类加载的连接阶段进行初始化. Student s= new Student(),在内存中做了那些事情 加载Student.class 文件进内存 在栈内存为s开辟空间 在堆内存为Student对象开辟空间 学生对象的成员变量进行显示初始化 通过构造方法对学生对象变量赋值 学生对象初始完毕，把对象地址赋值给s变量 相关资料： http://blog.csdn.net/wisgood/article/details/16818243]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM深入理解]]></title>
    <url>%2Fposts%2Fjvm_art_jvm_deep_learn.html</url>
    <content type="text"><![CDATA[Java虚拟机概览https://www.cnblogs.com/2014asm/p/7999049.html 内存分布概要 垃圾回收概要 JVM类字节码结构 类加载机制 类执行引擎 多态从虚拟机角度看Java多态-&gt;（重写override）的实现原理https://www.cnblogs.com/2014asm/p/8633660.html 动态委派和静态委派]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>深入理解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android查缺补漏-taskAffinity/lauchMode/Intent Flag/task record]]></title>
    <url>%2Fposts%2Fandroid_review_taskAffinity_lauchMode_intentflag.html</url>
    <content type="text"><![CDATA[taskAffinity、launchmode、Intent.FLAG_ACTIVITY_XXX 有关的堆栈和back键返回等http://www.voidcn.com/blog/fengniuma/article/p-3214732.htmlhttps://blog.piasy.com/2017/01/16/Android-Basics-Task-and-LaunchModehttp://blog.csdn.net/scnuxisan225/article/details/44930321http://blog.csdn.net/tuhuolong/article/details/8844936 taskAffinity解释：taskAffinity 标示以该Activity为root的所在task的名字。属性值推荐用.开头。可以通过给所有activity设置taskAffinity。 ***也可以单独设置activity 的taskAffinity 如果或都没有设置taskAffinity，则系统默认赋值为应用程序包名。也就是说taskAffinity要么是自己定义的值，要么去应用程序包名。值得注意的是，如果launcher activity使用默认taskAffinity，通过launcher activity启动的一个activity B，【B配置了taskAffinity属性，并且没有设置启动新的task, 那么其实B的taskAffinity就失效了】，因为task的名字是由root activity的taskAffinity决定的。taskAffinity结合singleTask和SingleIntance和FLAG_ACTIVITY_NEW_TASK 一起使用会产生效果，单独的task只存在一个activity，该task上的activity清除等。 LaunchmodeStandard singleTop singleTask singleInstance主要有这几种模式。其中standard模式比较简单，直接在当前栈启动一个新的activity，而不管之前是否存在相同activity实例。其中singleTop模式也比较简单，直接在当前栈查找是否存在该activity实例，如果存在直接调用onNewIntent方法，如果不存在那么直接创建改Activity。 不关注TaskAffinity。其中singleTask模式较为麻烦，先寻找名字为taskAffnity指定的task，如果该task存在这个activity，那么清楚之上的所有activity，然后调用OnNewIntent方法。如果不存在该task，那么创建task，创建activity。其中singleIntance模式，要求Activity实例独占task，所以先寻找是否存在该Activity，存在那么直接调用onNewIntent，如果不存在，那么创建该task和activity。 如果从该activity调用其他Activity那么会切换到其他task栈上，因为该activity独占task。Intent.FLAG_ACTIVITY_XXXFLAG_ACTIVITY_NEW_TASK 配合FLAG_ACTIVITY_CLEAR_TOP的时候，才会和“singleTask”行为一致–在已经存在目标activity的情况下，清除上层全部Activity.FLAG_ACTIVITY_SINGLE_TOP = singleTopFLAG_ACTIVITY_CLEAR_TOP + FLAG_ACTIVITY_NEW_TASK = singleTask ActivityRecord、TaskRecord、ActivityStack之间的关系ActivityStackSupervisor.mActivityDisplays-&gt; ActivityDisplay.mStacks -&gt; ActivityStack.mTaskHistory -&gt; TaskRecord.mActivities -&gt; ActivityRecord简单来说就是一下类的关系图，ActivityStackSupervisor与ActivityDisplay都是系统唯一，ActivityDisplay负责管理很多ActivityStack，ActivityDisplay主要有Home Stack和App Stack这两个栈；一个ActivityStack负责管理很多TaskRecord，一个TaskRecord又包含很多ActivityRecord。一个activityRecord包含ProcessRecord app //跑在哪个进程 TaskRecord task //跑在哪个task ActivityInfo info // Activity信息 int mActivityType //Activity类型 ActivityState state //Activity状态 ApplicationInfo appInfo //跑在哪个apphttp://gityuan.com/2017/06/11/activity_record/http://blog.csdn.net/itachi85/article/details/77542286http://blog.csdn.net/kebelzc24/article/details/53747506http://duanqz.github.io/2016-02-01-Activity-Maintenance#activitystack Intent-filter action category Data scheme匹配规则http://blog.csdn.net/iispring/article/details/48481793 intent匹配https://developer.android.com/guide/components/intents-filters.html?hl=zh-cn#Resolution PendingIntent如果Intent对象的Action是相同的，Data也是相同的，Categories也是相同的，Components也是相同的，Flags也是相同的），并且之前获取的PendingIntent对象还有效的话，那么该进程获取到的PendingItent对象将获得同一个对象的引用，可以通过cancel()方法来从系统中移除它。PendingIntent对象由系统持有，因此不能通过设置不同的Extra来生成不同的PendingIntent对象，系统只通过刚才在上面提到的几个要素来判断PendingIntent对象是否是相同的。PendingIntent有以下flag：FLAG_CANCEL_CURRENT:如果当前系统中已经存在一个相同的PendingIntent对象，那么就将先将已有的PendingIntent取消，然后重新生成一个PendingIntent对象。FLAG_NO_CREATE:如果当前系统中不存在相同的PendingIntent对象，系统将不会创建该PendingIntent对象而是直接返回null。FLAG_ONE_SHOT:该PendingIntent只作用一次。FLAG_UPDATE_CURRENT:如果系统中已存在该PendingIntent对象，那么系统将保留该PendingIntent对象，但是会使用新的Intent来更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras。创建PendingIntent方式：PendingIntent.getActivity (context, requestCode, broadIntent, flags)PendingIntent.getBroadcast(context,requestCode, broadIntent, flags)PendingIntent.getService (context, requestCode, broadIntent, flags)API文档里虽然未使用requestCode参数，但实际上是通过该参数来区别不同的Intent的http://blog.csdn.net/yangwen123/article/details/8019739]]></content>
      <categories>
        <category>21Android_review</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>查缺补漏</tag>
        <tag>taskAffinity</tag>
        <tag>lauchMode</tag>
        <tag>Intent Flag</tag>
        <tag>task record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收]]></title>
    <url>%2Fposts%2Fjvm_art_java_gc.html</url>
    <content type="text"><![CDATA[GC的收集方法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？ 标记清理：首先标记所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记的对象。缺点是效率低，且存在内存碎片。主要用于老生代垃圾回收。 标记整理：首先标记所有需要回收的对象，在标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。用于老年代。 复制算法：将内存按容量划分为大小相等的一块，每次只用其中一块。当内存用完了，将还存活的对象复制到另一块内存，然后把已使用过的内存空间一次清理掉。实现简单，高效。一般用于新生代。一般是将内存分为一块较大的Eden空间和两块较小的Survivor空间。HotSpot虚拟机默认比例是8:1,。每次使用Eden和一块Survivor，当回收时将这两块内存中还存活的对象复制到Survivor然后清理掉刚才Eden和Survivor的空间。如果复制过程内存不够使用则向老年代分配担保。 分代收集算法：根据对象的生存周期将内存划分为新生代和老年代，根据年代的特点采用最适当的收集算法。 GC收集器有哪些？CMS收集器与G1收集器的特点。 Serial: 单线程收集器，只会使用一个CPU或一条收集器线程去完成，垃圾回收工作，更重要的是在进行垃圾回收时，必须暂停其他所有的工作线程。（Stop the world）。简单高效，用于新生代。 ParNew: 是Serial收集器的多线程版本，垃圾回收时采用多线程方式进行回收。默认情况下使用的线程数是cpu数量。除了serial收集器，目前只有它能和CMS收集器配合工作。是server模式下首选的新生代收集器。 Parallel Scavenge: 使用复制算法收集器，也是一个并行的多线程收集器。Parallel Scavenge收集器与其他收集器关注点不同，其它收集器主要关注缩短垃圾回收时用户线程的停顿时间。而它关心吞吐量，即运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)。停顿时间越短越适合需要与用户交互的程序，高吞吐量则可以最高效率的利用CPU时间。 Serial Old: 老年代，单线程收集器，使用标记整理算法。主要有两个用途，一是和Parallel Scavenge 收集器配合使用，二是作为CMS的后备方案在并发收集器发生Concurrent Mode Failure时候使用。 Parallel Old:并行的老年代版本收集器，使用标记整理算法。主要与Parallel Scavenge配合使用。 CMS：是以获得最短回收停顿时间为目标的收集器，使用标记清除算法。整个过程包括4个： 初始标记: 标记Gc ROOTS能直接关联到的对象 并发标记：进行Roots Traceing的过程 重新标记：修正并发标记期间因用户继续工作导致标记产生变动 并发清除：并发清除数据。 初始标记和重新标记需要stop the world. 并发标记和并发清除过程用户线程和收集器线程可以并行执行。 G1(Garbage First): 基于标记-整理算法的收集器,不会产生空间碎片.它可以精确控制停顿,能够让使用者明确指定一个长度为M毫秒的时间片段内,消耗集上的时间不超过N秒.是不牺牲吞吐量的前提下完成低停顿的.G1将整个java堆(新生和老生)划分为大小相同的区,并跟踪这些区上发生的变化.在后台维护一个优先列表,每次根据允许的收集时间优先回收垃圾最多的区域. 现在公司中很多都采用了G1 垃圾回收期，建议大家多深入了解下G1，更多参考: G1垃圾回收器 GC的两种判定方法：引用计数与根搜索算法 引用计数： 给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1，当引用失效时，计数器值减1,。任何时候计数器都为0的对象就是不可能再被使用的。它很难解决对象之间相互循环引用问题。 根搜索算法（GC Roots Traceing）: 通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。 GC Roots对象一般是：虚拟机栈中的引用对象，方法区中类静态属性引用的对象，方法区常量引用的对象等。 Java中的四种引用Java中提供这四种引用类型主要有两个目的：第一是可以让程序员通过代码的方式决定某些对象的生命周期；第二是有利于JVM进行垃圾回收。 强引用：程序代码中的普通引用。如Object obj = new Object(),只要强引用存在，垃圾回收器就不会回收。在不使用对象时应及时将引用设置为null，便于垃圾回收。 软引用：描述一些有用但并非必须的对象。对于软引用关联的对象在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。SoftRefence 弱引用：描述非必须对象，比软引用弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakRefence 虚引用：最弱的引用，不管是否有虚引用存在，完全不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的是希望能够在这个对象被垃圾回收器之前收到系统通知。PhantomReference 相关参考：Java 如何有效地避免OOM：善于利用软引用和弱引用 OOM你遇到过哪些情况 java.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。 java.lang.OutOfMemoryError: PermGen space ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。 java.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存布局]]></title>
    <url>%2Fposts%2Fjvm_art_java_memory.html</url>
    <content type="text"><![CDATA[JVM虚拟机内存结构，以及它们的作用线程私有：栈区，本地方法栈，pc指针线程共有：方法区，堆区 JVM内存内存分布大纲垃圾回收大纲 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明 程序计数器：看做当前线程所执行的字节码行号指示器。是线程私有的内存，且唯一一块不报OutOfMemoryError异常的内存区域。 Java虚拟机栈：用于描述java方法的内存模型：每个方法被执行时都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度就报StackOverflowError, 如果虚拟 机栈可以动态扩展，当拓展时无法申请到足够的内存会抛出OutOfMemoryError. 是线程私有的。 本地方法栈：与虚拟机栈相似，不同的在于它是为虚拟机使用到Native方法服务的。会抛出StackOverflowError和OutOfMemoryError。是线程私有的。 Java堆: 是所有线程共享的一块内存，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。如果堆上没有内存完成实例的分配就会报OutOfMemoryError. 方法区（永久代）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。是共享内存。 运行时常量池：用于存放编译器生成的各种字面量和符号引用，是方法区的一部分。无法申请内存时抛出OutOfMemoryError。 直接内存：不是虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的区域，是计算机直接的内存空间。这部分也被频繁使用，如JAVA NIO的引入基于通道和缓存区的I/O使用native函数直接分配堆外内存。如果内存不足会报OutOfMemoryError。]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语法糖]]></title>
    <url>%2Fposts%2Fjvm_art_java_syntactic%20sugar.html</url>
    <content type="text"><![CDATA[Java语法糖：语法糖（Syntactic Sugar），也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言本身功能来说没有什么影响，只是为了方便程序员的开发，提高开发效率。说白了，语法糖就是对现有语法的一个封装。 Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种： 泛型与类型擦除 自动装箱与拆箱，变长参数、 增强for循环 内部类与枚举类 泛型与类型擦除Java语言并不是一开始就支持泛型的。在早期的JDK中，只能通过Object类是所有类型的父类和强制类型转换来实现泛型的功能。强制类型转换的缺点就是把编译期间的问题延迟到运行时，JVM并不能为我们提供编译期间的检查。 在JDK1.5中，Java语言引入了泛型机制。但是这种泛型机制是通过类型擦除来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码中自动用强制类型转换进行替代。也就是说，Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅。12345678/*** 在源代码中存在泛型*/public static void main(String[] args) &#123; Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;hello&quot;,&quot;你好&quot;); String hello = map.get(&quot;hello&quot;); System.out.println(hello); 当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换123456public static void main(String[] args) &#123; HashMap map = new HashMap(); //类型擦除 map.put(&quot;hello&quot;, &quot;你好&quot;); String hello = (String)map.get(&quot;hello&quot;);//强制转换 System.out.println(hello);&#125; 自动装箱与拆箱Java中的自动装箱与拆箱指的是基本数据类型与他们的包装类型之间的相互转换。 我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。 下面代码演示了自动装箱和拆箱功能123456public static void main(String[] args) &#123; Integer a = 1; int b = 2; int c = a + b; System.out.println(c);&#125; 经过编译后，代码如下123456public static void main(String[] args) &#123; Integer a = Integer.valueOf(1); // 自动装箱 byte b = 2; int c = a.intValue() + b;//自动拆箱 System.out.println(c);&#125; 变长参数所谓变长参数，就是方法可以接受长度不定确定的参数 变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。1234567891011public class Varargs &#123; public static void print(String... args) &#123; for(String str : args)&#123; System.out.println(str); &#125; &#125; public static void main(String[] args) &#123; print(&quot;hello&quot;, &quot;world&quot;); &#125;&#125; 编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的1234567891011121314151617181920public class Varargs &#123; public Varargs() &#123; &#125; public static void print(String... args) &#123; String[] var1 = args; int var2 = args.length; //增强for循环的数组实现方式 for(int var3 = 0; var3 &lt; var2; ++var3) &#123; String str = var1[var3]; System.out.println(str); &#125; &#125; public static void main(String[] args) &#123; //变长参数转换为数组 print(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;); &#125;&#125; 增强for循环增强for循环与普通for循环相比，功能更强并且代码更简洁 增强for循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，其在循环过程中不能改变集合的大小。12345678910111213public static void main(String[] args) &#123; String[] params = new String[]&#123;&quot;hello&quot;,&quot;world&quot;&#125;; //增强for循环对象为数组 for(String str : params)&#123; System.out.println(str); &#125; List&lt;String&gt; lists = Arrays.asList(&quot;hello&quot;,&quot;world&quot;); //增强for循环对象实现Iterable接口 for(String str : lists)&#123; System.out.println(str); &#125;&#125; 编译后的class文件为12345678910111213141516171819public static void main(String[] args) &#123; String[] params = new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;; String[] lists = params; int var3 = params.length; //数组形式的增强for退化为普通for for(int str = 0; str &lt; var3; ++str) &#123; String str1 = lists[str]; System.out.println(str1); &#125; List var6 = Arrays.asList(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;); Iterator var7 = var6.iterator(); //实现Iterable接口的增强for使用iterator接口进行遍历 while(var7.hasNext()) &#123; String var8 = (String)var7.next(); System.out.println(var8); &#125;&#125; 内部类内部类就是定义在一个类内部的类 Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。1234public class Outer &#123; class Inner&#123; &#125;&#125; 使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：12345class Outer$Inner &#123; Outer$Inner(Outer var1) &#123; this.this$0 = var1; &#125;&#125; 内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类，每一种都有其用法，这里就不介绍了 枚举类型枚举类型就是一些具有相同特性的类常量 java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。123public enum Fruit &#123; APPLE,ORINGE&#125; 使用jad对编译后的class文件进行反编译后得到：1234567891011121314151617181920212223242526272829303132//继承java.lang.Enum并声明为finalpublic final class Fruit extends Enum&#123; public static Fruit[] values() &#123; return (Fruit[])$VALUES.clone(); &#125; public static Fruit valueOf(String s) &#123; return (Fruit)Enum.valueOf(Fruit, s); &#125; private Fruit(String s, int i) &#123; super(s, i); &#125; //枚举类型常量 public static final Fruit APPLE; public static final Fruit ORANGE; private static final Fruit $VALUES[];//使用数组进行维护 static &#123; APPLE = new Fruit(&quot;APPLE&quot;, 0); ORANGE = new Fruit(&quot;ORANGE&quot;, 1); $VALUES = (new Fruit[] &#123; APPLE, ORANGE &#125;); &#125;&#125; 断言语句//运行时需要加上 VM参数 -ea1234567public static void main(String[] args) &#123; String str = &quot;fans2&quot;; boolean flag = &quot;fans&quot;.equals(str); assert (flag);&#125;//程序结果Exception in thread &quot;main&quot; java.lang.AssertionErrorat sugar.JavaTenSugar.main(JavaTenSugar.java:102) 对枚举和字符串的switch支持1234567891011public void enumStringSwitch() &#123; String str = &quot;fans&quot;; switch (str) &#123; case &quot;fans&quot;: break; case &quot;leiwen&quot;: break; default: break; &#125;&#125; 在try语句中定义和关闭资源 jdk7提供了try-with-resources,可以自动关闭相关的资源(只要该资源实现了AutoCloseable接口，jdk7为绝大部分资源对象都实现了这个接口) static String readFirstLineFromFile(String path) throws IOException{ try(BufferedReader br = new BufferedReader(new FileReader(path))){ return br.readLine(); }}]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>syntactic sugar</tag>
        <tag>deep learn</tag>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统安全深入]]></title>
    <url>%2Fposts%2Fbooks_recommand_operating_system_deeplearn.html</url>
    <content type="text"><![CDATA[#Linux内核ORANGE’S：一个操作系统的实现Linux内核设计与实现_第三版Linux内核设计的艺术Linux内核完全注释V3.0书签版30天自制操作系统.川合秀实 #系统安全原理篇计算机安全原理与实践黑客攻防技术宝典.系统实战篇.第二版.pdf黑客之道：漏洞发的艺术.Jon.Erickson.扫描版黑客调试技术揭密.美.Kaspersky.扫描版.pdf0day安全：软件漏洞分析技术（第2版）Shellcoder编程揭秘老码识途 从机器码到框架的系统观逆向修炼之路 #Android系统移动安全ANDROID安全架构深究Android安全攻防权威指南Android软件安全与逆向分析Android安全技术揭秘与防范_13877446Android安全攻防实战 (南非)keith makan, 崔孝晨;武晓音(译)]]></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>operating system</tag>
        <tag>安全深入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android查缺补漏-四大组件UI]]></title>
    <url>%2Fposts%2Fandroid_review_four_component_ui.html</url>
    <content type="text"><![CDATA[Service onStartCommand返回参数说明方法onStartCommand()的返回值为int类型，主要的作用是当Service进程被意外kill掉时，Service服务下一步要做哪些行为，主要有3种值。START_STICKY：Service被异外终止时不调用onDestroy()回调，并且终止后自动重启Service服务，只执行Service对象的onCreate()生命周期方法。START_NOT_STICKY：Service被异外终止时不调用onDestroy()回调，并且不自动重启服务。START_REDELIVER_INTENT：Service被异外终止时不调用onDestroy()回调，并且终止后自动重启Service服务，还要执行Service对象的onCreate()和onStartCommand()生命周期方法，并且从Intent中能取到值。http://book.51cto.com/art/201211/363296.htm Service stopSelf一直知道stopself是停掉Service的方法，但是却不知道什么时候停止。以为调用了stopself就会马上停止，实际上我错了.在onStartCommond方法里面调用stopself方法时，不会马上停止，而是onStartCommond方法执行结束才会停止。还有一点，调用stopself方法之后，service会执行onDestory方法。另外，如果onStartCommond中启动一个线程，调用stopself，线程也不会被杀死。来自 http://blog.csdn.net/hello0370/article/details/46781523 当调用finish方法时，onCreate方法会继续执行，之后调用onDestory方法。最后，总结一下，Service的stopself方法的功能是，当完成所有功能之后，将service停掉，而不是等着系统回收。同样finish方法，是当系统执行完onCreate方法之后，调用onDestory方法销毁Activity。来自 http://blog.csdn.net/hello0370/article/details/46781523 ACTION_CANCEL 请简述Android事件传递机制， ACTION_CANCEL事件何时触发？关于第一个问题，不做任何解释。关于ACTION_CANCEL何时被触发，系统文档有这么一种使用场景：在设计设置页面的滑动开关时，如果不监听ACTION_CANCEL，在滑动到中间时，如果你手指上下移动，就是移动到开关控件之外，则此时会触发ACTION_CANCEL，而不是ACTION_UP，造成开关的按钮停顿在中间位置。意思是当滑动的时候就会触发，不知道大家搞没搞过微信的长按录音，有一种状态是“松开手指，取消发送”，这时候就会触发ACTION_CANCEL。 简述Android的View绘制流程，Android的wrap_content是如何计算的https://blog.csdn.net/qinjuning/article/details/8051811https://blog.csdn.net/qinjuning/article/details/8074262https://www.cnblogs.com/duanweishi/p/4301742.html bundle的数据结构，如何存储，既然有了Intent.putExtra，为啥还要用bundle。bundle的内部结构其实是Map，传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口。 LocalBroadcastmanager使用首先获取LocalBroadcastManager实例：LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this);然后通过函数 registerReceiver方法来注册监听器：lbm.registerReceiver(new BroadcastReceiver(){ @Override public void onReceive(Context arg0, Intent arg1) { // TODO Auto-generated method stub }}, new IntentFilter(“com.android.action.PRIVATE_BROADCAST”));最后调用sendBroadcast方法发送广播：Intent intent=new Intent(“com.android.action.PRIVATE_BROADCAST”);intent.putExtra(KEY, SENSITIVE_DATA);lbm.sendBroadcast(intent); Sticky broadcast首先点击next Activity从代码中可以看到receiver已经注册，但Log无输出，这是当然的了~~~因为没有广播发出自然就不会有人响应了。按back后退到上图下面分别点击send broadcast 和 send stickybroadcast按钮，随便点击几次，此时对应的receiver并没有注册，所以是不会有人响应这两条广播的。然后点击next activity，当打开新的activity后对应的receiver被注册，此时从日志中就能看出已经收到了send stickybroadcast发出的广播，但没有send broadcast发出的广播。这就是sendStickyBroadcast的特别之处，它将发出的广播保存起来，一旦发现有人注册这条广播，则立即能接收到。日志打印为： action = com.android.action.sticky.broadcastand count = 4从上面的日志信息可以看出sendStickyBroadcast只保留最后一条广播，并且一直保留下去，这样即使已经处理了这条广播但当再一次注册这条广播后依然可以收到它。如果你只想处理一遍，removeStickyBroadcast方法可以帮你，处理完了后就将它删除吧。http://blog.csdn.net/yihua0607/article/details/6890805 要知道区别首先需要看一下Android Developers Reference， 它可是我们最好的老师了，sendBroadcast 大家应该都会用了我就不赘述了，下面来看看sendStickyBroadcastgoogle官方的解释是：Perform a sendBroadcast(Intent) that is “sticky,” meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value ofregisterReceiver(BroadcastReceiver, IntentFilter). In all other ways, this behaves the same as sendBroadcast(Intent).You must hold the BROADCAST_STICKY permission in order to use this API. If you do not hold that permission,SecurityException will be thrown.大概的意思是说： 发出的广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。 Activity生命周期http://www.cnblogs.com/zyw-205520/p/3313268.htmlhttps://developer.android.com/guide/components/activities/activity-lifecycle.html#tba 按back键处理流程我们在使用安卓手机时候，常常会用到back（返回）键来退出当前正在使用的Activity。这个事件的主要流程可以概括为两个步骤。 InputReader，InputDispatcher对输入事件的分发处理，包括调用PhoneWindowManager的interceptKeyBeforeDispatching和View，ViewGroup的dispatchTouchEvent等方法。2.事件分发到该Activity后，Activity方法调用finish方法退出，销毁Activity。众多第三方软件常常设置连续两次按下back键退出应用程序的功能，或者是在各浏览器APP中返回上一页浏览过的网页的功能，就是通过重写这一步骤中涉及的方法而实现的。本文分析的是第二步流程，第1步过程将在随后《android输入事件分发机制》一文中进行探讨。由于大部分Activity不会重写onBackPressed()方法，因此它们在接受到back键输入事件后，最终会辗转调用到父类Activity.Java的onBackPressed()方法。http://blog.csdn.net/jakioneplus/article/details/50034653 Android事件分发机制Activity ViewGroup ViewView是所有ViewGroup TextView LinearLayout等的基类LinearLayout/RelativeLayout还有一些可以包含多个TextView、Button等的组装均继承自ViewGroup，因此也是一个viewAndroid事件分发主要是从Activity到ViewGroup到具体某个View响应的过程，事件都是以MotionEvent.ACTION_DOWN事件开始、UP事件结束，中间有无数的MOVE事件。主要是dispatchTouchEvent onTouchEvent onInterceptTouchEvent之间的传递和拦截处理。基本思路是从Activity-&gt;ViewGroup-&gt;View的dispatchTouchEvent一直往下执行，如果有一个返回false那么直接向上返回onTouchEvent执行，如果返回true那么直接消费掉结束，如果不返回那么继续下一层dispatchTouchEvent； 如果到最后一层dispatchTouchEvent还没有返回，那么执行onTouchEvent依次往上执行，如果onTouchEvent返回true，那么就消费掉结束，否则一直向上执行onTouchEvent，到最上层结束。https://www.jianshu.com/p/38015afcdb58查看解析步骤：https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png?imageMogr2/auto-orient/]]></content>
      <categories>
        <category>21Android_review</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>查缺补漏</tag>
        <tag>四大组件</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java关键字50个深度解析]]></title>
    <url>%2Fposts%2Fjvm_art_key_words_learn.html</url>
    <content type="text"><![CDATA[Java关键字列表如下，包含50个关键，所有字符都是小写https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html 基本类型先介绍基本类型关键字如下有关基本类型的解释，主要是整形byte/short/int/long，浮点float/double，字符型char, 布尔值boolean，参考解释https://blog.csdn.net/qwe969153746/article/details/53353534 注意：Java浮点数默认是double， 整形默认是int，另外有一个常量池的缓存也需要注意，还有Integer.valueof()方法是Integer a = 10语句的默认赋值方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 8种基本类型的包装类和对象池 * 包装类：java提供的为原始数据类型的封装类，如：int(基本数据类型)，Integer封装类。 * 对象池：为了一定程度上减少频繁创建对象，将一些对象保存到一个&quot;容器&quot;中。 * * Byte,Short,Integer,Long,Character。这5种整型的包装类的对象池范围在-128~127之间，也就是说， * 超出这个范围的对象都会开辟自己的堆内存。 * * Boolean也实现了对象池技术。Double,Float两种浮点数类型的包装类则没有实现。 * String也实现了常量池技术。 * * 自动装箱拆箱技术 * JDK5.0及之后允许直接将基本数据类型的数据直接赋值给其对应地包装类。 * 如：Integer i = 3;（这就是自动装箱） * 实际编译代码是：Integer i=Integer.valueOf(3); 编译器自动转换 * 自动拆箱则与装箱相反：int i = (Integer)5; */public class Test &#123; public static void main(String[] args) &#123; //基本数据类型常量池范围-128~127 Integer n1 = -129; Integer n2 = -129; Long n3 = 100L; Long n4 = 100L; Double n5 = 12.0; Double n6 = 12.0; //false System.out.println(n1 == n2); //true System.out.println(n3 == n4); //false System.out.println(n5 == n6); //String常量池技术,注意：这里String不是用new创建的对象 String str1 = &quot;abcd&quot;; String str2 = &quot;abcd&quot;; //true System.out.println(str1 == str2); &#125;&#125; //5种整形的包装类Byte,Short,Integer,Long,Character的对象， //在值小于127时可以使用常量池 Integer i1=127; Integer i2=127; System.out.println(i1==i2)//输出true //值大于127时，不会从常量池中取对象 Integer i3=128; Integer i4=128; System.out.println(i3==i4)//输出false //Boolean类也实现了常量池技术 Boolean bool1=true; Boolean bool2=true; System.out.println(bool1==bool2);//输出true //浮点类型的包装类没有实现常量池技术 Double d1=1.0; Double d2=1.0; System.out.println(d1==d2)//输出false char 字符Java语言的一个关键字，用来定义一个字符类型 。 short 短的Java语言的关键字，用来定义一个short类型的变量。 int 整数类型Java(TM)的一个关键字，用来定义一个整形变量Java(TM)的一个关键字，用来定义一系列的方法和常量。它可以被类实现，通过implements关键字。 long 长整型Java语言的一个关键字，用来定义一个long类型的变量。 float 浮点数一个Java语言的关键字，用来定义一个浮点数变量 。 double 双精度型一个Java语言的关键字，用来定义一个double类型的变量 。 ##以下是条件分支和循环语句关键字 for 为了（循环语句）一个Java语言的关键字，用来声明一个循环。程序员可以指定要循环的语句，推出条件和初始化变量。 if 如果Java编程语言的一个关键字，用来生成一个条件测试，如果条件为真，就执行if下的语句。 else 否则一个Java语言的关键字，如果if语句的条件不满足就会执行该语句。 break 跳出一个Java的关键字，用来改变程序执行流程，立刻从当前语句的下一句开始执行从。如果后面跟有一个标签，则从标签对应的地方开始执行 。 case 实例Java语言的关键字，用来定义一组分支选择，如果某个值和switch中给出的值一样，就会从该分支开始执行。 continue 继续一个Java的关键字，用来打断当前循环过程，从当前循环的最后重新开始执行，如果后面跟有一个标签，则从标签对应的地方开始执行。 do一个Java语言的关键字，用来声明一个循环，这个循环的结束条件可以通过while关键字设置 while 一会儿（循环语句）Java语言的一个关键字，用来定义一段反复执行的循环语句。循环的退出条件是while语句的一部分。 关于break和continue。continue语句与break语句相关，但较少用到。continue语句用于使其所在的for、while或do-while语句开始下一次循环。在while与do-while语句中，continue语句的执行意味着立即执行测试部分；在for循环语句中，continue语句的执行则意味着使控制传递到增量部分。 以下是异常处理机制 throw 投、抛Java语言的关键字，允许用户抛出一个exception对象或者任何实现 throwable的对象throws 声明抛弃异常Java语言的关键字，用在方法的声明中来说明哪些异常这个方法是不处理的，而是提交到程序的更高一层。 try 尝试、审判Java语言的关键字，用来定义一个可能抛出异常语句块。如果一个异常被抛出，一个可选的catch语句块会处理try语句块中抛出的异常。同时，一个finally语句块会被执行，无论一个异常是否被抛出。 catch 捕捉Java的一个关键字，用来声明当try语句块中发生运行时错误或非运行时异常时运行的一个块。 finally 最后一个Java语言的关键字，用来执行一段代码不管在前面定义的try语句中是否有异常或运行时错误发生。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package test; //jdk 1.8 public class TestException1 &#123; /** * catch中的return和throw是不能共存的(无论谁先谁后都编译不通过) * 如果只throw e，则必须try-catch捕捉异常e或用throws抛出异常e * 如果只return ，则在catch段正常返回值 */ int testEx0()&#123; boolean ret = true; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return 0; &#125; catch (Exception e) &#123; System.out.println(&quot;testEx, catch exception&quot;); ret = false; return -1; throw e; &#125; &#125; /** * 在finally中的return和throw是不能共存的(无论谁先谁后都编译不通过) * 如果只throw e，则必须try-catch捕捉异常e或用throws抛出异常e * 如果只return ，则在catch段正常返回值 */ int testEx00()&#123; int ret = 0; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return ret; &#125; catch (Exception e) &#123; System.out.println(&quot;testEx, catch exception&quot;); ret = -1; &#125;finally&#123; ret = 1; System.out.println(&quot;testEx, finally; return value=&quot; + ret); throw e; return ret; &#125; &#125; /** * 结果： testEx, catch exception testEx, finally; return value=false false 结论：在finally里没有return的时候：先执行finally的语句，再执行catch的return */ boolean testEx01()&#123; boolean ret = true; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return true; &#125; catch (Exception e) &#123; System.out.println(&quot;testEx, catch exception&quot;); ret = false; return ret; &#125;finally&#123; System.out.println(&quot;testEx, finally; return value=&quot; + ret); &#125; &#125; /** * 结果： * testEx, catch exception testEx, finally; return value=1 1 结论：在finally里有return的时候：先执行finally的语句和return，忽略catch的return */ int testEx02()&#123; int ret = 0; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return ret; &#125; catch (Exception e) &#123; ret = -1; System.out.println(&quot;testEx, catch exception&quot;); return ret; &#125;finally&#123; ret = 1; System.out.println(&quot;testEx, finally; return value=&quot; + ret); return ret; &#125; &#125; /** * 编译能通过， * 但运行时抛异常（当然也没有返回值） * @return */ boolean testEx03()&#123; boolean ret = true; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return true; &#125; catch (Exception e) &#123; System.out.println(&quot;testEx, catch exception&quot;); ret = false; throw e; &#125;finally&#123; System.out.println(&quot;testEx, finally; return value=&quot; + ret); &#125; &#125; /** * 编译不能通过（必须加throws主动抛异常，或try-catch捕捉，） * 但运行时抛异常（当然也没有返回值） * @return * @throws Exception */ boolean testEx031()&#123; boolean ret = true; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return true; &#125; catch (Exception e) &#123; System.out.println(&quot;testEx, catch exception&quot;); ret = false; throw new Exception(e); &#125;finally&#123; System.out.println(&quot;testEx, finally; return value=&quot; + ret); &#125; &#125; /** * 结果： * testEx, catch exception testEx, finally; return value=1 1 结论： 函数在finally里正常返回return的值，无异常，显然catch中的throw被忽略 */ int testEx04()&#123; int ret = 0; try &#123; int c = 12 / 0; System.out.println(&quot;testEx,successfully&quot;); return ret; &#125; catch (Exception e) &#123; System.out.println(&quot;testEx, catch exception&quot;); ret = -1; throw e; &#125;finally&#123; ret = 1; System.out.println(&quot;testEx, finally; return value=&quot; + ret); return ret; &#125; &#125; public static void main(String[] args) &#123; try &#123; System.out.println(new TestException1().testEx0()); //System.out.println(new TestException1().testEx00()); //System.out.println(new TestException1().testEx01()); //System.out.println(new TestException1().testEx02()); //System.out.println(new TestException1().testEx03()); //System.out.println(new TestException1().testEx031()); //System.out.println(new TestException1().testEx04()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 以下是类或这变量的权限控制 private 私有的Java语言的一个关键字，用在方法或变量的声中。它表示这个方法或变量只能被这个类的其它元素所访问。 protected 保护类型Java语言的一个关键字，在方法和变量的声明中使用，它表示这个方法或变量只能被同一个类中的，子类中的或者同一个包中的类中的元素所访问。 public 公共的Java语言的一个关键字，在方法和变量的声明中使用，它表示这个方法或变量能够被其它类中的元素访问。 以下修饰字段变量的关键字 final 最终、不可更改的一个Java语言的关键字。你只能定义一个实体一次，以后不能改变它或继承它。更严格的讲：一个final修饰的类不能被子类化，一个final修饰的方法不能被重写，一个final修饰的变量不能改变其初始值。 volatile 挥发性、易挥发的Java语言的关键字，用在变量的声明中表示这个变量是被同时运行的几个线程异步修改的。volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。 static 静态的Java语言的关键字，用来定义一个变量为类变量。类只维护一个类变量的拷贝，不管该类当前有多少个实例。”static” 同样能够用来定义一个方法为类方法。类方法通过类名调用而不是特定的实例，并且只能操作类变量。 transient 短暂的、瞬时的Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 synchronized同步控制简单来说原理是 synchronized修饰对象或类重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（在 Synchronized 代码块中的监视器 ）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。 有monitorenter和monitorexit的操作 synchronized修饰方法当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有 monitor ， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor 轻量级锁和重量级锁轻量级锁。他的基本思想是，当线程要获取锁时把锁对象的 Mark Word 复制一份到当前线程的栈顶，然后执行一个 CAS 操作把锁对象的 Mark Word 更新为指向栈顶的副本的指针，如果成功则当前线程拥有了锁。偏向锁。获取的过程如下，当锁对象第一次被线程获取的时候，虚拟机把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中的偏向线程ID，并将是否偏向锁的状态位置置为1。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，直接检查ThreadId是否和自身线程Id一致，如果一致，则认为当前线程已经获取了锁，虚拟机就可以不再进行任何同步操作（例如Locking、Unlocking及对Mark Word的Update等）。详见原理： https://www.jianshu.com/p/ce4f5e43e0a8?utm_campaign=haruki&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=weixin 其他关键字 this 这个Java语言的关键字，用来代表它出现的类的一个实例。this可以用来访问类变量和类方法。 void 空Java语言的关键字，用在Java语言的方法声明中说明这个方法没有任何返回值。”void”也可以用来表示一句没有任何功能的语句。 return 返回Java语言的一个关键字，用来结束一个方法的执行。它后面可以跟一个方法声明中要求的值。 import 导入Java(TM)编程语言的一个关键字，在源文件的开始部分指明后面将要引用的一个类或整个包，这样就不必在使用的时候加上包的名字。 implements 实现Java(TM)编程语言的一个关键字，在类的声明中是可选的，用来指明当前类实现的接口。 tm=tradeMark（Java商标的意思） Abstract 抽象的一个Java语言中的关键字，用在类的声明中来指明一个类是不能被实例化的，但是可以被其它类继承。一个抽象类可以使用抽象方法，抽象方法不需要实现，但是需要在子类中被实现 。多态实现原理参考：从虚拟机角度看Java多态-&gt;（重写override）的实现原理https://www.cnblogs.com/2014asm/p/8633660.html instanceof 判断对象类型一个二操作数的Java(TM)语言关键字，用来测试第一个参数的运行时类型是否和第二个参数兼容。]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>deep learn</tag>
        <tag>key words</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android查缺补漏-常用工具]]></title>
    <url>%2Fposts%2Fandroid_review_android_tools_adb.html</url>
    <content type="text"><![CDATA[ProguarduseProguard minifyEnabledhttps://developer.android.com/studio/build/shrink-code.html?hl=zh-cn minifyEnabled true proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ 除了 minifyEnabled 属性外，还有用于定义 ProGuard 规则的 proguardFiles 属性： getDefaultProguardFile(‘proguard-android.txt’) 方法可从 Android SDK tools/proguard/ 文件夹获取默认的 ProGuard 设置。提示：要想做进一步的代码压缩，请尝试使用位于同一位置的 proguard-android-optimize.txt 文件。它包括相同的 ProGuard 规则，但还包括其他在字节码一级（方法内和方法间）执行分析的优化，以进一步减小 APK 大小和帮助提高其运行速度。 proguard-rules.pro 文件用于添加自定义 ProGuard 规则。默认情况下，该文件位于模块根目录（build.gradle 文件旁）。 https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html 资源压缩请在 build.gradle 文件中将 shrinkResources 属性设置为 true自定义要保留的资源如果您有想要保留或舍弃的特定资源，请在您的项目中创建一个包含 标记的 XML 文件，并在 tools:keep 属性中指定每个要保留的资源，在 tools:discard 属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。您可以使用星号字符作为通配符。 例如：&lt;?xml version=”1.0” encoding=”utf-8”?&gt; 将该文件保存在项目资源中，例如，保存在 res/raw/keep.xml。构建不会将该文件打包到 APK 之中。 Framework.jar 非dex的编译方式in Android M, you can achieve that by using LOCAL_JACK_ENABLED = disabled variable in your makefile.In Android N it is more tricky…it is broken and the solution to this is yet to come in AOSP mainline of Android N.Solution is available in master.Checked in 7.1.1 Android N.You need to make use of javac-check target. This has been implemented for this purpose.make javac-check-$(LOCAL_MODULE)So, if your module name is “ABCD”make javac-check-ABCDThis generates a classes-full-debug.jar, in the common\obj\JAVA_LIBRARIES\ABCD_intermediates.This is the jar which you can use in your Studio environment.Most important, this solution is not yet visible in any of the tags on Android N branch. It is part of the master hence you need to add this solution to your branch manually.https://android.googlesource.com/platform/build/+/32bd0adf9c5dcd1560d77bdb886c7acc78496657来自 https://groups.google.com/forum/#!topic/android-building/gRuDxqEB1H8 AM常见的用法我们可以通过命令启动android中的Activity，Service，BroadcastReceiver 等组件 拨打一个电话： am start -a android.intent.action.CALL -d tel:10086 这里-a表示动作，-d表述传入的数据，还有-t表示传入的类型。 打开一个网页： am start -a android.intent.action.VIEW -d http://www.baidu.com （这里-d表示传入的data） 打开音乐播放器： am start -a android.intent.action.MUSIC_PLAYER 或者 am start -n com.android.music/om.android.music.MusicBrowserActivity 启动一个服务： am startservice &lt;服务名称&gt; 例如：am startservice -n com.android.music/com.android.music.MediaPlaybackService (这里-n表示组件) 或者 am startservice -a com.smz.myservice (这里-a表示动作，就是你在Androidmanifest里定义的) 发送一个广播： am broadcast -a &lt;广播动作&gt; 例如： am broadcast -a com.smz.mybroadcast am还有很多的用法，有待研究。 来自 http://blog.csdn.net/electricity/article/details/6409354]]></content>
      <categories>
        <category>21Android_review</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架源码设计模式]]></title>
    <url>%2Fposts%2Fdesign_pattern_libs_source_dp.html</url>
    <content type="text"></content>
      <categories>
        <category>02DesignPattern</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>设计模式</tag>
        <tag>DesignPattern</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andriod源码设计模式]]></title>
    <url>%2Fposts%2Fdesign_pattern_android_source_dp.html</url>
    <content type="text"><![CDATA[简要说明Android中设计模式，以加深对设计的理解。 工厂方法模式： 接口 Iterable 中的 iterator 就是一个工厂方法， Activity 中的 onCreate 也可以看作是工厂方法 抽象工厂模式： MediaPlayerFactory 是一个抽象工厂 单例模式： 单例模式的应用非常广泛， Application 就是单例的， WindowManagerService 、 ActivityService 等系统级的 Service 也是单例的，具体可见 单例模式 建造者模式 ：建造者模式在图片加载库中使用非常普遍，例如 Picasso 、 Glide 、UniversalImageLoader 中都有建造者模式的身影。在 Android 源码中 AlertDialog 中应用了建造者模式，详见 设计模式之 Builder 模式 原型模式：原型模式就是实现接口 Cloneable ，这个太多了。。。 适配器模式：这个不用说了， AbsListView 和 RecyclerView 都使用了适配器模式。详见：设计模式之适配器模式 装饰器模式：Context 、 ContextImpl 、 ContextWrapper 、ContextThemeWrapper 代理模式： AIDL ，ActivityProxy（其实这也是 AIDL ） 外观模式：Context 作为 Android 系统中的上帝类，封装了很多功能，这也是外观模式的应用 桥接模式：Adapter 与 AdapterView 的桥接，Window 与 WindowManager 的桥接 详见：设计模式之桥接模式 组合模式： View 、 ViewGroup 享元模式：Message 中的 MessagePool 是用链表实现的。 策略模式：动画中的 InterPolator 和 TypeEvaluator 。详见Android 动画分析 模板方法模式: 模板模式的应用非常广泛， Android 中 AsyncTask 的几个回调可以看作模板。 观察者模式： AbsListView 和 RecyclerView 都使用了观察者模式，详见设计模式之观察者模式 迭代子模式： 这个不用说了，在 JDK 中的集合类都是迭代子模式。 责任链模式： View 中对于事件的分发处理可以看作是责任链模式。详见利用责任链模式实现加载不同来源的数据 命令模式： Android 事件的底层 NotifyArgs 就是一个命令对象。 备忘录模式： Android 的状态保存， onSaveInstanceState 、 onRestoreInstaceState 状态模式： WIFI 管理 访问者模式： Java 注解 APT 中介者模式： KeyGuard 功能的实现 解释器模式： PackageParser 中有解释器模式的影子 Copy fromhttp://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/]]></content>
      <categories>
        <category>02DesignPattern</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码</tag>
        <tag>设计模式</tag>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码设计模式]]></title>
    <url>%2Fposts%2Fdesign_pattern_JDK_source_dp.html</url>
    <content type="text"><![CDATA[创建型模式抽象工厂模式(通过创建的方法返回工厂本身, 可以依次创建另一个抽象/接口类型)javax.xml.parsers.DocumentBuilderFactory#newInstance()javax.xml.transform.TransformerFactory#newInstance()javax.xml.xpath.XPathFactory#newInstance() 生成器模式(通过创建的方法返回实例本身)java.lang.StringBuilder#append() (非同步的)java.lang.StringBuffer#append() (支持同步)java.nio.ByteBuffer#put() (与之相同的有: CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer 和 DoubleBuffer)javax.swing.GroupLayout.Group#addComponent()java.lang.Appendabled 的所有实现 工厂模式(通过创建的方法返回一个抽象/接口类型的实现)java.util.Calendar#getInstance()java.util.ResourceBundle#getBundle()java.text.NumberFormat#getInstance()java.nio.charset.Charset#forName()java.net.URLStreamHandlerFactory#createURLStreamHandler(String)(按协议返回单例对象) 原型模式(通过创建的方法返回一个包含相同属性的不同实例)java.lang.Object#clone() (类必须实现 java.lang.Cloneable) 单例模式(通过创建的方法在任何时间都返回一个相同实例(通常是它本身))java.lang.Runtime#getRuntime()java.awt.Desktop#getDesktop() 结构型模式适配器模式(接收不同抽象或接口类型的一个实例, 并返回一个装饰或重写了该实例的本身/其他的抽象/接口类型的指定实现)java.util.Arrays#asList()java.io.InputStreamReader(InputStream) (返回一个Reader)java.io.OutputStreamWriter(OutputStream) (返回一个Writer)javax.xml.bind.annotation.adapters.XmlAdapter#marshal() 和 #unmarshal() 桥接模式(接收不同抽象或接口类型的一个实例, 并返回一个委托或使用了该实例的本身/其他的抽象/接口类型的指定实现)一时之间没有想到. 一个虚构的例子: new LinkedHashMap(LinkedHashSet, List)返回一个不可变的链式map, 并且不会克隆内部元素而是直接使用他们. java.util.Collections#newSetFromMap() 和 singletonXXX()方法是有些接近这个模式的. 组合模式(通过行为式的方法接收一个相同的抽象或接口类型的实例转换为一个树状结构)java.awt.Container#add(Component) (几乎所有Swing都是这样)javax.faces.component.UIComponent#getChildren() (几乎所有JSF UI都是这样) 装饰器模式(通过创建的方法接收一个相同的抽象或接口类型的实例, 并添加附加的行为)java.io.InputStream, OutputStream, Reader 和 Writer的子类拥有一个持有相同类型的实例构造器.java.util.Collections, checkedXXX(), synchronizedXXX() 和 unmodifiableXXX().javax.servlet.http.HttpServletRequestWrapper 和 HttpServletResponseWrapper 门面模式(通过行为式的方法实现, 该方法内部使用不同的独立的抽象或接口类型的实例)javax.faces.context.FacesContext, 它内部之间使用 LifeCycle, ViewHandler, NavigationHandler 和很多无需最终能够用户关心的抽象/接口类型(可通过注入覆写).javax.faces.context.ExternalContext, 它内部使用ServletContext, HttpSession, HttpServletRequest, HttpServletResponse等. 享元模式(通过创建的方法返回一个缓存的实例, 有一些”多例”的思想)java.lang.Integer#valueOf(int) (类似的还包括: Boolean, Byte, Character, Short 和 Long) 代理模式(通过创建的方法返回指定的抽象或接口类型的实现, 该实现依次委托或使用了指定抽象或接口类型的不同实现)java.lang.reflect.Proxyjava.rmi.*下所有API. ##行为型模式 责任链模式(通过行为方法(间接地)在一个队列中调用另一个相同抽象/接口类型的相同方法)java.util.logging.Logger#log()javax.servlet.Filter#doFilter() 命令模式(一个抽象/接口类型内的行为方法中, 调用一个不同的象/接口类型的实现的方法, 该实现已经在其创建过程中被命令实现封装)java.lang.Runnable的所有实现javax.swing.Action的所有实现 解释器模式(行为方法返回一个有结构的并且与被提供的实例/类型不同的实例/类型; 注意parsing/formatting不是这个模式的组成部分, 而是用来确定该模式以及如何应用模式)java.util.Patternjava.text.Normalizerjava.text.Format的所有子类javax.el.ELResolver的所有子类 迭代器模式(行为方法按顺序的自一个队列中返回不同类型的实例)java.util.Iterator的所有实现 (除此以外, 还有 java.util.Scanner!).java.util.Enumeration的所有实现 中介者模式(行为方法接收一个不同抽象/接口类型的实例(通常使用命令模式), 该实例委托或使用了指定实例)java.util.Timer (所有 scheduleXXX() 方法)java.util.concurrent.Executor#execute()java.util.concurrent.ExecutorService (invokeXXX() 和 submit() 方法)java.util.concurrent.ScheduledExecutorService (所有 scheduleXXX() 方法)java.lang.reflect.Method#invoke() 备忘录模式(行为方法内部改变了整个实例的状态)java.util.Date ( setter 方法就是这么做的, Date 内部通过长整型long表示)java.io.Serializable的所有实现javax.faces.component.StateHolder的所有实现观察者或发布/订阅模式(行为方法在另一个抽象/接口类型的实例上调用方法, 并取决于自身状态)java.util.Observer/java.util.Observable (在现实世界中很少使用)java.util.EventListener 的所有实现 (几乎所有的Swing都是这样)javax.servlet.http.HttpSessionBindingListenerjavax.servlet.http.HttpSessionAttributeListenerjavax.faces.event.PhaseListener 状态模式(行为方法通过外部可控的实例状态改变它的行为)javax.faces.lifecycle.LifeCycle#execute() (通过FacesServlet控制, 行为取决于当前JSF生命周期的阶段(状态) 策略模式(行为方法内一个抽象/接口类型调用不同抽象/接口类型的不同实现内的方法, 该实现以方法参数型式被传进策略实现内)java.util.Comparator#compare(), 在Collections#sort()中执行.javax.servlet.http.HttpServlet, service() 和所有 doXXX() 方法接收 HttpServletRequest, HttpServletResponse, 并且实现者必须处理它们(而不是作为实例变量持有它们)javax.servlet.Filter#doFilter() 模板模式(行为方法已拥有一个被抽象类型定义的”默认”行为)java.io.InputStream, java.io.OutputStream, java.io.Reader 和 java.io.Writer 的所有非抽象方法.java.util.AbstractList, java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法.javax.servlet.http.HttpServlet, 所有 doXXX() 方法默认发送 HTTP 405 “Method Not Allowed” 错误到响应中. 你可以任意实现这些方法. 访问者模式(两个不同的抽象/接口类型中包含互相接收对方抽象/接口类型的方法; 实际调用的是另一个类型的方法和它上面的其他执行所需求的策略)javax.lang.model.element.AnnotationValue 和 AnnotationValueVisitorjavax.lang.model.element.Element 和 ElementVisitorjavax.lang.model.type.TypeMirror 和 TypeVisitor]]></content>
      <categories>
        <category>02DesignPattern</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>设计模式</tag>
        <tag>DesignPattern</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式经典书籍推荐]]></title>
    <url>%2Fposts%2Fdesign_pattern_books_recommand.html</url>
    <content type="text"><![CDATA[#书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 设计模式设计模式之禅（第2版）大话设计模式Android源码设计模式解析与实战Java设计模式经典搞笑珍藏版 源码Github源码https://github.com/iluwatar/java-design-patterns]]></content>
      <categories>
        <category>02DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>汇总</tag>
        <tag>分析精华</tag>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM和ART经典书籍推荐]]></title>
    <url>%2Fposts%2Fjvm_art_book_recommand.html</url>
    <content type="text"><![CDATA[#书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 #Java虚拟机深入理解Java虚拟机：JVM高级特性与最佳实践自己动手写Java虚拟机 (Java核心技术系列)Java虚拟机精讲HotSpot实战深入java虚拟机第二版 #Dalvik-ART虚拟机Android Dalvik 虚拟机结构及机制剖析深入解析Android 虚拟机]]></content>
      <categories>
        <category>03JVM&amp;ART</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>JVM</tag>
        <tag>ART</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式分析精华]]></title>
    <url>%2Fposts%2Fdesign_pattern_list_anylysis.html</url>
    <content type="text"><![CDATA[设计模式http://java-design-patterns.com/patterns/https://gof.quanke.name/http://vivianking6855.github.io/2017/12/14/Design_Pattern/http://yuanfentiank789.github.io/2016/06/20/java_principle/https://fangjian0423.github.io/2017/03/26/design-pattern/https://zeshaoaaa.github.io/%E5%9B%BE%E8%A7%A3-Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ 原则 开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle原则是尽量使用合成/聚合的方式，而不是使用继承。 分类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式 关系和对比 实践JDK中的设计模式https://clarkdo.js.org/design%20patterns%20stories/2014/10/20/46/https://blog.csdn.net/lovelion/article/details/8765177http://www.cnblogs.com/octobershiner/articles/2236843.html Andriod源码设计模式https://pgzxc.github.io/2017/12/24/Android%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/http://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/https://wdpm.github.io/20160327/android-common-design-patterns/ 常见框架中设计模式]]></content>
      <categories>
        <category>02DesignPattern</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>汇总</tag>
        <tag>分析精华</tag>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2Fposts%2Fds_algo_tree.html</url>
    <content type="text"><![CDATA[AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？https://www.zhihu.com/question/30527705 从B树、B+树、B*树谈到R 树http://blog.csdn.net/v_JULY_v/article/details/6530142/ B树、B-树、B+树、B*树 定义https://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html AVL树：https://zh.wikipedia.org/wiki/AVL%E6%A0%91特点在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的o(n)复杂度。旋转以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。点数计算 ##伸展树Splay：https://blog.csdn.net/u014634338/article/details/49586689http://www.cnblogs.com/skywang12345/p/3604286.htmlhttps://www.cnblogs.com/kuangbin/archive/2012/10/07/2714068.html背景和特点考虑到局部性原理（刚被访问的内容下次可能仍会被访问，查找次数多的内容可能下一次会被访问），为了使整个查找时间更小，被查频率高的那些节点应当经常处于靠近树根的位置。这样，很容易得想到以下这个方案：每次查找节点之后对树进行重构，把被查找的节点搬移到树根，这种自调整形式的二叉查找树就是伸展树。每次对伸展树进行操作后，它均会通过旋转的方法把被访问节点旋转到树根的位置。特点是不会保证树一直是平衡的，被访问节点旋转到树根，我们通常将节点自底向上旋转，直至该节点成为树根为止。“旋转”的巧妙之处就是在不打乱数列中数据大小关系（指中序遍历结果是全序的）情况下，所有基本操作的平摊复杂度仍为O（log n） 旋转思路参考https://blog.csdn.net/u014634338/article/details/49586689 效率对比伸展树(splay tree)，它对于m次连续搜索操作有很好的效率。伸展树会在一次搜索后，对树进行一些特殊的操作。这些操作的理念与AVL树有些类似，即通过旋转，来改变树节点的分布，并减小树的深度。但伸展树并没有AVL的平衡要求，任意节点的左右子树可以相差任意深度。与二叉搜索树类似，伸展树的单次搜索也可能需要n次操作。但伸展树可以保证，m次的连续搜索操作的复杂度为mlog(n)的量级，而不是mn量级。https://www.cnblogs.com/wxgblogs/p/5506234.html 优势可靠的性能——它的平均效率不输于其他[平衡树]存储所需的内存少——伸展树无需记录额外的什么值来维护树的信息，相对于其他平衡树，内存占用要小。由于Splay Tree仅仅是不断调整，并没有引入额外的标记，因而树结构与标准红黑树没有任何不同，从空间角度来看，它比Treap、SBT、AVL要高效得多。因为结构不变，因此只要是通过左旋和右旋进行的操作对Splay Tree性质都没有丝毫影响，因而它也提供了BST中最丰富的功能，包括快速的拆分和合并，并且实现极为便捷。这一点是其它结构较难实现的。其时间效率也相当稳定，和Treap基本相当，常数较高。 缺点伸展树最显著的缺点是它有可能会变成一条。这种情况可能发生在以非降顺序访问n个元素之后。然而均摊的最坏情况是对数级的——O(logn) treap树https://blog.csdn.net/chen_tr/article/details/50924073https://blog.csdn.net/u014634338/article/details/49612159https://blog.csdn.net/yang_yulei/article/details/46005845特点和背景Treap，顾名思义就是Tree+Heap。这么命名的原因就是它使用了二叉堆的性质来保持二叉树的平衡。我们知道，一个二叉（大根）堆满足这样的性质：一个节点的两个儿子的值都小于节点本身的值。如果一个二叉查找树满足这样的性质，那么它就被称作Treap。 Treap并不是二叉堆，二叉堆必须是完全二叉树，而Treap可以并不一定是。但是等等，这样的设定似乎和二叉查找树矛盾啊。一个要求节点值小于右儿子的值，一个要求节点值大于右儿子的值，这显然是不可能做到的。只有一种方法能够解决，就是让每个节点有2个值，其中一个满足二叉查找树的性质，一个满足大根堆的性质。为方便起见，下面把满足二叉查找树性质的值称作key，把满足大根堆性质的值称作prio（priority的简称）。每个节点的key我们是无法改变了，为了保证Treap的平衡性，我们需要在prio上做一点文章。其实也没有什么复杂的，就是让每个节点的prio都取一个随机值，这样我们就可以保证这棵树“基本平衡”。 旋转分类：左旋转和右旋转方法：一般先按照二叉查找方法，找到对应节点的位置，随机选取一个prio值，如果此时不满足堆得特性，那么就进行旋转 SBTree树http://www.cnblogs.com/gtarcoder/p/4724288.htmlhttps://blog.csdn.net/murmured/article/details/17029131https://www.cnblogs.com/zgmf_x20a/archive/2008/11/14/1333205.html 特点 Size Balanced Tree(SBT)是目前速度最快的平衡二叉搜索树，且能够进行多种搜索操作，区间操作；和AVL、红黑树、伸展树、Treap类似，SBT也是通过对节点的旋转来维持树的平衡，而相比其他平衡树，SBT维持平衡所需要的额外数据很少，只需要维持以当前节点为根的子树的大小；且SBT的编写复杂度低。因此具有空间优势、速度优势、编写优势。 RBTree 红黑树http://www.cnblogs.com/Lynn-Zhang/p/5653943.htmlhttps://tech.meituan.com/redblack-tree.htmlhttps://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.mdhttp://www.cnblogs.com/skywang12345/p/3245399.html 特点黑树的查找、插入、删除的时间复杂度最坏为O(log n)123451）每个结点要么是红的，要么是黑的。 2）根结点是黑的。 3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。 4）如果一个结点是红的，那么它的俩个儿子都是黑的。 5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 旋转和着色变换基本操作是左旋转和右旋转。http://www.cnblogs.com/Lynn-Zhang/p/5653943.html 算法复杂度证明 证明：一棵有 n 个内部节点的红黑树的高度至多为 2lg(n+1) 最长路径至多是最短路径的两倍 内部节点最多，内部节点最少 参考：https://blog.csdn.net/lanchunhui/article/details/75905478 B+树 R树AVL树，红黑树，B树，B+树，Trie树都分别应用在哪些现实场景中？https://www.zhihu.com/question/30527705从B树、B+树、B树谈到R 树http://blog.csdn.net/v_JULY_v/article/details/6530142/B树、B-树、B+树、B树 定义https://www.cnblogs.com/oldhorse/archive/2009/11/16/1604009.html 区间树二叉堆大根堆，小根堆 Trie树前缀树，后缀树]]></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2Fposts%2Fds_algo_dynamic.html</url>
    <content type="text"></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和链表]]></title>
    <url>%2Fposts%2Fds_algo_array_linklist.html</url>
    <content type="text"><![CDATA[数组和链表https://www.cnblogs.com/cici-new/archive/2013/08/04/3237276.html 三大数据结构的实现方式 数据结构 实现方式 栈 数组/单链表 队列 数组/双端链表 优先级队列 数组/堆/有序链表 双端队列 双向链表 数组单链表双端链表双向链表Java单链表、双端链表、有序链表实现http://blog.csdn.net/a19881029/article/details/22695289]]></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组和链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2Fposts%2Fds_algo_graph.html</url>
    <content type="text"></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代递归]]></title>
    <url>%2Fposts%2Fds_algo_recursion_iter.html</url>
    <content type="text"><![CDATA[解释器模式四则运算符=&gt;运算解释四则运算符=&gt;二叉树 递归https://blog.csdn.net/benweizhu/article/details/7730473https://blog.csdn.net/nkuhjp/article/details/53365036 迭代https://www.cnblogs.com/xiaobingqianrui/p/8894253.html]]></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>迭代递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2Fposts%2Fds_algo_complex_analyse.html</url>
    <content type="text"><![CDATA[算法重要特性 确定性: 算法中每一种运算都是确定的，有明确的定义，运算执行是清楚得无二义。 能行性: 每一种运算能由人用纸和笔在有限的时间内完成。 输入：算法有0或多个输入，算法开始前提前给出 输出：算法又一个或多个输出，同输入又某种特定的关系 有穷性： 总是在执行有穷步得运算后终止 凡是算法必须满足以上5中特性 算法的主要内容 如何设计算法 如何表示算法 (Spark等算法描述语言) 如何确认算法 (合法得输入可以得到正确得结果) 如何分析算法 (计算时间和存储空间定量分析) 如何测试程序 (调试和作时空分布图，调试只能指出错误，但不能证明他们不存在错误；做时空分布图用各种数据执行调试来确认算法得正确性，准确的计算出结果所需要花费得时间和空间。) 分析算法算法的时间复杂度： 复杂度计算时，基本运算定义为加减乘除，均为固定常数时间 多项式复杂度 1 &lt; log(n) &lt; n &lt; nlog(n) &lt; n^2 &lt; n^3 指数级复杂度 2^n &lt; n! &lt; n^n 当数量级增大时指数级复杂度增长迅速，所以应尽可能降低为多项式复杂度以节省运算时间。 logn n nlogn n^2 n^3 2^n 0 1 0 1 1 2 1 2 2 4 8 4 2 4 8 16 64 16 4 16 64 256 4096 65536 5 32 160 1024 32768 4294967296 算法时间表示：上界(最坏)、下界(最好)、平均 几个计算复杂度得例子：]]></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构详解]]></title>
    <url>%2Fposts%2Fds_algo_details.html</url>
    <content type="text"><![CDATA[数据结构和算法以weiss的数据结构和算法，以及算法导论为纲，另外参考July和左程云的书籍和代码。 https://github.com/julycoding/The-Art-Of-Programming-By-July 数据结构数组链表http://www.cnblogs.com/wangyingli/p/5928258.htmlhttp://www.cnblogs.com/flash610/archive/2013/05/14/3078251.htmlhttps://blog.csdn.net/u010275850/article/details/46011951https://blog.csdn.net/ajian005/article/details/53196224https://blog.csdn.net/judyge/article/details/42396079可分为：单链表，双向链表，双端链表，循环链表。双向和双端区别：https://blog.csdn.net/qq_29606255/article/details/76408285 数据结构 实现方式 栈 数组/单链表 队列 数组/双端链表 优先级队列 数组/堆/有序链表 双端队列 双向链表 栈Stack、队列Queue栈比较简单：Stack，LinkedList等队列几种特殊的：https://blog.csdn.net/beautiful_face/article/details/76693412https://blog.csdn.net/u011983531/article/details/78651466https://www.cnblogs.com/lemon-flm/p/7877898.htmlQueue的实现 没有实现的阻塞接口的LinkedList： 实现了java.util.Queue接口和java.util.AbstractQueue接口 内置的不阻塞队列： PriorityQueue 和 ConcurrentLinkedQueue PriorityQueue 和 ConcurrentLinkedQueue 类在 Collection Framework 中加入两个具体集合实现。 PriorityQueue 类实质上维护了一个有序列表。加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable 实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。 ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大 小， ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。 实现阻塞接口的： java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。五个队列所提供的各有不同： ArrayBlockingQueue ：一个由数组支持的有界队列。 LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。 PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。 DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。 * SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。 优先队列(堆)https://www.cnblogs.com/wuchanming/p/3809496.html可分为：二叉堆，d-堆，左式堆，斜堆，二项队列 跳表https://www.cnblogs.com/a8457013/p/8251967.html 树树的分类https://zh.wikipedia.org/wiki/AVL%E6%A0%9112345678910- 二叉树 **二叉查找树（BST）** 笛卡尔树 MVP树 Top tree T树- 自平衡二叉查找树 AA树 **AVL树** 左倾红黑树 **红黑树** 替罪羊树 **伸展树** 树堆 加权平衡树- B树 **B+树** B*树 Bx树 UB树 2-3树 2-3-4树 (a,b)-树 Dancing tree H树- 堆 **二叉堆** 二项堆 斐波那契堆 左偏树 配对堆 斜堆 Van Emde Boas tree- Trie **后缀树** 基数树 三叉查找树 X-快速前缀树 Y-快速前缀树 以上标黑的为重点关注项AVL树：https://zh.wikipedia.org/wiki/AVL%E6%A0%91伸展树Splay:Treap树：SBTree树RBTree树B树R树区间树二叉堆Trie树 图图的分类http://www.cnblogs.com/wangyingli/p/5974508.htmlhttps://blog.csdn.net/xujingzhou/article/details/79874835 图算法https://blog.csdn.net/simanstar/article/details/78906825https://blog.csdn.net/wsh6759/article/details/7008407https://blog.csdn.net/gqtcgq/article/details/45618279 最短路径的Floyd算法拓扑排序union-find算法无环加权有向图的最短路径算法关键路径计算无向图中连通分量的Kosaraju算法有向图中含必经点的最短路径问题TSP问题还有A*算法 散列算法查找算法http://www.cnblogs.com/wangyingli/p/5994282.html 排序算法http://www.cnblogs.com/wangyingli/p/5994256.html 分治算法贪心算法动态规划回溯算法随机化算法方案设计1.分治法： 将问题分成单独的阶段，每个阶段互相不干扰很独立，如10米长的木棍，切成10段，每段去解决每一段的问题。（阶段没有关系） 2.贪心法 站在全局的角度，也是将问题堪称分为多个阶段，只不过阶段和阶段之间有一定的递进关系，如从5毛，1元，2毛，1毛，2元中，去找最少的钱币构成10块钱。首先是站在全局的角度，先从中取其最大值，为第一阶段，然后在从剩余的当中在找最大值，构成第二阶段。。。。。。如此往复，这就是贪心法。 3.动态规划 是阶段和阶段之间有重复，举例说明：求一个数组的最长递增子序列。假设数组有10个元素，那么如何求解呢？将10个元素划分成10个阶段，第一个阶段，从第一个元素中求解，第二个阶段在第一个阶段求其解，第三个阶段在第一个，第二个阶段综合的基础上求解，第四个阶段在第1,2,3个阶段求其解，最后。。。。第k个阶段在第1,2....k-1个阶段求其最优解。 4.递归算法 个人感觉和动态规划反着来的样子，有点像，问题规模为10，转化为问题规模为9的问题，，问题规模为9的问题，转化为8.。。。。。 5.回溯法和分支限界法 都属于组合优化问题，就是按照过程向下面去寻找最优解，在寻找最优解的过程，不断的剪取枝条，来减少搜索情况。不行就换思路。 递推，搜索，贪心和动态规划的思想都是通过拆分问题，定义状态和状态之间的关系，从而最初阶段的状态到达最终状态的方式解决问题。 每个阶段只有一个状态－&gt;递推 每个阶段的所有状态都计算出来，从中选取最优的－&gt;搜索 每个阶段的最优状态都是由上一个阶段的最优状态得到的－&gt;贪心 每个阶段的最优状态可以从之前的某个阶段的某个（或某些）状态直接得到－&gt;动态规划 一个问题会有多种状态的定义和阶段的划分，某一种定义有后效性不代表该问题不适合用哪种方法。 贪心，动归这类的问题本质都是对搜索的剪枝 适用于哪种方法来解决，在于你怎么看待这个世界～ https://segmentfault.com/a/1190000006022019#articleHeader11]]></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据结构书籍推荐]]></title>
    <url>%2Fposts%2Fds_algo_books_recommand.html</url>
    <content type="text"><![CDATA[#数据结构数据结构与算法分析_Java语言描述(第2版) #算法计算机算法基础算法导论编程之法_面试和算法心得 #coding程序员代码面试指南_IT名企算法与数据结构题目最优解LeetCode/LintCode]]></content>
      <categories>
        <category>01Ds&amp;Algorithms</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk源码解析]]></title>
    <url>%2Fposts%2Fjava_jdk_source_read.html</url>
    <content type="text"><![CDATA[jdk source readjava collection集合https://github.com/CarpenterLee/JCFInternalshttp://calvin1978.blogcn.com/articles/collection.htmlhttp://wiki.jikexueyuan.com/project/java-collection/hashmap.htmlhttp://wiki.jikexueyuan.com/project/java-enhancement/java-twentytwo.htmlhttps://zhuanlan.zhihu.com/p/32997606https://blog.csdn.net/qq_34448345/article/details/79835190 java concurrenthttps://blog.csdn.net/qq_34448345/article/details/80087738http://wiki.jikexueyuan.com/project/java-memory-model/basic.htmlhttp://wiki.jikexueyuan.com/project/java-concurrent/introduction.htmlhttp://wiki.jikexueyuan.com/project/java-concurrency/concurrency-multithreading.htmlhttps://blog.csdn.net/column/details/wenniuwuren-jdk.html java niohttp://wiki.jikexueyuan.com/project/java-nio-zh/http://wiki.jikexueyuan.com/project/java-nio/ java iohttps://zhuanlan.zhihu.com/p/27931572https://zhuanlan.zhihu.com/p/28008754http://ifeve.com/java-io/ java langhttps://blog.csdn.net/qq_34448345/article/details/79955527 exception thread java security &amp; sunjce &amp; pkcs spi理解 bc provider密码算法理解 pkcs关键理解 java functionjava streamjava netjava math##java关键词https://www.cnblogs.com/nancyzhang/p/8147526.html]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>源码</tag>
        <tag>解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序优化]]></title>
    <url>%2Fposts%2Fjava_jdk_programe_opti.html</url>
    <content type="text"><![CDATA[Java程序优化参考书籍： Java程序性能优化 让你的Java程序更快、更稳定.pdf 性能分析-程序性能指标/瓶颈 指标测量，分析瓶颈 更快更省更稳 瓶颈取决于最坏的那个，木桶短板原理 代码优化- Java代码程序优化 数据结构优化 算法优化 数据库优化 NIO/IO优化 引用优化GC 代码优化- 设计模式优化系统优化- JVM优化系统优化- 操作系统调优]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>程序优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java密码]]></title>
    <url>%2Fposts%2Fjava_jdk_crypto.html</url>
    <content type="text"><![CDATA[Java密码参考 Java加解密艺术这本书进行整理如下 对称加密 symmetric AesCbcUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.security.symmetric;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * aes cbc and iv demo. * @author fitz * @version 1.0.0 */public class AesCbcUtils &#123; // aes cipher mode public static final String CIPHER_ALGORITHM = &quot;AES/CBC/NoPadding&quot;; // public static final String CIPHER_ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;; /** * encrypt * @param plain 16B * @param key 16B * @param iv 16B * @return byte[] 16B * @throws Exception */ public static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception &#123; if (key == null || key.length != 16 || iv == null || iv.length != 16) &#123; throw new Exception(&quot;key or iv error&quot;); &#125; SecretKeySpec sKeySpec = new SecretKeySpec(key, &quot;AES&quot;); Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(Cipher.ENCRYPT_MODE, sKeySpec, ivParameterSpec); byte[] encrypted = cipher.doFinal(plain); return encrypted; &#125; /** * decrypt * @param crypt 16B * @param key 16B * @param iv 16B * @return byte[] 16B * @throws Exception */ public static byte[] decrypt(byte[] crypt, byte[] key, byte[] iv) throws Exception &#123; if (key == null || key.length != 16 || iv == null || iv.length != 16) &#123; throw new Exception(&quot;key or iv error&quot;); &#125; SecretKeySpec sKeySpec = new SecretKeySpec(key, &quot;AES&quot;); sKeySpec.getClass().getSimpleName(); Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); IvParameterSpec ivParameterSpec = new IvParameterSpec(iv); cipher.init(Cipher.DECRYPT_MODE, sKeySpec, ivParameterSpec); byte[] original = cipher.doFinal(crypt); return original; &#125;&#125; AesUtils 12345678910111213141516171819202122232425262728package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class AesUtils &#123; private static final String KEY_TYPE = &quot;AES&quot;; private static final String CIPER_MODE = &quot;AES/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; CipherAsymmetricUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.Key;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public abstract class CipherAsymmetricUtils &#123; public enum KeyTypeEnum &#123; AES(&quot;AES&quot;), DES(&quot;DES&quot;), DESede(&quot;DESede&quot;), IDEA(&quot;IDEA&quot;); private String keyType; private KeyTypeEnum(String keyType) &#123; this.keyType = keyType; &#125; &#125; public enum WorkTypeEnum &#123; ECB(&quot;ECB&quot;), CBC(&quot;CBC&quot;); private String workType; private WorkTypeEnum(String workType) &#123; this.workType = workType; &#125; &#125; public enum PaddingTypeEnum &#123; NOPadding(&quot;NOPadding&quot;), PKCS5Padding(&quot;PKCS5Padding&quot;), PKCS7Padding(&quot;PKCS7Padding&quot;); private String paddingType; private PaddingTypeEnum(String paddingType) &#123; this.paddingType = paddingType; &#125; &#125; public static byte[] encrypt(Key key, byte[] data, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(data); &#125; public static byte[] decrypt(Key key, byte[] cipherText, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(cipherText); &#125; public static SecretKey generateSecretKey(String keyType) throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(keyType); return keyGenerator.generateKey(); &#125;&#125; Des3Utils 123456789101112131415161718192021222324252627package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class Des3Utils &#123; private static final String KEY_TYPE = &quot;DESede&quot;; private static final String CIPER_MODE = &quot;DESede/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; DesUtils 123456789101112131415161718192021222324252627package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class DesUtils &#123; private static final String KEY_TYPE = &quot;DES&quot;; private static final String CIPER_MODE = &quot;DES/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; CCM IdeaUtils 123456789101112131415161718192021222324252627package com.security.symmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class IdeaUtils &#123; private static final String KEY_TYPE = &quot;IDEA&quot;; private static final String CIPER_MODE = &quot;IDEA/ECB/PKCS5PADDING&quot;; private static SecretKey generateSecretKey() throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_TYPE); return keyGenerator.generateKey(); &#125; private static byte[] encrypt(SecretKey key, byte[] data) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(key, data, CIPER_MODE); &#125; private static byte[] decrypt(SecretKey key, byte[] cipherText) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(key, cipherText, CIPER_MODE); &#125;&#125; PbeUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.security.symmetric;import javax.crypto.*;import javax.crypto.spec.PBEKeySpec;import javax.crypto.spec.PBEParameterSpec;import java.security.InvalidAlgorithmParameterException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.spec.InvalidKeySpecException;/** * @author fitz * @version 1.0 */public class PbeUtils &#123; /** * &lt;pre&gt; * PBEWithMD5AndDES * PBEWithMD5AndTripleDES * PBEWithSHA1AndDESede * PBEWithSHA1AndRC2_40 * &lt;/pre&gt; */ private static final String ALGORITHM = &quot;PBEWithMD5AndTripleDES&quot;; private static final int ITERATION_COUNT = 100; public static SecretKey generateSecrectKey(String passwd) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; PBEKeySpec pbeKeySpec = new PBEKeySpec(passwd.toCharArray()); SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(ALGORITHM); return secretKeyFactory.generateSecret(pbeKeySpec); &#125; public static byte[] generateSalt() &#123; SecureRandom random = new SecureRandom(); return random.generateSeed(8); &#125; public static byte[] encrypt(SecretKey key, byte[] data, byte[] salt) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException &#123; Cipher cipher = Cipher.getInstance(ALGORITHM); PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, ITERATION_COUNT); cipher.init(Cipher.ENCRYPT_MODE, key, pbeParameterSpec); return cipher.doFinal(data); &#125; public static byte[] decrypt(SecretKey key, byte[] cipherText, byte[] salt) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException &#123; Cipher cipher = Cipher.getInstance(ALGORITHM); PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, ITERATION_COUNT); cipher.init(Cipher.DECRYPT_MODE, key, pbeParameterSpec); return cipher.doFinal(cipherText); &#125;&#125; SecretKeyUtils123456789101112131415161718192021222324package com.security.symmetric;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.SecretKeySpec;import java.security.NoSuchAlgorithmException;import java.security.spec.InvalidKeySpecException;import java.security.spec.KeySpec;/** * @author fitz * @version 1.0 */public class SecretKeyUtils &#123; public SecretKey getSecretKey(byte[] keyBytes, String keyType) &#123; SecretKey secretKey = new SecretKeySpec(keyBytes, keyType); return secretKey; &#125; public SecretKey generateSecretKey(String keyType, KeySpec keySpec) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(keyType); return secretKeyFactory.generateSecret(keySpec); &#125;&#125; 非对称加密 CipherAsymmetricUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.security.asymmetric;import javax.crypto.*;import java.security.InvalidKeyException;import java.security.Key;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public abstract class CipherAsymmetricUtils &#123; public enum KeyTypeEnum &#123; RSA(&quot;RSA&quot;), ECC(&quot;ECC&quot;); private String keyType; private KeyTypeEnum(String keyType) &#123; this.keyType = keyType; &#125; &#125; public enum WorkTypeEnum &#123; ECB(&quot;ECB&quot;), CBC(&quot;CBC&quot;); private String workType; private WorkTypeEnum(String workType) &#123; this.workType = workType; &#125; &#125; public enum PaddingTypeEnum &#123; NOPadding(&quot;NoPadding&quot;), PKCS5Padding(&quot;PKCS5Padding&quot;), PKCS7Padding(&quot;PKCS7Padding&quot;); private String paddingType; private PaddingTypeEnum(String paddingType) &#123; this.paddingType = paddingType; &#125; &#125; public static byte[] encrypt(Key key, byte[] data, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(data); &#125; public static byte[] decrypt(Key key, byte[] cipherText, String cipherType) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException &#123; Cipher cipher = Cipher.getInstance(cipherType); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(cipherText); &#125;&#125; DhKeyAgreementUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.security.asymmetric;import com.security.util.ByteUtils;import org.bouncycastle.crypto.digests.SHA1Digest;import org.bouncycastle.crypto.generators.KDF1BytesGenerator;import org.bouncycastle.crypto.params.ISO18033KDFParameters;import javax.crypto.KeyAgreement;import javax.crypto.SecretKey;import java.math.BigInteger;import java.security.*;import java.security.spec.*;/** * @author fitz * @version 1.0 */public class DhKeyAgreementUtils &#123; public static final String KEY_AGREEMENT_ALGORITHM_DH = &quot;DH&quot;; public static final String KEY_AGREEMENT_ALGORITHM_ECDH = &quot;ECDH&quot;; public static final String SECRET_KEY_ALGORITHM = &quot;AES&quot;; public SecretKey generateSecretKey(PublicKey publicKey, PrivateKey privateKey, String keyAgreementType) throws Exception &#123; KeyAgreement ka = KeyAgreement.getInstance(keyAgreementType); ka.init(privateKey); ka.doPhase(publicKey, true); SecretKey key = ka.generateSecret(SECRET_KEY_ALGORITHM); return key; &#125; public byte[] generateSessionKeyPki(PublicKey publicKey, PrivateKey privateKey) throws Exception &#123; KeyAgreement ka = KeyAgreement.getInstance(&quot;ECDH&quot;); //EcDhWithNistKdf256 ka.init(privateKey); ka.doPhase(publicKey, true); byte[] secret = ka.generateSecret(); KDF1BytesGenerator kdf1sha1 = new KDF1BytesGenerator(new SHA1Digest()); kdf1sha1.init(new ISO18033KDFParameters(secret)); byte[] key = new byte[16]; kdf1sha1.generateBytes(key,0,key.length); return key; &#125; public void generateDiffHellmanKeys(String keyType, int keySize) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(keySize); KeyPair keyPair = keyPairGenerator.generateKeyPair(); // A privateKey &amp; publicKey PrivateKey privateKeyA = keyPair.getPrivate(); PublicKey publicKeyA = keyPair.getPublic(); // B privateKey &amp; publicKey keyPair = keyPairGenerator.generateKeyPair(); PrivateKey privateKeyB = keyPair.getPrivate(); PublicKey publicKeyB = keyPair.getPublic(); &#125;&#125; EccCipherUtils 12345678910111213141516171819202122232425package com.security.asymmetric;import javax.crypto.BadPaddingException;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.interfaces.ECPrivateKey;import java.security.interfaces.ECPublicKey;/** * @author fitz * @version 1.0 */public class EccCipherUtils &#123; private static final String CIPHER_ALGORITHM = &quot;ECC/ECB/PKCS5Padding&quot;; public static byte[] encrypt(ECPublicKey publicKey, byte[] data, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(publicKey, data, cipherType); &#125; public static byte[] decrypt(ECPrivateKey privateKey, byte[] cipherText, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(privateKey, cipherText, cipherType); &#125;&#125; EccKeyGenerateUtils 12345678910111213141516171819202122232425262728293031323334353637383940package com.security.asymmetric;import org.bouncycastle.util.encoders.Hex;import java.math.BigInteger;import java.security.*;import java.security.spec.ECGenParameterSpec;import java.security.spec.ECParameterSpec;import java.security.spec.ECPoint;import java.security.spec.ECPublicKeySpec;/** * @author fitz * @version 1.0 */public class EccKeyGenerateUtils &#123; /** * generate keypair * @param keyType * @param size * @return KeyPair * can use KeyPair&apos;s getPublic or getPrivate * @throws NoSuchAlgorithmException */ public KeyPair generateKey(String keyType, int size) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(size); return keyPairGenerator.generateKeyPair(); &#125; public PublicKey getPublicKey(String x, String y) throws Exception &#123; ECPoint ecPoint = new ECPoint(new BigInteger(Hex.decode(x)), new BigInteger(Hex.decode(y))); AlgorithmParameters parameters = AlgorithmParameters.getInstance(&quot;EC&quot;, &quot;BC&quot;); parameters.init(new ECGenParameterSpec(&quot;secp256r1&quot;)); ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class); return KeyFactory.getInstance (&quot;EC&quot;).generatePublic(new ECPublicKeySpec(ecPoint, ecParameters)); &#125;&#125; RsaBlockUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.security.asymmetric;import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.Key;/** * no use, just for test block * @author fitz */public class RsaBlockUtils &#123; public static final String CIPHER_ALGORITHM = &quot;RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING&quot;; // for rsa 2048 private static final int KEY_SIZE = 2048; private static final int BLOCK_SIZE = 245; private static final int OUTPUT_BLOCK_SIZE = 256; // for rsa 1024 // private static final int KEY_SIZE = 1024; // private static final int BLOCK_SIZE = 117; // private static final int OUTPUT_BLOCK_SIZE = 128; /** * encryptByPublicKey * @param data * @param publicKey * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, Key publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, publicKey); int blocks = data.length / BLOCK_SIZE; int lastBlockSize = data.length % BLOCK_SIZE; byte[] encryptedData = new byte[(lastBlockSize == 0 ? blocks : blocks + 1) * OUTPUT_BLOCK_SIZE]; for (int i = 0; i &lt; blocks; i++) &#123; cipher.doFinal(data, i * BLOCK_SIZE, BLOCK_SIZE, encryptedData, i * OUTPUT_BLOCK_SIZE); &#125; if (lastBlockSize != 0) &#123; cipher.doFinal(data, blocks * BLOCK_SIZE, lastBlockSize, encryptedData, blocks * OUTPUT_BLOCK_SIZE); &#125; return encryptedData; &#125; /** * decryptByPrivateKey * @param decoded * @param privateKey * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] decoded, Key privateKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, privateKey); int blocks = decoded.length / OUTPUT_BLOCK_SIZE; ByteArrayOutputStream decodedStream = new ByteArrayOutputStream(decoded.length); for (int i = 0; i &lt; blocks; i++) &#123; decodedStream.write(cipher.doFinal(decoded, i * OUTPUT_BLOCK_SIZE, OUTPUT_BLOCK_SIZE)); &#125; return decodedStream.toByteArray(); &#125;&#125; RsaCipherUtils 12345678910111213141516171819202122232425262728293031323334353637package com.security.asymmetric;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.OAEPParameterSpec;import javax.crypto.spec.PSource;import java.security.*;import java.security.spec.*;/** * @author fitz * @version 1.0 */public class RsaCipherUtils &#123; private static final String CIPHER_ALGORITHM = &quot;RSA/ECB/PKCS5Padding&quot;; public static byte[] encrypt(PublicKey publicKey, byte[] data, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.encrypt(publicKey, data, cipherType); &#125; public static byte[] decrypt(PrivateKey privateKey, byte[] cipherText, String cipherType) throws IllegalBlockSizeException, InvalidKeyException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException &#123; return CipherAsymmetricUtils.decrypt(privateKey, cipherText, cipherType); &#125; public static byte[] encryptOaep(byte[] data, PublicKey publicKey) throws NoSuchProviderException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidParameterSpecException &#123; AlgorithmParameters algp = AlgorithmParameters.getInstance(&quot;OAEP&quot;, &quot;BC&quot;); AlgorithmParameterSpec paramSpec = new OAEPParameterSpec(&quot;SHA-1&quot;, &quot;MGF1&quot;, MGF1ParameterSpec.SHA1, PSource.PSpecified.DEFAULT); algp.init(paramSpec); Cipher oaepFromAlgo = Cipher.getInstance(&quot;RSA/ECB/OAEPWITHSHA-1ANDMGF1PADDING&quot;); oaepFromAlgo.init(Cipher.ENCRYPT_MODE, publicKey, algp); //algp byte[] ct = oaepFromAlgo.doFinal(data); return ct; &#125;&#125; RsaKeyGenerateUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.security.asymmetric;import java.math.BigInteger;import java.security.*;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.*;/** * @author fitz * @version 1.0 */public class RsaKeyGenerateUtils &#123; /** * generate keypair * @param keyType * @param size * @return KeyPair * can use KeyPair&apos;s getPublic or getPrivate * @throws NoSuchAlgorithmException */ public KeyPair generateKey(String keyType, int size) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(size); return keyPairGenerator.generateKeyPair(); &#125; public static Key toPrivateKey(String type, byte[] keyBytes) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(type); return keyFactory.generatePrivate(pkcs8EncodedKeySpec); &#125; public static Key toPublicKey(String type, byte[] keyBytes) throws NoSuchAlgorithmException, InvalidKeySpecException &#123; X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(type); return keyFactory.generatePublic(x509EncodedKeySpec); &#125; /** * Generate public key according to modulus and public exponent java Cipher* * @param modulus modulus * @param exponent public exponent * @return */ public static RSAPublicKey getPublicKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus, 16); BigInteger b2 = new BigInteger(exponent, 16); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2); return (RSAPublicKey) keyFactory.generatePublic(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * Generate private key according to modulus and private exponent java * @param modulus modulus * @param exponent private exponent * @return */ public static RSAPrivateKey getPrivateKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus, 16); BigInteger b2 = new BigInteger(exponent, 16); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(b1, b2); return (RSAPrivateKey) keyFactory.generatePrivate(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; EccParams RsaParams KdfUtils 签名 KeyUtils 12345678910111213141516171819202122232425package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class KeyUtils &#123; public static final String ALGORITHM = &quot;DSA&quot;; /** * generate keypair * @param keyType * @param size * @return KeyPair * can use KeyPair&apos;s getPublic or getPrivate * @throws NoSuchAlgorithmException */ public KeyPair generateKey(String keyType, int size) throws NoSuchAlgorithmException &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyType); keyPairGenerator.initialize(size); return keyPairGenerator.generateKeyPair(); &#125;&#125; EcdsaUtils 123456789101112131415161718192021222324252627282930package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class EcdsaUtils &#123; private static final String KEY_ALGORITHM = &quot;ECDSA&quot;; /** * NONEwithECDSA * RIPEMD160withECDSA * SHA1withECDSA * SHA224withECDSA * SHA256withECDSA * SHA384withECDSA * SHA512withECDSA */ private static final String SIGNATURE_ALGORITHM = &quot;SHA512withECDSA&quot;; public static byte[] sign(PrivateKey privateKey, byte[] data) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.sign(privateKey, data, SIGNATURE_ALGORITHM); &#125; public static boolean verify(PublicKey publicKey, byte[] data, byte[] sign) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.verify(publicKey, data, sign, SIGNATURE_ALGORITHM); &#125;&#125; RsaSignUtils 1234567891011121314151617181920package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class RsaSignUtils &#123; public static final String KEY_ALGORITHM = &quot;RSA&quot;; public static final String SIGNATURE_ALGORITHM = &quot;SHA1withRSA&quot;; public static byte[] sign(PrivateKey privateKey, byte[] data) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.sign(privateKey, data, SIGNATURE_ALGORITHM); &#125; public static boolean verify(PublicKey publicKey, byte[] data, byte[] sign) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; return SignatureUtils.verify(publicKey, data, sign, SIGNATURE_ALGORITHM); &#125;&#125; SignatureUtils 12345678910111213141516171819202122232425package com.security.signature;import java.security.*;/** * @author fitz * @version 1.0 */public class SignatureUtils &#123; public static final String SIGNATURE_ALGORITHM = &quot;SHA1withRSA&quot;; public static byte[] sign(PrivateKey privateKey, byte[] data, String signatureType) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; Signature signature = Signature.getInstance(signatureType); signature.initSign(privateKey); signature.update(data); return signature.sign(); &#125; public static boolean verify(PublicKey publicKey, byte[] data, byte[] sign, String signatureType) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException &#123; Signature signature = Signature.getInstance(signatureType); signature.initVerify(publicKey); signature.update(data); return signature.verify(sign); &#125;&#125; base64 Base64BcUtils 12345678910111213141516171819package com.security.base64;import org.bouncycastle.util.encoders.Base64;/** * @author fitz * @version 1.0 */public class Base64BcUtils &#123; public static byte[] encode(byte[] bytes) &#123; return Base64.encode(bytes); &#125; public static byte[] decode(byte[] bytes) &#123; return Base64.decode(bytes); &#125;&#125; Base64Utils 123456789101112131415161718package com.security.base64;import java.util.Base64;/** * @author fitz * @version 1.0 */public class Base64Utils &#123; public static byte[] encode(byte[] bytes) &#123; return Base64.getEncoder().encode(bytes); &#125; public static byte[] decode(byte[] bytes) &#123; return Base64.getDecoder().decode(bytes); &#125;&#125; UrlBase64Coder 12345678910111213141516171819202122232425262728package com.security.base64;import org.bouncycastle.util.encoders.UrlBase64;/** * @author fitz * @version 1.0 */public abstract class UrlBase64Coder &#123; public final static String ENCODING = &quot;UTF-8&quot;; public static String encode(String data) throws Exception &#123; byte[] b = UrlBase64.encode(data.getBytes(ENCODING)); return new String(b, ENCODING); &#125; public static String decode(String data) throws Exception &#123; byte[] b = UrlBase64.decode(data.getBytes(ENCODING)); return new String(b, ENCODING); &#125;&#125; hash crc MacStreamUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.security.hash;import org.apache.commons.codec.digest.DigestUtils;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.security.DigestInputStream;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * @author fitz * @version 1.0 */public class MacStreamUtils &#123; public static byte[] digest(FileInputStream fis, String type) throws NoSuchAlgorithmException, IOException &#123; DigestInputStream dis = new DigestInputStream(fis, MessageDigest.getInstance(type)); int bufLen = 1024; byte[] buffer = new byte[bufLen]; while (dis.read(buffer, 0, bufLen) &gt; -1) &#123; &#125; dis.close(); MessageDigest md = dis.getMessageDigest(); // can compare with DigestUtils.md5(fis); DigestUtils.md5(fis); return md.digest(); &#125; public static byte[] digest1(FileInputStream fis, String type) throws NoSuchAlgorithmException, IOException &#123; MessageDigest md = MessageDigest.getInstance(type); updateDigest(md, fis); return md.digest(); &#125; /** * ref: DigestUtils md5 * @param digest * @param data * @return * @throws IOException */ public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException &#123; final int STREAM_BUFFER_LENGTH = 1024; final byte[] buffer = new byte[STREAM_BUFFER_LENGTH]; int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH); while (read &gt; -1) &#123; digest.update(buffer, 0, read); read = data.read(buffer, 0, STREAM_BUFFER_LENGTH); &#125; return digest; &#125;&#125; MacUtils 123456789101112131415161718192021222324252627282930313233343536package com.security.hash;import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;/** * mac utils * @author fitz * @version 1.0 */public class MacUtils &#123; private static final String HmacMD2 = &quot;HmacMD2&quot;; private static final String HmacMD4 = &quot;HmacMD4&quot;; private static final String HmacSHA224 = &quot;HmacSHA224&quot;; private static final String HmacSHA256 = &quot;HmacSHA256&quot;; private static final String HmacRipeMD128 = &quot;HmacRipeMD128&quot;; private static final String HmacRipeMD160 = &quot;HmacRipeMD160&quot;; public static SecretKey generateSecretKey(String type) throws NoSuchAlgorithmException &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(type); return keyGenerator.generateKey(); &#125; public static byte[] mac(SecretKey key, byte[] bytes) throws NoSuchAlgorithmException, InvalidKeyException &#123; Mac mac = Mac.getInstance(key.getAlgorithm()); mac.init(key); return mac.doFinal(bytes); &#125;&#125; MessageDigestUtils 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.security.hash;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * message digest utils. * @author fitz * @version 1.0 */public class MessageDigestUtils &#123; private static final String MD2 =&quot;MD2&quot;; private static final String MD5 =&quot;MD5&quot;; private static final String SHA =&quot;SHA&quot;; private static final String SHA_256 =&quot;SHA-256&quot;; private static final String SHA_384 =&quot;SHA-384&quot;; private static final String SHA_512 =&quot;SHA-512&quot;; public static byte[] md2(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(MD2, bytes); &#125; public static byte[] md5(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(MD5, bytes); &#125; public static byte[] sha1(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA, bytes); &#125; public static byte[] sha256(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA_256, bytes); &#125; public static byte[] sha384(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA_384, bytes); &#125; public static byte[] sha512(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(SHA_512, bytes); &#125; private static byte[] md(String type, byte[] bytes) throws NoSuchAlgorithmException &#123; MessageDigest md = MessageDigest.getInstance(type); return md.digest(bytes); &#125;&#125; OtherMessageDigestUtils 123456789101112131415161718192021222324252627282930313233343536package com.security.hash;import org.bouncycastle.jce.provider.BouncyCastleProvider;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.Security;/** * @author fitz * @version 1.0 */public class OtherMessageDigestUtils &#123; static &#123; if(Security.getProvider(&quot;BC&quot;) == null ) &#123; Security.addProvider(new BouncyCastleProvider()); &#125; &#125; private static final String RipeMD128 =&quot;RipeMD128&quot;; private static final String RipeMD160 =&quot;RipeMD160&quot;; private static final String RipeMD256 =&quot;RipeMD256&quot;; private static final String RipeMD320 =&quot;RipeMD320&quot;; private static final String Tiger =&quot;Tiger&quot;; private static final String Whirlpool =&quot;Whirlpool&quot;; private static final String GOST3411 =&quot;GOST3411&quot;; public static byte[] RipeMD256(byte[] bytes) throws NoSuchAlgorithmException &#123; return md(RipeMD256, bytes); &#125; private static byte[] md(String type, byte[] bytes) throws NoSuchAlgorithmException &#123; MessageDigest md = MessageDigest.getInstance(type); return md.digest(bytes); &#125;&#125; certificate 证书生成 openssl 和 keytool操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374echo offecho 构建目录mkdir certsmkdir crlmkdir newcertsmkdir privateecho 构建文件echo 0 &gt; index.txtecho 01 &gt; serialecho 构建随机数openssl.exe rand -out private/.rand 1000echo 产生私钥openssl.exe genrsa -out private/ca.key.pem 2048openssl.exe genrsa -out private/ca1.key.pem 2048!openssl.exe genrsa -aes256 -out private/ca.key.pem 2048echo 生成根证书请求 ca.csropenssl.exe req -new -key private/ca.key.pem -out private/ca.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security&quot;openssl.exe req -new -key private/ca1.key.pem -out private/ca1.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security1&quot;echo 签发根证书 ca.ceropenssl.exe x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.ceropenssl.exe x509 -req -days 10000 -sha1 -extensions v3_ca -signkey private/ca1.key.pem -in private/ca1.csr -out certs/ca1.cerecho 根证书转换 ca.p12openssl.exe pkcs12 -export -clcerts -in certs/ca.cer -inkey private/ca.key.pem -out certs/ca.p12echo 颁发服务器证书openssl.exe genrsa -out private/server.key.pem 2048echo 生成服务器证书请求 server.csropenssl.exe req -new -key private/server.key.pem -out private/server.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM /OU=ANDROID/CN=com.android.security.server&quot;echo 签发服务器证书 server.ceropenssl.exe x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/server.csr -out certs/server.cerecho 服务器证书转换 server.p12openssl.exe pkcs12 -export -clcerts -in certs/server.cer -inkey private/server.key.pem -out certs/server.p12echo 产生客户私钥openssl.exe genrsa -out private/client.key.pem 2048echo 生成客户证书请求 client.csropenssl.exe req -new -key private/client.key.pem -out private/client.csr -subj &quot;/C=CN/ST=SH/L=PD/O=COM/OU=ANDROID/CN=com.android.security.client&quot;echo 签发客户证书 client.ceropenssl.exe x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/client.csr -out certs/client.ceropenssl.exe x509 -req -days 3650 -sha1 -extensions v3_req -CA certs/ca1.cer -CAkey private/ca1.key.pem -CAserial ca.srl -CAcreateserial -in private/client.csr -out certs/client.cer!openssl.exe ca -in private/client.csr -days 3650 -out certs/client.cer -cert certs/ca.cer -keyfile private/ca.key.pem -notextecho 客户证书转换 client.p12openssl.exe pkcs12 -export -inkey private/client.key.pem -in certs/client.cer -out certs/client.p12echo 根密钥库转换 ca.keystorekeytool -importkeystore -v -srckeystore certs/ca.p12 -srcstorepass 123456 -destkeystore certs/ca.keystore -srcstoretype pkcs12 -deststorepass 123456keytool -list -keystore certs/ca.keystore -v -storepass 123456echo 服务器密钥库转换 server.keystorekeytool -importkeystore -v -srckeystore certs/server.p12 -srcstorepass 123456 -destkeystore certs/server.keystore -srcstoretype pkcs12 -deststorepass 123456keytool -list -keystore certs/server.keystore -v -storepass 123456echo 客户密钥库转换 client.keystorekeytool -importkeystore -v -srckeystore certs/client.p12 -srcstorepass 123456 -destkeystore certs/client.keystore -srcstoretype pkcs12 -deststorepass 123456keytool -list -keystore certs/client.keystore -v -storepass 123456pauseecho on UdpSocket 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.security.certificate.udpsocket;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.SocketException;public class UdpSocket &#123; private byte[] buffer = new byte[1024]; private DatagramSocket receiveSocket; private DatagramSocket sendSocket; private String remoteHost; private int sendPort; public UdpSocket(String localHost, String remoteHost, int receivePort, int sendPort) throws SocketException &#123; this.remoteHost = remoteHost; this.sendPort = sendPort; this.receiveSocket = new DatagramSocket(new InetSocketAddress( localHost, receivePort)); this.sendSocket = new DatagramSocket(); &#125; public byte[] receive() throws IOException &#123; DatagramPacket dp = new DatagramPacket(buffer, buffer.length); receiveSocket.receive(dp); ByteArrayOutputStream baos = new ByteArrayOutputStream(); baos.write(dp.getData(), 0, dp.getLength()); byte[] data = baos.toByteArray(); baos.flush(); baos.close(); return data; &#125; public void send(byte[] data) throws IOException &#123; DatagramPacket dp = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(remoteHost), sendPort); dp.setData(data); sendSocket.send(dp); &#125; public void close() &#123; try &#123; if (receiveSocket.isConnected()) &#123; receiveSocket.disconnect(); receiveSocket.close(); &#125; if (sendSocket.isConnected()) &#123; sendSocket.disconnect(); sendSocket.close(); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;``` - client server package com.security.certificate.clientserver; import com.security.certificate.CertificateUtils; import javax.net.ssl.;import java.io.;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class Client implements Runnable { public static final String PROTOCOL = “TLS”; private static final String PASSWD = “123456”; private static final String ip = “127.0.0.1”; private static final int port = Server.PORT; private SSLSocketFactory socketFactory; public Client() throws Exception { // key manager KeyStore keyStore = getKeyManagerStore(); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, PASSWD.toCharArray()); // trust manager KeyStore trustStore = getTrustManagerStore(); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); // socket init SSLContext sslContext = SSLContext.getInstance(PROTOCOL); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); socketFactory = sslContext.getSocketFactory(); } private static KeyStore getKeyManagerStore() throws CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException { InputStream inputStream = Client.class.getResourceAsStream(&quot;/certs/client.p12&quot;); KeyStore keyStore = CertificateUtils.getKeyStore(inputStream, &quot;123456&quot;); inputStream.close(); return keyStore; } private static KeyStore getTrustManagerStore() throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); InputStream inputStream = Server.class.getResourceAsStream(&quot;/certs/ca.cer&quot;); X509Certificate certificate = (X509Certificate) CertificateUtils.getCertificate(inputStream, &quot;X.509&quot;); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, certificate); return keyStore; } @Override public void run() { int i = 0; while(i++ &lt;= 1) { try { SSLSocket sslSocket = (SSLSocket) socketFactory.createSocket(ip, port); InputStream is = sslSocket.getInputStream(); OutputStream os = sslSocket.getOutputStream(); DataOutputStream out = new DataOutputStream(os); out.writeUTF(&quot;GET /index.html HTTP/1.0&quot;); out.flush(); DataInputStream bin = new DataInputStream(is); String ln; if ((ln = bin.readUTF()) != null) { System.out.println(ln); } } catch (IOException e) { e.printStackTrace(); } } }} 12 package com.security.certificate.clientserver; import com.security.certificate.CertificateUtils; import javax.net.ssl.;import java.io.;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.cert.CertificateException;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class Server implements Runnable { private SSLServerSocket serverSocket; public static final String PROTOCOL = “TLS”; private static final String PASSWD = “123456”; public static final int PORT = 6666; public Server() throws Exception { // key manager KeyStore keyStore = getKeyManagerStore(); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, PASSWD.toCharArray()); // trust manager KeyStore trustStore = getTrustManagerStore(); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(trustStore); // ssl server init SSLContext sslContext = SSLContext.getInstance(PROTOCOL); sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); SSLServerSocketFactory serverSocketFactory = sslContext.getServerSocketFactory(); serverSocket = (SSLServerSocket) serverSocketFactory.createServerSocket(PORT); serverSocket.setNeedClientAuth(true); } private static KeyStore getKeyManagerStore() throws CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException { InputStream inputStream = Server.class.getResourceAsStream(&quot;/certs/server.p12&quot;); KeyStore keyStore = CertificateUtils.getKeyStore(inputStream, &quot;123456&quot;); inputStream.close(); return keyStore; } private static KeyStore getTrustManagerStore() throws KeyStoreException, CertificateException, IOException, NoSuchAlgorithmException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); InputStream inputStream = Server.class.getResourceAsStream(&quot;/certs/ca.cer&quot;); X509Certificate certificate = (X509Certificate) CertificateUtils.getCertificate(inputStream, &quot;X.509&quot;); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, certificate); return keyStore; } @Override public void run() { while (true) { try { SSLSocket socket = (SSLSocket) serverSocket.accept(); socket.startHandshake(); // new Thread(new Runnable() {// @Override// public void run() {// try {// //socket.startHandshake();////// } catch (IOException e) {// e.printStackTrace();// }// }// }); OutputStream outputStream = socket.getOutputStream(); InputStream inputStream = socket.getInputStream(); DataOutputStream out = new DataOutputStream(outputStream); DataInputStream bin = new DataInputStream(inputStream); String str = null; if((str = bin.readUTF()) != null) { System.out.println(str); } out.writeUTF(&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;); out.flush(); out.close(); bin.close(); socket.close(); System.out.println(Thread.currentThread().getName()); System.out.println(&quot;ssl socket...&quot;); } catch (Exception e) { e.printStackTrace(); } } } } 12 package com.security.certificate.clientserver; /** @author fitz @version 1.0*/public class ClientServerMain { public static void main(String[] args) throws Exception {Thread serverThread = new Thread(new Server()); serverThread.start(); new Thread(new Client()).start(); }} 123- CertificateUtils package com.security.certificate; import com.security.signature.SignatureUtils; import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.security.*;import java.security.cert.Certificate;import java.security.cert.CertificateException;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class CertificateUtils { /** p12 @param keyStorePath @param passwd @return @throws KeyStoreException @throws IOException @throws CertificateException @throws NoSuchAlgorithmException*/public static KeyStore getKeyStore(String keyStorePath, String passwd) throws KeyStoreException, IOException, CertificateException, NoSuchAlgorithmException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); FileInputStream fis = new FileInputStream(keyStorePath); keyStore.load(fis, passwd.toCharArray()); fis.close(); return keyStore;} public static KeyStore getKeyStore(InputStream fis, String passwd) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(fis, passwd.toCharArray()); return keyStore;} /** p12 @param keyStorePath @param passwd @return @throws KeyStoreException @throws CertificateException @throws NoSuchAlgorithmException @throws IOException*/public static KeyStore createKeyStore(String keyStorePath, String passwd) throws KeyStoreException, CertificateException, NoSuchAlgorithmException, IOException { KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(null, passwd.toCharArray()); FileOutputStream out = new FileOutputStream(keyStorePath); keyStore.store(out, passwd.toCharArray()); out.close(); return keyStore;} public static void storeKey(KeyStore keyStore, Key key, String alias, String passwd) throws KeyStoreException { keyStore.setKeyEntry(alias, key, passwd.toCharArray(),null);} public static void storeCertificate(KeyStore keyStore, Certificate certificate, String alias) throws KeyStoreException { keyStore.setCertificateEntry(alias, certificate);} public static PrivateKey getPrivateKey(KeyStore keyStore, String alias, String passwd) throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException { return (PrivateKey) keyStore.getKey(alias, passwd.toCharArray());} public static Certificate getCertificate(KeyStore keyStore, String alias) throws KeyStoreException { return keyStore.getCertificate(alias);} public static PublicKey getPublicKey(Certificate cert) { return cert.getPublicKey();} /* @param certPath @param certType can be “X.509” @return @throws CertificateException @throws IOException*/public static Certificate getCertificate(String certPath, String certType) throws CertificateException, IOException { CertificateFactory certificateFactory = CertificateFactory.getInstance(certType); FileInputStream in = new FileInputStream(certPath); Certificate certificate = certificateFactory.generateCertificate(in); in.close(); return certificate;} public static Certificate getCertificate(InputStream is, String certType) throws CertificateException, IOException { CertificateFactory certificateFactory = CertificateFactory.getInstance(certType); Certificate certificate = certificateFactory.generateCertificate(is); return certificate;} public static byte[] sign(KeyStore keyStore, String alias, String passwd, byte[] data) throws UnrecoverableKeyException, NoSuchAlgorithmException, KeyStoreException, SignatureException, InvalidKeyException { PrivateKey privateKey = getPrivateKey(keyStore, alias, passwd); X509Certificate certificate = (X509Certificate) getCertificate(keyStore, alias); return SignatureUtils.sign(privateKey, data, certificate.getSigAlgName()); } public static boolean verify(X509Certificate certificate, byte[] data, byte[] sign) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException { Signature signature = Signature.getInstance(certificate.getSigAlgName()); signature.initVerify(certificate); return signature.verify(sign); } } 12- HttpsCertificate package com.security.certificate; import javax.net.ssl.*;import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.InputStream;import java.net.URL;import java.security.KeyStore;import java.security.SecureRandom;import java.security.cert.Certificate;import java.security.cert.CertificateFactory;import java.security.cert.X509Certificate; /** @author fitz @version 1.0*/public class HttpsCertificate { public static final String PROTOCOL = “TLS”; /** * ssl https best practice * ref: https://developer.android.com/training/articles/security-ssl.html?hl=zh-cn * @throws Exception */ public static void androidHttps() throws Exception { CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;); // From https://www.washington.edu/itconnect/security/ca/load-der.crt InputStream caInput = new BufferedInputStream(new FileInputStream(&quot;load-der.crt&quot;)); Certificate ca; try { ca = cf.generateCertificate(caInput); System.out.println(&quot;ca=&quot; + ((X509Certificate) ca).getSubjectDN()); } finally { caInput.close(); } // Create a KeyStore containing our trusted CAs String keyStoreType = KeyStore.getDefaultType(); KeyStore keyStore = KeyStore.getInstance(keyStoreType); keyStore.load(null, null); keyStore.setCertificateEntry(&quot;ca&quot;, ca); // Create a TrustManager that trusts the CAs in our KeyStore String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm(); TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm); tmf.init(keyStore); // Create an SSLContext that uses our TrustManager SSLContext context = SSLContext.getInstance(&quot;TLS&quot;); context.init(null, tmf.getTrustManagers(), null); // Tell the URLConnection to use a SocketFactory from our SSLContext URL url = new URL(&quot;https://certs.cac.washington.edu/CAtest/&quot;); HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection(); urlConnection.setSSLSocketFactory(context.getSocketFactory()); InputStream in = urlConnection.getInputStream(); } /** * First and major difference between trustStore and keyStore is that trustStore is used by TrustManager * and keyStore is used by KeyManager class in Java. KeyManager and TrustManager performs different job * in Java, TrustManager determines whether remote connection should be trusted or not i.e. whether remote * party is who it claims to and KeyManager decides which authentication credentials should be sent to the * remote host for authentication during SSL handshake. if you are an SSL Server you will use private key * during key exchange algorithm and send certificates corresponding to your public keys to client, this * certificate is acquired from keyStore. On SSL client side, if its written in Java, it will use certificates * stored in trustStore to verify identity of Server. * * @param password * @param keyStorePath * @param trustStorePath * @return * @throws Exception */ private static SSLSocketFactory getSSLSocketFactory(String password, String keyStorePath, String trustStorePath) throws Exception { KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); KeyStore keyStore = CertificateUtils.getKeyStore(keyStorePath, password); keyManagerFactory.init(keyStore, password.toCharArray()); TrustManagerFactory trustManagerFactory = TrustManagerFactory .getInstance(TrustManagerFactory.getDefaultAlgorithm()); KeyStore trustStore = CertificateUtils.getKeyStore(trustStorePath, password); trustManagerFactory.init(trustStore); SSLContext ctx = SSLContext.getInstance(PROTOCOL); ctx.init(keyManagerFactory.getKeyManagers(), trustManagerFactory .getTrustManagers(), new SecureRandom()); return ctx.getSocketFactory(); } public static void configSSLSocketFactory(HttpsURLConnection conn, String password, String keyStorePath, String trustKeyStorePath) throws Exception { // 获得SSLSocketFactory SSLSocketFactory sslSocketFactory = getSSLSocketFactory(password, keyStorePath, trustKeyStorePath); // 设置SSLSocketFactory conn.setSSLSocketFactory(sslSocketFactory); } } 12345## asn1## util package com.security.util; /** @author fitz @version 1.0*/public class ByteUtils { public static byte[] stringToBytes(String s) { if(s == null || s.length() % 2 != 0) { return null; } int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i &lt; len; i += 2) { data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character.digit(s.charAt(i+1), 16)); } return data; } public static String bytesToString(byte[] bytes) { final char[] hexChars = {&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;}; char[] chars = new char[bytes.length * 2]; int byteValue; for (int j = 0; j &lt; bytes.length; j++) { byteValue = bytes[j] &amp; 0xFF; chars[j * 2] = hexChars[byteValue &gt;&gt;&gt; 4]; chars[j * 2 + 1] = hexChars[byteValue &amp; 0x0F]; } return new String(chars); }} `]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程和并发]]></title>
    <url>%2Fposts%2Fjava_jdk_thread_concurrent.html</url>
    <content type="text"><![CDATA[Java线程和并发Thread线程的创建，状态，优先级等线程创建：https://my.oschina.net/u/566591/blog/1576410https://cloud.tencent.com/developer/article/1038547线程状态：https://www.jianshu.com/p/d7c87eca472a线程优先级：https://blog.csdn.net/silent_paladin/article/details/54561496 Thread Pool线程池https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/ 锁的分类和解析，实现原理锁的分类：https://www.cnblogs.com/qifengshi/p/6831055.htmlCAS操作： https://www.cnblogs.com/zhengbin/p/5657707.html全面理解Java内存模型(JMM)及volatile关键字https://blog.csdn.net/javazejian/article/details/72772461锁原理Markword：https://www.jianshu.com/p/e674ee68fd3fhttps://blog.csdn.net/congyihao/article/details/60748514 线程安全集合类https://www.cnblogs.com/sarafill/archive/2011/05/18/2049461.htmlhttps://www.cnblogs.com/yjd_hycf_space/p/7760248.htmlhttp://mahuangyihao.iteye.com/blog/181156http://www.charlesxiao.top/2015/10/20/Java%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6/ 线程安全List：http://xxgblog.com/2016/04/02/traverse-list-thread-safe/https://blog.csdn.net/yangzl2008/article/details/39456817vector复合操作线程不安全：http://www.hollischuang.com/archives/1786 关键词拾遗 threadlocalhttps://juejin.im/post/5965ef1ff265da6c40737292]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2Fposts%2Fbooks_recommand_data_structure_algorithms.html</url>
    <content type="text"><![CDATA[#数据结构数据结构与算法分析_Java语言描述(第2版) #算法计算机算法基础算法导论编程之法_面试和算法心得 #coding程序员代码面试指南_IT名企算法与数据结构题目最优解LeetCode/LintCode]]></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>data_analysis</tag>
        <tag>algorithms</tag>
        <tag>books_recommand</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java&Jdk基础书籍推荐]]></title>
    <url>%2Fposts%2Fjava_jdk_base_books_best.html</url>
    <content type="text"><![CDATA[书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 JDK文档，最好的官方学习助手Oschina 中文API在线文档 Oracle官方文档下载 Oschina API文档集，包含各种Mybatis Mina 等API文档可以参考 Java系列经典好书推荐编码风格阿里巴巴Java开发手册Google Java编程风格指南 Java基础Effective_java中文版Thinking in Java 4th Edition-Java编程思想编写高质量代码改善Java程序的151个建议Java泛型和集合-Java.Generics.and.Collections).Maurice.Naftalin&amp;Philip.WadlerJava安全编码标准Java核心技术精讲_李兴华 Java线程和并发Java 并发编程实战Java多线程编程核心技术Java线程(第三版) Java程序优化Java性能优化权威指南Java程序性能优化 让你的Java程序更快、更稳定 Java密码学Java加密与解密的艺术Java安全第二版 (3)图解密码技术精通PKI网络安全认证技术与编程实现.马臣云.王彦PKI技术 Java虚拟机深入理解Java虚拟机：JVM高级特性与最佳实践自己动手写Java虚拟机 (Java核心技术系列)Java虚拟机精讲HotSpot实战 Web技术扩展架构探险_从零开始写JavaWeb框架深入分析Java Web技术内幕大型网站系统与JAVA中间件实践大型网站技术架构：核心原理与案例分析SPRING技术内幕：深入解析SPRING架构与设计原理Spring源码深度解析]]></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>书推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统与安全]]></title>
    <url>%2Fposts%2Fbooks_recommand_android_system_security.html</url>
    <content type="text"><![CDATA[#书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 #Android系统基础Android的设计与实现卷1深入理解Android卷1邓凡平深入理解Android卷2_邓凡平深入理解Android卷3_邓凡平Android技术内幕.系统卷Android系统级深入开发.移植与调试Android深度探索（卷2）系统应用源代码分析与ROM定制拨云见日-基于android的内核与系统架构源码分析Android底层开发技术实战详解 内核、移植和驱动 Android源码设计模式解析与实战Android：Wi-Fi NFC和GPSAndroid系统原理及开发要点详解(韩超,梁泉)ANDROID框架揭秘(带完整书签高清扫描版) #Android系统安全ANDROID安全架构深究Android安全攻防权威指南Android安全攻防实战 (南非)keith makan, 崔孝晨;武晓音(译)Android安全技术揭秘与防范Android软件安全与逆向分析_带书签 #Linux内核ORANGE’S：一个操作系统的实现Linux内核设计与实现_第三版Linux内核设计的艺术Linux内核完全注释V3.0书签版30天自制操作系统.川合秀实]]></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>android</tag>
        <tag>security</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java&Jdk基础书籍推荐]]></title>
    <url>%2Fposts%2Fbooks_recommand_java_jdk.html</url>
    <content type="text"><![CDATA[书籍学习外话：用书和文档镇楼，站在巨人的肩膀上，才能进步的更快，才能少踩坑，赶紧阅读吧少年们。 JDK文档，最好的官方学习助手Oschina 中文API在线文档 Oracle官方文档下载 Oschina API文档集，包含各种Mybatis Mina 等API文档可以参考 Java系列经典好书推荐编码风格阿里巴巴Java开发手册Google Java编程风格指南 Java基础Effective_java中文版Thinking in Java 4th Edition-Java编程思想编写高质量代码改善Java程序的151个建议Java泛型和集合-Java.Generics.and.Collections).Maurice.Naftalin&amp;Philip.WadlerJava安全编码标准Java核心技术精讲_李兴华 Java线程和并发Java 并发编程实战Java多线程编程核心技术Java线程(第三版) Java程序优化Java性能优化权威指南Java程序性能优化 让你的Java程序更快、更稳定 Java虚拟机深入理解Java虚拟机：JVM高级特性与最佳实践自己动手写Java虚拟机 (Java核心技术系列)Java虚拟机精讲HotSpot实战 Java密码学Java加密与解密的艺术Java安全第二版 (3)图解密码技术精通PKI网络安全认证技术与编程实现.马臣云.王彦PKI技术 Web技术扩展架构探险_从零开始写JavaWeb框架深入分析Java Web技术内幕大型网站系统与JAVA中间件实践大型网站技术架构：核心原理与案例分析Spring技术内幕：深入解析SPRING架构与设计原理Spring源码深度解析]]></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jdk</tag>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度理解Android技术总结]]></title>
    <url>%2Fposts%2Fbooks_recommand_android_tech_deep_learn.html</url>
    <content type="text"><![CDATA[#深度理解Android技术总结 ##Android基础 ###开发文档https://developer.android.com/guide/index.html?hl=zh-cn ###阿里巴巴Android开发规范https://github.com/Blankj/AndroidStandardDevelop ###框架层知识点分层架构 MVC MVVM MVPhttps://developer.android.com/topic/libraries/architecture/guide.htmlhttps://github.com/googlesamples/android-architecturehttps://github.com/googlesamples/android-architecture-components组件化 模块化 容器化 Atlas smallhttps://yq.aliyun.com/articles/7239依赖注入 Dagger2https://toutiao.io/posts/5a3fp5/previewAOP面向切面编程 Aspectjhttp://blog.csdn.net/xwh_1230/article/details/78213160http://blog.csdn.net/xwh_1230/article/details/78225258事件驱动 EventBus otto EventPosterhttp://blog.csdn.net/android2me/article/details/66973037RxJava数据异步http://blog.csdn.net/caihongdao123/article/details/51897793https://www.jianshu.com/p/5e93c9101dc5Http Restful请求框架Retrofithttps://segmentfault.com/a/1190000005638577框架列表https://www.ctolib.com/cheatsheets-Android-ch.html常用的Utilhttps://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/README-CN.mdAndroid开源项目源码解析https://github.com/android-cn/android-open-project-analysis ##Android中间件 ###插件化http://blog.csdn.net/ganyao939543405/article/details/76146760 ###热修复https://github.com/Tencent/tinker/wiki ###Hook框架http://www.snowdream.tech/2016/09/02/android-install-xposed-framework/https://jaq.alibaba.com/community/art/show?articleid=809 ##VirtualXposed 和epichttps://github.com/android-hacker/VirtualXposedhttps://github.com/tiann/epichttp://weishu.me/2017/12/02/non-root-xposed/ ##Android系统 ###Framework ###JVM/Dalvik/ART虚拟机 ###Linux ###TrustZone-TEEhttp://blog.csdn.net/shuaifengyun/article/details/73716352 ###InSE芯片系统 ##Android安全 ###逆向]]></content>
      <categories>
        <category>000书籍推荐</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
        <tag>android</tag>
        <tag>技术总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java最佳实践]]></title>
    <url>%2Fposts%2Fjava_jdk_best_practise.html</url>
    <content type="text"></content>
      <categories>
        <category>00Java&amp;JDK</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Learn]]></title>
    <url>%2Fposts%2Fgit_learn.html</url>
    <content type="text"><![CDATA[Git在线文档12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; New Project: new project with eclipse/android studio/vs2012/codeblocks/makefile/sublimetext12345678910$ git init$ git add .$ git commit -m &quot;new project,first commit&quot;onsite github add your repository.... (may you should add your ssh key!)reference the note: echo &quot;# Improve&quot; &gt;&gt; README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://github.com/iofcas/Improve.git (为版本库添加名为origin的远程版本库) git push -u origin master (把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。) Distributed Development:1git clone https://github.com/iofcas/learngit1.git (git:/ssh:) Daily Build:12345$ mv rm vim modify....that&apos;s ok$ git add -A$ git status (git diff) $ git commit -m &quot;your build&quot; $ git push -u origin master Branch New Function:12345git branch devgit checkout dev 1,2&lt;=&gt;git checkout -b devmv rm vim modify....that&apos;s okgit commit -m &quot;branch new function ok&quot;git checkout master No conflict:12git merge dev (Fast-forward)git branch -d dev if conflict:(when master is ahead of dev_newfunction_master,no Fast-forward)12345$ vim &amp; modify the conlicted file$ git add .$ git commit -m &quot;conflict ok&quot;$ git log --graph --pretty=oneline --abbrev-commit$ git log --graph --pretty=oneline 123456789101112131415* e2b770b473f4b01c95051f67df183b716c588554 process conflict|\| * 4cfb80d84f31611f53e643a408c62e99e25a1cbc branch add a file* | d954435c6637927da5bdf440ed80c41e3fa346d2 add aaa|/* 2f435ae3a03e6b5225e91fb4d704c1e2eb85d562 modify git learn* b60880ac8fcecf1a20a332f12222d5e6f316aef4 modify file.cpp added-&gt;add* 1ac939b4d2b67777d40ae5a5d3c8cecec51049d0 add branch hello function* 07e8db4d764b1440bf4fa3c275e1ec339f24f97b modify learngit &amp; daily build model* b6408d0509fef560205a0a64fec27afc61285cdf del a file &amp; new fileB* 1c408eafa0db0306a63fe9a44f8edced2e72b898 modify file-&gt;file.cpp;new file fileA* 6db1625bd6355cb7e53e8035dad50ff2ace6a193 file.c-&gt;file and so on* c7e0be6095dd168603a8661e308d9db1de660955 add a new file* b6ee53e718df3f135c16a94890b305204f7a6ad5 add readme* a61163eeef7dcac1a592252cf30fd1451e08fd04 leartgit1 first commit –no-ff:12git merge --no-ff -m &quot;merge with no-ff&quot; dev(合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。) BUG:(当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交)1234$ git stashProcess BUG Branch$ git stash list$ git stash pop (git stash apply + git stash drop) Del New function with no merge:(接到上级命令，因经费不足，新功能必须取消)1$ git branch -D dev Dev Branch:(创建远程new分支并推送本地dev分支到远程)1 git push origin dev:new Version Tag:(Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针)123456789$ git tag v1.0 (HEAD)$ git tag v0.9 6224937 (git log --pretty=oneline --abbrev-commit)$ git tag$ git show v0.9$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164$ git tag -d v0.1$ git push origin v1.0$ git push origin --tags (push所有分支)$ git push origin :refs/tags/v0.9 (删除远程分支) Open Source Join:(一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。)1234$ fork $ git clone https://...my.git$ vim...$ pull request .gitignore:(https://github.com/github/gitignore) 1 另存为.gitignore即可 alias:1234$ git config --global alias.st status =&gt; git st$ git config --global alias.unstage &apos;reset HEAD&apos; =&gt; git unstage test.py &lt;=&gt; git reset $ HEAD test.py$ git config --global alias.last &apos;log -1&apos; =&gt; git last$ git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; =&gt; $ git lg config:123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com Reset File:1234Not staged for commit (not add .):(git checkout -- 丢弃工作区的修改)(git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”)$ git checkout -- readme.txt Changes to be committed(has added .):(git reset既可以回退版本，也可以把暂存区回退到工作区的修改)1$ git reset HEAD readme.txt Reset:1234$ git reset --hard HEAD^(HEAD当前版本，HEAD^^前两版本，HEAD~100前100版本)$ git log --pretty=oneline$ git reset --hard 3628164 $ git reflog (查看命令历史，以便确定要回到未来的哪个版本.) Fetch&amp;Pull:( ! [rejected] master -&gt; master (fetch first))1234567891011121314151617181920212223242526271 git fetch origin master (master:master 中第一个master是origin/master)git fetch origin mastergit log -p master..origin/mastergit merge origin/master2 git fetch origin master:tmp git fetch origin master:tmp git diff tmp git merge tmp3 git pull: (相当于git fetch 和 git merge) git pull origin master4 决策：git fetch更安全一些因为在merge前，我们可以查看更新情况，然后再决定是否合并5 git fetch origin branch1:branch2 (使用远程branch1分支在本地创建branch2,但不会切换到该分支) 如果本地不存在branch2分支, 则会自动创建一个新的branch2分支, 如果本地存在branch2分支, 并且是`fast forward&apos;, 则自动合并两个分支, 否则, 会阻止以上操作.6 git fetch origin master:tmp , git push origin master:dev git fetch origin server:local 从server fetch 到local git push origin local:server 从local push 到server Diff:12git diff origin/master (当前版本跟origin/master比较)git diff dev (当前版本跟dev版本比较) Git commit:一次良好的提交信息应该包含一个信息头，尽量用一行文字总结那些必要信息然后空下一行，接着写下关于这次提交的具体内容，有关修复bug的背景等等，尽量表达你为什么要做这次提交而不是你正在作什么提交。这样被人才能很好的理解而不会弄不清楚为什么需要这个东西。所有的提交内容保持在74个字符之内，这样才能被 git log正常的显示，而不会超过屏幕。下面是一些： 提交者信息，或者其他信息，一般都是 git 里面需要的代码编写者或者测试者名字和邮箱，具体参考 git 。(http://blog.csdn.net/jingxia2008/article/details/41290837 http://blog.jobbole.com/92713/)1234567891011121314151617181920212223242526272829Summarize changes in around 50 characters or less More detailed explanatory text, if necessary. Wrap it to about 72characters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like `log`, `shortlog`and `rebase` can get confused if you run the two together. Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequenses of thischange? Here&apos;s the place to explain them. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary here If you use an issue tracker, put references to them at the bottom,like this: Resolves: #123See also: #456, #789Reported-by: whoever-reported-itSigned-off-by: Your Name &lt;youremail@yourhost.com&gt; modified: xxx(modified content, untracked content)大概意思是xxx目录没有被跟踪。那自然push上去的时候是空的了解决办法：后来发现这主要是xxx目录下有一个.git 目录，可能是被人给你这个目录的时候里面有了.git目录。删除.git目录。重新git add .就可123$ git add . 前最好删除所有字母下的.git 一个工程最好只有一个.git$ find . -name .git | xargs rm -fr$ git add . 如果在master做了修改，没有commit，就新建分支，分支commit，将导致master恢复版本，之前的修改自动放到branch新分支里]]></content>
      <categories>
        <category>22tools</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next主题]]></title>
    <url>%2Fposts%2Ftools_hexo_new.html</url>
    <content type="text"><![CDATA[这里简要做介绍，深入了解可以参考:官方文档 hexo next 安装 首先安装node npm 然后安装hexonpm install -g hexo-cli-g一般用在安装可以直接全局执行的程序。其他依赖，直接放在package.json运行npm install安装在本地即可，npm install xxx –save可以把xxx这个软件save到package.json得dependency里边，下次直接npm install就可以安装所有软件。 第2部已经安装好hexo 初始化hexo程序，运行一下命令 hexo init npm install hexo generate hexo server -p 5555 既可以直接看到localhost:5555生成得博客 博客默认是landscape主题，可以在themes/landscape看到，也可以在_config.yml中看到theme: landscape配置项得默认值。 克隆next主题到themes/next, 根目录运行 git clone –branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next 修改根目录配置文件_config.yml中theme: landscape为theme: next hexo generate hexo s -p 5555 可以观察到next已经生效 建议删除themes/next中得.git文件夹，否则需要使用submodules git来处理比较麻烦，正常来说配置好后很长时间不会改变，即使有改变也可以通过beyondcompare来比对就可以了。 hexo next 个性化修改主要涉及根目录_config.yml, themes/next/_config.yml配置文件，还有themes/next/sourec/images文件夹，其他地方一般不需要修改。 自定义博客名字 _config.yml123456789101112title: Fitz.Leesubtitle:description: Security &amp; Android &amp; Javakeywords:author: Fitz.Leeurl: https://fitzlee.github.iodeploy: type: git repo: https://github.com/fitzlee/FitzLee.github.io branch: master 自定义博客avatar和favicon 准备一个图标, 使用在线工具，转换成32*32的ico文件作为网站logo 替换images/favicon.ico这个文件 修改next/_config.yml中favicon: images/favicon.ico 替换images/avatar.gif这个文件 自定义菜单 修改next/_config.yml文件中 1234567menu: home: / categories: /categories/ #about: /about/ archives: /archives/ tags: /tags/ about: /resume/ 运行hexo new page “categories” 运行hexo new page “tags” 修改文件夹根目录source/categories/index.md, 添加type: “categories” 修改文件夹根目录source/tags/index.md, 添加type: “tags” about: /resume/ 说明about/直接运行到resume.git这个仓得gh-pages静态页面，源码可以直接参考resume.git的gh-pages分支。 自定义社交图标123456789101112131415social: #LinkLabel: Link GitHub: https://github.com/fitzlee E-Mail: mailto:fitz.lee@outlook.com JianShu: https://www.jianshu.com/u/c7757daadf27social_icons: enable: true icons_only: false transition: false # Icon Mappings. # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome GitHub: github E-Mail: envelope JianShu: book 自定义友情链接或有意思得link，如下1234567# Blog rollslinks_title: Links#links_layout: blocklinks_layout: inlinelinks: Anquanke: https://www.anquanke.com/ Gityuan: https://www.gityuan.com/ 自定义固化文章链接默认是使用md文章得title来生成链接，如类似2017/01/02/0x23-0x43等，甚至还包含中文字符，那么会导致标题变化后，地址也变化，不利于google/baidu的索引，所以固定链接很重要。如下修改根目录_config.yml，如下添加urlname作为文章唯一链接。12permalink: posts/:urlname.htmlpermalink_defaults: 修改每一篇文章为如下样式123456789101112131415---title: JVM和ART经典书籍推荐urlname: jvm_art_book_recommanddate: 2016-06-05comments: truetop: true#description: #tags: [git,hah,hha]#keywords: gitcategories: 03JVM&amp;ARTtags: - 书籍推荐 - JVM - ART--- 运行查看样式hexo generatehexo s -p 5555查看运行结果。置顶文章hexo-generator-index-pin-top安装hexo-generator-index-pin-top npm uninstall hexo-generator-indexnpm install hexo-generator-index-pin-top –save给文章添加top: true的标签即可，但是多个top的话，没法自主选择优先级 安装search搜索页面 npm install hexo-generator-searchdb –save直接在themes/next/_config.yml修改12local_search: enable: true 如果安装后搜索的链接不一致，那么请修改permalink: posts/:urlname.htmlw为这个样子，不是permalink: /posts/:urlname.html这样。 运行hexo g/hexo s -p 5555即可观察到效果。 添加travis ci支持https://www.jianshu.com/p/e22c13d85659 一些配置文章参考hexo 置顶文章https://blog.csdn.net/qwerty200696/article/details/79010629 hexo环境配置https://blog.csdn.net/lijiajun95/article/details/53862528 个性化About页面简历建议直接跳转到另外一个gh-pages具体建立可以参考该页模版: https://gitee.com/cool-resume 显示更多摘要，不现实全文最好对置顶得几篇文章，进行精确控制，其他不控制即可。精确控制需要在md文章中，添加 即可。 其他 Quick Start创建新文章1$ hexo new "My New Post" 打开source_posts\xxx.md,开始写文章主要用法12345678910111213title: Hexo写文章layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blog#tags: [Hexo]tags: - Hexo - Blogkeywords: Hexo, Blogdescription: 生命在于折腾photos: - https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superplus/img/logo_white_ee663702.png 显示摘要123以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 MarkDown Markdown-Chinese-Demo1234567891011121314151617181920212223# 标题1## 标题2### 标题3- 列表1测试- 列表2- 列表3水平线—————————-1. 列表12. 列表23. 列表35. 顺序错了不用担心3. 写错的列表，会自动纠正如果文字后面紧跟着水平线，看看是什么效果———————*我是斜体*测试文字里面，**我是粗体**，很简单__我是粗体__————————————————————————————保存后，就可以看到渲染后的效果： More info: Writing 本地查看1$ hexo server More info: Server 部署到git1$ hexo d -g More info: GeneratingMore info: DeploymentMore info: Markdown hexo travishttps://www.jianshu.com/p/e22c13d85659 一些命令npm -vnode -v]]></content>
      <categories>
        <category>22tools</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
