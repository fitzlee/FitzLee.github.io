<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="设计模式,汇总,分析精华,DesignPattern,uml,23dp," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="设计模式之 UML 类图前言为什么要学习设计模式？ 个人觉得设计模式传授的是一种思想，是一种脱离语言的编程习惯。对于一个没有太多经验的程序员，如何写出 简洁优雅，可复用性高，可扩展性强，高内聚低耦合 的代码至关重要。学习别人的设计模式就是为了在没有经验的情况下写出一手不错的代码，只看不写并不能深刻体验到设计模式的巧妙之处。 设计模式讲的是别人千锤百炼出来的精华，如果有那么一天你再次看设计模式觉得，">
<meta name="keywords" content="设计模式,汇总,分析精华,DesignPattern,uml,23dp">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式UML和23种分类解析">
<meta property="og:url" content="https://fitzlee.github.io/posts/design_pattern_uml_23gof_analysis.html">
<meta property="og:site_name" content="Fitz.Lee">
<meta property="og:description" content="设计模式之 UML 类图前言为什么要学习设计模式？ 个人觉得设计模式传授的是一种思想，是一种脱离语言的编程习惯。对于一个没有太多经验的程序员，如何写出 简洁优雅，可复用性高，可扩展性强，高内聚低耦合 的代码至关重要。学习别人的设计模式就是为了在没有经验的情况下写出一手不错的代码，只看不写并不能深刻体验到设计模式的巧妙之处。 设计模式讲的是别人千锤百炼出来的精华，如果有那么一天你再次看设计模式觉得，">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-92bf9082359ed12dfae4476d7286674c_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-dce9c2eb387354bb7de9a3a47d5f3ed5_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-2b4dad2a2fa58923eaf6cec0460eea72_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-ac8ead9f8e60ed1abebf847d65c1633e_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-35f373e86c1f44ba4f3ff020ff52ff8c_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-86ac2db5174fcf34875a9e872ed4d27e_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-a5ab6c82e96b2119bf658f489886e888_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-f489103646695deda45ac115321d7634_hd.jpg">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_factory_simple.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_factory_method.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_factory_abstract.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_builder.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_prototype.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_singleton.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_adapter_class.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_adapter_object.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_bridge.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_composite.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_decorator.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_facade.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_flyweight.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_proxy.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_interpreter.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_template_method.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_chainofresponsibility.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_command.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_iterator.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_mediator.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_memento.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_observer.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_state.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_strategy.png">
<meta property="og:image" content="http://jayfeng.com/images/dp_uml_visitor.png">
<meta property="og:image" content="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png">
<meta property="og:image" content="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/program/design_pattern.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/builder/mr.simple/images/result.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/prototype-uml.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/result.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/result-2.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/result-3.png">
<meta property="og:image" content="http://blog.qiji.tech/wp-content/uploads/2016/02/UML_%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8.png">
<meta property="og:image" content="http://blog.qiji.tech/wp-content/uploads/2016/02/UML_%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/facade/elsdnwn/images/contextimpl.png">
<meta property="og:image" content="http://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/abs_bridge.jpg">
<meta property="og:image" content="http://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/win_bridge.jpg">
<meta property="og:image" content="https://user-images.githubusercontent.com/16668676/29739978-6c03d780-8a7e-11e7-8aad-3da3590c2ea1.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/proxy/singwhatiwanna/images/proxy-uml.png">
<meta property="og:image" content="https://img-blog.csdn.net/20160308154820959">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/template-method/mr.simple/images/async-flow.png">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml.png">
<meta property="og:image" content="https://github.com/suzeyu1992/repo/raw/master/project/design-pattern/%E7%9E%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EAndroid(%E7%AF%87%E4%B8%80">
<meta property="og:image" content="https://img-blog.csdn.net/20160824023119734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="https://img-blog.csdn.net/20160824014820658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="c:/Users/Li/AppData/Local/Temp/1532708415340.png">
<meta property="og:image" content="c:/Users/Li/AppData/Local/Temp/1532708445035.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/966283-d01a5845f7426097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700">
<meta property="og:image" content="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/iterator/haoxiqiang/images/Iterator_UML_class_diagram.svg.png">
<meta property="og:updated_time" content="2018-07-27T18:27:20.675Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式UML和23种分类解析">
<meta name="twitter:description" content="设计模式之 UML 类图前言为什么要学习设计模式？ 个人觉得设计模式传授的是一种思想，是一种脱离语言的编程习惯。对于一个没有太多经验的程序员，如何写出 简洁优雅，可复用性高，可扩展性强，高内聚低耦合 的代码至关重要。学习别人的设计模式就是为了在没有经验的情况下写出一手不错的代码，只看不写并不能深刻体验到设计模式的巧妙之处。 设计模式讲的是别人千锤百炼出来的精华，如果有那么一天你再次看设计模式觉得，">
<meta name="twitter:image" content="https://pic4.zhimg.com/80/v2-92bf9082359ed12dfae4476d7286674c_hd.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fitzlee.github.io/posts/design_pattern_uml_23gof_analysis.html"/>





  <title>设计模式UML和23种分类解析 | Fitz.Lee</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fitz.Lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/resume/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fitzlee.github.io/posts/design_pattern_uml_23gof_analysis.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fitz.Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fitz.Lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式UML和23种分类解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-27T18:27:20+00:00">
                2018-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/02DesignPattern/" itemprop="url" rel="index">
                    <span itemprop="name">02DesignPattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="设计模式之-UML-类图"><a href="#设计模式之-UML-类图" class="headerlink" title="设计模式之 UML 类图"></a>设计模式之 UML 类图</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>为什么要学习设计模式？</p>
<p><strong>个人觉得设计模式传授的是一种思想，是一种脱离语言的编程习惯。</strong>对于一个没有太多经验的程序员，如何写出 <strong>简洁优雅，可复用性高，可扩展性强，高内聚低耦合</strong> 的代码至关重要。学习别人的设计模式就是为了在没有经验的情况下写出一手不错的代码，只看不写并不能深刻体验到设计模式的巧妙之处。</p>
<p>设计模式讲的是别人千锤百炼出来的精华，如果有那么一天你再次看设计模式觉得，这些没什么特别的，那么说明你已经走上正轨，你的编程习惯已经向设计模式靠拢了。</p>
<p>这是我学习设计模式的开篇第一章，主要介绍下 UML 类图。在之后的文章我也会介绍设计模式的一些基本原则以及 23 种设计模式，并给出详细的代码说明。</p>
<h2 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a><strong>UML 类图</strong></h2><p>学习设计模式必定需要先读懂 UML 类图，下面就谈谈具体 UML 类图中的概念。</p>
<p>首先是关于类本身，下面我以人为例，先看 UML 图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-92bf9082359ed12dfae4476d7286674c_hd.jpg" alt="img"></p>
<p>用 Java 代码可表示为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">	return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void takeExam(Course course) &#123;</span><br><span class="line">        course.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Course &#123;</span><br><span class="line">    private String courseName;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // take exam...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类名叫做 Student 和 Course</li>
<li>+ 代表 public 公共，- 代表 private 私有，# 代表 protected</li>
<li>成员变量类型写在前，参数名称写在后</li>
<li>函数传递参数，参数名写在前，类型写在后</li>
<li>函数返回值写在函数签名的后面</li>
<li>两个类之间若存在关系，可使用箭头进行关联，具体关联规则在下文介绍</li>
<li>箭头上的数字代表 1 个学生可以不参加课程，也可以无限制参加各种课程</li>
<li>1 代表一个，0..* 代表 0 个到无限个</li>
</ul>
<p><strong>在 Java 或其它面向对象设计模式中，类与类之间主要有 6 种关系，他们分别为：依赖，关联，聚合，组合，继承，实现。他们的耦合度依次增强。</strong></p>
<h2 id="1-依赖-Dependency"><a href="#1-依赖-Dependency" class="headerlink" title="1. 依赖 (Dependency)"></a>1. 依赖 (Dependency)</h2><p>依赖关系的定义为：对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。</p>
<p>可以简单的理解为：类 A 使用到了类 B，而这种使用关系具有偶然性，临时性，非常弱的，但是 B 类中的变化会影响到类 A，比如某个学生要用笔写字，学生与笔的关系就是一种依赖关系，如果笔没水了，那学生就不能写字了(B 类的变化会影响类 A) 或者换另一只笔继续写字(临时性体现)。</p>
<p>思考下面这样的场景：</p>
<p>你是一名出租车司机，每天开着公司给你分配的车去载客，而每天出租车可能不同，我只是个司机，公司给我什么车我就开什么车，我使用这个车。</p>
<p><strong>具体 UML 类图表现为：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-dce9c2eb387354bb7de9a3a47d5f3ed5_hd.jpg" alt="img"></p>
<p>Java 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123;</span><br><span class="line">    public void drive(Car car) &#123;</span><br><span class="line">	car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Car &#123;</span><br><span class="line">    public void run()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖关系不一定表现为形参，一共可以有三种表现形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123;</span><br><span class="line">    //通过形参方式发生依赖关系 </span><br><span class="line">    public void drive1(Car car) &#123;</span><br><span class="line">	car.run();</span><br><span class="line">    &#125;</span><br><span class="line">     //通过局部变量发生依赖关系</span><br><span class="line">    public void drive2() &#123;</span><br><span class="line">	Car car = new Car();</span><br><span class="line">	car.run();</span><br><span class="line">    &#125;</span><br><span class="line">    //通过静态变量发生依赖关系</span><br><span class="line">    public void drive3() &#123;</span><br><span class="line">	Car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-关联-Association"><a href="#2-关联-Association" class="headerlink" title="2. 关联 (Association)"></a>2. 关联 (Association)</h2><p>关联关系的定义为：对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。</p>
<p>它体现的两个类中一种强依赖关系，比如我和我的朋友，这种关系比依赖更强，不存在依赖关系中的偶然性，关系也不是临时的，一般是长期性的。</p>
<p>关联关系分为单向关联和双向关联：</p>
<ol>
<li>在 Java 中，单向关联表现为：类 A 当中使用了 类 B，其中类 B 是作为类 A 的成员变量。</li>
<li>双向关联表现为: 类 A 当中使用类 B 作为成员变量，同时类 B 中也使用了类 A 作为成员变量。</li>
</ol>
<p>根据可以上面的例子可以修改为以下的场景：</p>
<p>我是一名老司机，车是我自己的，我拥有这辆车，平时也会用着辆车去载客人。</p>
<p><strong>用 UML 类图表示为:</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-2b4dad2a2fa58923eaf6cec0460eea72_hd.jpg" alt="img"></p>
<p><strong>双向关联的话箭头可以省略。</strong></p>
<p>用 Java 代码表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123;</span><br><span class="line">    private Car car = new Car();</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">	car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Car &#123;</span><br><span class="line">    public void run()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖和关联区别：</p>
<ul>
<li>用锤子修了一下桌子，我和锤子之间就是一种依赖，我和我的同事就是一种关联。</li>
<li>依赖是一种弱关联，只要一个类用到另一个类，但是和另一个类的关系不是太明显的时候（可以说是“uses”了那个类），就可以把这种关系看成是依赖，依赖也可说是一种偶然的关系，而不是必然的关系。</li>
<li>关联是类之间的一种关系，例如老师教学生，老公和老婆这种关系是非常明显的。依赖是比较陌生，关联是我们已经认识熟悉了。</li>
</ul>
<h2 id="3-聚合-Aggregation"><a href="#3-聚合-Aggregation" class="headerlink" title="3.聚合 (Aggregation)"></a>3.聚合 (Aggregation)</h2><p>聚合关系是关联关系的一种，耦合度强于关联，他们的代码表现是相同的，仅仅是在语义上有所区别：关联关系的对象间是相互独立的，而聚合关系的对象之间存在着包容关系，他们之间是“整体-个体”的相互关系。</p>
<p>聚合关系中作为成员变量的类一般使用 set 方法赋值。</p>
<p><strong>用 UML 类图表示为：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-ac8ead9f8e60ed1abebf847d65c1633e_hd.jpg" alt="img"></p>
<p>Java 代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123;</span><br><span class="line">    private Car car = null;</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">	car.run();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCar(Car c)&#123;</span><br><span class="line">	car = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Car &#123;</span><br><span class="line">    public void run()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-组合-Composition"><a href="#4-组合-Composition" class="headerlink" title="4. 组合 (Composition)"></a>4. 组合 (Composition)</h2><p>相比于聚合，组合是一种耦合度更强的关联关系。存在组合关系的类表示“整体-部分”的关联关系，“整体”负责“部分”的生命周期，他们之间是共生共死的；并且“部分”单独存在时没有任何意义。</p>
<p>对比与聚合关系，我们可以将前面的例子变为下面的场景：</p>
<ol>
<li>车是一辆私家车，是司机财产的一部分，<strong>强调的是人财产的部分性</strong>，则相同的代码即可表示聚合关系。</li>
<li>车是司机必须有的财产，要想成为一个司机必须要现有财产，车要是没了，司机也不想活了。而且司机要是不干司机了，这车也就没了。</li>
</ol>
<p><strong>所以，关联、聚合、组合只能配合语义，结合上下文才能够判断出来，而只给出一段代码让我们判断是关联，聚合，还是组合关系，则是无法判断的。</strong></p>
<p><strong>用 UML 类图表示为:</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-35f373e86c1f44ba4f3ff020ff52ff8c_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Driver &#123;</span><br><span class="line">    private Car car = null;</span><br><span class="line">    public Driver(Car car) &#123;</span><br><span class="line">	this.car = car;</span><br><span class="line">    &#125;</span><br><span class="line">    public void drive() &#123;</span><br><span class="line">	car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Car &#123;</span><br><span class="line">    public void run()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再举一个恰当点的例子：</p>
<p>人和灵魂，身体之间是组合关系，当人的生命周期开始时，必须同时拥有灵魂和肉体，当人的生命周期结束时，灵魂肉体随之消亡；无论是灵魂还是肉体，都不能单独存在，他们必须作为人的组成部分存在。</p>
<p><strong>用 UML 类图表示为</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-86ac2db5174fcf34875a9e872ed4d27e_hd.jpg" alt="img"></p>
<h2 id="5-继承-Generalization"><a href="#5-继承-Generalization" class="headerlink" title="5. 继承 (Generalization)"></a>5. 继承 (Generalization)</h2><p>继承表示类与类 (或者接口与接口) 之间的父子关系。在 Java 中，用关键字 extends 表示继承关系。</p>
<p>思考下面的场景：</p>
<p>人是一种高级动物，不仅可以像动物可以吃和睡觉，而且还可以学习。</p>
<p><strong>用 UML 类图表示为:</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-a5ab6c82e96b2119bf658f489886e888_hd.jpg" alt="img"></p>
<p>Java 代码表示为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public void eat()&#123;&#125;</span><br><span class="line">    public void sleep()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class People extends Animal &#123;</span><br><span class="line">    public void study()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-实现-Implementation"><a href="#6-实现-Implementation" class="headerlink" title="6. 实现 (Implementation)"></a>6. 实现 (Implementation)</h2><p>表示一个类实现一个或多个接口的方法。接口定义好操作的集合，由实现类去完成接口的具体操作, 在 Java 中使用 implements 表示。在 Java 中，如果实现了某个接口，那么就必须实现接口中所有的方法。</p>
<p>比如一个人可以吃饭和学习，那么就可以定义一个人的接口。让具体的人去实现它。</p>
<p><strong>用 UML 类图表示为：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-f489103646695deda45ac115321d7634_hd.jpg" alt="img"></p>
<p>Java 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface IPeople &#123;</span><br><span class="line">    public void eat();</span><br><span class="line">    public void study();</span><br><span class="line">&#125;</span><br><span class="line">class People implements IPeople &#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void study()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="意图、UML类图"><a href="#意图、UML类图" class="headerlink" title="意图、UML类图"></a>意图、UML类图</h1><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><blockquote>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>与对象的创建有关。</p>
</blockquote>
<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_factory_simple.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_factory_simple.png" alt="简单工厂UML类图"></a><br><a href="http://jayfeng.com/images/dp_uml_factory_method.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_factory_method.png" alt="工厂方法UML类图"></a></p>
<h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_factory_abstract.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_factory_abstract.png" alt="抽象工厂UML类图"></a></p>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_builder.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_builder.png" alt="建造者模式UML类图"></a></p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_prototype.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_prototype.png" alt="原型模式UML类图"></a></p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_singleton.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_singleton.png" alt="单例模式UML类图"></a></p>
<blockquote>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>处理类或对象的组合。</p>
</blockquote>
<h2 id="结构型模式-1"><a href="#结构型模式-1" class="headerlink" title="结构型模式"></a>结构型模式</h2><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_adapter_class.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_adapter_class.png" alt="类适配器UML类图"></a><br><a href="http://jayfeng.com/images/dp_uml_adapter_object.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_adapter_object.png" alt="对象适配器UML类图"></a></p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_bridge.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_bridge.png" alt="桥接模式UML类图"></a></p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><blockquote>
<p>将对象组合成树形结构以表示“部分 -整体”的层次结构。 Composite使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_composite.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_composite.png" alt="组合模式UML类图"></a></p>
<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说, Decorator模式相比生成子类更为灵活。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_decorator.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_decorator.png" alt="装饰者模式UML类图"></a></p>
<h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><blockquote>
<p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_facade.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_facade.png" alt="门面模式UML类图"></a></p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_flyweight.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_flyweight.png" alt="享元模式UML类图"></a></p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_proxy.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_proxy.png" alt="代理模式UML类图"></a></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote>
<h3 id="行为型模式-1"><a href="#行为型模式-1" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>对类或对象怎样交互和怎样分配职责进行描述。</p>
</blockquote>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_interpreter.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_interpreter.png" alt="解释器模式UML类图"></a></p>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_template_method.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_template_method.png" alt="模板方法模式UML类图"></a></p>
<h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_chainofresponsibility.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_chainofresponsibility.png" alt="职责链模式UML类图"></a></p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_command.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_command.png" alt="命令模式UML类图"></a></p>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><blockquote>
<p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_iterator.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_iterator.png" alt="迭代器模式UML类图"></a></p>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_mediator.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_mediator.png" alt="中介者模式UML类图"></a></p>
<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><blockquote>
<p>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_memento.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_memento.png" alt="备忘录模式UML类图"></a></p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><blockquote>
<p>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_observer.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_observer.png" alt="观察者模式UML类图"></a></p>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_state.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_state.png" alt="状态模式UML类图"></a></p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><blockquote>
<p>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_strategy.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_strategy.png" alt="策略模式UML类图"></a></p>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p><a href="http://jayfeng.com/images/dp_uml_visitor.png" target="_blank" rel="noopener"><img src="http://jayfeng.com/images/dp_uml_visitor.png" alt="访问者模式UML类图"></a></p>
<p><a href="http://jayfeng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">#设计模式</a> <a href="http://jayfeng.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">#面向对象</a> <a href="http://jayfeng.com/tags/OOP/" target="_blank" rel="noopener">#OOP</a> <a href="http://jayfeng.com/tags/%E6%84%8F%E5%9B%BE/" target="_blank" rel="noopener">#意图</a> <a href="http://jayfeng.com/tags/UML/" target="_blank" rel="noopener">#UML</a></p>
<h1 id="Android系统编程思想：设计模式"><a href="#Android系统编程思想：设计模式" class="headerlink" title="Android系统编程思想：设计模式"></a>Android系统编程思想：设计模式</h1><p><strong>关于作者</strong></p>
<blockquote>
<p>郭孝星，程序员，吉他手，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的<a href="https://github.com/guoxiaoxing" target="_blank" rel="noopener">Github</a>提issue或者发邮件至<a href="mailto:guoxiaoxingse@163.com" target="_blank" rel="noopener">guoxiaoxingse@163.com</a>与我交流。</p>
</blockquote>
<p><strong>文章目录</strong></p>
<p>提到设计模式，大家并不陌生，我们之前在分析Android源码的时候也有提及，但都比较零散，不成系统。今天的这篇文章就来系统的总结一下23种 设计模式的模式定义与实现方式，让读者有一个整体上的模式。</p>
<p>什么是设计模式？<img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f914.png" alt="thinking"></p>
<blockquote>
<p>通俗来讲，设计模式就是针对某一种特殊场景而给出的标准解决方案，它是前辈们的经验性总结，也是实现软件工程化的基础，良好的设计模式应用 可以是我们的软件变得更加健壮可维护。</p>
</blockquote>
<p>设计模式按照类型划分可以分为三大类，如下所示：</p>
<ul>
<li>创建型设计模式：如同它的名字那样，它是用来解耦对象的实例化过程。</li>
<li>结构型设计模式：将类和对象按照一定规则组合成一个更加强大的结构体。</li>
<li>行为型设计模式：定义类和对象的交互行为。</li>
</ul>
<p>23种设计模式划分如下图所示：</p>
<p><a href="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/program/design_pattern.png" target="_blank" rel="noopener"><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/program/design_pattern.png" alt="img"></a></p>
<p>注：23种设计模式很多小伙伴都烂熟于心，但是真正编程实践的时候未必会想的起来，这其实是一个潜移默化的过程，在看设计模式的时候，尽量多动手写一写，其中 手写（不借助IDE）的效果最佳，可以加深理解，理解的深了，编程的时候自然就可以想的到去应用。</p>
<h2 id="一-创建型设计模式"><a href="#一-创建型设计模式" class="headerlink" title="一 创建型设计模式"></a>一 创建型设计模式</h2><blockquote>
<p>创建型设计模式主要用来解耦对象的实例化过程，控制实例的生成。</p>
</blockquote>
<p>创建型设计模式一共有六种，如下所示：</p>
<h3 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1 单例模式"></a>1.1 单例模式</h3><p>模式定义</p>
<blockquote>
<p>当系统中只需要一个实例或者一个全局访问点的时候可以使用单例模式。</p>
</blockquote>
<ul>
<li>优点：节省系统创建对象的资源，提高了系统效率，提供了统一的访问入口，可以严格控制用户对该对象的访问。</li>
<li>缺点：只有一个对象，积累的职责过重，违背了单一职责原则。构造方法为private，无法继承，扩展性较差。</li>
</ul>
<p>单例模式的实现由很多种，如下所示：</p>
<ol>
<li>懒汉式单例</li>
<li>双层校验锁单例</li>
<li>容器单例</li>
<li>静态内部类单例</li>
<li>枚举单例</li>
</ol>
<p>其中静态内部类单例和枚举单例都是单例模式最佳的实现，但是出于便利性的考量，双层校验锁的实现应用的更为广泛，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DoubleCheckSingleton &#123;</span><br><span class="line">    </span><br><span class="line">    // volatile关键字保证了：① instance实例对于所有线程都是可见的 ② 禁止了instance </span><br><span class="line">    // 操作指令重排序。</span><br><span class="line">    private volatile static DoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    private DoubleCheckSingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static DoubleCheckSingleton getInstance() &#123;</span><br><span class="line">        // 第一次校验，防止不必要的同步。</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // synchronized关键字加锁，保证每次只有一个线程执行对象初始化操作</span><br><span class="line">            synchronized (DoubleCheckSingleton.class) &#123;</span><br><span class="line">                // 第二次校验，进行判空，如果为空则执行初始化</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                     instance = new DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于双层校验锁单例为何能实现JVM单例，它的要点在于两次判空和synchronized、volatile关键字，具体原理已经写在上方的注释里，这里 我们单独说一下volatile关键字。</p>
<p>说明我们说到，volatile关键字禁止了instance 操作指令重排序，我们来解释一下，我们知道instance = new DoubleCheckSingleton()这个操作 在汇编指令里大致会做三件事情：</p>
<ol>
<li>给我们知道instance分配内存。</li>
<li>调用DoubleCheckSingleton()构造方法。</li>
<li>将构造的对象赋值给instance。</li>
</ol>
<p>但是在真正执行的时候，Java编译器是允许指令乱序执行的（编译优化），所以上述3步的顺序得不到保证，有可能是132，试想一下，如果线程A没有执行第2步，先执行了 第3步，而恰在此时，线程B取走了instance对象，在使用instance对象时就会有问题，双层校验锁单例失败，而volatile关键字可以禁止指令重排序从而解决这个问题。</p>
<p>单例模式的另一个问题就是多进程的情况下的失败问题，因为JVN里的单例是基于一个虚拟机进程的，这个时候通常的做法就是让这个单例支持跨进程调用，这个在 Android里一般用AIDL实现。</p>
<h3 id="1-2-建造者模式"><a href="#1-2-建造者模式" class="headerlink" title="1.2 建造者模式"></a>1.2 建造者模式</h3><h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>封装一个复杂对象的构建过程，可以按照流程来构建对象。</p>
</blockquote>
<ul>
<li>优点：它可以将一个复杂对象的构建与表示相分离，同一个构建过程，可以构成出不同的产品，简化了投建逻辑。</li>
<li>缺点：如果构建流程特别复杂，就是导致这个构建系统过于庞大，不利于控制。</li>
</ul>
<p>建造者模式的实现，也十分简单，如下所示：</p>
<h4 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line"></span><br><span class="line">    private String board;</span><br><span class="line">    private String display;</span><br><span class="line">    private String os;</span><br><span class="line"></span><br><span class="line">    public String getBoard() &#123;</span><br><span class="line">        return board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDisplay() &#123;</span><br><span class="line">        return display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOs() &#123;</span><br><span class="line">        return os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Product(Builder builder) &#123;</span><br><span class="line">        // 进行构建</span><br><span class="line">        this.board = builder.board;</span><br><span class="line">        this.display = builder.display;</span><br><span class="line">        this.os = builder.os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        // 建造者模式还可以设置默认值</span><br><span class="line">        private String board = &quot;default value&quot;;</span><br><span class="line">        private String display = &quot;default value&quot;;</span><br><span class="line">        private String os = &quot;default value&quot;;</span><br><span class="line"></span><br><span class="line">        public void setBoard(String board) &#123;</span><br><span class="line">            this.board = board;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setDisplay(String display) &#123;</span><br><span class="line">            this.display = display;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setOs(String os) &#123;</span><br><span class="line">            this.os = os;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Product build() &#123;</span><br><span class="line">            return new Product(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android中的应用"><a href="#Android中的应用" class="headerlink" title="Android中的应用"></a>Android中的应用</h4><p>在Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder， 使用该Builder来构建复杂的AlertDialog对象。简单示例如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//显示基本的AlertDialog  </span><br><span class="line">private void showDialog(Context context) &#123;  </span><br><span class="line">    AlertDialog.Builder builder = new AlertDialog.Builder(context);  </span><br><span class="line">    builder.setIcon(R.drawable.icon);  </span><br><span class="line">    builder.setTitle(&quot;Title&quot;);  </span><br><span class="line">    builder.setMessage(&quot;Message&quot;);  </span><br><span class="line">    builder.setPositiveButton(&quot;Button1&quot;,  </span><br><span class="line">            new DialogInterface.OnClickListener() &#123;  </span><br><span class="line">                public void onClick(DialogInterface dialog, int whichButton) &#123;  </span><br><span class="line">                    setTitle(&quot;点击了对话框上的Button1&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    builder.setNeutralButton(&quot;Button2&quot;,  </span><br><span class="line">            new DialogInterface.OnClickListener() &#123;  </span><br><span class="line">                public void onClick(DialogInterface dialog, int whichButton) &#123;  </span><br><span class="line">                    setTitle(&quot;点击了对话框上的Button2&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    builder.setNegativeButton(&quot;Button3&quot;,  </span><br><span class="line">            new DialogInterface.OnClickListener() &#123;  </span><br><span class="line">                public void onClick(DialogInterface dialog, int whichButton) &#123;  </span><br><span class="line">                    setTitle(&quot;点击了对话框上的Button3&quot;);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">    builder.create().show();  // 构建AlertDialog， 并且显示</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果 : <a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/builder/mr.simple/images/result.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/builder/mr.simple/images/result.png" alt="result"></a></p>
<p>下面我们看看AlertDialog的相关源码 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">// AlertDialog</span><br><span class="line">public class AlertDialog extends Dialog implements DialogInterface &#123;</span><br><span class="line">    // Controller, 接受Builder成员变量P中的各个参数</span><br><span class="line">    private AlertController mAlert;</span><br><span class="line"></span><br><span class="line">    // 构造函数</span><br><span class="line">    protected AlertDialog(Context context, int theme) &#123;</span><br><span class="line">        this(context, theme, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4 : 构造AlertDialog</span><br><span class="line">    AlertDialog(Context context, int theme, boolean createContextWrapper) &#123;</span><br><span class="line">        super(context, resolveDialogTheme(context, theme), createContextWrapper);</span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert = new AlertController(getContext(), this, getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实际上调用的是mAlert的setTitle方法</span><br><span class="line">    @Override</span><br><span class="line">    public void setTitle(CharSequence title) &#123;</span><br><span class="line">        super.setTitle(title);</span><br><span class="line">        mAlert.setTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实际上调用的是mAlert的setCustomTitle方法</span><br><span class="line">    public void setCustomTitle(View customTitleView) &#123;</span><br><span class="line">        mAlert.setCustomTitle(customTitleView);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setMessage(CharSequence message) &#123;</span><br><span class="line">        mAlert.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // AlertDialog其他的代码省略</span><br><span class="line">    </span><br><span class="line">    // ************  Builder为AlertDialog的内部类   *******************</span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        // 1 : 存储AlertDialog的各个参数, 例如title, message, icon等.</span><br><span class="line">        private final AlertController.AlertParams P;</span><br><span class="line">        // 属性省略</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * Constructor using a context for this builder and the &#123;@link AlertDialog&#125; it creates.</span><br><span class="line">         */</span><br><span class="line">        public Builder(Context context) &#123;</span><br><span class="line">            this(context, resolveDialogTheme(context, 0));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Builder(Context context, int theme) &#123;</span><br><span class="line">            P = new AlertController.AlertParams(new ContextThemeWrapper(</span><br><span class="line">                    context, resolveDialogTheme(context, theme)));</span><br><span class="line">            mTheme = theme;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Builder的其他代码省略 ......</span><br><span class="line"></span><br><span class="line">        // 2 : 设置各种参数</span><br><span class="line">        public Builder setTitle(CharSequence title) &#123;</span><br><span class="line">            P.mTitle = title;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        public Builder setMessage(CharSequence message) &#123;</span><br><span class="line">            P.mMessage = message;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder setIcon(int iconId) &#123;</span><br><span class="line">            P.mIconId = iconId;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123;</span><br><span class="line">            P.mPositiveButtonText = text;</span><br><span class="line">            P.mPositiveButtonListener = listener;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        public Builder setView(View view) &#123;</span><br><span class="line">            P.mView = view;</span><br><span class="line">            P.mViewSpacingSpecified = false;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 3 : 构建AlertDialog, 传递参数</span><br><span class="line">        public AlertDialog create() &#123;</span><br><span class="line">            // 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog </span><br><span class="line">            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);</span><br><span class="line">            // 5 : 将P中的参数应用的dialog中的mAlert对象中</span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            if (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(true);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            if (P.mOnKeyListener != null) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            return dialog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java应用"><a href="#Java应用" class="headerlink" title="Java应用"></a>Java应用</h4><h3 id="1-3-原型模式"><a href="#1-3-原型模式" class="headerlink" title="1.3 原型模式"></a>1.3 原型模式</h3><h4 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>当某个对象的数据结构或者构建过程特别复杂，频繁的构建势必会消耗系统性能，这个时候我们采用原型模式对原有的 对象进行克隆，构建新的对象。</p>
</blockquote>
<ul>
<li>优点：直接克隆原有实例生成新的实例，免去了复杂的构建过程，节省了系统资源。</li>
<li>缺点：</li>
</ul>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/prototype/mr.simple/images/prototype-uml.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/prototype-uml.png" alt="uml"></a></p>
<h5 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h5><ul>
<li>Client : 客户端用户。</li>
<li>Prototype : 抽象类或者接口，声明具备clone能力。</li>
<li>ConcretePrototype : 具体的原型类.</li>
</ul>
<p>实现原型模式也很简单，主需要声明实现loneable接口，然后覆写Object的clone()方法接口。</p>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Person implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    public int age;</span><br><span class="line">    public String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Person clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return (Person) super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原型模式要注意深拷贝和浅拷贝的问题，Object的clone()方法默认是钱拷贝，即对于引用对象拷贝的地址而不是值，所以要实现 深拷贝，在clone()方法里对于引用对象也有调用一下clone()方法，并且引用对象也要实现Cloneable接口和覆写clone()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.dp.example.builder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.dp.example.prototype;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文档类型, 扮演的是ConcretePrototype角色，而cloneable是代表prototype角色</span><br><span class="line"> * </span><br><span class="line"> * @author mrsimple</span><br><span class="line"> */</span><br><span class="line">public class WordDocument implements Cloneable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 文本</span><br><span class="line">     */</span><br><span class="line">    private String mText;</span><br><span class="line">    /**</span><br><span class="line">     * 图片名列表</span><br><span class="line">     */</span><br><span class="line">    private ArrayList&lt;String&gt;&lt;string&gt; mImages = new ArrayList&lt;String&gt;&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    public WordDocument() &#123;</span><br><span class="line">        System.out.println(&quot;----------- WordDocument构造函数 -----------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 克隆对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected WordDocument clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            WordDocument doc = (WordDocument) super.clone();</span><br><span class="line">            doc.mText = this.mText;</span><br><span class="line">            doc.mImages = this.mImages;</span><br><span class="line">            return doc;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getText() &#123;</span><br><span class="line">        return mText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setText(String mText) &#123;</span><br><span class="line">        this.mText = mText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;string&gt; getImages() &#123;</span><br><span class="line">        return mImages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param img</span><br><span class="line">     */</span><br><span class="line">    public void addImage(String img) &#123;</span><br><span class="line">        this.mImages.add(img);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 打印文档内容</span><br><span class="line">     */</span><br><span class="line">    public void showDocument() &#123;</span><br><span class="line">        System.out.println(&quot;----------- Word Content Start -----------&quot;);</span><br><span class="line">        System.out.println(&quot;Text : &quot; + mText);</span><br><span class="line">        System.out.println(&quot;Images List: &quot;);</span><br><span class="line">        for (String imgName : mImages) &#123;</span><br><span class="line">            System.out.println(&quot;image name : &quot; + imgName);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;----------- Word Content End -----------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过WordDocument类模拟了word文档中的基本元素，即文字和图片。WordDocument的在该原型模式示例中扮演的角色为ConcretePrototype， 而Cloneable的角色则为Prototype。WordDocument实现了clone方法以实现对象克隆。下面我们看看Client端的使用 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WordDocument originDoc = new WordDocument();</span><br><span class="line">        originDoc.setText(&quot;这是一篇文档&quot;);</span><br><span class="line">        originDoc.addImage(&quot;图片1&quot;);</span><br><span class="line">        originDoc.addImage(&quot;图片2&quot;);</span><br><span class="line">        originDoc.addImage(&quot;图片3&quot;);</span><br><span class="line">        originDoc.showDocument();</span><br><span class="line"></span><br><span class="line">        WordDocument doc2 = originDoc.clone();</span><br><span class="line">        doc2.showDocument();</span><br><span class="line">        </span><br><span class="line">        doc2.setText(&quot;这是修改过的Doc2文本&quot;);</span><br><span class="line">        doc2.showDocument();</span><br><span class="line">         </span><br><span class="line">        originDoc.showDocument();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下 :<br><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/prototype/mr.simple/images/result.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/result.png" alt="result"></a></p>
<p>可以看到，doc2是通过originDoc.clone()创建的，并且doc2第一次输出的时候和originDoc输出是一样的。即doc2是originDoc的一份拷贝，他们的内容是一样的，而doc2修改了文本内容以后并不会影响originDoc的文本内容。需要注意的是通过clone拷贝对象的时候并不会执行构造函数！</p>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>将main函数的内容修改为如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    WordDocument originDoc = new WordDocument();</span><br><span class="line">    originDoc.setText(&quot;这是一篇文档&quot;);</span><br><span class="line">    originDoc.addImage(&quot;图片1&quot;);</span><br><span class="line">    originDoc.addImage(&quot;图片2&quot;);</span><br><span class="line">    originDoc.addImage(&quot;图片3&quot;);</span><br><span class="line">    originDoc.showDocument();</span><br><span class="line"></span><br><span class="line">    WordDocument doc2 = originDoc.clone();</span><br><span class="line">    </span><br><span class="line">    doc2.showDocument();</span><br><span class="line">    </span><br><span class="line">    doc2.setText(&quot;这是修改过的Doc2文本&quot;);</span><br><span class="line">    doc2.addImage(&quot;哈哈.jpg&quot;);</span><br><span class="line">    doc2.showDocument();</span><br><span class="line">    </span><br><span class="line">    originDoc.showDocument();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下 :<br><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/prototype/mr.simple/images/result-2.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/result-2.png" alt="result"></a><br>细心的朋友可能发现了，在doc2添加了一张名为”哈哈.jpg”的照片，但是却也显示在originDoc中？这是怎么回事呢？ 其实学习过C++的朋友都知道，这是因为上文中WordDocument的clone方法中只是简单的进行浅拷贝，引用类型的新对象doc2的mImages只是单纯的指向了this.mImages引用，而并没有进行拷贝。doc2的mImages添加了新的图片，实际上也就是往originDoc里添加了新的图片，所以originDoc里面也有”哈哈.jpg” 。那如何解决这个问题呢？ 那就是采用深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用的形式。示例如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 克隆对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected WordDocument clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            WordDocument doc = (WordDocument) super.clone();</span><br><span class="line">            doc.mText = this.mText;</span><br><span class="line">//            doc.mImages = this.mImages;</span><br><span class="line">            doc.mImages = (ArrayList&lt;String&gt;) this.mImages.clone();</span><br><span class="line">            return doc;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，将doc.mImages指向this.mImages的一份拷贝， 而不是this.mImages本身，这样在doc2添加图片时并不会影响originDoc，如图所示 :<br><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/prototype/mr.simple/images/result-3.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/prototype/mr.simple/images/result-3.png" alt="result"></a></p>
<h4 id="Androi应用Intent"><a href="#Androi应用Intent" class="headerlink" title="Androi应用Intent"></a>Androi应用Intent</h4><p>在Android源码中，我们以熟悉的Intent来分析源码中的原型模式。简单示例如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(&quot;smsto:0800000123&quot;);    </span><br><span class="line">Intent shareIntent = new Intent(Intent.ACTION_SENDTO, uri);    </span><br><span class="line">shareIntent.putExtra(&quot;sms_body&quot;, &quot;The SMS text&quot;);    </span><br><span class="line"></span><br><span class="line">Intent intent = (Intent)shareIntent.clone() ;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们通过shareIntent.clone方法拷贝了一个对象intent, 然后执行startActivity(intent)， 随即就进入了短信页面，号码为0800000123,文本内容为The SMS text，即这些内容都与shareIntent一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    return new Intent(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Copy constructor.</span><br><span class="line"> */</span><br><span class="line">public Intent(Intent o) &#123;</span><br><span class="line">    this.mAction = o.mAction;</span><br><span class="line">    this.mData = o.mData;</span><br><span class="line">    this.mType = o.mType;</span><br><span class="line">    this.mPackage = o.mPackage;</span><br><span class="line">    this.mComponent = o.mComponent;</span><br><span class="line">    this.mFlags = o.mFlags;</span><br><span class="line">    if (o.mCategories != null) &#123;</span><br><span class="line">        this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);</span><br><span class="line">    &#125;</span><br><span class="line">    if (o.mExtras != null) &#123;</span><br><span class="line">        this.mExtras = new Bundle(o.mExtras);</span><br><span class="line">    &#125;</span><br><span class="line">    if (o.mSourceBounds != null) &#123;</span><br><span class="line">        this.mSourceBounds = new Rect(o.mSourceBounds);</span><br><span class="line">    &#125;</span><br><span class="line">    if (o.mSelector != null) &#123;</span><br><span class="line">        this.mSelector = new Intent(o.mSelector);</span><br><span class="line">    &#125;</span><br><span class="line">    if (o.mClipData != null) &#123;</span><br><span class="line">        this.mClipData = new ClipData(o.mClipData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，clone方法实际上在内部调用了new Intent(this); 这就和C++中的拷贝构造函数完全一致了，而且是深拷贝。由于该模式比较简单，就不做太多说明。</p>
<p>接下来我们继续看看三种工厂模式，如下所示：</p>
<ul>
<li>简单工厂模式：根据传入的参数决定实例化哪个对象。</li>
<li>工厂模式：工厂模式定义了一个创建对象的接口，由子类进行对象的初始化，即工厂模式将子类的初始化推迟到了子类里。</li>
<li>抽象工厂模式：抽象工厂模式和工厂模式很相似，只是它利用接口或者抽象类定义了一个产品族，例如定义一个拨号产品族，只定义功能，不 关心实现，具体实现交由Android、iOS等操作系统自己完成。</li>
</ul>
<h3 id="1-4-简单工厂模式"><a href="#1-4-简单工厂模式" class="headerlink" title="1.4 简单工厂模式"></a>1.4 简单工厂模式</h3><h4 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>根据传入的参数决定实例化哪个对象。</p>
</blockquote>
<p>简单工厂模式是工厂模式的简化版本，无需定义抽象工厂，通常还可以利用反射来生成对象，简化操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 简单工厂</span><br><span class="line">public class SimpleFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T extends AbstractProduct&gt; T create(Class&lt;T&gt; clasz) &#123;</span><br><span class="line">        AbstractProduct product = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            product = (AbstractProduct) Class.forName(clasz.getName()).newInstance();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android中简单工厂模式的应用"><a href="#Android中简单工厂模式的应用" class="headerlink" title="Android中简单工厂模式的应用"></a>Android中简单工厂模式的应用</h4><p>在Android中我们了解的使用到了简单工厂方法的地方有Bitmap对象的获取、Fragment创建等。接下来我们分开看一下。</p>
<p>Bitmap源码分析</p>
<p><strong>首先来说我们是不能通过new方法来创建Bitmap对象的，因为Bitmap类的构造函数是私有的，只能是通过JNI实例化。</strong></p>
<p>接下来我们随便找个入口开始看，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bmp = BitmapFactory.decodeFile(String pathName);</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>我们把源码中的调用关系找出来，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public static Bitmap decodeFile(String pathName) &#123;</span><br><span class="line">    return decodeFile(pathName, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Bitmap decodeFile(String pathName, Options opts) &#123;</span><br><span class="line">    Bitmap bm = null;</span><br><span class="line">    InputStream stream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        stream = new FileInputStream(pathName);</span><br><span class="line">        bm = decodeStream(stream, null, opts);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        /*  do nothing.</span><br><span class="line">            If the exception happened on open, bm will be null.</span><br><span class="line">        */</span><br><span class="line">        Log.e(&quot;BitmapFactory&quot;, &quot;Unable to decode stream: &quot; + e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (stream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                // do nothing here</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) &#123;</span><br><span class="line">    // we don&apos;t throw in this case, thus allowing the caller to only check</span><br><span class="line">    // the cache, and not force the image to be decoded.</span><br><span class="line">    if (is == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bitmap bm = null;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, &quot;decodeBitmap&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (is instanceof AssetManager.AssetInputStream) &#123;</span><br><span class="line">            final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset();</span><br><span class="line">            bm = nativeDecodeAsset(asset, outPadding, opts);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bm = decodeStreamInternal(is, outPadding, opts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bm == null &amp;&amp; opts != null &amp;&amp; opts.inBitmap != null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Problem decoding into existing bitmap&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setDensityFromOptions(bm, opts);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage,</span><br><span class="line">        Rect padding, Options opts);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Set the newly decoded bitmap&apos;s density based on the Options.</span><br><span class="line"> */</span><br><span class="line">private static void setDensityFromOptions(Bitmap outputBitmap, Options opts) &#123;</span><br><span class="line">    if (outputBitmap == null || opts == null) return;</span><br><span class="line"></span><br><span class="line">    final int density = opts.inDensity;</span><br><span class="line">    if (density != 0) &#123;</span><br><span class="line">        outputBitmap.setDensity(density);</span><br><span class="line">        final int targetDensity = opts.inTargetDensity;</span><br><span class="line">        if (targetDensity == 0 || density == targetDensity || density == opts.inScreenDensity) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] np = outputBitmap.getNinePatchChunk();</span><br><span class="line">        final boolean isNinePatch = np != null &amp;&amp; NinePatch.isNinePatchChunk(np);</span><br><span class="line">        if (opts.inScaled || isNinePatch) &#123;</span><br><span class="line">            outputBitmap.setDensity(targetDensity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (opts.inBitmap != null) &#123;</span><br><span class="line">        // bitmap was reused, ensure density is reset</span><br><span class="line">        outputBitmap.setDensity(Bitmap.getDefaultDensity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485</span><br></pre></td></tr></table></figure>
<p>我们来分析一下调用过程，可以看到<strong>decodeFile(String pathName)调用的是decodeFile(String pathName, Options opts)，在两个参数的decodeFile方法中又去调用了decodeStream(InputStream is, Rect outPadding, Options opts)方法，然后最终调用nativeDecodeAsset或者nativeDecodeStream来构建Bitmap对象，这两个都是native方法(Android中使用Skia库来解析图像 )。再经过setDensityFromOptions方法的一些设置解码密度之类的操作，返回我们要的Bitmap对象。</strong></p>
<blockquote>
<p>/*<em><br>\</em> Creates Bitmap objects from various sources, including files, streams, and byte-arrays.<br>*/</p>
</blockquote>
<p>看下BitmapFactory的注释我们可以看到，这个工厂支持从不同的资源创建Bitmap对象，包括files, streams, 和byte-arrays，但是调用关系都大同小异。</p>
<h3 id="1-5-工厂模式"><a href="#1-5-工厂模式" class="headerlink" title="1.5 工厂模式"></a>1.5 工厂模式</h3><h4 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>工厂模式定义了一个创建对象的接口，由子类进行对象的初始化，即工厂模式将子类的初始化推迟到了子类里。抽象工厂模式</p>
</blockquote>
<ul>
<li>优点：工厂模式符合开闭原则，当需要增加一个新产品时，只需要增加一个具体产品类和一个具体工厂类，无需修改原有的系统，外界也无需 知道具体的产品类的实现。</li>
<li>缺点：每次增加新产品的时候都会增加产品类和工厂类，势必会让系统越来越庞大。</li>
</ul>
<p>工厂模式的实现也很简单，就是定义一个抽象类或者接口工厂，在子类工厂中决定实例化具体的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    public abstract AbstractProduct create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂</span><br><span class="line">public class ConcretetFactory extends AbstractFactory&#123;</span><br><span class="line"></span><br><span class="line">    public static AbstractProduct create() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">//        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象产品</span><br><span class="line">public class AbstractProduct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A</span><br><span class="line">public class ConcreteProductA extends AbstractProduct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B</span><br><span class="line">public class ConcreteProductB extends AbstractProduct &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android源码中的应用"><a href="#Android源码中的应用" class="headerlink" title="Android源码中的应用"></a>Android源码中的应用</h4><p>工厂方法模式应用很广泛，开发中使用到的数据结构中就隐藏着对工厂方法模式的应用，例如 List、Set，List、Set 继承自 Collection 接口，而 Collection 接口继承于 Iterable 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure>
<p>这意味着 List、Set 接口也会继承 iterator() 方法，下面以 ArrayList 为例进行分析：<br>ArrayList 中 iterator() 方法的实现就是构造并返回一个迭代器对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    // 迭代器</span><br><span class="line">    private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        protected int limit = java.util.ArrayList.this.size;</span><br><span class="line">        int cursor;       // index of next element to return</span><br><span class="line">        int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor &lt; limit;</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            int i = cursor;</span><br><span class="line">            if (i &gt;= limit)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData = java.util.ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;= elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            return (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            try &#123;</span><br><span class="line">                java.util.ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -1;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">                limit--;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 代码省略</span><br><span class="line">    &#125;</span><br><span class="line">    // 代码省略</span><br><span class="line">&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647</span><br></pre></td></tr></table></figure>
<p>其中的 iterator() 方法其实就相当于一个工厂方法，专为 new 对象而生，构造并返回一个具体的迭代器。</p>
<h3 id="1-6-抽象工厂模式"><a href="#1-6-抽象工厂模式" class="headerlink" title="1.6 抽象工厂模式"></a>1.6 抽象工厂模式</h3><p>模式定义</p>
<blockquote>
<p>抽象工厂模式和工厂模式很相似，只是它利用接口或者抽象类定义了一个产品族，例如定义一个拨号产品族，只定义功能，不 关心实现，具体实现交由Android、iOS等操作系统自己完成。</p>
</blockquote>
<ul>
<li>优点：</li>
<li>缺点：</li>
</ul>
<p>实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 抽象产品A</span><br><span class="line">public abstract class AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象产品B</span><br><span class="line">public abstract class AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A1</span><br><span class="line">public class ConcreteProductA1 extends AbstractProductA&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品A2</span><br><span class="line">public class ConcreteProductA2 extends AbstractProductA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B1</span><br><span class="line">public class ConcreteProductB1 extends AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品B2</span><br><span class="line">public class ConcreteProductB2 extends AbstractProductB &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象工厂</span><br><span class="line">public abstract class AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">    public abstract AbstractProductA createProductA();</span><br><span class="line">    public abstract AbstractProductB createProductB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂</span><br><span class="line">public class ConcreteFactory extends AbstractFactory &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ConcreteProductA1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ConcreteProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-结构型设计模式"><a href="#二-结构型设计模式" class="headerlink" title="二 结构型设计模式"></a>二 结构型设计模式</h2><p><strong>通过继承和对象组合实现结构型模式，其中继承实现的是类结构型模式，对象组合实现的是对象结构型模式。注意优先使用对象组合，而不是类继承。</strong>  </p>
<h3 id="2-1-适配器模式"><a href="#2-1-适配器模式" class="headerlink" title="2.1 适配器模式"></a>2.1 适配器模式</h3><p>模式定义</p>
<blockquote>
<p>适配器模式可以将一个类的接口，转换成客户端期望的另一个接口，让两个原本不兼容的接口可以无缝对接。</p>
</blockquote>
<ul>
<li>优点：</li>
<li>缺点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 目标接口</span><br><span class="line">public interface TargetInterface &#123;</span><br><span class="line">    int getFive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被适配对象</span><br><span class="line">public class Adaptee &#123;</span><br><span class="line"></span><br><span class="line">    public int getTen() &#123;</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 适配器</span><br><span class="line">public class Adapter extends Adaptee implements TargetInterface &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getFive() &#123;</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适配器的类图表示"><a href="#适配器的类图表示" class="headerlink" title="适配器的类图表示"></a>适配器的类图表示</h4><p>适配器模式又分两种，1. 类适配器模式；2. 对象适配器。如图一，图二所示。</p>
<p><img src="http://blog.qiji.tech/wp-content/uploads/2016/02/UML_%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8.png" alt="图一"><br>图一 类适配器模式<br><img src="http://blog.qiji.tech/wp-content/uploads/2016/02/UML_%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8.png" alt="图二"></p>
<h4 id="Android-ListView-中的-Adapter-模式"><a href="#Android-ListView-中的-Adapter-模式" class="headerlink" title="Android ListView 中的 Adapter 模式"></a>Android ListView 中的 Adapter 模式</h4><p>由于不同的 ListView 所要呈现的视图也是不同的，为了应对这些不同，就需要通过一个适配器来实现隔离和适配。我们可以通过一个继承自 BaseAdapter 类来实现自己的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ListView mListView = (ListView) findViewById(listView_id);</span><br><span class="line">mListView.setAdapter(new MyAdapter(context, mdData));</span><br><span class="line"></span><br><span class="line">public class MyAdapter extends BaseAdapter &#123;</span><br><span class="line">  private LayoutInflater mInflater;</span><br><span class="line">  private List&lt;String&gt; mData;</span><br><span class="line">  public MyAdapter(Context context, List&lt;String&gt; data) &#123;</span><br><span class="line">    this.mInflater = LayoutInflater.from(context);</span><br><span class="line">    mData = data;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public int getCount() &#123;</span><br><span class="line">    return mData.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public String getItem(int positon) &#123;</span><br><span class="line">    return mData.get(positon);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public long getItemId(int position) &#123;</span><br><span class="line">    return pos;</span><br><span class="line">  &#125;</span><br><span class="line">  //解析、设置、缓存 convertView 以及相关内容</span><br><span class="line">  @Override</span><br><span class="line">  public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">    ViewHolder holder = null;</span><br><span class="line">    // Item View 的复用</span><br><span class="line">    if (convertView == null) &#123;</span><br><span class="line">      holder = new ViewHolder();</span><br><span class="line">      convertView = mInflater.inflate(R.layout.my_listview_item, null);</span><br><span class="line">      holder.title = (TextView) convertView.findViewById(R.id.title);</span><br><span class="line">      convertView.setTag(holder);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      holder = (ViewHolder) convertView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">    holder.title.setText(mData.get(position));</span><br><span class="line">    return convertView;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加一个 Adapter 层来应对变化，将 ListView 需要的接口抽象到 Adapter 对象中，这样只要用户实现了 Adapter 的接口， ListView 就可以按照用户设定的显示效果、数量、数据来显示特定的 Item View。通过代理数据集来告知ListView 数据的个数（ getCount方法 ）以及每个数据 （ getItem方法 ），最重要的是要解决 Item View 的输出。Item View 千变万化，但终究它都是 View 类型， Adapter 统一将 Item View 输出为 View （ getView方法 ），这样就很好的应对了 Item View 的可变性。 </p>
<h3 id="2-2-组合模式"><a href="#2-2-组合模式" class="headerlink" title="2.2 组合模式"></a>2.2 组合模式</h3><h4 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>将对象组成树形结构以表示整体-部分的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>表示对象部分-整体的层次结构。</li>
<li>从一个整体中能够独立出部分模块或者功能的场景。</li>
</ul>
<h4 id="Android具体实现代码"><a href="#Android具体实现代码" class="headerlink" title="Android具体实现代码"></a>Android具体实现代码</h4><p>View.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class View ....&#123;</span><br><span class="line"> //此处省略无关代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewGroup.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ViewGroup extends View ...&#123;</span><br><span class="line"></span><br><span class="line">     //增加子节点</span><br><span class="line">    public void addView(View child, int index) &#123; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //删除子节点</span><br><span class="line">    public void removeView(View view) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">     //查找子节点</span><br><span class="line">    public View getChildAt(int index) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">            return mChildren[index];</span><br><span class="line">          &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            return null;</span><br><span class="line">          &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-装饰模式"><a href="#2-3-装饰模式" class="headerlink" title="2.3 装饰模式"></a>2.3 装饰模式</h3><h4 id="模式定义-5"><a href="#模式定义-5" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>动态的为对象增加一些额外的功能。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>需要透明且动态的扩展类的功能时。</li>
</ul>
<h4 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 抽象组件类</span><br><span class="line">public abstract class AbstractComponent &#123;</span><br><span class="line">    </span><br><span class="line">    protected abstract void operation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体组件类</span><br><span class="line">public class ConcreteComponent extends AbstractComponent &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void operation() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象装饰类</span><br><span class="line">public abstract class AbstractDecorator extends AbstractComponent &#123;</span><br><span class="line"></span><br><span class="line">    private AbstractComponent mComponent;</span><br><span class="line"></span><br><span class="line">    public AbstractDecorator(AbstractComponent component) &#123;</span><br><span class="line">        mComponent = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void operation() &#123;</span><br><span class="line">        mComponent.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体装饰类</span><br><span class="line">public class ConcreteDecorator extends AbstractDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteDecorator(AbstractComponent component) &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void operation() &#123;</span><br><span class="line">        operationA();</span><br><span class="line">        super.operation();</span><br><span class="line">        operationB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void operationA() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void operationB() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android源码中的模式实现"><a href="#Android源码中的模式实现" class="headerlink" title="Android源码中的模式实现"></a>Android源码中的模式实现</h4><p>Android源码中的装饰模式其实我们经常接触，但并不一定有过真正的了解，Context类在Android中被称为“上帝对象”，它本质是一个抽象类，其在我们装饰模式中就相当于抽象组件，而在其内部定义了大量的抽象方法，比如我们经常会用到的startActivity方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface to global information about an application environment.  This is</span><br><span class="line"> * an abstract class whose implementation is provided by</span><br><span class="line"> * the Android system.  It</span><br><span class="line"> * allows access to application-specific resources and classes, as well as</span><br><span class="line"> * up-calls for application-level operations such as launching activities,</span><br><span class="line"> * broadcasting and receiving intents, etc.</span><br><span class="line"> */</span><br><span class="line">public abstract class Context &#123;</span><br><span class="line"></span><br><span class="line">    // 省略代码</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Same as &#123;@link #startActivity(Intent, Bundle)&#125; with no options</span><br><span class="line">     * specified.</span><br><span class="line">     *</span><br><span class="line">     * @param intent The description of the activity to start.</span><br><span class="line">     *</span><br><span class="line">     * @throws ActivityNotFoundException &amp;nbsp;</span><br><span class="line">     *</span><br><span class="line">     * @see #startActivity(Intent, Bundle)</span><br><span class="line">     * @see PackageManager#resolveActivity</span><br><span class="line">     */</span><br><span class="line">    public abstract void startActivity(Intent intent);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Launch a new activity.  You will not receive any information about when</span><br><span class="line">     * the activity exits.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Note that if this method is being called from outside of an</span><br><span class="line">     * &#123;@link android.app.Activity&#125; Context, then the Intent must include</span><br><span class="line">     * the &#123;@link Intent#FLAG_ACTIVITY_NEW_TASK&#125; launch flag.  This is because,</span><br><span class="line">     * without being started from an existing Activity, there is no existing</span><br><span class="line">     * task in which to place the new activity and thus it needs to be placed</span><br><span class="line">     * in its own separate task.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method throws &#123;@link ActivityNotFoundException&#125;</span><br><span class="line">     * if there was no Activity found to run the given Intent.</span><br><span class="line">     *</span><br><span class="line">     * @param intent The description of the activity to start.</span><br><span class="line">     * @param options Additional options for how the Activity should be started.</span><br><span class="line">     * May be null if there are no options.  See &#123;@link android.app.ActivityOptions&#125;</span><br><span class="line">     * for how to build the Bundle supplied here; there are no supported definitions</span><br><span class="line">     * for building it manually.</span><br><span class="line">     *</span><br><span class="line">     * @throws ActivityNotFoundException &amp;nbsp;</span><br><span class="line">     *</span><br><span class="line">     * @see #startActivity(Intent)</span><br><span class="line">     * @see PackageManager#resolveActivity</span><br><span class="line">     */</span><br><span class="line">    public abstract void startActivity(Intent intent, @Nullable Bundle options);</span><br><span class="line">    </span><br><span class="line">    // 省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Context真正的实现类是ContextImpl，ContextImpl继承自Context抽象类，并实现了Context中的抽象方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Common implementation of Context API, which provides the base</span><br><span class="line"> * context object for Activity and other application components.</span><br><span class="line"> */</span><br><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    </span><br><span class="line">    // 代码省略</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        startActivity(intent, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void startActivity(Intent intent, Bundle options) &#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123;</span><br><span class="line">            throw new AndroidRuntimeException(</span><br><span class="line">                    &quot;Calling startActivity() from outside of an Activity &quot;</span><br><span class="line">                    + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span><br><span class="line">                    + &quot; Is this really what you want?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), null,</span><br><span class="line">            (Activity)null, intent, -1, options);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里ContextImpl就相当于组件具体实现类，那么谁来承担装饰者的身份呢？我们知道Activity从类层次上来说本质是一个Context，如果大家留意过其代码会发现Activity并非直接继承于Context，而是继承于ContextThemeWrapper，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Activity extends ContextThemeWrapper</span><br><span class="line">        implements LayoutInflater.Factory2,</span><br><span class="line">        Window.Callback, KeyEvent.Callback,</span><br><span class="line">        OnCreateContextMenuListener, ComponentCallbacks2,</span><br><span class="line">        Window.OnWindowDismissedCallback &#123;</span><br><span class="line"> </span><br><span class="line">    // 代码省略       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个ContextThemeWrapper又继承了ContextWrapper：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A ContextWrapper that allows you to modify the theme from what is in the </span><br><span class="line"> * wrapped context. </span><br><span class="line"> */</span><br><span class="line">public class ContextThemeWrapper extends ContextWrapper &#123;</span><br><span class="line">    // 代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终这个ContextWrapper才继承于Context，为什么类层次会这么复杂？其实这里就是一个典型的装饰模式，ContextWrapper就是我们要找的装饰者，在ContextWrapper中有一个Context的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Proxying implementation of Context that simply delegates all of its calls to</span><br><span class="line"> * another Context.  Can be subclassed to modify behavior without changing</span><br><span class="line"> * the original Context.</span><br><span class="line"> */</span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line">    Context mBase;</span><br><span class="line"></span><br><span class="line">    public ContextWrapper(Context base) &#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止已经有点装饰模式的样子了，不过好像还缺点什么，没错，一个来自于抽象组件的方法，这里我们还是先看startActivity，在ContextWrapper中同样有一个startActivity方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Proxying implementation of Context that simply delegates all of its calls to</span><br><span class="line"> * another Context.  Can be subclassed to modify behavior without changing</span><br><span class="line"> * the original Context.</span><br><span class="line"> */</span><br><span class="line">public class ContextWrapper extends Context &#123;</span><br><span class="line"></span><br><span class="line">    // 代码省略</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        mBase.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void startActivity(Intent intent, Bundle options) &#123;</span><br><span class="line">        mBase.startActivity(intent, options);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出ContextWrapper中的startActivity方法也仅仅是简单地调用了具体组件实现类ContextImpl中的对应方法而已，实质上ContextWrapper中所有的方法都仅仅是调用了ContextImpl中的方法，对Context具体的包装拓展则由ContextWrapper的具体子类完成，比如我们的Activity、Service和Application。</p>
<h3 id="2-4-外观模式"><a href="#2-4-外观模式" class="headerlink" title="2.4 外观模式"></a>2.4 外观模式</h3><h4 id="模式定义-6"><a href="#模式定义-6" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>要求一个字系统的外部与其内部的通信都通过一个统一的而对象进行。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>子系统在迭代的过程中可以会不断变化，甚至被替代掉，给一个统一的访问接口，避免子系统的改变影响到外部的调用者。</li>
<li>当需要构建层次结构型的系统时，为各层子系统提供访问的接口进行通信，避免直接产生依赖。</li>
</ul>
<h4 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h4><p>简单实现的介绍</p>
<p>电视遥控器是现实生活中一个比较好的外观模式的运用，遥控器可以控制电源的开源、声音的调整、频道的切换等。这个遥控器就是我们这里说的外观或者门面，而电源、声音、频道切换系统就是我们的子系统。遥控器统一对这些子模块的控制，我想你没有用过多个遥控器来分别控制电源开关、声音控制等功能。下面我们就来简单模拟一下这个系统。</p>
<p>实现源码</p>
<p>TvController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TvController &#123;</span><br><span class="line">    private PowerSystem mPowerSystem = new PowerSystem();</span><br><span class="line">    private VoiceSystem mVoiceSystem = new VoiceSystem();</span><br><span class="line">    private ChannelSystem mChannelSystem = new ChannelSystem();</span><br><span class="line"></span><br><span class="line">    public void powerOn() &#123;</span><br><span class="line">        mPowerSystem.powerOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOff() &#123;</span><br><span class="line">        mPowerSystem.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnUp() &#123;</span><br><span class="line">        mVoiceSystem.turnUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnDown() &#123;</span><br><span class="line">        mVoiceSystem.turnDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void nextChannel() &#123;</span><br><span class="line">        mChannelSystem.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prevChannel() &#123;</span><br><span class="line">        mChannelSystem.prev();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PowerSystem.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 电源控制系统</span><br><span class="line"> */</span><br><span class="line"> class PowerSystem &#123;</span><br><span class="line">    public void powerOn() &#123;</span><br><span class="line">        System.out.println(&quot;开机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOff() &#123;</span><br><span class="line">        System.out.println(&quot;关机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VoiceSystem.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 声音控制系统</span><br><span class="line"> */</span><br><span class="line">class VoiceSystem &#123;</span><br><span class="line">    public void turnUp() &#123;</span><br><span class="line">        System.out.println(&quot;音量增大&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnDown() &#123;</span><br><span class="line">        System.out.println(&quot;音量减小&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelSystem.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 频道控制系统</span><br><span class="line"> */</span><br><span class="line">class ChannelSystem &#123;</span><br><span class="line">    public void next() &#123;</span><br><span class="line">        System.out.println(&quot;下一频道&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prev() &#123;</span><br><span class="line">        System.out.println(&quot;上一频道&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TvController &#123;</span><br><span class="line">    private PowerSystem mPowerSystem = new PowerSystem();</span><br><span class="line">    private VoiceSystem mVoiceSystem = new VoiceSystem();</span><br><span class="line">    private ChannelSystem mChannelSystem = new ChannelSystem();</span><br><span class="line"></span><br><span class="line">    public void powerOn() &#123;</span><br><span class="line">        mPowerSystem.powerOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOff() &#123;</span><br><span class="line">        mPowerSystem.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnUp() &#123;</span><br><span class="line">        mVoiceSystem.turnUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnDown() &#123;</span><br><span class="line">        mVoiceSystem.turnDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void nextChannel() &#123;</span><br><span class="line">        mChannelSystem.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void prevChannel() &#123;</span><br><span class="line">        mChannelSystem.prev();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开机</span><br><span class="line">下一频道</span><br><span class="line">音量增大</span><br><span class="line">关机</span><br></pre></td></tr></table></figure>
<p>上面的TvController封装了对电源、声音、频道切换的操作，为用户提供了一个统一的接口。使得用户控制电视机更加的方便、更易于使用。</p>
<h4 id="Android应用-context封装"><a href="#Android应用-context封装" class="headerlink" title="Android应用-context封装"></a>Android应用-context封装</h4><p>在开发过程中，Context是最重要的一个类型。它封装了很多重要的操作，比如startActivity()、sendBroadcast()等，几乎是开发者对应用操作的统一入口。Context是一个抽象类，它只是定义了抽象接口，真正的实现在ContextImpl类中。它就是今天我们要分析的外观类。</p>
<p>在应用启动时，首先会fork一个子进程，并且调用ActivityThread.main方法启动该进程。ActivityThread又会构建Application对象，然后和Activity、ContextImpl关联起来，然后再调用Activity的onCreate、onStart、onResume函数使Activity运行起来。我们看看下面的相关代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">private final void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">		// 代码省略</span><br><span class="line"></span><br><span class="line">        // 1、创建并且加载Activity，调用其onCreate函数</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">            Bundle oldState = r.state;</span><br><span class="line">            // 2、调用Activity的onResume方法，使Activity变得可见</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     private final Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">        // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;);</span><br><span class="line">		// 代码省略</span><br><span class="line"></span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            // 1、创建Activity</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            if (r.state != null) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to instantiate activity &quot; + component</span><br><span class="line">                    + &quot;: &quot; + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 2、创建Application</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                // ***** 构建ContextImpl  ****** </span><br><span class="line">                ContextImpl appContext = new ContextImpl();</span><br><span class="line">                appContext.init(r.packageInfo, r.token, this);</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line">                // 获取Activity的title</span><br><span class="line">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config = new Configuration(mConfiguration);</span><br><span class="line">            </span><br><span class="line">                 // 3、Activity与context, Application关联起来</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstance,</span><br><span class="line">                        r.lastNonConfigurationChildInstances, config);</span><br><span class="line">				// 代码省略</span><br><span class="line"></span><br><span class="line">                // 4、回调Activity的onCreate方法</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">           </span><br><span class="line">                // 代码省略</span><br><span class="line">            &#125;</span><br><span class="line">            r.paused = true;</span><br><span class="line"></span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">        &#125; catch (SuperNotCalledException e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123;</span><br><span class="line">   </span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">        // 1、最终调用Activity的onResume方法</span><br><span class="line">        ActivityClientRecord r = performResumeActivity(token, clearHide);</span><br><span class="line">        // 代码省略</span><br><span class="line">        // 2、这里是重点，在这里使DecorView变得可见</span><br><span class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                // 获取Window，即PhoneWindow类型</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                // 3、获取Window的顶级视图，并且使它可见</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                // 4、获取WindowManager</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                // 5、构建LayoutParams参数</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                if (a.mVisibleFromClient) &#123;</span><br><span class="line">                    a.mWindowAdded = true;</span><br><span class="line">                    // 6、将DecorView添加到WindowManager中，最终的操作是通过WindowManagerService的addView来操作</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!willBeVisible) &#123;</span><br><span class="line">                if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);</span><br><span class="line">                r.hideForNow = true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 代码省略</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public final ActivityClientRecord performResumeActivity(IBinder token,</span><br><span class="line">            boolean clearHide) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">       </span><br><span class="line">        if (r != null &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                // 代码省略</span><br><span class="line">                // 执行onResume</span><br><span class="line">                r.activity.performResume();</span><br><span class="line">				// 代码省略</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Activity启动之后，Android给我们提供了操作系统服务的统一入口，也就是Activity本身。这些工作并不是Activity自己实现的，而是将操作委托给Activity父类ContextThemeWrapper的mBase对象，这个对象的实现类就是ContextImpl ( 也就是performLaunchActivity方法中构建的ContextImpl )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">class ContextImpl extends Context &#123;</span><br><span class="line">    private final static String TAG = &quot;ApplicationContext&quot;;</span><br><span class="line">    private final static boolean DEBUG = false;</span><br><span class="line">    private final static boolean DEBUG_ICONS = false;</span><br><span class="line"></span><br><span class="line">    private static final Object sSync = new Object();</span><br><span class="line">    private static AlarmManager sAlarmManager;</span><br><span class="line">    private static PowerManager sPowerManager;</span><br><span class="line">    private static ConnectivityManager sConnectivityManager;</span><br><span class="line">    private AudioManager mAudioManager;</span><br><span class="line">    LoadedApk mPackageInfo;</span><br><span class="line">    private Resources mResources;</span><br><span class="line">    private PackageManager mPackageManager;</span><br><span class="line">    private NotificationManager mNotificationManager = null;</span><br><span class="line">    private ActivityManager mActivityManager = null;</span><br><span class="line">    </span><br><span class="line">	// 代码省略</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">    public void sendBroadcast(Intent intent) &#123;</span><br><span class="line">        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">        try &#123;</span><br><span class="line">            ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, null,</span><br><span class="line">                Activity.RESULT_OK, null, null, null, false, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">    public void startActivity(Intent intent) &#123;</span><br><span class="line">        if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123;</span><br><span class="line">            throw new AndroidRuntimeException(</span><br><span class="line">                    &quot;Calling startActivity() from outside of an Activity &quot;</span><br><span class="line">                    + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span><br><span class="line">                    + &quot; Is this really what you want?&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">            getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">    public ComponentName startService(Intent service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()));</span><br><span class="line">            if (cn != null &amp;&amp; cn.getPackageName().equals(&quot;!&quot;)) &#123;</span><br><span class="line">                throw new SecurityException(</span><br><span class="line">                        &quot;Not allowed to start service &quot; + service</span><br><span class="line">                        + &quot; without permission &quot; + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">            return cn;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">    public String getPackageName() &#123;</span><br><span class="line">        if (mPackageInfo != null) &#123;</span><br><span class="line">            return mPackageInfo.getPackageName();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RuntimeException(&quot;Not supported in system context&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ContextImpl内部有很多xxxManager类的对象，也就是我们上文所说的各种子系统的角色。ContextImpl内部封装了一些系统级别的操作，有的子系统功能虽然没有实现，但是也提供了访问该子系统的接口，比如获取ActivityManager的getActivityManager方法。</p>
<p>比如我们要启动一个Activity的时候，我们调用的是startActivity方法，这个功能的内部实现实际上是Instrumentation完成的。ContextImpl封装了这个功能，使得用户根本不需要知晓Instrumentation相关的信息，直接使用startActivity即可完成相应的工作。其他的子系统功能也是类似的实现，比如启动Service和发送广播内部使用的是ActivityManagerNative等。ContextImpl的结构图如下 :<br><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/facade/elsdnwn/images/contextimpl.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/facade/elsdnwn/images/contextimpl.png" alt="context"></a></p>
<p>外观模式非常的简单，只是封装了子系统的操作，并且暴露接口让用户使用，避免了用户需要与多个子系统进行交互，降低了系统的耦合度、复杂度。如果没有外观模式的封装，那么用户就必须知道各个子系统的相关细节，子系统之间的交互必然造成纠缠不清的关系，影响系统的稳定性、复杂度。</p>
<h3 id="2-5-桥接模式"><a href="#2-5-桥接模式" class="headerlink" title="2.5 桥接模式"></a>2.5 桥接模式</h3><p>模式定义</p>
<blockquote>
<p>将抽象部分和实现部分相互分离，使它们可以独立变化。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>如果一个系统需要在抽象部分和实现部分增加更多的灵活性，避免两种变化的时候相互影响。</li>
<li>如果不希望使用继承而增加系统的复杂度，可以考虑使用桥接模式。</li>
<li>一个类存在两个独立变化的纬度，且这两个纬度都希望进行扩展。</li>
</ul>
<h4 id="Android-源码中的桥接模式"><a href="#Android-源码中的桥接模式" class="headerlink" title="Android 源码中的桥接模式"></a>Android 源码中的桥接模式</h4><p>桥接模式在 Android 源码中应用广泛，比较典型的有 Adapter 与 AdapterView 的桥接，Window 与 WindowManager 的桥接模式。</p>
<h5 id="Adapter-与-AdapterView-的桥接"><a href="#Adapter-与-AdapterView-的桥接" class="headerlink" title="Adapter 与 AdapterView 的桥接"></a>Adapter 与 AdapterView 的桥接</h5><p><img src="http://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/abs_bridge.jpg" alt="abs_bridge.jpg"></p>
<h5 id="Window-与-WindowManager-的桥接"><a href="#Window-与-WindowManager-的桥接" class="headerlink" title="Window 与 WindowManager 的桥接"></a>Window 与 WindowManager 的桥接</h5><p><img src="http://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/win_bridge.jpg" alt="win_bridge.jpg"></p>
<p>通过以上两 UML 类图应该能明显的看出来桥接模式的影子。</p>
<h3 id="2-6-享元模式"><a href="#2-6-享元模式" class="headerlink" title="2.6 享元模式"></a>2.6 享元模式</h3><h4 id="模式定义-7"><a href="#模式定义-7" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>使用共享对象可以有效的支持大量的细粒度对象。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>系统中存在着大量的相似对象。</li>
<li>细粒度的对象都具有较接近的外部状态，而且内部状态与外部环境无关。</li>
<li>需要缓冲池的场景。</li>
</ul>
<h4 id="Android-源码中的享元模式"><a href="#Android-源码中的享元模式" class="headerlink" title="Android 源码中的享元模式"></a>Android 源码中的享元模式</h4><p>在使用 Handler 发送消息之前，我们一般都会使用如下代码调用 <code>mHandler.obtainMessage()</code> 方法获取一个 Message 对象。这其中究竟是怎么实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler = new Handler();</span><br><span class="line"></span><br><span class="line">public void do() &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //do sth</span><br><span class="line">            Message message = mHandler.obtainMessage();</span><br><span class="line">            message.what = 1;</span><br><span class="line">            message.obj = result;</span><br><span class="line">            mHandler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Handler.otainMessage()方法</span><br><span class="line">public final Message obtainMessage()&#123;</span><br><span class="line">    return Message.obtain(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Handler.obtainMessage() 实际上调用的是 Message 的 obtain 方法，我们顺着源码看下去。</p>
<p>先看看 Message 类部分源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// sometimes we store linked lists of these things</span><br><span class="line">Message next;</span><br><span class="line"></span><br><span class="line">private static final Object sPoolSync = new Object();//作为锁对象</span><br><span class="line">private static Message sPool;//虽然名称为 sPool 但是实际上是一个指向消息队列队首的指针</span><br><span class="line">private static int sPoolSize = 0;//</span><br><span class="line"></span><br><span class="line">private static final int MAX_POOL_SIZE = 50;//「对象池」中的最大数量</span><br><span class="line"></span><br><span class="line">public static Message obtain(Handler h) &#123;</span><br><span class="line">    Message m = obtain();//调用 obtain 方法获取 message 对象</span><br><span class="line">    m.target = h;//指定 message 的目标对象</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从消息对象池中取出一个 Message 对象，如果没有就创建一个</span><br><span class="line">public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            m.flags = 0; // 清空 in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();//消息池中没有可复用的 Message 就创建一个新的 Message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从对象池中获取对象的大致流程。无论是 Handler.obtainMessage(参数列表) 方法，还是 Message 的 obtain(参数列表) 方法，最终都会调用 Message.obtain() 方法。在 Message.obtain() 方法的实现中，会先从对象池中获取 Message 对象，如果获取不到，则创建一个新的 Message 对象，然后返回。该对象在后续的执行过程中会被回收到对象池，以便复用。</p>
<p>但是 Message 对象是如何被回收到「对象池」中的呢？ 从 Message 类的部分代码中我们看到 sPool 的实际类型是一个 Message 对象，而不是一个容器。另外从 obtain 方法中我们不难看到链表的踪影。难道消息池是使用链表实现的吗？</p>
<p>在 AS 中打开 Message 类的结构图，可以看到其中有一个 recycle 方法，我们看看里面是怎么实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123;//判断消息是否还在使用</span><br><span class="line">        if (gCheckRecycle) &#123;//如果消息处在使用状态时被 gc 回收，就抛出异常</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot; + &quot;is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;//直接返回，取消回收操作</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();//调用回收方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 回收一个可能还在使用的对象</span><br><span class="line"> */</span><br><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">    // 只要该对象还在回收对象池中，就标记该对象为正在使用状态。</span><br><span class="line">    // 清空其他状态</span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = 0;</span><br><span class="line">    arg1 = 0;</span><br><span class="line">    arg2 = 0;</span><br><span class="line">    obj = null;</span><br><span class="line">    replyTo = null;</span><br><span class="line">    sendingUid = -1;</span><br><span class="line">    when = 0;</span><br><span class="line">    target = null;</span><br><span class="line">    callback = null;</span><br><span class="line">    data = null;</span><br><span class="line">	//回收消息到消息池中</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = this;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recycle 方法首先会判断 Message 对象是否处在使用状态。如果处在使用状态会直接返回（如果此时 GC 回收该对象会抛出异常），否则调用 recycleUnchecked 方法，具体的回收逻辑是在 recycleUnchecked 方法中实现的。首先会标记 Message 处于使用状态，然后清空对象中的其他状态。将消息存入回收池，主要是链表的操作。大致如下图所示。</p>
<p><a href="https://user-images.githubusercontent.com/16668676/29739978-6c03d780-8a7e-11e7-8aad-3da3590c2ea1.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/16668676/29739978-6c03d780-8a7e-11e7-8aad-3da3590c2ea1.png" alt="msg"></a></p>
<p>小结</p>
<p>Message 通过在内部构建一个链表来维护一个被会受到 Message 对象的对象池，当用户调用 obtain 方法时，会优先从池中获取。如果池中没有可以复用的对象就创建一个新的对象，该对象使用完之后，会被缓存到对象池中，当下次调用 obtain 方法时，他们就会被复用。</p>
<p>此处 Message 扮演了三个角色。既是 FlyWeight 抽象，又是 ConcreteFlyWeight 对象，同时还担任 FlyWeightFactory 角色，承担着管理对象池的职责。</p>
<p>想进一步了解 Android 消息机制的同学可参考<a href="https://ivanljt.github.io/blog/2017/04/28/Android-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Android 消息机制解析</a>。</p>
<h3 id="2-7-代理模式"><a href="#2-7-代理模式" class="headerlink" title="2.7 代理模式"></a>2.7 代理模式</h3><h4 id="模式定义-8"><a href="#模式定义-8" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>为其他对象提供一个代理以提供对这个对象的访问。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>当无法或者不想直接访问某个对象时，可以通过一个代理对象进行访问。</li>
</ul>
<h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/proxy/singwhatiwanna/images/proxy-uml.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/proxy/singwhatiwanna/images/proxy-uml.png" alt="url"></a></p>
<h4 id="角色介绍-1"><a href="#角色介绍-1" class="headerlink" title="角色介绍"></a>角色介绍</h4><ul>
<li>抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。</li>
<li>目标对象角色：定义了代理对象所代表的目标对象。</li>
<li>代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。</li>
</ul>
<h4 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h4><p>代理模式按照代理类运行前是否存在还可以分为静态代理和动态代理，如下所示：</p>
<p>静态代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 被代理接口，定义要实现的功能。</span><br><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">    void visit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被代理类，完成实际的功能。</span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit() &#123;</span><br><span class="line">        System.out.println(&quot;visit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态代理类，与被代理类实现同一套接口</span><br><span class="line">public class StaticProxy implements Subject &#123;</span><br><span class="line"></span><br><span class="line">    private Subject mSubject;</span><br><span class="line"></span><br><span class="line">    public StaticProxy(Subject subject) &#123;</span><br><span class="line">        mSubject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit() &#123;</span><br><span class="line">        mSubject.visit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 被代理接口，定义要实现的功能。</span><br><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">    void visit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被代理类，完成实际的功能。</span><br><span class="line">public class ConcreteSubject implements Subject &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit() &#123;</span><br><span class="line">        System.out.println(&quot;visit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 动态代理类，实现InvocationHandler接口。</span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Subject mSubject;</span><br><span class="line"></span><br><span class="line">    public DynamicProxy(Subject subject) &#123;</span><br><span class="line">        mSubject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;函数执行前自定义操作&quot;);</span><br><span class="line">        // 调用被代理类的方法时会调用该方法</span><br><span class="line">        method.invoke(mSubject, args);</span><br><span class="line">        System.out.println(&quot;函数执行后自定义操作&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Subject subject = new ConcreteSubject();</span><br><span class="line">        DynamicProxy proxy = new DynamicProxy(subject);</span><br><span class="line"></span><br><span class="line">        // 动态生成代理类</span><br><span class="line">        Subject proxySubject = (Subject) Proxy.newProxyInstance(DynamicProxy.class.getClassLoader()</span><br><span class="line">                , subject.getClass().getInterfaces()</span><br><span class="line">                , proxy);</span><br><span class="line">        proxySubject.visit();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android代理模式-Binder"><a href="#Android代理模式-Binder" class="headerlink" title="Android代理模式-Binder"></a>Android代理模式-Binder</h4><p>直观来说，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
<p>Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。</p>
<p>为了更好地说明Binder，这里我们先手动实现了一个Binder。为了使得逻辑更清晰，这里简化一下，我们来模拟一个银行系统，这个银行提供的功能只有一个：即查询余额，只有传递一个int的id过来，银行就会将你的余额设置为id*10，满足下大家的发财梦。</p>
<ol>
<li>先定义一个Binder接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.ryg.design.manualbinder;</span><br><span class="line"></span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.IInterface;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">public interface IBank extends IInterface &#123;</span><br><span class="line"></span><br><span class="line">   static final String DESCRIPTOR = &quot;com.ryg.design.manualbinder.IBank&quot;;</span><br><span class="line"></span><br><span class="line">   static final int TRANSACTION_queryMoney = (IBinder.FIRST_CALL_TRANSACTION + 0);</span><br><span class="line"></span><br><span class="line">   public long queryMoney(int uid) throws RemoteException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建一个Binder并实现这个上述接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package com.ryg.design.manualbinder;</span><br><span class="line"></span><br><span class="line">import android.os.Binder;</span><br><span class="line">import android.os.IBinder;</span><br><span class="line">import android.os.Parcel;</span><br><span class="line">import android.os.RemoteException;</span><br><span class="line"></span><br><span class="line">public class BankImpl extends Binder implements IBank &#123;</span><br><span class="line"></span><br><span class="line">    public BankImpl() &#123;</span><br><span class="line">        this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IBank asInterface(IBinder obj) &#123;</span><br><span class="line">        if ((obj == null)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if (((iin != null) &amp;&amp; (iin instanceof IBank))) &#123;</span><br><span class="line">            return ((IBank) iin);</span><br><span class="line">        &#125;</span><br><span class="line">        return new BankImpl.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        case TRANSACTION_queryMoney: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            int uid = data.readInt();</span><br><span class="line">            long result = this.queryMoney(uid);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeLong(result);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long queryMoney(int uid) throws RemoteException &#123;</span><br><span class="line">        return uid * 10l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Proxy implements IBank &#123;</span><br><span class="line">        private IBinder mRemote;</span><br><span class="line"></span><br><span class="line">        Proxy(IBinder remote) &#123;</span><br><span class="line">            mRemote = remote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public IBinder asBinder() &#123;</span><br><span class="line">            return mRemote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public java.lang.String getInterfaceDescriptor() &#123;</span><br><span class="line">            return DESCRIPTOR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public long queryMoney(int uid) throws RemoteException &#123;</span><br><span class="line">            Parcel data = Parcel.obtain();</span><br><span class="line">            Parcel reply = Parcel.obtain();</span><br><span class="line">            long result;</span><br><span class="line">            try &#123;</span><br><span class="line">                data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                data.writeInt(uid);</span><br><span class="line">                mRemote.transact(TRANSACTION_queryMoney, data, reply, 0);</span><br><span class="line">                reply.readException();</span><br><span class="line">                result = reply.readLong();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                reply.recycle();</span><br><span class="line">                data.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，到此为止，我们的Binder就完成了，这里只要创建服务端和客户端，二者就能通过我们的Binder来通信了。这里就不做这个示例了，我们的目的是分析代理模式在Binder中的使用。</p>
<p>我们看上述Binder的实现中，有一个叫做“Proxy”的类，它的构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proxy(IBinder remote) &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Proxy类接收一个IBinder参数，这个参数实际上就是服务端Service中的onBind方法返回的Binder对象在客户端重新打包后的结果，因为客户端无法直接通过这个打包的Binder和服务端通信，因此客户端必须借助Proxy类来和服务端通信，这里Proxy的作用就是代理的作用，客户端所有的请求全部通过Proxy来代理，具体工作流程为：Proxy接收到客户端的请求后，会将客户端的请求参数打包到Parcel对象中，然后将Parcel对象通过它内部持有的Ibinder对象传送到服务端，服务端接收数据、执行方法后返回结果给客户端的Proxy，Proxy解析数据后返回给客户端的真正调用者。很显然，上述所分析的就是典型的代理模式。至于Binder如何传输数据，这涉及到很底层的知识，这个很难搞懂，但是数据传输的核心思想是共享内存。</p>
<h2 id="三-行为型设计模式"><a href="#三-行为型设计模式" class="headerlink" title="三 行为型设计模式"></a>三 行为型设计模式</h2><p><img src="https://img-blog.csdn.net/20160308154820959" alt="这里写图片描述"> </p>
<h3 id="3-1-模板模式"><a href="#3-1-模板模式" class="headerlink" title="3.1 模板模式"></a>3.1 模板模式</h3><h4 id="模式定义-9"><a href="#模式定义-9" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>定义一个操作的算法框架，而将具体实现延迟到子类中进行，使得子类在不改变整体算法框架的基础上，可以自定义算法实现。</p>
</blockquote>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>多个子类有公有的方法，并且逻辑基本相同时。</li>
<li>重要复杂的算法可以把核心算法设计为模板方法，具体细节则由子类实现</li>
<li>重构代码时，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li>
</ul>
<h4 id="Android应用-Activity-AsyncTask"><a href="#Android应用-Activity-AsyncTask" class="headerlink" title="Android应用-Activity/AsyncTask"></a>Android应用-Activity/AsyncTask</h4><ul>
<li><p>启动一个Activity过程非常复杂，如果让开发者每次自己去调用启动Activity过程无疑是一场噩梦。好在启动Activity大部分代码时不同的，但是有很多地方需要开发者定制。也就是说，整体算法框架是相同的，但是将一些步骤延迟到子类中，比如Activity的onCreate、onStart等等。这样子类不用改变整体启动Activity过程即可重定义某些具体的操作了~ </p>
</li>
<li><p>Android 中 AsyncTask 的几个回调可以看作模板 </p>
<p>在Android中，使用了模板方法且为我们熟知的一个典型类就是AsyncTask了，关于AsyncTask的更详细的分析请移步Android中AsyncTask的使用与源码分析，我们这里只分析在该类中使用的模板方法模式。</p>
<p>在使用AsyncTask时，我们都有知道耗时的方法要放在doInBackground(Params… params)中，在doInBackground之前如果还想做一些类似初始化的操作可以写在onPreExecute方法中，当doInBackground方法执行完成后，会执行onPostExecute方法，而我们只需要构建AsyncTask对象，然后执行execute方法即可。我们可以看到，它整个执行过程其实是一个框架，具体的实现都需要子类来完成。而且它执行的算法框架是固定的，调用execute后会依次执行onPreExecute,doInBackground,onPostExecute,当然你也可以通过onProgressUpdate来更新进度。我们可以简单的理解为如下图的模式 :</p>
<p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/template-method/mr.simple/images/async-flow.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/template-method/mr.simple/images/async-flow.png" alt="async-flow"></a></p>
<p>下面我们看源码，首先我们看执行异步任务的入口, 即execute方法 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;</span><br><span class="line">       return executeOnExecutor(sDefaultExecutor, params);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,</span><br><span class="line">           Params... params) &#123;</span><br><span class="line">       if (mStatus != Status.PENDING) &#123;</span><br><span class="line">           switch (mStatus) &#123;</span><br><span class="line">               case RUNNING:</span><br><span class="line">                   throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                           + &quot; the task is already running.&quot;);</span><br><span class="line">               case FINISHED:</span><br><span class="line">                   throw new IllegalStateException(&quot;Cannot execute task:&quot;</span><br><span class="line">                           + &quot; the task has already been executed &quot;</span><br><span class="line">                           + &quot;(a task can be executed only once)&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       mStatus = Status.RUNNING;</span><br><span class="line">  </span><br><span class="line">       onPreExecute();</span><br><span class="line">  </span><br><span class="line">       mWorker.mParams = params;</span><br><span class="line">       exec.execute(mFuture);</span><br><span class="line">  </span><br><span class="line">       return this;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到execute方法(为final类型的方法)调用了executeOnExecutor方法，在该方法中会判断该任务的状态，如果不是PENDING状态则抛出异常，这也解释了为什么AsyncTask只能被执行一次，因此如果该任务已经被执行过的话那么它的状态就会变成FINISHED。继续往下看，我们看到在executeOnExecutor方法中首先执行了onPreExecute方法，并且该方法执行在UI线程。然后将params参数传递给了mWorker对象的mParams字段，然后执行了exec.execute(mFuture)方法。</p>
<p>mWorker和mFuture又是什么呢？其实mWorker只是实现了Callable接口，并添加了一个参数数组字段，关于Callable和FutureTask的资料请参考<a href="http://blog.csdn.net/bboyfeiyu/article/details/24851847" target="_blank" rel="noopener">Java中的Runnable、Callable、Future、FutureTask的区别与示例</a>，我们挨个来分析吧，跟踪代码我们可以看到，这两个字段都是在构造函数中初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public AsyncTask() &#123;</span><br><span class="line">     mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">         public Result call() throws Exception &#123;</span><br><span class="line">             mTaskInvoked.set(true);</span><br><span class="line">  </span><br><span class="line">             Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">             return postResult(doInBackground(mParams));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">  </span><br><span class="line">     mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         protected void done() &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 final Result result = get();</span><br><span class="line">  </span><br><span class="line">                 postResultIfNotInvoked(result);</span><br><span class="line">             &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                 android.util.Log.w(LOG_TAG, e);</span><br><span class="line">             &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                 throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,</span><br><span class="line">                         e.getCause());</span><br><span class="line">             &#125; catch (CancellationException e) &#123;</span><br><span class="line">                 postResultIfNotInvoked(null);</span><br><span class="line">             &#125; catch (Throwable t) &#123;</span><br><span class="line">                 throw new RuntimeException(&quot;An error occured while executing &quot;</span><br><span class="line">                         + &quot;doInBackground()&quot;, t);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>简单的说就是mFuture就包装了这个mWorker对象，会调用mWorker对象的call方法，并且将之返回给调用者。<br>关于AsyncTask的更详细的分析请移步<a href="http://blog.csdn.net/bboyfeiyu/article/details/8973058" target="_blank" rel="noopener">Android中AsyncTask的使用与源码分析</a>，我们这里只分析模板方法模式。总之，call方法会在子线程中调用，而在call方法中又调用了doInBackground方法，因此doInBackground会执行在子线程。doInBackground会返回结果，最终通过postResult投递给UI线程。 我们再看看postResult的实现 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private Result postResult(Result result) &#123;</span><br><span class="line">    Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">            new AsyncTaskResult&lt;Result&gt;(this, result));</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        AsyncTaskResult result = (AsyncTaskResult) msg.obj;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case MESSAGE_POST_RESULT:</span><br><span class="line">                // There is only one result</span><br><span class="line">                result.mTask.finish(result.mData[0]);</span><br><span class="line">                break;</span><br><span class="line">            case MESSAGE_POST_PROGRESS:</span><br><span class="line">                result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">private void finish(Result result) &#123;</span><br><span class="line">    if (isCancelled()) &#123;</span><br><span class="line">        onCancelled(result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        onPostExecute(result);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，postResult就是把一个消息( msg.what == MESSAGE_POST_RESULT)发送给sHandler，sHandler类型为InternalHandler类型，当InternalHandler接到MESSAGE_POST_RESULT类型的消息时就会调用result.mTask.finish(result.mData[0])方法。我们可以看到result为AsyncTaskResult类型，源码如下 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;RawUseOfParameterizedType&quot;&#125;)</span><br><span class="line">private static class AsyncTaskResult&lt;Data&gt; &#123;</span><br><span class="line">    final AsyncTask mTask;</span><br><span class="line">    final Data[] mData;</span><br><span class="line">  </span><br><span class="line">    AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">        mTask = task;</span><br><span class="line">        mData = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到mTask就是AsyncTask对象</strong>，调用AsyncTask对象的finish方法时又调用了onPostExecute，这个时候整个执行过程就完成了。 总之，execute方法内部封装了onPreExecute, doInBackground, onPostExecute这个算法框架，用户可以根据自己的需求来在覆写这几个方法，使得用户可以很方便的使用异步任务来完成耗时操作，又可以通过onPostExecute来完成更新UI线程的工作。<br>另一个比较好的模板方法示例就是Activity的声明周期函数，例如Activity从onCreate、onStart、onResume这些程式化的执行模板，这就是一个Activity的模板方法。</p>
</li>
</ul>
<h4 id="Java应用："><a href="#Java应用：" class="headerlink" title="Java应用："></a>Java应用：</h4><ul>
<li><code>java.io.InputStream</code>, <code>java.io.OutputStream</code>, <code>java.io.Reader</code> 和 <code>java.io.Writer</code> 的所有非抽象方法.</li>
<li><code>java.util.AbstractList</code>, <code>java.util.AbstractSet</code> 和 <code>java.util.AbstractMap</code> 的所有非抽象方法.</li>
<li><code>javax.servlet.http.HttpServlet</code>, 所有 <code>doXXX()</code> 方法默认发送 <code>HTTP 405 &quot;Method Not Allowed&quot;</code> 错误到响应中. 你可以任意实现这些方法.</li>
</ul>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的Computer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrsimple</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启电源"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHardware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"硬件检查"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadOS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"载入操作系统"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小白的电脑无验证，直接进入系统"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板-启动电脑方法, 步骤固定为开启电源、系统检查、加载操作系统、用户登录。该方法为final， 防止算法框架被覆写.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------ 开机 START ------"</span>);</span><br><span class="line">        powerOn();</span><br><span class="line">        checkHardware();</span><br><span class="line">        loadOS();</span><br><span class="line">        login();</span><br><span class="line">        System.out.println(<span class="string">"------ 开机 END ------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 码农的计算机</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrsimple</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoderComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"码农只需要进行用户和密码验证就可以了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 军用计算机</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mrsimple</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MilitaryComputer</span> <span class="keyword">extends</span> <span class="title">AbstractComputer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHardware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.checkHardware();</span><br><span class="line">        System.out.println(<span class="string">"检查硬件防火墙"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行指纹之别等复杂的用户验证"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.dp.example.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractComputer comp = <span class="keyword">new</span> CoderComputer();</span><br><span class="line">        comp.startUp();</span><br><span class="line"></span><br><span class="line">        comp = <span class="keyword">new</span> MilitaryComputer();</span><br><span class="line">        comp.startUp();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-解释器模式"><a href="#3-2-解释器模式" class="headerlink" title="3.2 解释器模式"></a>3.2 解释器模式</h3><h4 id="模式定义-10"><a href="#模式定义-10" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>给定一个语音，定义它的文法的一种表示，并定义一个解释器。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>如果某个简单的语音需要解释执行并且可以将该语言中的语句表示为一个抽象语法树时可以使用解释器模式。</li>
<li>在某些特定领域不断出现的问题是，可以将该领域的问题转船为一种语法规则下的语句，然后构建解释器来解释该语句。</li>
</ul>
<h4 id="Android应用"><a href="#Android应用" class="headerlink" title="Android应用"></a>Android应用</h4><p>PackageParser是对AndroidManifest.xml配置文件进行读取的，具体原理参考：<a href="http://blog.csdn.net/zhbinary/article/details/7353739" target="_blank" rel="noopener">解析AndroidManifest原理</a> </p>
<p>这个用到的地方也不少，其一就是Android的四大组件需要在AndroidManifest.xml中定义，其实AndroidManifest.xml就定义了，等标签（语句）的属性以及其子标签，规定了具体的使用（语法），通过PackageManagerService（解释器）进行解析。PackageParser</p>
<h3 id="3-3-策略模式"><a href="#3-3-策略模式" class="headerlink" title="3.3 策略模式"></a>3.3 策略模式</h3><h4 id="模式定义-11"><a href="#模式定义-11" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>策略模式定义了一系列算法，并将算法封装起来可以互相替换，策略模式让算法与使用它的客户端解耦，可以独立变化。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>针对同一类型的问题有多种处理方式，仅仅是具体的行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象类的多个字类，而又需要使用if-else来选择子类时。</li>
</ul>
<h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/strategy/gkerison/images/strategy-kerison-uml.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/strategy/gkerison/images/strategy-kerison-uml.png" alt="url"></a></p>
<h4 id="角色介绍-2"><a href="#角色介绍-2" class="headerlink" title="角色介绍"></a>角色介绍</h4><ul>
<li>Context：用来操作策略的上下文环境。</li>
<li>Strategy : 策略的抽象。</li>
<li>ConcreteStrategyA、ConcreteStrategyB : 具体的策略实现。</li>
</ul>
<p>策略模式的实现也非常简单，依赖于接口或者抽象类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 策略接口，定义功能。</span><br><span class="line">public interface IStrategy &#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 策略A</span><br><span class="line">public class StrategyA implements IStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 策略B</span><br><span class="line">public class StrategyB implements IStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 设置策略-&gt;执行</span><br><span class="line">public class Client&#123;</span><br><span class="line">    IStrategy strategy;</span><br><span class="line">    public void setStrategy(IStrategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public void execute()&#123;</span><br><span class="line">        strategy.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android源码对应实现"><a href="#Android源码对应实现" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p>动画里面的<code>插值器Interpolator</code>利用了策略模式, 利用<code>Interpolator</code>策略的抽象, <code>LinearInterpolator</code>,<code>CycleInterpolator</code>等插值器为具体的实现策略, 通过注入不同的插值器实现不同的动态效果.</p>
<p>看一下大概的类图</p>
<p><img src="https://github.com/suzeyu1992/repo/raw/master/project/design-pattern/%E7%9E%B0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8EAndroid(%E7%AF%87%E4%B8%80" alt="img">/imgs/UML_Animation.png) </p>
<ul>
<li>动画中的<code>TimeInterpolator</code>时间插值器, 它的作用是根据时间流逝的百分比计算出当前属性值改变的百分比, 内置的插值器有如下几种<ul>
<li><code>线性插值器(LinearInterpolator)</code>用于匀速动画</li>
<li><code>加速减速插值器(AccelerateDecelerateInterpolator)</code>:起始时动画加速, 结尾时动画减速</li>
<li><code>减速插值器(DecelerateInterpolator)</code>: 用于随着时间的推移动画越来越慢.</li>
</ul>
</li>
<li>动画中的<code>TypeEvalutor</code>类型估值器: 根据当前属性改变的百分比来计算改变后的属性值. 内置的类型估值器有如下几种<ul>
<li><code>整型估值器(IntEvalutor)</code></li>
<li><code>浮点型估值器(FloatEvalutor)</code></li>
<li><code>Color估值器(ArgbEvalutor)</code></li>
</ul>
</li>
</ul>
<p>接下来就开始回忆一下从一个动画开始后, 代码究竟做了什么?</p>
<p>对于源码的起始点入口就是调用<code>View的startAnimation()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnimation</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.初始化动画的开始时间</span></span><br><span class="line">   animation.setStartTime(Animation.START_ON_FIRST_FRAME);</span><br><span class="line">   <span class="comment">// 2.对View设置动画</span></span><br><span class="line">   setAnimation(animation);</span><br><span class="line">   <span class="comment">// 3.刷新父类缓存</span></span><br><span class="line">   invalidateParentCaches();</span><br><span class="line">   <span class="comment">// 4.刷新View本身及子View</span></span><br><span class="line">   invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先设置了动画的起始时间, 然后将该动画设置到<code>View</code>中, 最后再向<code>ViewGroup</code>请求刷新视图, 随后<code>ViewGroup</code>会调用<code>dispatchDraw()</code>方法对这个<code>View</code>所在的区域进行重绘. 其实对于某一个<code>View</code>的重绘最终是调用其<code>ViewGroup</code>的<code>drawChild(...)</code>方法. 跟入一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 简单的转发</span></span><br><span class="line">   <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// 查看是否需要清除动画信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取设置的动画信息</span></span><br><span class="line">    <span class="keyword">final</span> Animation a = getAnimation();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 绘制动画</span></span><br><span class="line">           more = drawAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类会调用子类的<code>draw</code>方法, 其中会先判断是否设置了清除动画的标记, 然后再获取该<code>View</code>动画信息, 如果设置了动画, 就会调用<code>View#drawAnimation()</code>方法. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawAnimation</span><span class="params">(ViewGroup parent, <span class="keyword">long</span> drawingTime,</span></span></span><br><span class="line"><span class="function"><span class="params">       Animation a, <span class="keyword">boolean</span> scalingRequired)</span> </span>&#123;</span><br><span class="line">   Transformation invalidationTransform;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> flags = parent.mGroupFlags;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> initialized = a.isInitialized();</span><br><span class="line">   <span class="comment">// 1. 判断动画是否已经初始化过</span></span><br><span class="line">   <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">       a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());</span><br><span class="line">       a.initializeInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">       <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) a.setListenerHandler(mAttachInfo.mHandler);</span><br><span class="line">       <span class="comment">// 如果设置了动画的监听, 则触发对应的回调</span></span><br><span class="line">       onAnimationStart();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取Transformation对象, 存储动画的信息</span></span><br><span class="line">   <span class="keyword">final</span> Transformation t = parent.getChildTransformation();</span><br><span class="line">   <span class="comment">// 2. 调用Animation#getTransformation, 通过计算获取动画的相关值</span></span><br><span class="line">   <span class="keyword">boolean</span> more = a.getTransformation(drawingTime, t, <span class="number">1f</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (more) &#123;</span><br><span class="line">        <span class="comment">// 3. 根据具体实现, 判断当前动画类型是否需要进行调整位置大小, 然后刷新不同的区域</span></span><br><span class="line">       <span class="keyword">if</span> (!a.willChangeBounds()) &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 获取重绘区域</span></span><br><span class="line">           a.getInvalidateRegion(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, region,</span><br><span class="line">                   invalidationTransform);</span><br><span class="line">           parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新计算有效区域</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft + (<span class="keyword">int</span>) region.left;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> top = mTop + (<span class="keyword">int</span>) region.top;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 进行区域更新</span></span><br><span class="line">           parent.invalidate(left, top, left + (<span class="keyword">int</span>) (region.width() + .<span class="number">5f</span>),</span><br><span class="line">                   top + (<span class="keyword">int</span>) (region.height() + .<span class="number">5f</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawAnimation</code>中主要操作是动画的初始化, 动画操作, 界面刷新. 动画的回调监听<code>onStart()</code>会在动画进行初始化的时候调用, 动画的具体实现是通过<code>Animation#getTransformation()</code>方法.这个方法主要获取了<code>缩放系数</code>和调用<code>Animation.getTransformation(long, Transformation)</code>来计算和应用动画效果.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">float</span> normalizedTime;</span><br><span class="line">   <span class="comment">// 1.计算当前时间的流逝百分比</span></span><br><span class="line">   <span class="keyword">if</span> (duration != <span class="number">0</span>) &#123;</span><br><span class="line">       normalizedTime = ((<span class="keyword">float</span>) (currentTime - (mStartTime + startOffset))) /</span><br><span class="line">               (<span class="keyword">float</span>) duration;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// time is a step-change with a zero duration</span></span><br><span class="line">       normalizedTime = currentTime &lt; mStartTime ? <span class="number">0.0f</span> : <span class="number">1.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 动画是否完成标记</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> expired = normalizedTime &gt;= <span class="number">1.0f</span>;</span><br><span class="line">   mMore = !expired;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((normalizedTime &gt;= <span class="number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="number">1.0f</span> || mFillAfter)) &#123;</span><br><span class="line">        <span class="comment">// 2.通过插值器获取动画执行百分比  , 这里获取的方法就是通过策略模式</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">       <span class="comment">// 3.应用动画效果</span></span><br><span class="line">       applyTransformation(interpolatedTime, outTransformation);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4. 如果动画执行完毕, 那么触发动画完成的回调或者执行重复动画等操作</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">if</span> (!mMore &amp;&amp; mOneMoreTime) &#123;</span><br><span class="line">       mOneMoreTime = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mMore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码, 先计算已经流逝的的时间百分比, 然后再通过<code>具体的插值器</code>重新计算这个百分比, 也就是上面的第二步. 而具体是哪一个插值器是通过之前说的策略模式来实现的. </p>
<p>第3步调用了<code>applyTransformation</code>, 这个方法在基类<code>Animation</code>中是空实现, 可以在子类查看实现如<code>ScaleAnimation</code>,<code>AlphaAnimation</code>等查看.  当这个方法内部主要通过<code>矩阵</code>来实现动画.  当这个方法执行完毕之后, View的属性也就发生了变化, 不断地重复这个过程, 动画就随之产生. </p>
<p>Java应用</p>
<h3 id="3-4-状态模式"><a href="#3-4-状态模式" class="headerlink" title="3.4 状态模式"></a>3.4 状态模式</h3><h4 id="模式定义-12"><a href="#模式定义-12" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>允许一个对象在内部状态改变时改变它的行为。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>一个对象的行为取决于它的状态，并且它在运行时根据状态改变它的行为。</li>
<li>代码中包含大量与对象状态相关的判断语句。</li>
</ul>
<p>状态模式的核心是根据不同的状态对应不同的操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 操作接口</span><br><span class="line">public interface TVState &#123;</span><br><span class="line">    void nextChannel();</span><br><span class="line"></span><br><span class="line">    void lastChannel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开机状态</span><br><span class="line">public class PowerOnState implements TVState &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void nextChannel() &#123;</span><br><span class="line">        // next channel </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lastChannel() &#123;</span><br><span class="line">        // last channel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关机状态</span><br><span class="line">public class PowerOffChannel implements TVState &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void nextChannel() &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void lastChannel() &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android应用-StateMachine机制"><a href="#Android应用-StateMachine机制" class="headerlink" title="Android应用-StateMachine机制"></a>Android应用-StateMachine机制</h4><p><a href="http://blog.csdn.net/maybe_windleave/article/details/9881991" target="_blank" rel="noopener">http://blog.csdn.net/maybe_windleave/article/details/9881991</a></p>
<p><a href="http://blog.csdn.net/lilian0118/article/details/21974229" target="_blank" rel="noopener">http://blog.csdn.net/lilian0118/article/details/21974229</a></p>
<p>在我们的应用开发中也可以使用源码中的<code>StateMachine</code>类，只要从源码中把<code>StateMachine</code>和<code>State</code>类拷贝到我们的工程目录就可以使用了，对于其 import 的一些类，在我们的开发环境中也全都有，不用担心。</p>
<p>如果你对状态机有那么一丝丝的了解，那么学习 StateMachine 类最好的资料就是它的注释了，解释的一清二楚。</p>
<p>简单使用阐述</p>
<p>Android 中的状态机是一个分层的消息处理机制，每一层都会有一到多个节点，而状态机的消息就是在这些节点之间流转处理，如下结构所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 状态机分层结构</span><br><span class="line">         mP0</span><br><span class="line">        /   \</span><br><span class="line">       mP1   mS0</span><br><span class="line">      /   \</span><br><span class="line">     mS2   mS1</span><br><span class="line">    /  \    \</span><br><span class="line">   mS3  mS4  mS5  ---&gt; initial state 初始节点</span><br></pre></td></tr></table></figure>
<p>而节点就是<code>State</code>类，它实现了<code>IState</code>接口，除了<code>enter</code>、<code>exit</code>方法外，还有<code>processMessage</code>方法，表示用来处理节点的消息。若返回<code>HANDLED</code>则表示消息处理完成，若返回<code>NOT_HANDLED</code>则表示消息没有处理。</p>
<p>构造状态机</p>
<p>在我们使用 StateMachine 之前，要构造好所需的状态分层结构。通过<code>addState</code>方法来向状态机中添加节点，例如如下的状态结构，mS1 和 mS2 节点有公共的父节点 mP1，同时还有一个孤立的节点 mP2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 状态分层结构设定</span><br><span class="line">  mP1      mP2</span><br><span class="line"> /   \</span><br><span class="line">mS2   mS1</span><br><span class="line">// 构造状态机结构代码</span><br><span class="line">addState(mP1);</span><br><span class="line">    addState(mS1, mP1);</span><br><span class="line">    addState(mS2, mP1);</span><br><span class="line">addState(mP2);</span><br></pre></td></tr></table></figure>
<p><code>addState</code>方法添加节点时，还能指定其父节点添加。</p>
<p>当我们构造完了状态机时，还需要指定其中一个节点为启动点，消息从启动点开始处理，通过<code>setInitialState</code>方法来指定启动点，最后通过<code>start</code>方法启动状态机。</p>
<p>状态机消息处理</p>
<p>当构造完想要的状态机结构时，就是对状态机内部消息流转的处理了。</p>
<p>当<code>start</code>状态机时，状态机的第一个动作就是调用节点的<code>enter</code>方法，不过，它调用的是指定的启动点的最远的父节点的<code>enter</code>方法，然后再是次一级的父节点的<code>enter</code>方法，最后才是启动点的<code>enter</code>方法，就如同上面的结构所示，先调用 mP1 点，然后才是 mS1 点的方法，此时 mS1 节点就是状态机的当前对外的点。由此可见，当启动点进入 <code>enter</code>状态时，它的父节点，直至最顶层的父节点都进入了<code>enter</code>状态了。</p>
<p>状态机中的每个节点都 0 个或 1 个父节点，当子节点不能处理当前消息时，它可以通过返回<code>NOT_HANDLED</code>将当前消息传递给其父节点来处理。如果一个消息从未被处理过，那么<code>unhandledMessage</code>方法将会被调用给最后一次机会来处理该消息。</p>
<p>除此之外，节点还可以通过<code>transitionTo</code>方法将当前节点转移至另外一个新的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      mP0</span><br><span class="line">     /   \</span><br><span class="line">    mP1   mS0</span><br><span class="line">   /   \</span><br><span class="line">  mS2   mS1</span><br><span class="line"> /  \    \</span><br><span class="line">mS3  mS4  mS5  ---&gt; initial state</span><br></pre></td></tr></table></figure>
<p>例如，当 mS5 处理消息，想要将当前节点转移至 mS4 时，那么它会先找到 mS5 和 mS4 最近的公有父节点 mP1。然后，除了这个最近的公有父节点 mP1 以及它的上层节点外，mS5 进入<code>enter</code>状态时启动的那些父节点都会退出调用<code>exit</code>方法。最后再由 mP1 节点下的节点调用<code>enter</code>方法直到新节点 mS4 调用了<code>enter</code>方法。</p>
<p>也就是说，从 mS5 到 mS4 状态的转变，先是 mS5、mS1 调用了<code>exit</code>方法，再是 mS2、mS4 调用了<code>enter</code>方法，这就是状态机中节点发生状态转移时的调用过程。</p>
<p>除此之外，节点还可以调用<code>deferMessage</code>和<code>sendMessageAtFroneOfQueue</code>方法。<code>deferMessage</code>方法使得消息存储在消息队列中，当状态转移到新节点时才会处理，而<code>sendMessageAtFrontOfQueue</code>方法则是将消息放置到消息队列的头部。</p>
<p>当状态机的所有消息都完成时，可以调用<code>transitionToHaltingState</code>方法来将状态机处理停止状态。此时，状态机将转移到<code>HaltingState</code>停止状态，并调用<code>halting</code>方法。随后收到的所有消息都只是会调用<code>haltedProcessMessage</code>方法来处理了。</p>
<p>若想要完全的停止状态机，则可以使用<code>quit</code>或者<code>quitNow</code>方法来处理。</p>
<p>以上就是状态机对于消息处理的过程，长篇的文字说明还是不如代码来的直观，这里就不贴完整的代码了，参考代码的连接如下：<a href="https://gist.github.com/glumes/e76ea009843eecb2b1e5cf9d8a38a369" target="_blank" rel="noopener">GithubGist 链接地址</a></p>
<p>状态机实现原理分析</p>
<p>如果我们在初始化状态机时只是传递了一个名字，而没有传递 Looper 或者 Handler 之类的消息循环，那么状态机默认就是启用其内部的一个线程<code>HandlerThread</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">StateMachine</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      mSmThread = <span class="keyword">new</span> HandlerThread(name); <span class="comment">// 创建 HandlerThread 线程</span></span><br><span class="line">      mSmThread.start();</span><br><span class="line">      Looper looper = mSmThread.getLooper();</span><br><span class="line">      initStateMachine(name, looper);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将消息循环 Looper 与 Handler 进行绑定</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initStateMachine</span><span class="params">(String name, Looper looper)</span> </span>&#123;</span><br><span class="line">      mName = name;</span><br><span class="line">      mSmHandler = <span class="keyword">new</span> SmHandler(looper, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>构造状态及时，在其内部开启了一个线程，并将其消息循环 Looer 传递给了 <code>SmHandler</code> 对象，而<code>SmHandler</code>对象就是状态机中最主要的用来派发消息事件和切换状态的了，它派发的消息都是在 HandlerThread 线程进行处理的。</p>
<p>同时，SmHandler 内部有两个数组，用来保存状态机中的链式状态关系，分别是<code>mStateStack</code>和<code>mTempStateStack</code>变量。当状态机完成启动时，就会通过上面来个变量来保存节点信息。</p>
<p>而状态机的消息处理，内部也是通过 SmHandler 来处理转发的。</p>
<p>具体的实现，建议参考这篇文章：<a href="http://blog.csdn.net/yangwen123/article/details/10591451" target="_blank" rel="noopener">http://blog.csdn.net/yangwen123/article/details/10591451</a> 讲的实在太详细了，拜读了多遍也不敢说写的能比它更清楚。</p>
<h3 id="3-5-观察者模式"><a href="#3-5-观察者模式" class="headerlink" title="3.5 观察者模式"></a>3.5 观察者模式</h3><h4 id="模式定义-13"><a href="#模式定义-13" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>定义对象间一对多的依赖关系，每当这个对象发生改变时，其他对象都能收到通知并更新自己。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，例如消息队列，事件总线的处理机制。</li>
</ul>
<p>观察者模式的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 监听接口，通知被监听对象发生改变</span><br><span class="line">public interface Listener &#123;</span><br><span class="line"></span><br><span class="line">    void change();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被监听者</span><br><span class="line">public class Observable &#123;</span><br><span class="line"></span><br><span class="line">    private Listener mListener;</span><br><span class="line"></span><br><span class="line">    // 设置监听器</span><br><span class="line">    public void setListener(Listener listener) &#123;</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange() &#123;</span><br><span class="line">        // 通知对象发生改变</span><br><span class="line">        mListener.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监听者</span><br><span class="line">public class Observer &#123;</span><br><span class="line"></span><br><span class="line">    public void setup() &#123;</span><br><span class="line">        Observable observable = new Observable();</span><br><span class="line">        observable.setListener(new Listener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void change() &#123;</span><br><span class="line">                // TODO 监听的对象发生改变</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ul>
<li><p>android应用</p>
<p>我们看看ListView的适配器，有个函数notifyDataSetChanged()函数，这个函数其实就是通知ListView的每个Item，数据源发生了变化，请各位Item重新刷新一下。 </p>
</li>
<li><p>jdk应用</p>
<ul>
<li><code>java.util.Observer/java.util.Observable</code> (在现实世界中很少使用)</li>
<li><code>java.util.EventListener</code> 的所有实现 (几乎所有的<code>Swing</code>都是这样)</li>
<li><code>javax.servlet.http.HttpSessionBindingListener</code></li>
<li><code>javax.servlet.http.HttpSessionAttributeListener</code></li>
<li><code>javax.faces.event.PhaseListener</code></li>
</ul>
</li>
</ul>
<h4 id="1-JDK源码中的观察者模式"><a href="#1-JDK源码中的观察者模式" class="headerlink" title="1 JDK源码中的观察者模式"></a><strong>1 JDK源码中的观察者模式</strong></h4><p>​        不管是在《大话设计模式》，还是GoF的《设计模式》，还是别的关于设计模式的经典书籍，抑或是在各类技术博客，大家可以轻易地找到关于观察者模式的定义和示例。因此观察者模式的概念和基本使用不是本文的讨论重点。重点是，观察者模式的使用是如此的广泛，以至于JDK源码中已为该模式提供java.util.Observable基类和java.util.Observers接口。</p>
<p><img src="https://img-blog.csdn.net/20160824023119734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="JDK中的观察者模式UML类图"></p>
<p>​        JDK中的观察者模式的使用如图所示：Student类实现Observer接口，通过addObserver方法注册到Teacher的观察者列表中去；而Teacher类继承自Observable基类，当Teacher发布消息（publishMessage)时调用notifyObservers()方法，遍历观察者列表中的所有Student，调用他们的update方法；于是Teacher中的message传递到了每个Student中。</p>
<p>​        JDK中的Observable基类和Observer接口为我们的简单使用观察者模式提供了方便，但它有一个非常明显的缺点：为了使用观察者模式，需要让Teacher继承Observable这个基类，但是Teacher可能已经继承了Person类，而Java又是单继承，不能同时再继承Observable类。解决这个矛盾的思路有两种：一是自定义观察者模式，将add、delete、notify等方法写进Teacher类；二是使用代理模式，在Teacher中维护一个Observable类的对象，并且实现同名的方法，类似如下代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void addObserver(Observer observer)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mObservable.addObserver(observer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处不展开讨论了，Android源码中的观察者就是采用类似第二种思路的方法。</span><br></pre></td></tr></table></figure>
<h4 id="2-Android源码中的观察者模式"><a href="#2-Android源码中的观察者模式" class="headerlink" title="2 Android源码中的观察者模式"></a>2 Android源码中的观察者模式</h4><p>​      其实翻看Android源码，发现Android并没有使用JDK的Observable基类和Observer接口。Instead，Android定义了一个android.database.Observable<t>抽象类，其中T是Oberver type。Observable抽象类中只有registerObserver、unregisterObserver和unregisterAll三个抽象方法，notify的操作需要子类自己定义。与JDK中Observer接口相对应的是DataSetObserver抽象类，里面有onChanged和onValidated两个抽象方法。notify方法、DataSetObserver类、onChanged方法，是不是想到了什么东西？对，setDataSetChanged()！是不是很熟悉？</t></p>
<h5 id="2-1-ListView源码中的观察者模式"><a href="#2-1-ListView源码中的观察者模式" class="headerlink" title="2.1 ListView源码中的观察者模式"></a><strong>2.1 ListView源码中的观察者模式</strong></h5><p>​      在使用ListView时，数据改变后，我们会手动去调用ListView对应的adapter的setDataSetChanged()方法来通知ListView更新UI。换一种说法，ListView的UI是观察者，ListView对应的adapter中的数据是被观察者，ListView通过注册一个观察者到adapter中，以实现监听adapter的数据变化的目的。经过刨祖坟一般的Ctrl+鼠标左键之后，画出如下UML类图。图中可以看到，ListView注册到adapter中的观察者叫AdapterDataSetObserver，定义在ListView的父类AbsListview中。它又继承自AbsListView的父类AdapterView类中的同名AdapterDataSetObserver。AdapterView.AdapterDataSetObserver最终继承自DataSetObserver抽象类。</p>
<p><img src="https://img-blog.csdn.net/20160824014820658?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="ListView中的观察者模式UML类图"></p>
<p>​      那当数据发生改变，要更新 UI 的时候怎么办呢？</p>
<p>Android 的做法是，在 Adapter 中添加一个『老板』对象，让 Adapter 拥有『老板』的所有权利。然后在 ListView 中，添加一个『员工』对象（继承 DataSetObserver，在重写父类方法时，更新 UI）。另外在 ListView 的 setAdapter 方法中，将『员工』和『老板』绑定起来，实现『老板』和『员工』的雇佣关系。最后开发者就可以调用 Adapter 的方法notifyDataSetChanged()，让『老板』命令『员工』干活了！</p>
<p>接下来我们看一下代码实现。<br><br> <strong>BaseAdapter.Java：</strong> 拥有DataSetObservable对象，就是说Adapter是『老板』的上司，拥有『老板』的所有权利。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseAdapter &#123;</span><br><span class="line">    private final DataSetObservable mDataSetObservable = new DataSetObservable();</span><br><span class="line">    public void registerDataSetObserver(DataSetObserver observer) &#123;</span><br><span class="line">        mDataSetObservable.registerObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    public void unregisterDataSetObserver(DataSetObserver observer) &#123;</span><br><span class="line">        mDataSetObservable.unregisterObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyDataSetChanged() &#123;</span><br><span class="line">        mDataSetObservable.notifyChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyDataSetInvalidated() &#123;</span><br><span class="line">        mDataSetObservable.notifyInvalidated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ListView.Java：</strong>setAdapter()方法中，将 AdapterDataSetObserver 注册到 Adapter 的DataSetObservable中，实现『老板』和『员工』的雇佣关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ListView &#123;</span><br><span class="line">    ...代码省略</span><br><span class="line">    @Override</span><br><span class="line">    public void setAdapter(ListAdapter adapter) &#123;</span><br><span class="line">        ...代码省略</span><br><span class="line">        mDataSetObserver = new AdapterDataSetObserver();</span><br><span class="line">        mAdapter.registerDataSetObserver(mDataSetObserver);</span><br><span class="line">        ...代码省略</span><br><span class="line">    &#125;</span><br><span class="line">    ...代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdapterDataSetObserver 继承了 DataSetObserver，重写父类函数时，进行更新界面的操作。</p>
<h5 id="2-2-RecyclerView中的观察者模式"><a href="#2-2-RecyclerView中的观察者模式" class="headerlink" title="2.2 RecyclerView中的观察者模式"></a>2.2 RecyclerView中的观察者模式</h5><p>​      由于最近使用RecyclerView代替ListView，所以把RecyclerView中的观察者模式的实现源码也挖出来了.</p>
<h3 id="3-6-备忘录模式"><a href="#3-6-备忘录模式" class="headerlink" title="3.6 备忘录模式"></a>3.6 备忘录模式</h3><h4 id="模式定义-14"><a href="#模式定义-14" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>在不破坏封装的前提下，保存一个对象的内部状态，并在该对象之外保存这个状态，以便可以将该对象恢复到保存时的状态。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>需要保存某个对象在某一时刻的状态。</li>
<li>外界向访问对象的状态，但是又不想直接暴露接口给外部，这时候可以将对象状态保存下来，间接的暴露给外部。</li>
</ul>
<h4 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h4><ul>
<li><p>Activity的onSaveInstanceState和onRestoreInstanceState就是用到了备忘录模式，分别用于保存和恢复。 </p>
</li>
<li><h4 id="jdk源码中应用"><a href="#jdk源码中应用" class="headerlink" title="jdk源码中应用"></a>jdk源码中应用</h4><ul>
<li><code>java.util.Date</code> ( setter 方法就是这么做的, <code>Date</code> 内部通过长整型<code>long</code>表示)</li>
<li><code>java.io.Serializable</code>的所有实现</li>
<li><code>javax.faces.component.StateHolder</code>的所有实现</li>
</ul>
</li>
</ul>
<h3 id="3-7-中介者模式"><a href="#3-7-中介者模式" class="headerlink" title="3.7 中介者模式"></a>3.7 中介者模式</h3><h4 id="模式定义-15"><a href="#模式定义-15" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>中介者模式定义了一系列对象间的交互方式，使得这些对象像话作用而又不耦合在一起。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>当对象间有很多的交互操作，而且一个对象的行为依赖于其他对象时，可以利用中介者模式解决紧耦合的问题。</li>
</ul>
<h4 id="Android应用-1"><a href="#Android应用-1" class="headerlink" title="Android应用"></a>Android应用</h4><p>中介者模式的意图为：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式的结构图如下：</p>
<p><img src="C:\Users\Li\AppData\Local\Temp\1532708415340.png" alt="1532708415340"></p>
<p>​     在 ANDROID系统中keyguard的功能实现采用了中介者模式，用来中介keyguard相关的请求，包括查询keyguard的状态，影响keyguard应当显示和复位的电源管理事件，以及当keyguard显示时对窗口管理的通知事件和来自keyguard视图本身的关于keyguard是否成功unlocked的事件等。相关UML类图如下：</p>
<p>​      <img src="C:\Users\Li\AppData\Local\Temp\1532708445035.png" alt="img"></p>
<p>​      其中KeyguardViewMediator作为中介者角色，与电源管理、用户管理、报警管理、声音管理、状态条管理、KeyguardViewManager、KeyguardDisplayManager、KeyguardUpdateMonitor等服务或对象交互， 读取相关状态，执行和触发keyguard事件相关的功能等 ，而KeyguardViewManager、KeyguardHostView、KeyguardUpdateMonitor类通过相关回调向KeyguardViewMediator传送Keyguard视图本身和keyguard有关状态更新方面的事件， 另外KeyguardService服务也是通过KeyguardViewMediator查询keyguard的状态 并通过IKeyguardService接口对外提供keyguard的状态信息。</p>
<h3 id="3-8-命令模式"><a href="#3-8-命令模式" class="headerlink" title="3.8 命令模式"></a>3.8 命令模式</h3><h4 id="模式定义-16"><a href="#模式定义-16" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>将一个请求封装成一个对象，可以将不同的请求参数化，可以对请求就行排队、日志记录以及撤销等操作。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>需要抽象待执行的动作，然后以参数的形式提供出来。</li>
<li>在不同的时刻，指定和排列请求。</li>
<li>需要支持撤销操作。</li>
<li>需要支持日志功能，这样当系统崩溃时，可以重做一遍。</li>
<li>需要支持事务操作。</li>
</ul>
<p>命令模式的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 接收命令</span><br><span class="line">public class Receiver &#123;</span><br><span class="line"></span><br><span class="line">    public void action() &#123;</span><br><span class="line">        // TODO 真正执行命令具体逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象命令</span><br><span class="line">public interface AbstractCommand &#123;</span><br><span class="line">    </span><br><span class="line">    // 执行命令</span><br><span class="line">    void command();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体命令</span><br><span class="line">public class ConcreteCommand implements AbstractCommand &#123;</span><br><span class="line"></span><br><span class="line">    private Receiver mReceiver;</span><br><span class="line"></span><br><span class="line">    public ConcreteCommand(Receiver receiver) &#123;</span><br><span class="line">        mReceiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void command() &#123;</span><br><span class="line">        mReceiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用者</span><br><span class="line">public class Invoker &#123;</span><br><span class="line"></span><br><span class="line">    private AbstractCommand mCommmand;</span><br><span class="line"></span><br><span class="line">    public Invoker(AbstractCommand command) &#123;</span><br><span class="line">        mCommmand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void invoke() &#123;</span><br><span class="line">        mCommmand.command();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android源码中的模式实现-1"><a href="#Android源码中的模式实现-1" class="headerlink" title="Android源码中的模式实现"></a>Android源码中的模式实现</h4><p>Command接口中定义了一个execute方法，客户端通过Invoker调用命令操作再来调用Recriver执行命令；把对Receiver的操作请求封装在具体的命令中，使得命令发起者和命令接收者解耦。 以Android中大家常见的Runnable为例：客户端只需要new Thread(new Runnable(){}).start()就开始执行一系列相关的请求，这些请求大部分都是实现Runnable接口的匿名类。 【O_o 模式就在我们身边~】</p>
<p>命令接口Runnable接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">/**</span><br><span class="line"> * Represents a command that can be executed. Often used to run code in a</span><br><span class="line"> * different &#123;@link Thread&#125;.</span><br><span class="line"> */</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Starts executing the active part of the class&apos; code. This method is</span><br><span class="line">     * called when a thread is started that has been created with a class which</span><br><span class="line">     * implements &#123;@code Runnable&#125;.</span><br><span class="line">     */</span><br><span class="line">    public void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者Thread源码如下（省略部分代码）： Tips：命令模式在这里本来不需要继承Runnable接口，但为了方便性等，继承了Runnable接口实现了run方法，这个run是Thread自身的运行run的方法，而不是命令Runnable的run。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    //省略部分无关代码...</span><br><span class="line">    /* some of these are accessed directly by the VM; do not rename them */</span><br><span class="line">    volatile VMThread vmThread;</span><br><span class="line">    volatile ThreadGroup group;</span><br><span class="line">    volatile boolean daemon;</span><br><span class="line">    volatile String name;</span><br><span class="line">    volatile int priority;</span><br><span class="line">    volatile long stackSize;</span><br><span class="line">    Runnable target;</span><br><span class="line">    private static int count = 0;</span><br><span class="line">    </span><br><span class="line">    public synchronized void start() &#123;</span><br><span class="line">        if (hasBeenStarted) &#123;</span><br><span class="line">            throw new IllegalThreadStateException(&quot;Thread already started.&quot;); // TODO Externalize?</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hasBeenStarted = true;</span><br><span class="line"></span><br><span class="line">        VMThread.create(this, stackSize);</span><br><span class="line">    &#125;</span><br><span class="line">    //省略部分代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面可以看到执行start()方法的时候实际执行了VMThread.create(this, stackSize)方法；create是VMThread的本地方法，其JNI实现在 android/dalvik/vm/native/java_lang_VMThread.cpp 中的 Dalvik_java_lang_VMThread_create方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void Dalvik_java_lang_VMThread_create(const u4* args, JValue* pResult)</span><br><span class="line">&#123;</span><br><span class="line">    Object* threadObj = (Object*) args[0];</span><br><span class="line">    s8 stackSize = GET_ARG_LONG(args, 1);</span><br><span class="line"></span><br><span class="line">    /* copying collector will pin threadObj for us since it was an argument */</span><br><span class="line">    dvmCreateInterpThread(threadObj, (int) stackSize);</span><br><span class="line">    RETURN_VOID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而dvmCreateInterpThread的实现在Thread.app中，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool dvmCreateInterpThread(Object* threadObj, int reqStackSize)&#123;</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    </span><br><span class="line">    Thread* newThread = allocThread(stackSize); </span><br><span class="line">    newThread-&gt;threadObj = threadObj;</span><br><span class="line">    </span><br><span class="line">    Object* vmThreadObj = dvmAllocObject(gDvm.classJavaLangVMThread, ALLOC_DEFAULT);</span><br><span class="line">    dvmSetFieldInt(vmThreadObj, gDvm.offJavaLangVMThread_vmData, (u4)newThread);</span><br><span class="line">    dvmSetFieldObject(threadObj, gDvm.offJavaLangThread_vmThread, vmThreadObj);</span><br><span class="line">    </span><br><span class="line">    pthread_t threadHandle;</span><br><span class="line">    int cc = pthread_create(&amp;threadHandle, &amp;threadAttr, interpThreadStart, newThread);</span><br><span class="line"></span><br><span class="line">    dvmLockThreadList(self);</span><br><span class="line"></span><br><span class="line">    assert(newThread-&gt;status == THREAD_STARTING);</span><br><span class="line">    newThread-&gt;status = THREAD_VMWAIT;</span><br><span class="line">    pthread_cond_broadcast(&amp;gDvm.threadStartCond);</span><br><span class="line"></span><br><span class="line">    dvmUnlockThreadList();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Thread* allocThread(int interpStackSize)</span><br><span class="line">&#123;</span><br><span class="line">    Thread* thread;</span><br><span class="line">    thread = (Thread*) calloc(1, sizeof(Thread));</span><br><span class="line">    </span><br><span class="line">    thread-&gt;status = THREAD_INITIALIZING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是底层代码，简单介绍下就行了： 第4行通过调用 allocThread 创建一个名为newThread的dalvik Thread并设置一些属性，第5行设置其成员变量threadObj为传入的Android Thread，这样dalvik Thread就与Android Thread对象关联起来了；第7行然后创建一个名为vmThreadObj的VMThread对象，设置其成员变量vmData为前面创建的newThread，设置 Android Thread threadObj的成员变量vmThread为这个vmThreadObj，这样Android Thread通过VMThread的成员变量vmData就和dalvik Thread关联起来了。</p>
<p>接下来在12行通过pthread_create创建pthread线程，并让这个线程start，这样就会进入该线程的thread entry运行，下来我们来看新线程的thread entry方法 interpThreadStart，同样只列出关键的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//pthread entry function for threads started from interpreted code.</span><br><span class="line">static void* interpThreadStart(void* arg)&#123;</span><br><span class="line">    Thread* self = (Thread*) arg;</span><br><span class="line">    std::string threadName(dvmGetThreadName(self));</span><br><span class="line">    setThreadName(threadName.c_str());</span><br><span class="line"></span><br><span class="line">    //Finish initializing the Thread struct.</span><br><span class="line">    dvmLockThreadList(self);</span><br><span class="line">    prepareThread(self);</span><br><span class="line"></span><br><span class="line">    while (self-&gt;status != THREAD_VMWAIT)</span><br><span class="line">        pthread_cond_wait(&amp;gDvm.threadStartCond, &amp;gDvm.threadListLock);</span><br><span class="line"></span><br><span class="line">    dvmUnlockThreadList();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Add a JNI context.</span><br><span class="line">     */</span><br><span class="line">    self-&gt;jniEnv = dvmCreateJNIEnv(self);</span><br><span class="line"></span><br><span class="line">    //修改状态为THREAD_RUNNING</span><br><span class="line">    dvmChangeStatus(self, THREAD_RUNNING);</span><br><span class="line">    </span><br><span class="line">    //执行run方法</span><br><span class="line">    Method* run = self-&gt;threadObj-&gt;clazz-&gt;vtable[gDvm.voffJavaLangThread_run];</span><br><span class="line"></span><br><span class="line">    JValue unused;</span><br><span class="line">    ALOGV(&quot;threadid=%d: calling run()&quot;, self-&gt;threadId);</span><br><span class="line">    assert(strcmp(run-&gt;name, &quot;run&quot;) == 0);</span><br><span class="line">    dvmCallMethod(self, run, self-&gt;threadObj, &amp;unused);</span><br><span class="line">    ALOGV(&quot;threadid=%d: exiting&quot;, self-&gt;threadId);</span><br><span class="line">    </span><br><span class="line">    //移出线程并释放资源</span><br><span class="line">    dvmDetachCurrentThread();</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Finish initialization of a Thread struct.</span><br><span class="line">static bool prepareThread(Thread* thread)&#123;</span><br><span class="line">    assignThreadId(thread);</span><br><span class="line">    thread-&gt;handle = pthread_self();</span><br><span class="line">    thread-&gt;systemTid = dvmGetSysThreadId();</span><br><span class="line">    setThreadSelf(thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Explore our sense of self.  Stuffs the thread pointer into TLS.</span><br><span class="line">static void setThreadSelf(Thread* thread)&#123;</span><br><span class="line">    int cc;</span><br><span class="line">    cc = pthread_setspecific(gDvm.pthreadKeySelf, thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在新线程的interpThreadStart方法中，首先设置线程的名字，然后调用prepareThread设置线程id以及其它一些属性，其中调用了setThreadSelf将新dalvik Thread自身保存在TLS中，这样之后就能通过dvmThreadSelf方法从TLS中获取它。然后在29行处修改状态为THREAD_RUNNING，并在36行调用对应Android Thread的run()方法，其中调用了Runnable的run方法，运行我们自己的代码。 绕这么深才执行到我们的run方法，累不累？ v_v</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Calls the &lt;code&gt;run()&lt;/code&gt; method of the Runnable object the receiver</span><br><span class="line"> * holds. If no Runnable is set, does nothing.</span><br><span class="line"> * @see Thread#start</span><br><span class="line"> */</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (target != null) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此我们已经完成一次命令调用，至于底层run调用完毕后续执行代码，读者可以自行跟进看看~~~</p>
<h3 id="3-9-访问者模式"><a href="#3-9-访问者模式" class="headerlink" title="3.9 访问者模式"></a>3.9 访问者模式</h3><h4 id="模式定义-17"><a href="#模式定义-17" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>封装一些作用于某些数据结构中的各元素的操作，它可以在不改变数据结构的前提下赋予这些元素新的操作。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>对象结构比较稳定，但是需要在对象结构的基础上定义新的操作。</li>
<li>需要对同一个类的不同对象执行不不同的操作，但是不希望增加操作的时候改变这些类。</li>
</ul>
<h4 id="Android源码对应实现-1"><a href="#Android源码对应实现-1" class="headerlink" title="Android源码对应实现"></a>Android源码对应实现</h4><p><code>APT</code>的注解. 简单记录一下. 首先编译器将代码抽象成一个代码元素的树, 然后在编译时对整棵树进行遍历访问, 每个元素都有一个<code>accept()</code>接收访问者的访问, 每个访问者中都有对应的<code>visit()</code>函数, 例如<code>visitType()</code>函数就是对类型元素的访问, 在每个<code>visit</code>函数中对不同的类型进行不同的处理, 这样就达到了差异处理效果, 同时将数据结构与数据操作分离, 使得每个类型的职责单一, 易于升级维护. <code>JDK</code>还特意预留了<code>visitUnknown()</code>接口应对<code>Java</code>语言后续发展可能添加的元素类型问题, 灵活的将访问者模式的缺点化解.</p>
<p><a href="https://blog.csdn.net/xxxzhi/article/details/51747513" target="_blank" rel="noopener">https://blog.csdn.net/xxxzhi/article/details/51747513</a></p>
<p>编译时注解依赖于APT(Annotation Processing Tools)实现，在编译器会自己生成相关的java类。</p>
<p>注解可以指定作用于哪种元素上，  比如：</p>
<p>PackageElement，包元素</p>
<p>TypeElement，类型元素</p>
<p>ExecutableElement，可执行元素</p>
<p>VariableElement，变量元素</p>
<p>TypeParameterElement，类型参数元素</p>
<p>Element基类里面有一个accept(ElementVisitor&lt;R,p&gt; v,P p)方法</p>
<p>ElementVisitor里面又根据不同的元素类型重载很很多visit方法。</p>
<p>比如类型元素访问者 里面是visitType(TypeElement e,P p)方法，然后里面做了这种类型元素需要的操作。</p>
<h3 id="3-10-责任链模式"><a href="#3-10-责任链模式" class="headerlink" title="3.10 责任链模式"></a>3.10 责任链模式</h3><h4 id="模式定义-18"><a href="#模式定义-18" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote>
<p>将请求的发送者和接收者进行解耦，使得多个对象都有机会处理该请求，将这些对象串成一条链，并沿着这条链子处理请求，直到有对象处理它为止。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>多个对象可以处理同一个请求，但是具体由哪个对象处理在运行时动态决定。</li>
<li>在请求处理者不明确的情况下向多个对象中的一个提交请求。</li>
<li>需要动态指定一组对象的处理请求。</li>
</ul>
<p>责任链模式的实现主要在于处理器的迭代，要么使用循环迭代，要么使用链表后继，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 处理器，定位行为和下一个处理器</span><br><span class="line">public abstract class Handler &#123;</span><br><span class="line">    protected Handler next;</span><br><span class="line"></span><br><span class="line">    public abstract void handleRequest(String condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理器1</span><br><span class="line">public class Handler1 extends Handler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(String condition) &#123;</span><br><span class="line">        if (TextUtils.equals(condition, &quot;Handler1&quot;)) &#123;</span><br><span class="line">            // process request</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // next handler</span><br><span class="line">            next.handleRequest(condition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理器2</span><br><span class="line">public class Handler2 extends Handler &#123;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void handleRequest(String condition) &#123;</span><br><span class="line">        if (TextUtils.equals(condition, &quot;Handler2&quot;)) &#123;</span><br><span class="line">            // process request</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // next handler</span><br><span class="line">            next.handleRequest(condition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Android应用-事件分发"><a href="#Android应用-事件分发" class="headerlink" title="Android应用-事件分发"></a>Android应用-事件分发</h4><p><img src="https://upload-images.jianshu.io/upload_images/966283-d01a5845f7426097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="img"> </p>
<p><a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">https://www.jianshu.com/p/e99b5e8bd67b</a></p>
<h3 id="3-11-迭代器模式"><a href="#3-11-迭代器模式" class="headerlink" title="3.11 迭代器模式"></a>3.11 迭代器模式</h3><p>模式定义</p>
<blockquote>
<p>提供一个方法顺序访问一个容器内的元素，而又不暴露该对象的内部表示。</p>
</blockquote>
<p>应用场景</p>
<ul>
<li>遍历一个容器时。</li>
</ul>
<h4 id="UML类图-3"><a href="#UML类图-3" class="headerlink" title="UML类图"></a>UML类图</h4><p>　　　 　<a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/iterator/haoxiqiang/images/Iterator_UML_class_diagram.svg.png" target="_blank" rel="noopener"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/iterator/haoxiqiang/images/Iterator_UML_class_diagram.svg.png" alt="iterator"></a></p>
<h4 id="角色介绍-3"><a href="#角色介绍-3" class="headerlink" title="角色介绍　　"></a>角色介绍　　</h4><ul>
<li>迭代器接口Iterator：该接口必须定义实现迭代功能的最小定义方法集比如提供hasNext()和next()方法。</li>
<li>迭代器实现类：迭代器接口Iterator的实现类。可以根据具体情况加以实现。</li>
<li>容器接口：定义基本功能以及提供类似Iterator iterator()的方法。</li>
<li>容器实现类：容器接口的实现类。必须实现Iterator iterator()方法。</li>
</ul>
<h4 id="Android应用-2"><a href="#Android应用-2" class="headerlink" title="Android应用"></a>Android应用</h4><p>一个集合想要实现Iterator很是很简单的,需要注意的是每次需要重新生成一个Iterator来进行遍历.且遍历过程是单方向的,HashMap是通过一个类似HashIterator来实现的,我们为了解释简单,这里只是研究ArrayList(此处以Android L源码为例,其他版本略有不同)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Override public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new ArrayListIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class ArrayListIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /** Number of elements remaining in this iteration */</span><br><span class="line">    private int remaining = size;</span><br><span class="line"></span><br><span class="line">    /** Index of element that remove() would remove, or -1 if no such elt */</span><br><span class="line">    private int removalIndex = -1;</span><br><span class="line"></span><br><span class="line">    /** The expected modCount value */</span><br><span class="line">    private int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return remaining != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123;</span><br><span class="line">        ArrayList&lt;E&gt; ourList = ArrayList.this;</span><br><span class="line">        int rem = remaining;</span><br><span class="line">        if (ourList.modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (rem == 0) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        remaining = rem - 1;</span><br><span class="line">        return (E) ourList.array[removalIndex = ourList.size - rem];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        Object[] a = array;</span><br><span class="line">        int removalIdx = removalIndex;</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (removalIdx &lt; 0) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining);</span><br><span class="line">        a[--size] = null;  // Prevent memory leak</span><br><span class="line">        removalIndex = -1;</span><br><span class="line">        expectedModCount = ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>java中的写法一般都是通过iterator()来生成Iterator,保证iterator()每次生成新的实例</li>
<li>remaining初始化使用整个list的size大小,removalIndex表示remove掉的位置,modCount在集合大小发生变化的时候后都会进行一次modCount++操作,避免数据不一致,前面我写的例子这方面没有写,请务必注意这点</li>
<li>hasNext方法中,因为remaining是一个size-&gt;0的变化过程,这样只需要判断非0就可以得知当前遍历的是否还有未完成的元素</li>
<li>next,第一次调用的时候返回array[0]的元素,这个过程中removalIndex会被设置成当前array的index</li>
<li>remove的实现是直接操作的内存中的数据,是能够直接删掉元素的,不展开了</li>
</ul>
<h2 id="三种模式关系"><a href="#三种模式关系" class="headerlink" title="三种模式关系"></a>三种模式关系</h2><h3 id="1．创建型模式"><a href="#1．创建型模式" class="headerlink" title="1．创建型模式"></a>1．创建型模式</h3><p>创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。</p>
<p>社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：</p>
<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
<li>创建者模式（Builder）</li>
<li>原型模式（Prototype）</li>
<li>单例模式（Singleton）</li>
</ul>
<blockquote>
<p>简单工厂模式不是GoF总结出来的23种设计模式之一</p>
</blockquote>
<h3 id="2．结构型模式"><a href="#2．结构型模式" class="headerlink" title="2．结构型模式"></a>2．结构型模式</h3><p>结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。</p>
<p>在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：</p>
<ul>
<li>外观模式/门面模式（Facade门面模式）</li>
<li>适配器模式（Adapter）</li>
<li>代理模式（Proxy）</li>
<li>装饰模式（Decorator）</li>
<li>桥梁模式/桥接模式（Bridge）</li>
<li>组合模式（Composite）</li>
<li>享元模式（Flyweight）</li>
</ul>
<h3 id="3．行为型模式"><a href="#3．行为型模式" class="headerlink" title="3．行为型模式"></a>3．行为型模式</h3><p>行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。1. 行为类模式使用继承机制在类间分派行为。2. 行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</p>
<p>在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：</p>
<ul>
<li>模板方法模式（Template Method）</li>
<li>观察者模式（Observer）</li>
<li>状态模式（State）</li>
<li>策略模式（Strategy）</li>
<li>职责链模式（Chain of Responsibility）</li>
<li>命令模式（Command）</li>
<li>访问者模式（Visitor）</li>
<li>调停者模式（Mediator）</li>
<li>备忘录模式（Memento）</li>
<li>迭代器模式（Iterator）</li>
<li>解释器模式（Interpreter）</li>
</ul>
<h3 id="三者之间的区别和联系"><a href="#三者之间的区别和联系" class="headerlink" title="三者之间的区别和联系"></a>三者之间的区别和联系</h3><blockquote>
<p>创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。</p>
</blockquote>
<ol>
<li>创建型模式为其他两种模式使用提供了环境。</li>
<li>结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。</li>
<li>行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。</li>
</ol>
<table>
<thead>
<tr>
<th><strong>的</strong></th>
<th><strong>创建型模式Creational Pattern</strong></th>
<th><strong>结构型模式Structural Patterns</strong></th>
<th><strong>行为型模式Behavioral Pattern</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>概念</strong></td>
<td>创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑</td>
<td>结构型模式是为解决怎样组装现有的类，设计他们的交互方式，从而达到实现一定的功能的目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）封装性（适配器，桥接）</td>
<td>行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为型模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式1.行为模式使用继承机制在类间分派行为2.行为对象模式使用对象聚合来分配行为。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。</td>
</tr>
<tr>
<td><strong>类</strong></td>
<td>Factory Method</td>
<td>Adapter(类)</td>
<td>Interpreter</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Template Method</td>
</tr>
<tr>
<td><strong>对象</strong></td>
<td>Abstract Factory</td>
<td>Adapter(对象)</td>
<td>Chain of Responsibility</td>
</tr>
<tr>
<td></td>
<td>Builder</td>
<td>Bridge</td>
<td>Command</td>
</tr>
<tr>
<td></td>
<td>Prototype</td>
<td>Composite</td>
<td>Iterator</td>
</tr>
<tr>
<td></td>
<td>Singleton</td>
<td>Decorator</td>
<td>Mediator</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Facade</td>
<td>Memento</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Flyweight</td>
<td>Observer</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Proxy</td>
<td>State</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Strategy</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>Visitor</td>
</tr>
</tbody>
</table>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>开闭原则： 对扩展开放，对修改关闭</li>
<li>里氏转换原则： 子类继承父类，单独完全可以运行</li>
<li>依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型</li>
<li>接口隔离原则： 每一个接口应该是一种角色</li>
<li>合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分</li>
<li>迪米特原则： 一个对象应对其他对象有尽可能少的了解</li>
</ol>
<h2 id="Android-源码中设计模式"><a href="#Android-源码中设计模式" class="headerlink" title="Android 源码中设计模式"></a>Android 源码中设计模式</h2><p>下面我们简要的介绍一下设计模式在 Android 源码中的应用<br>工厂方法模式： 接口 Iterable 中的 iterator 就是一个工厂方法， Activity 中的 onCreate 也可以看作是工厂方法<br>抽象工厂模式： MediaPlayerFactory 是一个抽象工厂<br>单例模式： 单例模式的应用非常广泛， Application 就是单例的， WindowManagerService 、 ActivityService 等系统级的 Service 也是单例的，具体可见 <a href="http://weiqianghu.github.io/2016/09/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">单例模式</a><br>建造者模式 ：建造者模式在图片加载库中使用非常普遍，例如 Picasso 、 Glide 、UniversalImageLoader 中都有建造者模式的身影。在 Android 源码中 AlertDialog 中应用了建造者模式，详见 <a href="http://weiqianghu.github.io/2016/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-Builder-%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式之 Builder 模式</a><br>原型模式：原型模式就是实现接口 Cloneable ，这个太多了。。。<br>适配器模式：这个不用说了， AbsListView 和 RecyclerView 都使用了适配器模式。详见：<a href="http://weiqianghu.github.io/2016/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式之适配器模式</a><br>装饰器模式：Context 、 ContextImpl 、 ContextWrapper 、ContextThemeWrapper<br>代理模式： AIDL ，ActivityProxy（其实这也是 AIDL ）<br>外观模式：Context 作为 Android 系统中的上帝类，封装了很多功能，这也是外观模式的应用<br>桥接模式：Adapter 与 AdapterView 的桥接，Window 与 WindowManager 的桥接 详见：<a href="http://weiqianghu.github.io/2016/10/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式之桥接模式</a><br>组合模式： View 、 ViewGroup<br>享元模式：Message 中的 MessagePool 是用链表实现的。<br>策略模式：动画中的 InterPolator 和 TypeEvaluator 。详见<a href="http://weiqianghu.github.io/2016/08/23/Android-%E5%8A%A8%E7%94%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Android 动画分析</a><br>模板方法模式: 模板模式的应用非常广泛， Android 中 AsyncTask 的几个回调可以看作模板。<br>观察者模式： AbsListView 和 RecyclerView 都使用了观察者模式，详见<a href="http://weiqianghu.github.io/2016/09/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">设计模式之观察者模式</a><br>迭代子模式： 这个不用说了，在 JDK 中的集合类都是迭代子模式。<br>责任链模式： View 中对于事件的分发处理可以看作是责任链模式。详见<a href="http://weiqianghu.github.io/2016/07/14/%E5%88%A9%E7%94%A8%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%90%8C%E6%9D%A5%E6%BA%90%E7%9A%84%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">利用责任链模式实现加载不同来源的数据</a><br>命令模式： Android 事件的底层 NotifyArgs 就是一个命令对象。<br>备忘录模式： Android 的状态保存， onSaveInstanceState 、 onRestoreInstaceState<br>状态模式： WIFI 管理<br>访问者模式： Java 注解 APT<br>中介者模式： KeyGuard 功能的实现<br>解释器模式： PackageParser 中有解释器模式的影子</p>
<h2 id="Java设计模式-JDK中的应用"><a href="#Java设计模式-JDK中的应用" class="headerlink" title="Java设计模式:JDK中的应用"></a>Java设计模式:JDK中的应用</h2><h3 id="创建型模式-1"><a href="#创建型模式-1" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>抽象工厂模式(通过创建的方法返回工厂本身, 可以依次创建另一个抽象/接口类型)<br>javax.xml.parsers.DocumentBuilderFactory#newInstance()<br>javax.xml.transform.TransformerFactory#newInstance()<br>javax.xml.xpath.XPathFactory#newInstance()<br>生成器模式(通过创建的方法返回实例本身)<br>java.lang.StringBuilder#append() (非同步的)<br>java.lang.StringBuffer#append() (支持同步)<br>java.nio.ByteBuffer#put() (与之相同的有: CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer 和 DoubleBuffer)<br>javax.swing.GroupLayout.Group#addComponent()<br>java.lang.Appendabled 的所有实现<br>工厂模式(通过创建的方法返回一个抽象/接口类型的实现)<br>java.util.Calendar#getInstance()<br>java.util.ResourceBundle#getBundle()<br>java.text.NumberFormat#getInstance()<br>java.nio.charset.Charset#forName()<br>java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (按协议返回单例对象)<br>原型模式(通过创建的方法返回一个包含相同属性的不同实例)<br>java.lang.Object#clone() (类必须实现 java.lang.Cloneable)<br>单例模式(通过创建的方法在任何时间都返回一个相同实例(通常是它本身))<br>java.lang.Runtime#getRuntime()<br>java.awt.Desktop#getDesktop()</p>
<h3 id="结构型模式-2"><a href="#结构型模式-2" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>适配器模式(接收不同抽象或接口类型的一个实例, 并返回一个装饰或重写了该实例的本身/其他的抽象/接口类型的指定实现)<br>java.util.Arrays#asList()<br>java.io.InputStreamReader(InputStream) (返回一个Reader)<br>java.io.OutputStreamWriter(OutputStream) (返回一个Writer)<br>javax.xml.bind.annotation.adapters.XmlAdapter#marshal() 和 #unmarshal()<br>桥接模式(接收不同抽象或接口类型的一个实例, 并返回一个委托或使用了该实例的本身/其他的抽象/接口类型的指定实现)<br>一时之间没有想到. 一个虚构的例子: new LinkedHashMap(LinkedHashSet<k>, List<v>)返回一个不可变的链式map, 并且不会克隆内部元素而是直接使用他们. java.util.Collections#newSetFromMap() 和 singletonXXX()方法是有些接近这个模式的.<br>组合模式(通过行为式的方法接收一个相同的抽象或接口类型的实例转换为一个树状结构)<br>java.awt.Container#add(Component) (几乎所有Swing都是这样)<br>javax.faces.component.UIComponent#getChildren() (几乎所有JSF UI都是这样)<br>装饰器模式(通过创建的方法接收一个相同的抽象或接口类型的实例, 并添加附加的行为)<br>java.io.InputStream, OutputStream, Reader 和 Writer的子类拥有一个持有相同类型的实例构造器.<br>java.util.Collections, checkedXXX(), synchronizedXXX() 和 unmodifiableXXX().<br>javax.servlet.http.HttpServletRequestWrapper 和 HttpServletResponseWrapper<br>门面模式(通过行为式的方法实现, 该方法内部使用不同的独立的抽象或接口类型的实例)<br>javax.faces.context.FacesContext, 它内部之间使用 LifeCycle, ViewHandler, NavigationHandler 和很多无需最终能够用户关心的抽象/接口类型(可通过注入覆写).<br>javax.faces.context.ExternalContext, 它内部使用ServletContext, HttpSession, HttpServletRequest, HttpServletResponse等.<br>享元模式(通过创建的方法返回一个缓存的实例, 有一些”多例”的思想)<br>java.lang.Integer#valueOf(int) (类似的还包括: Boolean, Byte, Character, Short 和 Long)<br>代理模式(通过创建的方法返回指定的抽象或接口类型的实现, 该实现依次委托或使用了指定抽象或接口类型的不同实现)<br>java.lang.reflect.Proxy<br>java.rmi.*下所有API.</v></k></p>
<h3 id="行为型模式-2"><a href="#行为型模式-2" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>责任链模式(通过行为方法(间接地)在一个队列中调用另一个相同抽象/接口类型的相同方法)<br>java.util.logging.Logger#log()<br>javax.servlet.Filter#doFilter()<br>命令模式(一个抽象/接口类型内的行为方法中, 调用一个不同的象/接口类型的实现的方法, 该实现已经在其创建过程中被命令实现封装)<br>java.lang.Runnable的所有实现<br>javax.swing.Action的所有实现<br>解释器模式(行为方法返回一个有结构的并且与被提供的实例/类型不同的实例/类型; 注意parsing/formatting不是这个模式的组成部分, 而是用来确定该模式以及如何应用模式)<br>java.util.Pattern<br>java.text.Normalizer<br>java.text.Format的所有子类<br>javax.el.ELResolver的所有子类<br>迭代器模式(行为方法按顺序的自一个队列中返回不同类型的实例)<br>java.util.Iterator的所有实现 (除此以外, 还有 java.util.Scanner!).<br>java.util.Enumeration的所有实现<br>中介者模式(行为方法接收一个不同抽象/接口类型的实例(通常使用命令模式), 该实例委托或使用了指定实例)<br>java.util.Timer (所有 scheduleXXX() 方法)<br>java.util.concurrent.Executor#execute()<br>java.util.concurrent.ExecutorService (invokeXXX() 和 submit() 方法)<br>java.util.concurrent.ScheduledExecutorService (所有 scheduleXXX() 方法)<br>java.lang.reflect.Method#invoke()<br>备忘录模式(行为方法内部改变了整个实例的状态)<br>java.util.Date ( setter 方法就是这么做的, Date 内部通过长整型long表示)<br>java.io.Serializable的所有实现<br>javax.faces.component.StateHolder的所有实现<br>观察者或发布/订阅模式(行为方法在另一个抽象/接口类型的实例上调用方法, 并取决于自身状态)<br>java.util.Observer/java.util.Observable (在现实世界中很少使用)<br>java.util.EventListener 的所有实现 (几乎所有的Swing都是这样)<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener<br>状态模式(行为方法通过外部可控的实例状态改变它的行为)<br>javax.faces.lifecycle.LifeCycle#execute() (通过FacesServlet控制, 行为取决于当前JSF生命周期的阶段(状态)<br>策略模式(行为方法内一个抽象/接口类型调用不同抽象/接口类型的不同实现内的方法, 该实现以方法参数型式被传进策略实现内)<br>java.util.Comparator#compare(), 在Collections#sort()中执行.<br>javax.servlet.http.HttpServlet, service() 和所有 doXXX() 方法接收 HttpServletRequest, HttpServletResponse, 并且实现者必须处理它们(而不是作为实例变量持有它们)<br>javax.servlet.Filter#doFilter()<br>模板模式(行为方法已拥有一个被抽象类型定义的”默认”行为)<br>java.io.InputStream, java.io.OutputStream, java.io.Reader 和 java.io.Writer 的所有非抽象方法.<br>java.util.AbstractList, java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法.<br>javax.servlet.http.HttpServlet, 所有 doXXX() 方法默认发送 HTTP 405 “Method Not Allowed” 错误到响应中. 你可以任意实现这些方法.<br>访问者模式(两个不同的抽象/接口类型中包含互相接收对方抽象/接口类型的方法; 实际调用的是另一个类型的方法和它上面的其他执行所需求的策略)<br>javax.lang.model.element.AnnotationValue 和 AnnotationValueVisitor<br>javax.lang.model.element.Element 和 ElementVisitor<br>javax.lang.model.type.TypeMirror 和 TypeVisitor</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>UML： <a href="https://zhuanlan.zhihu.com/p/24576502" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24576502</a></p>
<p>精简uml图：</p>
<p><a href="http://jayfeng.com/2016/04/02/%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%86%E7%B1%BB%E3%80%81%E6%84%8F%E5%9B%BE%E3%80%81UML%E7%B1%BB%E5%9B%BE/" target="_blank" rel="noopener">http://jayfeng.com/2016/04/02/%E7%90%86%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%86%E7%B1%BB%E3%80%81%E6%84%8F%E5%9B%BE%E3%80%81UML%E7%B1%BB%E5%9B%BE/</a></p>
<p><a href="https://blog.csdn.net/sfdev/article/details/2845488" target="_blank" rel="noopener">https://blog.csdn.net/sfdev/article/details/2845488</a></p>
<p>设计模式：</p>
<p><a href="http://linbinghe.com/2017/1646c9f3.html" target="_blank" rel="noopener">http://linbinghe.com/2017/1646c9f3.html</a></p>
<p><a href="https://github.com/suzeyu1992/repo/tree/master/project/design-pattern" target="_blank" rel="noopener">https://github.com/suzeyu1992/repo/tree/master/project/design-pattern</a></p>
<p><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/tree/master/design_patterns" target="_blank" rel="noopener">https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/tree/master/design_patterns</a></p>
<p><a href="https://www.kancloud.cn/longxuan/my-designpattern/117488" target="_blank" rel="noopener">https://www.kancloud.cn/longxuan/my-designpattern/117488</a></p>
<p><a href="https://github.com/jiayisheji/blog/issues/2" target="_blank" rel="noopener">https://github.com/jiayisheji/blog/issues/2</a></p>
<p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/README.md" target="_blank" rel="noopener">https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/README.md</a></p>
<p><a href="https://www.cnblogs.com/happykoukou/p/5382649.html" target="_blank" rel="noopener">https://www.cnblogs.com/happykoukou/p/5382649.html</a></p>
<p><a href="https://pgzxc.github.io/2017/12/24/Android%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">https://pgzxc.github.io/2017/12/24/Android%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></p>
<p><a href="https://github.com/guoxiaoxing/android-open-source-project-analysis/blob/master/doc/Android%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AF%87/02Android%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">https://github.com/guoxiaoxing/android-open-source-project-analysis/blob/master/doc/Android%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AF%87/02Android%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md</a></p>
<p><a href="https://github.com/quanke/design-pattern-java" target="_blank" rel="noopener">https://github.com/quanke/design-pattern-java</a></p>
<p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/README.md" target="_blank" rel="noopener">https://github.com/simple-android-framework/android_design_patterns_analysis/blob/master/README.md</a></p>
<p><a href="https://clarkdo.js.org/design%20patterns%20stories/2014/10/20/46/" target="_blank" rel="noopener">https://clarkdo.js.org/design%20patterns%20stories/2014/10/20/46/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"># 设计模式</a>
          
            <a href="/tags/汇总/" rel="tag"># 汇总</a>
          
            <a href="/tags/分析精华/" rel="tag"># 分析精华</a>
          
            <a href="/tags/DesignPattern/" rel="tag"># DesignPattern</a>
          
            <a href="/tags/uml/" rel="tag"># uml</a>
          
            <a href="/tags/23dp/" rel="tag"># 23dp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/android_app_thread_bg_sum.html" rel="next" title="Android 后台线程">
                <i class="fa fa-chevron-left"></i> Android 后台线程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/java_jdk_base_thread_lock.html" rel="prev" title="java 8简明指南">
                java 8简明指南 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Fitz.Lee" />
          <p class="site-author-name" itemprop="name">Fitz.Lee</p>
           
              <p class="site-description motion-element" itemprop="description">Security & Android & Java</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">91</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">144</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fitzlee" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:fitz.lee@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/c7757daadf27" target="_blank" title="JianShu">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                    
                      JianShu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.anquanke.com/" title="Anquanke" target="_blank">Anquanke</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.gityuan.com/" title="Gityuan" target="_blank">Gityuan</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式之-UML-类图"><span class="nav-number">1.</span> <span class="nav-text">设计模式之 UML 类图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UML-类图"><span class="nav-number">1.2.</span> <span class="nav-text">UML 类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-依赖-Dependency"><span class="nav-number">1.3.</span> <span class="nav-text">1. 依赖 (Dependency)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-关联-Association"><span class="nav-number">1.4.</span> <span class="nav-text">2. 关联 (Association)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-聚合-Aggregation"><span class="nav-number">1.5.</span> <span class="nav-text">3.聚合 (Aggregation)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-组合-Composition"><span class="nav-number">1.6.</span> <span class="nav-text">4. 组合 (Composition)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-继承-Generalization"><span class="nav-number">1.7.</span> <span class="nav-text">5. 继承 (Generalization)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-实现-Implementation"><span class="nav-number">1.8.</span> <span class="nav-text">6. 实现 (Implementation)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#意图、UML类图"><span class="nav-number">2.</span> <span class="nav-text">意图、UML类图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建模式"><span class="nav-number">2.1.</span> <span class="nav-text">创建模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建型模式"><span class="nav-number">2.1.1.</span> <span class="nav-text">创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂方法"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">工厂方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象工厂"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">抽象工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建造者模式"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">建造者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型模式"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">原型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构型模式"><span class="nav-number">2.1.2.</span> <span class="nav-text">结构型模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构型模式-1"><span class="nav-number">2.2.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器模式"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">适配器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#桥接模式"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合模式"><span class="nav-number">2.2.0.3.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰者模式"><span class="nav-number">2.2.0.4.</span> <span class="nav-text">装饰者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#门面模式"><span class="nav-number">2.2.0.5.</span> <span class="nav-text">门面模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#享元模式"><span class="nav-number">2.2.0.6.</span> <span class="nav-text">享元模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理模式"><span class="nav-number">2.2.0.7.</span> <span class="nav-text">代理模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#行为型模式"><span class="nav-number">2.3.</span> <span class="nav-text">行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#行为型模式-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解释器模式"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">解释器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板方法模式"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">模板方法模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#职责链模式"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">职责链模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令模式"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器模式"><span class="nav-number">2.3.1.5.</span> <span class="nav-text">迭代器模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中介者模式"><span class="nav-number">2.3.1.6.</span> <span class="nav-text">中介者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#备忘录模式"><span class="nav-number">2.3.1.7.</span> <span class="nav-text">备忘录模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察者模式"><span class="nav-number">2.3.1.8.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态模式"><span class="nav-number">2.3.1.9.</span> <span class="nav-text">状态模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#策略模式"><span class="nav-number">2.3.1.10.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问者模式"><span class="nav-number">2.3.1.11.</span> <span class="nav-text">访问者模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android系统编程思想：设计模式"><span class="nav-number">3.</span> <span class="nav-text">Android系统编程思想：设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-创建型设计模式"><span class="nav-number">3.1.</span> <span class="nav-text">一 创建型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-单例模式"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-建造者模式"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 建造者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code："><span class="nav-number">3.1.2.2.</span> <span class="nav-text">code：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android中的应用"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">Android中的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java应用"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">Java应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-原型模式"><span class="nav-number">3.1.3.</span> <span class="nav-text">1.3 原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-1"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UML类图"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">UML类图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#角色介绍"><span class="nav-number">3.1.3.2.1.</span> <span class="nav-text">角色介绍</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浅拷贝和深拷贝"><span class="nav-number">3.1.3.4.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Androi应用Intent"><span class="nav-number">3.1.3.5.</span> <span class="nav-text">Androi应用Intent</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-简单工厂模式"><span class="nav-number">3.1.4.</span> <span class="nav-text">1.4 简单工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-2"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android中简单工厂模式的应用"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">Android中简单工厂模式的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-工厂模式"><span class="nav-number">3.1.5.</span> <span class="nav-text">1.5 工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-3"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android源码中的应用"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">Android源码中的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-抽象工厂模式"><span class="nav-number">3.1.6.</span> <span class="nav-text">1.6 抽象工厂模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-结构型设计模式"><span class="nav-number">3.2.</span> <span class="nav-text">二 结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-适配器模式"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器的类图表示"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">适配器的类图表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-ListView-中的-Adapter-模式"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Android ListView 中的 Adapter 模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-组合模式"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-4"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android具体实现代码"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">Android具体实现代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-装饰模式"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-5"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code-1"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android源码中的模式实现"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">Android源码中的模式实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-外观模式"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.4 外观模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-6"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code-2"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">code</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用-context封装"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">Android应用-context封装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-桥接模式"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.5 桥接模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-源码中的桥接模式"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">Android 源码中的桥接模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Adapter-与-AdapterView-的桥接"><span class="nav-number">3.2.5.1.1.</span> <span class="nav-text">Adapter 与 AdapterView 的桥接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Window-与-WindowManager-的桥接"><span class="nav-number">3.2.5.1.2.</span> <span class="nav-text">Window 与 WindowManager 的桥接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-享元模式"><span class="nav-number">3.2.6.</span> <span class="nav-text">2.6 享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-7"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android-源码中的享元模式"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">Android 源码中的享元模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-代理模式"><span class="nav-number">3.2.7.</span> <span class="nav-text">2.7 代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-8"><span class="nav-number">3.2.7.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UML类图-1"><span class="nav-number">3.2.7.2.</span> <span class="nav-text">UML类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#角色介绍-1"><span class="nav-number">3.2.7.3.</span> <span class="nav-text">角色介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code：-1"><span class="nav-number">3.2.7.4.</span> <span class="nav-text">code：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android代理模式-Binder"><span class="nav-number">3.2.7.5.</span> <span class="nav-text">Android代理模式-Binder</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-行为型设计模式"><span class="nav-number">3.3.</span> <span class="nav-text">三 行为型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-模板模式"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.1 模板模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-9"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用场景"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用-Activity-AsyncTask"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">Android应用-Activity/AsyncTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java应用："><span class="nav-number">3.3.1.4.</span> <span class="nav-text">Java应用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Code"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">Code:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-解释器模式"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.2 解释器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-10"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">Android应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-策略模式"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3 策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-11"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UML类图-2"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">UML类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#角色介绍-2"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">角色介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android源码对应实现"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">Android源码对应实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-状态模式"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.4 状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-12"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用-StateMachine机制"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">Android应用-StateMachine机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-观察者模式"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.5 观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-13"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实际应用"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">实际应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-JDK源码中的观察者模式"><span class="nav-number">3.3.5.3.</span> <span class="nav-text">1 JDK源码中的观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Android源码中的观察者模式"><span class="nav-number">3.3.5.4.</span> <span class="nav-text">2 Android源码中的观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-ListView源码中的观察者模式"><span class="nav-number">3.3.5.4.1.</span> <span class="nav-text">2.1 ListView源码中的观察者模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-RecyclerView中的观察者模式"><span class="nav-number">3.3.5.4.2.</span> <span class="nav-text">2.2 RecyclerView中的观察者模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-备忘录模式"><span class="nav-number">3.3.6.</span> <span class="nav-text">3.6 备忘录模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-14"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实际应用-1"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">实际应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk源码中应用"><span class="nav-number">3.3.6.3.</span> <span class="nav-text">jdk源码中应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-中介者模式"><span class="nav-number">3.3.7.</span> <span class="nav-text">3.7 中介者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-15"><span class="nav-number">3.3.7.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用-1"><span class="nav-number">3.3.7.2.</span> <span class="nav-text">Android应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-命令模式"><span class="nav-number">3.3.8.</span> <span class="nav-text">3.8 命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-16"><span class="nav-number">3.3.8.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android源码中的模式实现-1"><span class="nav-number">3.3.8.2.</span> <span class="nav-text">Android源码中的模式实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-访问者模式"><span class="nav-number">3.3.9.</span> <span class="nav-text">3.9 访问者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-17"><span class="nav-number">3.3.9.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android源码对应实现-1"><span class="nav-number">3.3.9.2.</span> <span class="nav-text">Android源码对应实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-责任链模式"><span class="nav-number">3.3.10.</span> <span class="nav-text">3.10 责任链模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模式定义-18"><span class="nav-number">3.3.10.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用-事件分发"><span class="nav-number">3.3.10.2.</span> <span class="nav-text">Android应用-事件分发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11-迭代器模式"><span class="nav-number">3.3.11.</span> <span class="nav-text">3.11 迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UML类图-3"><span class="nav-number">3.3.11.1.</span> <span class="nav-text">UML类图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#角色介绍-3"><span class="nav-number">3.3.11.2.</span> <span class="nav-text">角色介绍　　</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Android应用-2"><span class="nav-number">3.3.11.3.</span> <span class="nav-text">Android应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种模式关系"><span class="nav-number">3.4.</span> <span class="nav-text">三种模式关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1．创建型模式"><span class="nav-number">3.4.1.</span> <span class="nav-text">1．创建型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2．结构型模式"><span class="nav-number">3.4.2.</span> <span class="nav-text">2．结构型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3．行为型模式"><span class="nav-number">3.4.3.</span> <span class="nav-text">3．行为型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三者之间的区别和联系"><span class="nav-number">3.4.4.</span> <span class="nav-text">三者之间的区别和联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计原则"><span class="nav-number">3.5.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-源码中设计模式"><span class="nav-number">3.6.</span> <span class="nav-text">Android 源码中设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java设计模式-JDK中的应用"><span class="nav-number">3.7.</span> <span class="nav-text">Java设计模式:JDK中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建型模式-1"><span class="nav-number">3.7.1.</span> <span class="nav-text">创建型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构型模式-2"><span class="nav-number">3.7.2.</span> <span class="nav-text">结构型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行为型模式-2"><span class="nav-number">3.7.3.</span> <span class="nav-text">行为型模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">3.8.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fitz.Lee</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
