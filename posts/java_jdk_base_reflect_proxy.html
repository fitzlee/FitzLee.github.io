<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,jdk,reflect,proxy,anotation," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="JAVA反射 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。  反射机制是什么 面试有可能会问到，这句话不管你能不能理解，但是你只要记住就可以了  反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的">
<meta name="keywords" content="java,jdk,reflect,proxy,anotation">
<meta property="og:type" content="article">
<meta property="og:title" content="java reflect反射注解动态代理原理">
<meta property="og:url" content="https://fitzlee.github.io/posts/java_jdk_base_reflect_proxy.html">
<meta property="og:site_name" content="Fitz.Lee">
<meta property="og:description" content="JAVA反射 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。  反射机制是什么 面试有可能会问到，这句话不管你能不能理解，但是你只要记住就可以了  反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1637925-9ce9f69f8b7c26e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://images.cnitblog.com/blog/400827/201409/161325133151441.jpg">
<meta property="og:image" content="https://camo.githubusercontent.com/1fb49fef65877a7f80ad4622bf231f2b01804be3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f33303638392d353538343639393866346635623463652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/511e2eb42079b442554e0c20cdf8bb39fcd68bc5/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f33303638392d373766613462613334633461666536302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:updated_time" content="2018-07-27T18:27:20.679Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java reflect反射注解动态代理原理">
<meta name="twitter:description" content="JAVA反射 主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。  反射机制是什么 面试有可能会问到，这句话不管你能不能理解，但是你只要记住就可以了  反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1637925-9ce9f69f8b7c26e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fitzlee.github.io/posts/java_jdk_base_reflect_proxy.html"/>





  <title>java reflect反射注解动态代理原理 | Fitz.Lee</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fitz.Lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/resume/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fitzlee.github.io/posts/java_jdk_base_reflect_proxy.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fitz.Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fitz.Lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java reflect反射注解动态代理原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-27T18:27:20+00:00">
                2018-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/00Java-JDK/" itemprop="url" rel="index">
                    <span itemprop="name">00Java&JDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h1><blockquote>
<p>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
</blockquote>
<h2 id="反射机制是什么"><a href="#反射机制是什么" class="headerlink" title="反射机制是什么"></a>反射机制是什么</h2><blockquote>
<p>面试有可能会问到，这句话不管你能不能理解，但是你只要记住就可以了</p>
</blockquote>
<p>反射机制就是在运行状态中，<strong>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</strong>；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>用一句话总结就是反射可以实现在<strong>运行</strong>时可以知道<strong>任意一个类</strong>的<strong>属性和方法</strong>。</p>
<h2 id="反射机制能做什么"><a href="#反射机制能做什么" class="headerlink" title="反射机制能做什么"></a>反射机制能做什么</h2><p>反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成<a href="https://www.daidingkang.cc/2017/07/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener"><strong>动态代理</strong></a>(ps:这个知识点也很重要，后续会为大家讲到)</li>
</ul>
<h2 id="Java-反射机制的应用场景"><a href="#Java-反射机制的应用场景" class="headerlink" title="Java 反射机制的应用场景"></a>Java 反射机制的应用场景</h2><ul>
<li>逆向代码 ，例如反编译</li>
<li>与注解相结合的框架 例如Retrofit</li>
<li>单纯的反射机制应用框架 例如EventBus</li>
<li>动态生成类框架 例如Gson</li>
</ul>
<h2 id="反射机制的优点与缺点"><a href="#反射机制的优点与缺点" class="headerlink" title="反射机制的优点与缺点"></a>反射机制的优点与缺点</h2><p>为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象,即通过。</li>
<li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。</li>
</ul>
<p>优点</p>
<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</li>
</ul>
<p>缺点</p>
<ul>
<li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</li>
</ul>
<h2 id="理解Class类和类类型"><a href="#理解Class类和类类型" class="headerlink" title="理解Class类和类类型"></a>理解Class类和类类型</h2><p>想要了解反射首先理解一下Class类，它是反射实现的基础。<br>类是java.lang.Class类的实例对象，而Class是所有类的类（There is a class named Class）<br>对于普通的对象，我们一般都会这样创建和表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code code1 = new Code();</span><br></pre></td></tr></table></figure>
<p>上面说了，所有的类都是Class的对象，那么如何表示呢，可不可以通过如下方式呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = new Class();</span><br></pre></td></tr></table></figure>
<p>但是我们查看Class的源码时，是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private  Class(ClassLoader loader) &#123; </span><br><span class="line">    classLoader = loader; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，虽然我们不能new一个Class对象，但是却可以通过已有的类得到一个Class对象，共有三种方式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Code.class; 这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的</span><br><span class="line">Class c2 = code1.getClass(); code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的 </span><br><span class="line">Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;); 这种方法是Class类调用forName方法，通过一个类的全量限定名获得</span><br></pre></td></tr></table></figure>
<p>这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。<br>这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。</p>
<p>举个简单例子代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //第一种：Class c1 = Code.class;</span><br><span class="line">        Class class1=ReflectDemo.class;</span><br><span class="line">        System.out.println(class1.getName());</span><br><span class="line"></span><br><span class="line">        //第二种：Class c2 = code1.getClass();</span><br><span class="line">        ReflectDemo demo2= new ReflectDemo();</span><br><span class="line">        Class c2 = demo2.getClass();</span><br><span class="line">        System.out.println(c2.getName());</span><br><span class="line"></span><br><span class="line">        //第三种：Class c3 = Class.forName(&quot;com.trigl.reflect.Code&quot;);</span><br><span class="line">        Class class3 = Class.forName(&quot;com.tengj.reflect.ReflectDemo&quot;);</span><br><span class="line">        System.out.println(class3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br><span class="line">com.tengj.reflect.ReflectDemo</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="Java反射相关操作"><a href="#Java反射相关操作" class="headerlink" title="Java反射相关操作"></a>Java反射相关操作</h1><blockquote>
<p>在这里先看一下sun为我们提供了那些反射机制中的类：<br>java.lang.Class;<br>java.lang.reflect.Constructor; java.lang.reflect.Field;<br>java.lang.reflect.Method;<br>java.lang.reflect.Modifier;</p>
</blockquote>
<p>前面我们知道了怎么获取Class，那么我们可以通过这个Class干什么呢？<br>总结如下：</p>
<ul>
<li>获取成员方法Method</li>
<li>获取成员变量Field</li>
<li>获取构造函数Constructor</li>
</ul>
<p>下面来具体介绍</p>
<ol>
<li><h2 id="获取成员方法信息"><a href="#获取成员方法信息" class="headerlink" title="获取成员方法信息"></a>获取成员方法信息</h2><blockquote>
<p><strong>两个参数分别是方法名和方法参数类的类类型列表。</strong></p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的方法，不包括父类的 </span><br><span class="line">public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) // 得到该类所有的public方法，包括父类的</span><br><span class="line"></span><br><span class="line">//具体使用</span><br><span class="line">Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法 </span><br><span class="line">Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法 </span><br><span class="line">Method method = class1.getMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的public方法 </span><br><span class="line">Method declaredMethod = class1.getDeclaredMethod(&quot;info&quot;, String.class);//返回次Class对象对应类的、带指定形参列表的方法</span><br></pre></td></tr></table></figure>
<p><strong>举个例子：</strong></p>
<p>例如类A有如下一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void fun(String name,int age) &#123;</span><br><span class="line">        System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在知道A有一个对象a，那么就可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);  //先生成class</span><br><span class="line">Object o = c.newInstance();                           //newInstance可以初始化一个实例</span><br><span class="line">Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);//获取方法</span><br><span class="line">method.invoke(o, &quot;tengj&quot;, 10);                         //通过invoke调用该方法，参数第一个为实例对象，后面为具体参数值</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String msg=&quot;hello wrold&quot;;</span><br><span class="line"> public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">  System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void fun() &#123;</span><br><span class="line">        System.out.println(&quot;fun&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void fun(String name,int age) &#123;</span><br><span class="line">        System.out.println(&quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            Method method = c.getMethod(&quot;fun&quot;, String.class, int.class);</span><br><span class="line">            method.invoke(o, &quot;tengj&quot;, 10);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我叫tengj,今年10岁</span><br></pre></td></tr></table></figure>
<p>怎样，是不是感觉很厉害，我们只要知道这个类的路径全称就能玩弄它于鼓掌之间。</p>
<p>有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现：</p>
<p>1.获取所有方法的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的</span><br><span class="line">或者：</span><br><span class="line">Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的</span><br></pre></td></tr></table></figure>
<p>2.然后循环这个数组就得到每个方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Method method : methods)</span><br></pre></td></tr></table></figure>
<p>完整代码如下：<br>person类跟上面一样，这里以及后面就不贴出来了，只贴关键代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Method[] methods = c.getDeclaredMethods();</span><br><span class="line">            for(Method m:methods)&#123;</span><br><span class="line">                String  methodName= m.getName();</span><br><span class="line">                System.out.println(methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">getAge</span><br></pre></td></tr></table></figure>
<p>这里如果把c.getDeclaredMethods();改成c.getMethods();执行结果如下，多了很多方法，以为把Object里面的方法也打印出来了，因为Object是所有类的父类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getName</span><br><span class="line">setName</span><br><span class="line">getAge</span><br><span class="line">setAge</span><br><span class="line">fun</span><br><span class="line">fun</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">wait</span><br><span class="line">equals</span><br><span class="line">toString</span><br><span class="line">hashCode</span><br><span class="line">getClass</span><br><span class="line">notify</span><br><span class="line">notifyAll</span><br></pre></td></tr></table></figure>
<ol>
<li><h2 id="获取成员变量信息"><a href="#获取成员变量信息" class="headerlink" title="获取成员变量信息"></a>获取成员变量信息</h2></li>
</ol>
<p>想一想成员变量中都包括什么：<strong>成员变量类型+成员变量名</strong></p>
<p>类的成员变量也是一个对象，它是<code>java.lang.reflect.Field</code>的一个对象，所以我们通过<code>java.lang.reflect.Field</code>里面封装的方法来获取这些信息。</p>
<p>单独获取某个成员变量，通过Class类的以下方法实现：</p>
<blockquote>
<p><strong>参数是成员变量的名字</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量</span><br><span class="line">public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量</span><br><span class="line"></span><br><span class="line">//具体实现</span><br><span class="line">Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性 </span><br><span class="line">Field[] publicFields = class1.getFields();//获取class对象的public属性 </span><br><span class="line">Field ageField = class1.getDeclaredField(&quot;age&quot;);//获取class指定属性 </span><br><span class="line">Field desField = class1.getField(&quot;des&quot;);//获取class指定的public属性</span><br></pre></td></tr></table></figure>
<p><strong>举个例子：</strong></p>
<p>例如一个类A有如下成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private int n;</span><br></pre></td></tr></table></figure>
<p>如果A有一个对象a，那么就可以这样得到其成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = a.getClass();</span><br><span class="line">Field field = c.getDeclaredField(&quot;n&quot;);</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            //获取成员变量</span><br><span class="line">            Field field = c.getDeclaredField(&quot;msg&quot;); //因为msg变量是private的，所以不能用getField方法</span><br><span class="line">            Object o = c.newInstance();</span><br><span class="line">            field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问，如果msg是public的就不需要这行了。</span><br><span class="line">            Object msg = field.get(o);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello wrold</span><br></pre></td></tr></table></figure>
<p>同样，如果想要获取所有成员变量的信息，可以通过以下几步</p>
<p>1.获取所有成员变量的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c.getDeclaredFields();</span><br></pre></td></tr></table></figure>
<p>2.遍历变量数组，获得某个成员变量field</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Field field : fields)</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            Field[] fields = c.getDeclaredFields();</span><br><span class="line">            for(Field field :fields)&#123;</span><br><span class="line">                System.out.println(field.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br><span class="line">msg</span><br></pre></td></tr></table></figure>
<ol>
<li><h2 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h2></li>
</ol>
<p>最后再想一想构造函数中都包括什么：<code>构造函数参数</code><br>同上，类的成构造函数也是一个对象，它是<code>java.lang.reflect.Constructor</code>的一个对象，所以我们通过<code>java.lang.reflect.Constructor</code>里面封装的方法来获取这些信息。</p>
<p>单独获取某个构造函数,通过<code>Class</code>类的以下方法实现：</p>
<blockquote>
<p><strong>这个参数为构造函数参数类的类类型列表</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) //  获得该类所有的构造器，不包括其父类的构造器</span><br><span class="line">public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) // 获得该类所以public构造器，包括父类</span><br><span class="line"></span><br><span class="line">//具体</span><br><span class="line">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数 </span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数 </span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数 </span><br><span class="line">Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数</span><br></pre></td></tr></table></figure>
<p><strong>举个例子：</strong></p>
<p>例如类A有如下一个构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public A(String a, int b) &#123;</span><br><span class="line">    // code body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就可以通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = a.getDeclaredConstructor(String.class, int.class);</span><br></pre></td></tr></table></figure>
<p>来获取这个构造函数。</p>
<p>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.tengj.reflect.Person&quot;);</span><br><span class="line">            //获取构造函数</span><br><span class="line">            Constructor constructor = c.getDeclaredConstructor(String.class);</span><br><span class="line">            constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问，如果构造器是public的就不需要这行了。</span><br><span class="line">            constructor.newInstance(&quot;tengj&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tengj</span><br></pre></td></tr></table></figure>
<p>注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，如果某类只有带参数的构造函数，那么就要使用另外一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromClass.getDeclaredConstructor(String.class).newInstance(&quot;tengj&quot;);</span><br></pre></td></tr></table></figure>
<p>获取所有的构造函数，可以通过以下步骤实现：</p>
<p>1.获取该类的所有构造函数，放在一个数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor[] constructors = c.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>
<p>2.遍历构造函数数组，获得某个构造函数<code>constructor</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (Constructor constructor : constructors)</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">            Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">            for(Constructor constructor:constructors)&#123;</span><br><span class="line">                System.out.println(constructor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public com.tengj.reflect.Person()</span><br><span class="line">public com.tengj.reflect.Person(java.lang.String)</span><br></pre></td></tr></table></figure>
<ol>
<li><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2></li>
</ol>
<p>注解需要用到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解 </span><br><span class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解 </span><br><span class="line">Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 </span><br><span class="line">Type Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合</span><br></pre></td></tr></table></figure>
<p>获取class对象的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型 </span><br><span class="line">boolean isArray = class1.isArray();//判断是否是集合类</span><br><span class="line"> boolean isAnnotation = class1.isAnnotation();//判断是否是注解类 </span><br><span class="line">boolean isInterface = class1.isInterface();//判断是否是接口类 </span><br><span class="line">boolean isEnum = class1.isEnum();//判断是否是枚举类 </span><br><span class="line">boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类 </span><br><span class="line">boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰 </span><br><span class="line">String className = class1.getName();//获取class名字 包含包名路径 </span><br><span class="line">Package aPackage = class1.getPackage();//获取class的包信息 </span><br><span class="line">String simpleName = class1.getSimpleName();//获取class类名 </span><br><span class="line">int modifiers = class1.getModifiers();//获取class访问权限 </span><br><span class="line">Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类 </span><br><span class="line">Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类</span><br><span class="line"></span><br><span class="line">getSuperclass()：获取某类的父类  </span><br><span class="line">getInterfaces()：获取某类实现的接口</span><br></pre></td></tr></table></figure>
<h2 id="通过反射了解集合泛型的本质"><a href="#通过反射了解集合泛型的本质" class="headerlink" title="通过反射了解集合泛型的本质"></a>通过反射了解集合泛型的本质</h2><blockquote>
<p>扩展的知识点，了解就可以了。后续会为大家写一篇关于泛型的文章。</p>
</blockquote>
<p>首先下结论：</p>
<blockquote>
<p><strong>Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。</strong></p>
</blockquote>
<p>下面通过一个实例来验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 集合泛型的本质</span><br><span class="line"> */</span><br><span class="line">public class GenericEssence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list1 = new ArrayList(); // 没有泛型 </span><br><span class="line">        List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); // 有泛型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 1.首先观察正常添加元素方式，在编译器检查泛型，</span><br><span class="line">         * 这个时候如果list2添加int类型会报错</span><br><span class="line">         */</span><br><span class="line">        list2.add(&quot;hello&quot;);</span><br><span class="line">//      list2.add(20); // 报错！list2有泛型限制，只能添加String，添加int报错</span><br><span class="line">        System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 此时list2长度为1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 2.然后通过反射添加元素方式，在运行期动态加载类，首先得到list1和list2</span><br><span class="line">         * 的类类型相同，然后再通过方法反射绕过编译器来调用add方法，看能否插入int</span><br><span class="line">         * 型的元素</span><br><span class="line">         */</span><br><span class="line">        Class c1 = list1.getClass();</span><br><span class="line">        Class c2 = list2.getClass();</span><br><span class="line">        System.out.println(c1 == c2); // 结果：true，说明类类型完全相同</span><br><span class="line"></span><br><span class="line">        // 验证：我们可以通过方法的反射来给list2添加元素，这样可以绕过编译检查</span><br><span class="line">        try &#123;</span><br><span class="line">            Method m = c2.getMethod(&quot;add&quot;, Object.class); // 通过方法反射得到add方法</span><br><span class="line">            m.invoke(list2, 20); // 给list2添加一个int型的，上面显示在编译器是会报错的</span><br><span class="line">            System.out.println(&quot;list2的长度是：&quot; + list2.size()); // 结果：2，说明list2长度增加了，并没有泛型检查</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 综上可以看出，在编译器的时候，泛型会限制集合内元素类型保持一致，但是编译器结束进入</span><br><span class="line">         * 运行期以后，泛型就不再起作用了，即使是不同类型的元素也可以插入集合。</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list2的长度是：1</span><br><span class="line">true</span><br><span class="line">list2的长度是：2</span><br></pre></td></tr></table></figure>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><blockquote>
<p>有助于理解上述所讲的知识点</p>
</blockquote>
<p><a href="http://upload-images.jianshu.io/upload_images/1637925-9ce9f69f8b7c26e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/1637925-9ce9f69f8b7c26e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p>
<p>拓展阅读<br><a href="http://www.cnblogs.com/hxsyl/archive/2013/03/23/2977593.html" target="_blank" rel="noopener">Java反射机制深入详解 - 火星十一郎 - 博客园</a><br><a href="http://blog.csdn.net/trigl/article/details/51042403" target="_blank" rel="noopener">Java反射入门 - Trigl的博客 - CSDN博客</a><br><a href="http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html" target="_blank" rel="noopener">Java反射机制 - ①块腹肌 - 博客园</a><br><a href="http://www.cnblogs.com/gulvzhe/archive/2012/01/27/2330001.html" target="_blank" rel="noopener">Java 反射机制浅析 - 孤旅者 - 博客园</a><br><a href="http://uule.iteye.com/blog/1423512" target="_blank" rel="noopener">反射机制的理解及其用途 - 每天进步一点点！ - ITeye博客</a><br><a href="http://www.cnblogs.com/haodawang/p/5967185.html" target="_blank" rel="noopener">Java动态代理与反射详解 - 浩大王 - 博客园</a></p>
<h1 id="JAVA注解"><a href="#JAVA注解" class="headerlink" title="JAVA注解"></a>JAVA注解</h1><h2 id="概念及作用"><a href="#概念及作用" class="headerlink" title="概念及作用"></a>概念及作用</h2><ol>
<li>概念</li>
</ol>
<ul>
<li>注解即元数据,就是源代码的元数据</li>
<li>注解在代码中添加信息提供了一种形式化的方法,可以在后续中更方便的 使用这些数据</li>
<li>Annotation是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具。</li>
</ul>
<ol>
<li>作用</li>
</ol>
<ul>
<li>生成文档</li>
<li>跟踪代码依赖性，实现替代配置文件功能,减少配置。如Spring中的一些注解</li>
<li>在编译时进行格式检查，如@Override等</li>
<li>每当你创建描述符性质的类或者接口时,一旦其中包含重复性的工作，就可以考虑使用注解来简化与自动化该过程。</li>
</ul>
<h2 id="什么是java注解？"><a href="#什么是java注解？" class="headerlink" title="什么是java注解？"></a>什么是java注解？</h2><p>在java语法中，使用<code>@</code>符号作为开头，并在@后面紧跟注解名。被运用于类，接口，方法和字段之上，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void myMethod() &#123; </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中@Override就是注解。这个注解的作用也就是告诉编译器，myMethod()方法覆写了父类中的myMethod()方法。</p>
<h2 id="java中内置的注解"><a href="#java中内置的注解" class="headerlink" title="java中内置的注解"></a>java中内置的注解</h2><p>java中有三个内置的注解：</p>
<ul>
<li><p><strong>@Override:</strong>表示当前的方法定义将覆盖超类中的方法，如果出现错误，编译器就会报错。</p>
</li>
<li><p><strong>@Deprecated:</strong>如果使用此注解，编译器会出现警告信息。</p>
</li>
<li><p><strong>@SuppressWarnings:</strong>忽略编译器的警告信息。</p>
</li>
</ul>
<p>本文不在阐述三种内置注解的使用情节和方法，感兴趣的请看<a href="http://www.jianshu.com/p/89c07ce0c99c" target="_blank" rel="noopener">这里</a></p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><blockquote>
<p>自定义注解的时候用到的，也就是自定义<strong>注解的注解</strong>；（这句话我自己说的，不知道对不对）</p>
</blockquote>
<p>元注解的作用就是负责注解其他注解。<code>Java5.0</code>定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p>
<h3 id="Java5-0定义的4个元注解："><a href="#Java5-0定义的4个元注解：" class="headerlink" title="Java5.0定义的4个元注解："></a><code>Java5.0</code>定义的4个元注解：</h3><ol>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ol>
<blockquote>
<p>java8加了两个新注解，后续我会讲到。</p>
</blockquote>
<p>这些类型和它们所支持的类在java.lang.annotation包中可以找到。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><blockquote>
<p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p>
</blockquote>
<p><strong>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p>
<p><strong>取值(ElementType)有：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTRUCTOR</td>
<td>用于描述构造器</td>
</tr>
<tr>
<td>FIELD</td>
<td>用于描述域</td>
</tr>
<tr>
<td>LOCAL_VARIABLE</td>
<td>用于描述局部变量</td>
</tr>
<tr>
<td>METHOD</td>
<td>用于描述方法</td>
</tr>
<tr>
<td>PACKAGE</td>
<td>用于描述包</td>
</tr>
<tr>
<td>PARAMETER</td>
<td>用于描述参数</td>
</tr>
<tr>
<td>TYPE</td>
<td>用于描述类、接口(包括注解类型) 或enum声明</td>
</tr>
</tbody>
</table>
<p>比如说这个注解表示只能在方法中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface MyCustomAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">   @MyCustomAnnotation</span><br><span class="line">   public void myMethod()</span><br><span class="line">   &#123;</span><br><span class="line">    ......</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><blockquote>
<p>@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p>
</blockquote>
<p><strong>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</strong></p>
<p><strong>取值（RetentionPoicy）有：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SOURCE</td>
<td>在源文件中有效（即源文件保留）</td>
<td>仅出现在源代码中，而被编译器丢弃</td>
</tr>
<tr>
<td>CLASS</td>
<td>在class文件中有效（即class保留）</td>
<td>被编译在class文件中</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>在运行时有效（即运行时保留）</td>
<td>编译在class文件中</td>
</tr>
</tbody>
</table>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line"> * 字段注解接口</span><br><span class="line"> */</span><br><span class="line">@Target(value = &#123;ElementType.FIELD&#125;)//注解可以被添加在属性上</span><br><span class="line">@Retention(value = RetentionPolicy.RUNTIME)//注解保存在JVM运行时刻,能够在运行时刻通过反射API来获取到注解的信息</span><br><span class="line">public @interface Column &#123;</span><br><span class="line">    String name();//注解的name属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><blockquote>
<p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
</blockquote>
<p><strong>作用：将注解包含在javadoc中</strong></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.annotation.Documented</span><br><span class="line">@Documented</span><br><span class="line">public @interface MyCustomAnnotation &#123; //Annotation body&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><ul>
<li><p>是一个标记注解</p>
</li>
<li><p>阐述了某个被标注的类型是被继承的</p>
</li>
<li><p>使用了@Inherited修饰的annotation类型被用于一个class,则这个annotation将被用于该class的子类<br>@Inherited annotation类型是被标注过的class的子类所继承。类并不从实现的接口继承annotation,方法不从它所重载的方法继承annotation</p>
</li>
<li><p>当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
</li>
</ul>
<p><strong>作用：允许子类继承父类中的注解</strong></p>
<p>示例，这里的MyParentClass 使用的注解标注了@Inherited，所以子类可以继承这个注解信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.annotation.Inherited</span><br><span class="line">@Inherited</span><br><span class="line">public @interface MyCustomAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@MyCustomAnnotation</span><br><span class="line">public class MyParentClass &#123; </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MyChildClass extends MyParentClass &#123; </span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface 注解名&#123;</span><br><span class="line">  定义体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解参数的可支持数据类型"><a href="#注解参数的可支持数据类型" class="headerlink" title="注解参数的可支持数据类型:"></a>注解参数的可支持数据类型:</h3><ul>
<li>所有基本数据类型(int,float,double,boolean,byte,char,long,short)</li>
<li>String 类型</li>
<li>Class类型</li>
<li>enum类型</li>
<li>Annotation类型</li>
<li>以上所有类型的数组</li>
</ul>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>修饰符只能是public 或默认(default)</li>
<li>参数成员只能用基本类型byte,short,int,long,float,double,boolean八种基本类型和String,Enum,Class,annotations及这些类型的数组</li>
<li>如果只有一个参数成员,最好将名称设为”value”</li>
<li>注解元素必须有确定的值,可以在注解中定义默认值,也可以使用注解时指定,非基本类型的值不可为null,常使用空字符串或0作默认值</li>
<li>在表现一个元素存在或缺失的状态时,定义一下特殊值来表示,如空字符串或负值</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * test注解</span><br><span class="line"> * @author ddk</span><br><span class="line"> *</span><br><span class="line"> */ </span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface TestAnnotation &#123;</span><br><span class="line">    /**</span><br><span class="line">     * id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int id() default -1;</span><br><span class="line">    /**</span><br><span class="line">     * name</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String name() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解处理器类库"><a href="#注解处理器类库" class="headerlink" title="注解处理器类库"></a>注解处理器类库</h2><blockquote>
<p>java.lang.reflect.AnnotatedElement</p>
</blockquote>
<p>Java使用Annotation接口来代表程序元素前面的注解，该接口是所有Annotation类型的父接口。除此之外，Java在java.lang.reflect 包下新增了AnnotatedElement接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p>
<ul>
<li>　Class：类定义</li>
<li>　Constructor：构造器定义</li>
<li>　Field：累的成员变量定义</li>
<li>　Method：类的方法定义</li>
<li>　Package：类的包定义</li>
</ul>
<p>java.lang.reflect 包下主要包含一些实现反射功能的工具类，实际上，java.lang.reflect 包所有提供的反射API扩充了读取运行时Annotation信息的能力。当一个Annotation类型被定义为运行时的Annotation后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p>
<ul>
<li>方法1： T getAnnotation(Class annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</li>
<li>方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</li>
<li>方法3：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</li>
<li>方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<h3 id="注解处理器示例"><a href="#注解处理器示例" class="headerlink" title="注解处理器示例:"></a>注解处理器示例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">/***********注解声明***************/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 水果名称注解</span><br><span class="line"> * @author peida</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FruitName &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 水果颜色注解</span><br><span class="line"> * @author peida</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FruitColor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 颜色枚举</span><br><span class="line">     * @author peida</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public enum Color&#123; BULE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 颜色属性</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Color fruitColor() default Color.GREEN;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 水果供应者注解</span><br><span class="line"> * @author peida</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FruitProvider &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 供应商编号</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public int id() default -1;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 供应商名称</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String name() default &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 供应商地址</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String address() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***********注解使用***************/</span><br><span class="line"></span><br><span class="line">public class Apple &#123;</span><br><span class="line">    </span><br><span class="line">    @FruitName(&quot;Apple&quot;)</span><br><span class="line">    private String appleName;</span><br><span class="line">    </span><br><span class="line">    @FruitColor(fruitColor=Color.RED)</span><br><span class="line">    private String appleColor;</span><br><span class="line">    </span><br><span class="line">    @FruitProvider(id=1,name=&quot;陕西红富士集团&quot;,address=&quot;陕西省西安市延安路89号红富士大厦&quot;)</span><br><span class="line">    private String appleProvider;</span><br><span class="line">    </span><br><span class="line">    public void setAppleColor(String appleColor) &#123;</span><br><span class="line">        this.appleColor = appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleColor() &#123;</span><br><span class="line">        return appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAppleName(String appleName) &#123;</span><br><span class="line">        this.appleName = appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleName() &#123;</span><br><span class="line">        return appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAppleProvider(String appleProvider) &#123;</span><br><span class="line">        this.appleProvider = appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleProvider() &#123;</span><br><span class="line">        return appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void displayName()&#123;</span><br><span class="line">        System.out.println(&quot;水果的名字是：苹果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***********注解处理器***************/</span><br><span class="line">//其实是用的反射</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FruitInfoUtil &#123;</span><br><span class="line">    public static void getFruitInfo(Class&lt;?&gt; clazz)&#123;</span><br><span class="line">        </span><br><span class="line">        String strFruitName=&quot; 水果名称：&quot;;</span><br><span class="line">        String strFruitColor=&quot; 水果颜色：&quot;;</span><br><span class="line">        String strFruitProvicer=&quot;供应商信息：&quot;;</span><br><span class="line">        </span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        </span><br><span class="line">        for(Field field :fields)&#123;</span><br><span class="line">            if(field.isAnnotationPresent(FruitName.class))&#123;</span><br><span class="line">                FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);</span><br><span class="line">                strFruitName=strFruitName+fruitName.value();</span><br><span class="line">                System.out.println(strFruitName);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(field.isAnnotationPresent(FruitColor.class))&#123;</span><br><span class="line">                FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor.class);</span><br><span class="line">                strFruitColor=strFruitColor+fruitColor.fruitColor().toString();</span><br><span class="line">                System.out.println(strFruitColor);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(field.isAnnotationPresent(FruitProvider.class))&#123;</span><br><span class="line">                FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider.class);</span><br><span class="line">                strFruitProvicer=&quot; 供应商编号：&quot;+fruitProvider.id()+&quot; 供应商名称：&quot;+fruitProvider.name()+&quot; 供应商地址：&quot;+fruitProvider.address();</span><br><span class="line">                System.out.println(strFruitProvicer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***********输出结果***************/</span><br><span class="line">public class FruitRun &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        FruitInfoUtil.getFruitInfo(Apple.class);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">====================================</span><br><span class="line"> 水果名称：Apple</span><br><span class="line"> 水果颜色：RED</span><br><span class="line"> 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦</span><br></pre></td></tr></table></figure>
<h2 id="Java-8-中注解新特性"><a href="#Java-8-中注解新特性" class="headerlink" title="Java 8 中注解新特性"></a>Java 8 中注解新特性</h2><ul>
<li><p>@Repeatable 元注解,表示被修饰的注解可以用在同一个声明式或者类型加上多个相同的注解（包含不同的属性值）</p>
</li>
<li><p>@Native 元注解,本地方法</p>
</li>
<li><p>java8 中Annotation 可以被用在任何使用 Type 的地方</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> //初始化对象时</span><br><span class="line">String myString = new @NotNull String();</span><br><span class="line">//对象类型转化时</span><br><span class="line">myString = (@NonNull String) str;</span><br><span class="line">//使用 implements 表达式时</span><br><span class="line">class MyList&lt;T&gt; implements @ReadOnly List&lt;@ReadOnly T&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">//使用 throws 表达式时</span><br><span class="line">public void validateValues() throws @Critical ValidationFailedException&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h2><p><a href="http://images.cnitblog.com/blog/400827/201409/161325133151441.jpg" target="_blank" rel="noopener"><img src="http://images.cnitblog.com/blog/400827/201409/161325133151441.jpg" alt="img"></a></p>
<h1 id="动态代理Java-Proxy和CGLIB"><a href="#动态代理Java-Proxy和CGLIB" class="headerlink" title="动态代理Java Proxy和CGLIB"></a>动态代理Java Proxy和CGLIB</h1><p>动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。静态代理的代理关系在编译时就确定了，而动态代理的代理关系是在编译期确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性。今天我们来探讨Java中两种常见的动态代理方式：<strong>JDK原生动态代理和CGLIB动态代理</strong>。</p>
<h2 id="JDK原生动态代理"><a href="#JDK原生动态代理" class="headerlink" title="JDK原生动态代理"></a>JDK原生动态代理</h2><p>先从直观的示例说起，假设我们有一个接口<code>Hello</code>和一个简单实现<code>HelloImp</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 接口</span><br><span class="line">interface Hello&#123;</span><br><span class="line">    String sayHello(String str);</span><br><span class="line">&#125;</span><br><span class="line">// 实现</span><br><span class="line">class HelloImp implements Hello&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String str) &#123;</span><br><span class="line">        return &quot;HelloImp: &quot; + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是Java种再常见不过的场景，使用接口制定协议，然后用不同的实现来实现具体行为。假设你已经拿到上述类库，如果我们想通过日志记录对<code>sayHello()</code>的调用，使用静态代理可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 静态代理方式</span><br><span class="line">class StaticProxiedHello implements Hello&#123;</span><br><span class="line">    ...</span><br><span class="line">    private Hello hello = new HelloImp();</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String str) &#123;</span><br><span class="line">        logger.info(&quot;You said: &quot; + str);</span><br><span class="line">        return hello.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中静态代理类<code>StaticProxiedHello</code>作为<code>HelloImp</code>的代理，实现了相同的<code>Hello</code>接口。用Java动态代理可以这样做：</p>
<ol>
<li>首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。</li>
<li>然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Java Proxy</span><br><span class="line">// 1. 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。</span><br><span class="line">class LogInvocationHandler implements InvocationHandler&#123;</span><br><span class="line">    ...</span><br><span class="line">    private Hello hello;</span><br><span class="line">    public LogInvocationHandler(Hello hello) &#123;</span><br><span class="line">        this.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        if(&quot;sayHello&quot;.equals(method.getName())) &#123;</span><br><span class="line">            logger.info(&quot;You said: &quot; + Arrays.toString(args));</span><br><span class="line">        &#125;</span><br><span class="line">        return method.invoke(hello, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 2. 然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。</span><br><span class="line">Hello hello = (Hello)Proxy.newProxyInstance(</span><br><span class="line">    getClass().getClassLoader(), // 1. 类加载器</span><br><span class="line">    new Class&lt;?&gt;[] &#123;Hello.class&#125;, // 2. 代理需要实现的接口，可以有多个</span><br><span class="line">    new LogInvocationHandler(new HelloImp()));// 3. 方法调用的实际处理者</span><br><span class="line">System.out.println(hello.sayHello(&quot;I love you!&quot;));</span><br></pre></td></tr></table></figure>
<p>运行上述代码输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日志信息: You said: [I love you!]</span><br><span class="line">HelloImp: I love you!</span><br></pre></td></tr></table></figure>
<p>上述代码的关键是<code>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler)</code>方法，该方法会根据指定的参数动态创建代理对象。三个参数的意义如下：</p>
<ol>
<li><code>loader</code>，指定代理对象的类加载器；</li>
<li><code>interfaces</code>，代理对象需要实现的接口，可以同时指定多个接口；</li>
<li><code>handler</code>，方法调用的实际处理者，代理对象的方法调用都会转发到这里（*注意1）。</li>
</ol>
<p><code>newProxyInstance()</code>会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给<code>InvocationHandler.invoke()</code>方法。理解上述代码需要对Java反射机制有一定了解。动态代理神奇的地方就是：</p>
<ol>
<li>代理对象是在程序运行时产生的，而不是编译期；</li>
<li><strong>对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法</strong>，在<code>invoke()</code>方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体，示例中通过反射调用了Hello对象的相应方法，还可以通过RPC调用远程方法。</li>
</ol>
<blockquote>
<p>注意1：对于从Object中继承的方法，JDK Proxy会把<code>hashCode()</code>、<code>equals()</code>、<code>toString()</code>这三个非接口方法转发给<code>InvocationHandler</code>，其余的Object方法则不会转发。详见<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="noopener">JDK Proxy官方文档</a>。</p>
</blockquote>
<p>如果对JDK代理后的对象类型进行深挖，可以看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Hello代理对象的类型信息</span><br><span class="line">class=class jdkproxy.$Proxy0</span><br><span class="line">superClass=class java.lang.reflect.Proxy</span><br><span class="line">interfaces: </span><br><span class="line">interface jdkproxy.Hello</span><br><span class="line">invocationHandler=jdkproxy.LogInvocationHandler@a09ee92</span><br></pre></td></tr></table></figure>
<p>代理对象的类型是<code>jdkproxy.$Proxy0</code>，这是个动态生成的类型，类名是形如$ProxyN的形式；父类是<code>java.lang.reflect.Proxy</code>，所有的JDK动态代理都会继承这个类；同时实现了<code>Hello</code>接口，也就是我们接口列表中指定的那些接口。</p>
<p>如果你还对<code>jdkproxy.$Proxy0</code>具体实现感兴趣，它大致长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// JDK代理类具体实现</span><br><span class="line">public final class $Proxy0 extends Proxy implements Hello</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  public $Proxy0(InvocationHandler invocationhandler)</span><br><span class="line">  &#123;</span><br><span class="line">    super(invocationhandler);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  @Override</span><br><span class="line">  public final String sayHello(String str)&#123;</span><br><span class="line">    ...</span><br><span class="line">    return super.h.invoke(this, m3, new Object[] &#123;str&#125;);// 将方法调用转发给invocationhandler</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。更多详情，可参考BrightLoong的<a href="https://www.jianshu.com/p/e2917b0b9614" target="_blank" rel="noopener">Java静态代理&amp;动态代理笔记</a></p>
<p>Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？CGLIB登场。</p>
<h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。</p>
<p>来看示例，假设我们有一个没有实现任何接口的类<code>HelloConcrete</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloConcrete &#123;</span><br><span class="line">    public String sayHello(String str) &#123;</span><br><span class="line">        return &quot;HelloConcrete: &quot; + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为没有实现接口该类无法使用JDK代理，通过CGLIB代理实现如下：</p>
<ol>
<li>首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li>
<li>然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CGLIB动态代理</span><br><span class="line">// 1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</span><br><span class="line">class MyMethodInterceptor implements MethodInterceptor&#123;</span><br><span class="line">  ...</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        logger.info(&quot;You said: &quot; + Arrays.toString(args));</span><br><span class="line">        return proxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 2. 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。</span><br><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloConcrete.class);</span><br><span class="line">enhancer.setCallback(new MyMethodInterceptor());</span><br><span class="line"></span><br><span class="line">HelloConcrete hello = (HelloConcrete)enhancer.create();</span><br><span class="line">System.out.println(hello.sayHello(&quot;I love you!&quot;));</span><br></pre></td></tr></table></figure>
<p>运行上述代码输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日志信息: You said: [I love you!]</span><br><span class="line">HelloConcrete: I love you!</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们通过CGLIB的<code>Enhancer</code>来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用<code>create()</code>方法得到代理对象，<strong>对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法</strong>，在<code>intercept()</code>方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用<code>MethodProxy.invokeSuper()</code>方法，我们将调用转发给原始对象，具体到本例，就是<code>HelloConcrete</code>的具体方法。CGLIG中<a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/MethodInterceptor.html" target="_blank" rel="noopener">MethodInterceptor</a>的作用跟JDK代理中的<code>InvocationHandler</code>很类似，都是方法调用的中转站。</p>
<blockquote>
<p>注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如<code>hashCode()</code>、<code>equals()</code>、<code>toString()</code>等，但是<code>getClass()</code>、<code>wait()</code>等方法不会，因为它是final方法，CGLIB无法代理。</p>
</blockquote>
<p>如果对CGLIB代理之后的对象类型进行深挖，可以看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># HelloConcrete代理对象的类型信息</span><br><span class="line">class=class cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52</span><br><span class="line">superClass=class lh.HelloConcrete</span><br><span class="line">interfaces: </span><br><span class="line">interface net.sf.cglib.proxy.Factory</span><br><span class="line">invocationHandler=not java proxy class</span><br></pre></td></tr></table></figure>
<p>我们看到使用CGLIB代理之后的对象类型是<code>cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52</code>，这是CGLIB动态生成的类型；父类是<code>HelloConcrete</code>，印证了CGLIB是通过继承实现代理；同时实现了<code>net.sf.cglib.proxy.Factory</code>接口，这个接口是CGLIB自己加入的，包含一些工具方法。</p>
<p>注意，既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出类似如下异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete</span><br></pre></td></tr></table></figure>
<p>同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。</p>
<p>如果你还对代理类<code>cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52</code>具体实现感兴趣，它大致长这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// CGLIB代理类具体实现</span><br><span class="line">public class HelloConcrete$$EnhancerByCGLIB$$e3734e52</span><br><span class="line">  extends HelloConcrete</span><br><span class="line">  implements Factory</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  private MethodInterceptor CGLIB$CALLBACK_0; // ~~</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  public final String sayHello(String paramString)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp17_14 != null) &#123;</span><br><span class="line">      // 将请求转发给MethodInterceptor.intercept()方法。</span><br><span class="line">      return (String)tmp17_14.intercept(this, </span><br><span class="line">              CGLIB$sayHello$0$Method, </span><br><span class="line">              new Object[] &#123; paramString &#125;, </span><br><span class="line">              CGLIB$sayHello$0$Proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.sayHello(paramString);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我们看到，当调用代理对象的<code>sayHello()</code>方法时，首先会尝试转发给<code>MethodInterceptor.intercept()</code>方法，如果没有<code>MethodInterceptor</code>就执行父类的<code>sayHello()</code>。这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。如何获取CGLIB代理类字节码可参考<a href="https://github.com/cglib/cglib/wiki/How-To#access-the-generated-byte-array-directly" target="_blank" rel="noopener">Access the generated byte[] array directly</a>。</p>
<p>更多关于CGLIB的介绍可以参考Rafael Winterhalter的<a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">cglib: The missing manual</a>，一篇很深入的文章。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了Java两种常见动态代理机制的用法和原理，JDK原生动态代理是Java原生支持的，不需要任何外部依赖，但是它只能基于接口进行代理；CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，但是无法处理final的情况。</p>
<p>动态代理是<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop" target="_blank" rel="noopener">Spring AOP</a>(<em>Aspect Orient Programming, 面向切面编程</em>)的实现方式，了解动态代理原理，对理解Spring AOP大有帮助。</p>
<p>参考：<a href="http://www.cnblogs.com/CarpenterLee/p/8241042.html" target="_blank" rel="noopener">http://www.cnblogs.com/CarpenterLee/p/8241042.html</a></p>
<h1 id="Android依赖注入-ioc"><a href="#Android依赖注入-ioc" class="headerlink" title="Android依赖注入 ioc"></a>Android依赖注入 ioc</h1><p>基本思想 = 配置文件 + factory实例</p>
<p><a href="https://www.cnblogs.com/Eason-S/p/5851078.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eason-S/p/5851078.html</a></p>
<p>IOC(Inversion of control):控制反转,依赖注入</p>
<p>概念:控制权有对象本身专享容器,由容器根据配置文件去创建实例,并创建各个实例之间的关系,则通俗的说，对象的创建再也不需要程序员来管理,而是可以有spring容器来进行创建和销毁,我们只需要关注业务逻辑.</p>
<p>依赖IOC容器并管理bean,有两种,一种是BeanFactory,另一种是ApplicationContext,但是APPlicationContext extends BeanFactory.</p>
<p>核心:Spring中,bean工厂创建的各个实例称作bean.</p>
<p>通过 @Inject 注解了构造函数之后，在 Activity 中的 Boss 属性声明之前也添加 @Inject 注解。像这种在属性前添加的 @Inject 注解的目的是告诉 Dagger 哪些属性需要被注入。</p>
<p>public class MainActivity extends Activity {</p>
<pre><code>@Inject Boss boss;

...
</code></pre><p>}</p>
<p>最后，我们在合适的位置(例如 onCreate() 函数中)调用 ObjectGraph.inject() 函数，Dagger 就会自动调用上面 (1) 中的生成方法生成依赖的实例，并注入到当前对象(MainActivity)。</p>
<p>public class MainActivity extends Activity {</p>
<pre><code>@Inject Boss boss;





@Override

protected void onCreate(Bundle savedInstanceState) {

    ObjectGraph.create(AppModule.class).inject(this);

}

...
</code></pre><p>}</p>
<p>具体怎么注入即设置的过程后面会详细介绍，这里简单透露下，APT 会在 MainActivity 所在 package 下生成一个辅助类 MainActivity$$InjectAdapter，这个类有个 injectMembers() 函数，代码类似：</p>
<p>public void injectMembers(MainActivity paramMainActivity) {</p>
<pre><code>paramMainActivity.boss = ((Boss)boss.get());

……
</code></pre><p>}</p>
<p>上面我们已经通过 ObjectGraph.inject() 函数传入了 paramMainActivity，并且 boss 属性是 package 权限，所以 Dagger 只需要调用这个辅助类的 injectMembers() 函数即可完成依赖注入，这里的 boss.get() 会调用 Boss 的生成函数。</p>
<p>到此为止，使用 Dagger 的 @Inject 方式将一个 Boss 对象注入到 MainActivity 的流程就完成了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Human &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Inject Father father;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Human() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public class Human &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Father father;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Human() &#123;</span><br><span class="line"></span><br><span class="line">        father = new Father();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另可以参考</strong>：<a href="https://blog.csdn.net/lmj623565791/article/details/39269193" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/39269193</a></p>
<h1 id="Spring依赖注入原理分析"><a href="#Spring依赖注入原理分析" class="headerlink" title="Spring依赖注入原理分析"></a>Spring依赖注入原理分析</h1><p>2015年07月18日 23:55:58</p>
<p>阅读数：1817</p>
<p>我们知道Spring的依赖注入有四种方式，分别是get/set方法注入、构造器注入、静态工厂方法注入、实例工厂方法注入<br>下面我们先分析下这几种注入方式<br><strong>1、get/set方法注入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SpringAction &#123;</span><br><span class="line">        //注入对象springDao</span><br><span class="line">    private SpringDao springDao;</span><br><span class="line">        //一定要写被注入对象的set方法</span><br><span class="line">        public void setSpringDao(SpringDao springDao) &#123;</span><br><span class="line">        this.springDao = springDao;</span><br><span class="line">    &#125;</span><br><span class="line">        public void ok()&#123;</span><br><span class="line">        springDao.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011</span><br></pre></td></tr></table></figure>
<p>配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置bean,配置后该类由spring管理--&gt;</span><br><span class="line">    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;</span><br><span class="line">        &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt;</span><br><span class="line">        &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt;123456</span><br></pre></td></tr></table></figure>
<p><strong>2、构造器注入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpringAction &#123;</span><br><span class="line">    //注入对象springDao</span><br><span class="line">    private SpringDao springDao;</span><br><span class="line">    private User user;</span><br><span class="line"></span><br><span class="line">    public SpringAction(SpringDao springDao,User user)&#123;</span><br><span class="line">        this.springDao = springDao;</span><br><span class="line">        this.user = user;</span><br><span class="line">        System.out.println(&quot;构造方法调用springDao和user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        public void save()&#123;</span><br><span class="line">        springDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112131415</span><br></pre></td></tr></table></figure>
<p>在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置bean,配置后该类由spring管理--&gt;</span><br><span class="line">    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;</span><br><span class="line">        &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">        &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt;12345678</span><br></pre></td></tr></table></figure>
<p>在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性：<br>解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;  </span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt;  </span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot; ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt;  </span><br><span class="line">&lt;/bean&gt;  1234</span><br></pre></td></tr></table></figure>
<p>另一种是设置参数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg type=&quot;java.lang.String&quot; ref=&quot;&quot;/&gt;  1</span><br></pre></td></tr></table></figure>
<p><strong>3、静态工厂方法注入</strong><br>通过调用静态工厂方法来获取自己需要的对象，为了让Spring管理所有对象，我们不能直接通过类名加方法来获取对象，那样就脱离了Spring的管理，而是通过Spring注入的形式来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.bless.springdemo.factory;</span><br><span class="line">import com.bless.springdemo.dao.FactoryDao;</span><br><span class="line">import com.bless.springdemo.dao.impl.FactoryDaoImpl;</span><br><span class="line">import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;</span><br><span class="line">public class DaoFactory &#123;</span><br><span class="line">    //静态工厂</span><br><span class="line">    public static final FactoryDao getStaticFactoryDaoImpl()&#123;</span><br><span class="line">        return new StaticFacotryDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;12345678910</span><br></pre></td></tr></table></figure>
<p>同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public class SpringAction &#123;</span><br><span class="line">        //注入对象</span><br><span class="line">    private FactoryDao staticFactoryDao;</span><br><span class="line"></span><br><span class="line">    public void staticFactoryOk()&#123;</span><br><span class="line">        staticFactoryDao.saveFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    //注入对象的set方法</span><br><span class="line">    public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123;</span><br><span class="line">        this.staticFactoryDao = staticFactoryDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456789101112</span><br></pre></td></tr></table></figure>
<p>配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置bean,配置后该类由spring管理--&gt;</span><br><span class="line">    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot; &gt;</span><br><span class="line">        &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt;</span><br><span class="line">        &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt;</span><br><span class="line">    &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt;12345678</span><br></pre></td></tr></table></figure>
<p><strong>4、实例工厂方法注入</strong><br>实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DaoFactory &#123;</span><br><span class="line">    //实例工厂</span><br><span class="line">    public FactoryDao getFactoryDaoImpl()&#123;</span><br><span class="line">        return new FactoryDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;123456</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SpringAction &#123;</span><br><span class="line">    //注入对象</span><br><span class="line">    private FactoryDao factoryDao;</span><br><span class="line"></span><br><span class="line">    public void factoryOk()&#123;</span><br><span class="line">        factoryDao.saveFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFactoryDao(FactoryDao factoryDao) &#123;</span><br><span class="line">        this.factoryDao = factoryDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置bean,配置后该类由spring管理--&gt;</span><br><span class="line">    &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt;</span><br><span class="line">        &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt;</span><br><span class="line">        &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br><span class="line">    &lt;bean name=&quot;daoFactory&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt;123456789</span><br></pre></td></tr></table></figure>
<p>对于第1、2种我们用的比较多，对后两种可能比较陌生。<br>下面我们来分析下Spring是如何完成依赖注入的。如果我们去看Spring的源码可能涉及的类和接口相当多，不易掌握，在此我用自己的代码和方式来帮助我们Spring依赖注入的过程。<br>当我们启动Spring容器的时候他会执行以下几个过程：<br><strong>1、加载Xml配置文件(readXML(String filename))在Spring这个由ApplicationContext类完成</strong><br>这一步会解析Xml属性，把bean的属性存放到BeanDefinition类中<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 读取xml配置文件</span><br><span class="line">     * @param filename</span><br><span class="line">     */</span><br><span class="line">    private void readXML(String filename) &#123;</span><br><span class="line">           SAXReader saxReader = new SAXReader();   </span><br><span class="line">            Document document=null;   </span><br><span class="line">            try&#123;</span><br><span class="line">             URL xmlpath = this.getClass().getClassLoader().getResource(filename);</span><br><span class="line">             document = saxReader.read(xmlpath);</span><br><span class="line">             Map&lt;String,String&gt; nsMap = new HashMap&lt;String,String&gt;();</span><br><span class="line">             nsMap.put(&quot;ns&quot;,&quot;http://www.springframework.org/schema/beans&quot;);//加入命名空间</span><br><span class="line">             XPath xsub = document.createXPath(&quot;//ns:beans/ns:bean&quot;);//创建beans/bean查询路径</span><br><span class="line">             xsub.setNamespaceURIs(nsMap);//设置命名空间</span><br><span class="line">             List&lt;Element&gt; beans = xsub.selectNodes(document);//获取文档下所有bean节点 </span><br><span class="line">             for(Element element: beans)&#123;</span><br><span class="line">                String id = element.attributeValue(&quot;id&quot;);//获取id属性值</span><br><span class="line">                String clazz = element.attributeValue(&quot;class&quot;); //获取class属性值        </span><br><span class="line">                BeanDefinition beanDefine = new BeanDefinition(id, clazz);</span><br><span class="line">                XPath propertysub =  element.createXPath(&quot;ns:property&quot;);</span><br><span class="line">                propertysub.setNamespaceURIs(nsMap);//设置命名空间</span><br><span class="line">                List&lt;Element&gt; propertys = propertysub.selectNodes(element);</span><br><span class="line">                for(Element property : propertys)&#123;                  </span><br><span class="line">                    String propertyName = property.attributeValue(&quot;name&quot;);</span><br><span class="line">                    String propertyref = property.attributeValue(&quot;ref&quot;);</span><br><span class="line">                    PropertyDefinition propertyDefinition = new PropertyDefinition(propertyName, propertyref);</span><br><span class="line">                    beanDefine.getPropertys().add(propertyDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">                beanDefines.add(beanDefine);</span><br><span class="line">             &#125; </span><br><span class="line">            &#125;catch(Exception e)&#123;   </span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure>
<p><strong>2、Bean的实例化</strong><br>在配置文件以bean的id为key，BeanDefinition为value放到Map中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 完成bean的实例化</span><br><span class="line">     */</span><br><span class="line">    private void instanceBeans() &#123;</span><br><span class="line">        for(BeanDefinition beanDefinition : beanDefines)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if(beanDefinition.getClassName()!=null &amp;&amp; !&quot;&quot;.equals(beanDefinition.getClassName().trim()))</span><br><span class="line">                    sigletons.put(beanDefinition.getId(), Class.forName(beanDefinition.getClassName()).newInstance());</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;1234567891011121314</span><br></pre></td></tr></table></figure>
<p><strong>3、为Bean的输入注入值，完成依赖注入</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 为bean对象的属性注入值</span><br><span class="line">     */</span><br><span class="line">    private void injectObject() &#123;</span><br><span class="line">        for(BeanDefinition beanDefinition : beanDefines)&#123;</span><br><span class="line">            Object bean = sigletons.get(beanDefinition.getId());</span><br><span class="line">            if(bean!=null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    PropertyDescriptor[] ps = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();</span><br><span class="line">                    for(PropertyDefinition propertyDefinition : beanDefinition.getPropertys())&#123;</span><br><span class="line">                        for(PropertyDescriptor properdesc : ps)&#123;</span><br><span class="line">                            if(propertyDefinition.getName().equals(properdesc.getName()))&#123;</span><br><span class="line">                                Method setter = properdesc.getWriteMethod();//获取属性的setter方法 ,private</span><br><span class="line">                                if(setter!=null)&#123;</span><br><span class="line">                                    Object value = sigletons.get(propertyDefinition.getRef());</span><br><span class="line">                                    setter.setAccessible(true);</span><br><span class="line">                                    setter.invoke(bean, value);//把引用对象注入到属性</span><br><span class="line">                                &#125;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;123456789101112131415161718192021222324252627</span><br></pre></td></tr></table></figure>
<p>其实Spring依赖注入的过程就是这么简单，再就是各种细节了，比如懒加载、单例等的额外处理了。</p>
<h1 id="Android中的aop思路："><a href="#Android中的aop思路：" class="headerlink" title="Android中的aop思路："></a>Android中的aop思路：</h1><p><strong>面向切面编程（AOP，Aspect-oriented programming）</strong>需要把程序逻辑分解成『<strong>关注点</strong>』（concerns，功能的内聚区域）。这意味着，在 AOP 中，我们不需要显式的修改就可以向代码中添加可执行的代码块。这种编程范式假定『横切关注点』（cross-cutting concerns，多处代码中需要的逻辑，但没有一个单独的类来实现）应该只被实现一次，且能够多次注入到需要该逻辑的地方。</p>
<p><strong>代码注入是 AOP 中的重要部分：</strong>它在处理上述提及的横切整个应用的<strong>『关注点』</strong>时很有用，例如日志或者性能监控。这种方式，并不如你所想的应用甚少，相反的，每个程序员都可以有使用这种注入代码能力的场景，这样可以避免很多痛苦和无奈。</p>
<p><strong>AOP</strong> 是一种已经存在了很多年的编程范式。我发现把它应用到 Android 开发中也很有用。经过一番调研后，我认为我们用它可以获得很多好处和有用的东西。</p>
<h2 id="术语（迷你术语表）"><a href="#术语（迷你术语表）" class="headerlink" title="术语（迷你术语表）"></a>术语（迷你术语表）</h2><p>在开始之前，我们先看看需要了解的词汇：</p>
<ul>
<li><strong>Cross-cutting concerns（横切关注点）:</strong> 尽管面向对象模型中大多数类会实现单一特定的功能，但通常也会开放一些通用的附属功能给其他类。例如，我们希望在数据访问层中的类中添加日志，同时也希望当UI层中一个线程进入或者退出调用一个方法时添加日志。尽管每个类都有一个区别于其他类的主要功能，但在代码里，仍然经常需要添加一些相同的附属功能。</li>
<li><strong>Advice（通知）:</strong> 注入到class文件中的代码。典型的 Advice 类型有 before、after 和 around，分别表示在目标方法执行之前、执行后和完全替代目标方法执行的代码。 除了在方法中注入代码，也可能会对代码做其他修改，比如在一个class中增加字段或者接口。</li>
<li><strong>Joint point（连接点）:</strong> 程序中可能作为代码注入目标的特定的点，例如一个方法调用或者方法入口。</li>
<li><strong>Pointcut（切入点）:</strong> 告诉代码注入工具，在何处注入一段特定代码的表达式。例如，在哪些 joint points 应用一个特定的 Advice。切入点可以选择唯一一个，比如执行某一个方法，也可以有多个选择，比如，标记了一个定义成@DebguTrace 的自定义注解的所有方法。</li>
<li><strong>Aspect（切面）:</strong> Pointcut 和 Advice 的组合看做切面。例如，我们在应用中通过定义一个 pointcut 和给定恰当的advice，添加一个日志切面。</li>
<li><strong>Weaving（织入）:</strong> 注入代码（advices）到目标位置（joint points）的过程。</li>
</ul>
<p>下面这张图简要总结了一下上述这些概念。</p>
<p><a href="https://camo.githubusercontent.com/1fb49fef65877a7f80ad4622bf231f2b01804be3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f33303638392d353538343639393866346635623463652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1fb49fef65877a7f80ad4622bf231f2b01804be3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f33303638392d353538343639393866346635623463652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p>
<h2 id="那么…我们何时何地应用AOP呢？"><a href="#那么…我们何时何地应用AOP呢？" class="headerlink" title="那么…我们何时何地应用AOP呢？"></a>那么…我们何时何地应用AOP呢？</h2><p>一些示例的 cross-cutting concerns 如下：</p>
<ul>
<li><strong>日志</strong></li>
<li><strong>持久化</strong></li>
<li><strong>性能监控</strong></li>
<li><strong>数据校验</strong></li>
<li><strong>缓存</strong></li>
<li><a href="http://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="noopener">其他更多</a></li>
</ul>
<p>取决于你所选的其中一种或其他方案 :)。</p>
<h2 id="工具和库"><a href="#工具和库" class="headerlink" title="工具和库"></a>工具和库</h2><p>有一些工具和库帮助我们使用 AOP:</p>
<ul>
<li><a href="https://eclipse.org/aspectj/" target="_blank" rel="noopener">AspectJ:</a> 一个 JavaTM 语言的面向切面编程的无缝扩展（适用Android）。</li>
<li><a href="https://github.com/crimsonwoods/javassist-android" target="_blank" rel="noopener">Javassist for Android:</a> 用于字节码操作的知名 java 类库 Javassist 的 Android 平台移植版。</li>
<li><a href="https://code.google.com/p/dexmaker/" target="_blank" rel="noopener">DexMaker:</a> Dalvik 虚拟机上，在编译期或者运行时生成代码的 Java API。</li>
<li><a href="http://asm.ow2.org/asmdex-index.html" target="_blank" rel="noopener">ASMDEX:</a> 一个类似 ASM 的字节码操作库，运行在Android平台，操作Dex字节码。</li>
</ul>
<h2 id="为什么用-AspectJ？"><a href="#为什么用-AspectJ？" class="headerlink" title="为什么用 AspectJ？"></a>为什么用 AspectJ？</h2><p>我们下面的例子选用 AspectJ，有以下原因：</p>
<ul>
<li><strong>功能强大</strong></li>
<li><strong>支持编译期和加载时代码注入</strong></li>
<li><strong>易于使用</strong></li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>比方说，我们要测量一个方法的性能（执行这个方法需要多长时间）。为此我们用一个 <strong>@DebugTrace</strong> 的注解标记我们的这个方法，并且无需在每个注解过的方法中编写代码，就可以通过 logcat 输出结果。我们的方法是使用 AspectJ 达到这个目的。</p>
<p>我们看下在底层到底发生了什么：</p>
<ul>
<li><strong>我们在编译过程中增加一个新的步骤处理注解。</strong></li>
<li><strong>注解的方法内会生成和注入必要的样板代码。</strong></li>
</ul>
<p>在此，我必须要提到当我研究这些时，发现了<a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">Jake Wharton’s Hugo Library</a> 这个项目，支持做同样的事情。因此，我重构了我的代码，看上去和它类似。尽管，我的代码是一个更加原始和简化的版本（顺便提一下，通过看这个项目的代码，我学到了很多）。</p>
<p><a href="https://camo.githubusercontent.com/511e2eb42079b442554e0c20cdf8bb39fcd68bc5/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f33303638392d373766613462613334633461666536302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/511e2eb42079b442554e0c20cdf8bb39fcd68bc5/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f33303638392d373766613462613334633461666536302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p>
<h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><p>我们会把一个简单的示例应用拆分成两个 modules，第一个包含我们的 Android App 代码，第二个是一个 Android Library 工程，使用 AspectJ 织入代码（代码注入）。</p>
<p>你可能会想知道为什么我们用一个 Android Library 工程，而不是用一个纯的 Java Library：原因是为了使 AspectJ 能在 Android 上运行，我们必须在编译时做一些 hook。这只能使用 andorid-library gradle 插件完成。（先不要为此担心，后面我会给出更多细节。）</p>
<h3 id="创建注解"><a href="#创建注解" class="headerlink" title="创建注解"></a>创建注解</h3><p>首先我们创建我们的Java注解。这个注解周期声明在 class 文件上（RetentionPolicy.CLASS），可以注解构造函数和方法（ElementType.CONSTRUCTOR 和 ElementType.METHOD）。因此，我们的 DebugTrace.java 文件看上是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">@Target(&#123; ElementType.CONSTRUCTOR, ElementType.METHOD &#125;)</span><br><span class="line">public @interface DebugTrace &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="我们的性能监控计时类"><a href="#我们的性能监控计时类" class="headerlink" title="我们的性能监控计时类"></a>我们的性能监控计时类</h3><p>我已经创建了一个简单的计时类，包含 <code>start/stop</code> 方法。下面是 StopWatch.java 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class representing a StopWatch for measuring time.</span><br><span class="line"> */</span><br><span class="line">public class StopWatch &#123;</span><br><span class="line">  private long startTime;</span><br><span class="line">  private long endTime;</span><br><span class="line">  private long elapsedTime;</span><br><span class="line"></span><br><span class="line">  public StopWatch() &#123;</span><br><span class="line">    //empty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void reset() &#123;</span><br><span class="line">    startTime = 0;</span><br><span class="line">    endTime = 0;</span><br><span class="line">    elapsedTime = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void start() &#123;</span><br><span class="line">    reset();</span><br><span class="line">    startTime = System.nanoTime();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void stop() &#123;</span><br><span class="line">    if (startTime != 0) &#123;</span><br><span class="line">      endTime = System.nanoTime();</span><br><span class="line">      elapsedTime = endTime - startTime;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public long getTotalTimeMillis() &#123;</span><br><span class="line">    return (elapsedTime != 0) ? TimeUnit.NANOSECONDS.toMillis(endTime - startTime) : 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DebugLog-类"><a href="#DebugLog-类" class="headerlink" title="DebugLog 类"></a>DebugLog 类</h3><p>我只是包装了一下 “android.util.Log”，因为我首先想到的是向 android log 中增加更多的实用功能。下面是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Wrapper around &#123;@link android.util.Log&#125;</span><br><span class="line"> */</span><br><span class="line">public class DebugLog &#123;</span><br><span class="line"></span><br><span class="line">  private DebugLog() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Send a debug log message</span><br><span class="line">   *</span><br><span class="line">   * @param tag Source of a log message.</span><br><span class="line">   * @param message The message you would like logged.</span><br><span class="line">   */</span><br><span class="line">  public static void log(String tag, String message) &#123;</span><br><span class="line">    Log.d(tag, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Aspect-类"><a href="#Aspect-类" class="headerlink" title="Aspect 类"></a>Aspect 类</h3><p>现在是时候创建我们的 Aspect 类（TraceAspect.java）了。Aspect 类负责管理注解的处理和代码织入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Aspect representing the cross cutting-concern: Method and Constructor Tracing.</span><br><span class="line"> */</span><br><span class="line">@Aspect</span><br><span class="line">public class TraceAspect &#123;</span><br><span class="line"></span><br><span class="line">  private static final String POINTCUT_METHOD =</span><br><span class="line">      &quot;execution(@org.android10.gintonic.annotation.DebugTrace * *(..))&quot;;</span><br><span class="line"></span><br><span class="line">  private static final String POINTCUT_CONSTRUCTOR =</span><br><span class="line">      &quot;execution(@org.android10.gintonic.annotation.DebugTrace *.new(..))&quot;;</span><br><span class="line"></span><br><span class="line">  @Pointcut(POINTCUT_METHOD)</span><br><span class="line">  public void methodAnnotatedWithDebugTrace() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Pointcut(POINTCUT_CONSTRUCTOR)</span><br><span class="line">  public void constructorAnnotatedDebugTrace() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Around(&quot;methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()&quot;)</span><br><span class="line">  public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">    String className = methodSignature.getDeclaringType().getSimpleName();</span><br><span class="line">    String methodName = methodSignature.getName();</span><br><span class="line"></span><br><span class="line">    final StopWatch stopWatch = new StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    Object result = joinPoint.proceed();</span><br><span class="line">    stopWatch.stop();</span><br><span class="line"></span><br><span class="line">    DebugLog.log(className, buildLogMessage(methodName, stopWatch.getTotalTimeMillis()));</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Create a log message.</span><br><span class="line">   *</span><br><span class="line">   * @param methodName A string with the method name.</span><br><span class="line">   * @param methodDuration Duration of the method in milliseconds.</span><br><span class="line">   * @return A string representing message.</span><br><span class="line">   */</span><br><span class="line">  private static String buildLogMessage(String methodName, long methodDuration) &#123;</span><br><span class="line">    StringBuilder message = new StringBuilder();</span><br><span class="line">    message.append(&quot;Gintonic --&gt; &quot;);</span><br><span class="line">    message.append(methodName);</span><br><span class="line">    message.append(&quot; --&gt; &quot;);</span><br><span class="line">    message.append(&quot;[&quot;);</span><br><span class="line">    message.append(methodDuration);</span><br><span class="line">    message.append(&quot;ms&quot;);</span><br><span class="line">    message.append(&quot;]&quot;);</span><br><span class="line"></span><br><span class="line">    return message.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几个在此提到的重点：</p>
<ul>
<li>我们声明了两个作为 pointcuts 的 public 方法，筛选出所有通过 <code>“org.android10.gintonic.annotation.DebugTrace”</code> 注解的方法和构造函数。</li>
<li>我们使用 <code>“@Around”</code> 注解定义了<code>“weaveJointPoint(ProceedingJoinPoint joinPoint)”</code>方法,使我们的代码注入在使用<code>&quot;@DebugTrace&quot;</code>注解的地方生效。</li>
<li><code>“Object result = joinPoint.proceed();”</code>这行代码是被注解的方法执行的地方。因此，在此之前，我们启动我们的计时类计时，在这之后，停止计时。</li>
<li>最后，我们构造日志信息，用 Android Log 输出。</li>
</ul>
<p>###使 AspectJ 运行在 Anroid 上 现在，所有代码都可以正常工作了，但是，如果我们编译我们的例子，我们并没有看到任何事情发生。原因是我们必须使用 AspectJ 的编译器（ajc，一个java编译器的扩展）对所有受 aspect 影响的类进行织入。这就是为什么，我之前提到的，我们需要在 gradle 的编译 task 中增加一些额外配置，使之能正确编译运行。</p>
<p>我们的 build.gradle 文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import com.android.build.gradle.LibraryPlugin</span><br><span class="line">import org.aspectj.bridge.IMessage</span><br><span class="line">import org.aspectj.bridge.MessageHandler</span><br><span class="line">import org.aspectj.tools.ajc.Main</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:0.12.+&apos;</span><br><span class="line">    classpath &apos;org.aspectj:aspectjtools:1.8.1&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;android-library&apos;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  compile &apos;org.aspectj:aspectjrt:1.8.1&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 19</span><br><span class="line">  buildToolsVersion &apos;19.1.0&apos;</span><br><span class="line"></span><br><span class="line">  lintOptions &#123;</span><br><span class="line">    abortOnError false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android.libraryVariants.all &#123; variant -&gt;</span><br><span class="line">  LibraryPlugin plugin = project.plugins.getPlugin(LibraryPlugin)</span><br><span class="line">  JavaCompile javaCompile = variant.javaCompile</span><br><span class="line">  javaCompile.doLast &#123;</span><br><span class="line">    String[] args = [&quot;-showWeaveInfo&quot;,</span><br><span class="line">                     &quot;-1.5&quot;,</span><br><span class="line">                     &quot;-inpath&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                     &quot;-aspectpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                     &quot;-d&quot;, javaCompile.destinationDir.toString(),</span><br><span class="line">                     &quot;-classpath&quot;, javaCompile.classpath.asPath,</span><br><span class="line">                     &quot;-bootclasspath&quot;, plugin.project.android.bootClasspath.join(</span><br><span class="line">        File.pathSeparator)]</span><br><span class="line"></span><br><span class="line">    MessageHandler handler = new MessageHandler(true);</span><br><span class="line">    new Main().run(args, handler)</span><br><span class="line"></span><br><span class="line">    def log = project.logger</span><br><span class="line">    for (IMessage message : handler.getMessages(null, true)) &#123;</span><br><span class="line">      switch (message.getKind()) &#123;</span><br><span class="line">        case IMessage.ABORT:</span><br><span class="line">        case IMessage.ERROR:</span><br><span class="line">        case IMessage.FAIL:</span><br><span class="line">          log.error message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.WARNING:</span><br><span class="line">        case IMessage.INFO:</span><br><span class="line">          log.info message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">        case IMessage.DEBUG:</span><br><span class="line">          log.debug message.message, message.thrown</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="我们的测试方法"><a href="#我们的测试方法" class="headerlink" title="我们的测试方法"></a>我们的测试方法</h3><p>我们添加一个测试方法，来使用我们炫酷的 aspect 注解。我已经在主 Activity 类中增加了一个方法用来测试。看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@DebugTrace</span><br><span class="line">private void testAnnotatedMethod() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(10);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行我们的应用"><a href="#运行我们的应用" class="headerlink" title="运行我们的应用"></a>运行我们的应用</h3><p>我们用 gradle 命令编译部署我们的 app 到 android 设备或者模拟器上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradlew clean build installDebug</span><br></pre></td></tr></table></figure>
<p>If we open the logcat and execute our sample, we will see a debug log with: 如果我们打开 logcat，执行我们的例子，会看到一条 debug 日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gintonic --&gt; testAnnotatedMethod --&gt; [10ms]</span><br></pre></td></tr></table></figure>
<p><strong>我们的第一个使用 AOP 的 Androd 应用可以工作了！</strong> 你可以用 Dex Dump 或者任何其他的逆向工具反编译 apk 文件，看一下生成和注入的代码。</p>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾总结如下：</p>
<ul>
<li>我们已经对面向切面编程（AOP）这一范式有了初步体验。</li>
<li>代码注入是 AOP 中的重要部分。</li>
<li>AspectJ 是在 Android 应用中进行代码织入的强大且易用的工具。</li>
<li>我们已经使用 AOP 能力创建了一个可以工作的示例。</li>
</ul>
<p>参考：<a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Android%E4%B8%AD%E7%9A%84AOP%E7%BC%96%E7%A8%8B.md" target="_blank" rel="noopener">https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Android%E4%B8%AD%E7%9A%84AOP%E7%BC%96%E7%A8%8B.md</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/jdk/" rel="tag"># jdk</a>
          
            <a href="/tags/reflect/" rel="tag"># reflect</a>
          
            <a href="/tags/proxy/" rel="tag"># proxy</a>
          
            <a href="/tags/anotation/" rel="tag"># anotation</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/java_jdk_base_opt_perfermance.html" rel="next" title="java 程序优化">
                <i class="fa fa-chevron-left"></i> java 程序优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/java_jdk_base_kotlin_learn.html" rel="prev" title="kotlin简明教程">
                kotlin简明教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Fitz.Lee" />
          <p class="site-author-name" itemprop="name">Fitz.Lee</p>
           
              <p class="site-description motion-element" itemprop="description">Security & Android & Java</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">91</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">144</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fitzlee" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:fitz.lee@outlook.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/c7757daadf27" target="_blank" title="JianShu">
                  
                    <i class="fa fa-fw fa-book"></i>
                  
                    
                      JianShu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.anquanke.com/" title="Anquanke" target="_blank">Anquanke</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.gityuan.com/" title="Gityuan" target="_blank">Gityuan</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA反射"><span class="nav-number">1.</span> <span class="nav-text">JAVA反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射机制是什么"><span class="nav-number">1.1.</span> <span class="nav-text">反射机制是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射机制能做什么"><span class="nav-number">1.2.</span> <span class="nav-text">反射机制能做什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-反射机制的应用场景"><span class="nav-number">1.3.</span> <span class="nav-text">Java 反射机制的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射机制的优点与缺点"><span class="nav-number">1.4.</span> <span class="nav-text">反射机制的优点与缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解Class类和类类型"><span class="nav-number">1.5.</span> <span class="nav-text">理解Class类和类类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java反射相关操作"><span class="nav-number">2.</span> <span class="nav-text">Java反射相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取成员方法信息"><span class="nav-number">2.1.</span> <span class="nav-text">获取成员方法信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取成员变量信息"><span class="nav-number">2.2.</span> <span class="nav-text">获取成员变量信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取构造函数"><span class="nav-number">2.3.</span> <span class="nav-text">获取构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他方法"><span class="nav-number">2.4.</span> <span class="nav-text">其他方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过反射了解集合泛型的本质"><span class="nav-number">2.5.</span> <span class="nav-text">通过反射了解集合泛型的本质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思维导图"><span class="nav-number">2.6.</span> <span class="nav-text">思维导图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA注解"><span class="nav-number">3.</span> <span class="nav-text">JAVA注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念及作用"><span class="nav-number">3.1.</span> <span class="nav-text">概念及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是java注解？"><span class="nav-number">3.2.</span> <span class="nav-text">什么是java注解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java中内置的注解"><span class="nav-number">3.3.</span> <span class="nav-text">java中内置的注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元注解"><span class="nav-number">3.4.</span> <span class="nav-text">元注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java5-0定义的4个元注解："><span class="nav-number">3.4.1.</span> <span class="nav-text">Java5.0定义的4个元注解：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Target"><span class="nav-number">3.4.2.</span> <span class="nav-text">@Target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Retention"><span class="nav-number">3.4.3.</span> <span class="nav-text">@Retention</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Documented"><span class="nav-number">3.4.4.</span> <span class="nav-text">@Documented</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inherited"><span class="nav-number">3.4.5.</span> <span class="nav-text">@Inherited</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义注解"><span class="nav-number">3.5.</span> <span class="nav-text">自定义注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式"><span class="nav-number">3.5.1.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解参数的可支持数据类型"><span class="nav-number">3.5.2.</span> <span class="nav-text">注解参数的可支持数据类型:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规则"><span class="nav-number">3.5.3.</span> <span class="nav-text">规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-number">3.5.4.</span> <span class="nav-text">示例:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注解处理器类库"><span class="nav-number">3.6.</span> <span class="nav-text">注解处理器类库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注解处理器示例"><span class="nav-number">3.6.1.</span> <span class="nav-text">注解处理器示例:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-8-中注解新特性"><span class="nav-number">3.7.</span> <span class="nav-text">Java 8 中注解新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思维导图-1"><span class="nav-number">3.8.</span> <span class="nav-text">思维导图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态代理Java-Proxy和CGLIB"><span class="nav-number">4.</span> <span class="nav-text">动态代理Java Proxy和CGLIB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK原生动态代理"><span class="nav-number">4.1.</span> <span class="nav-text">JDK原生动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CGLIB动态代理"><span class="nav-number">4.2.</span> <span class="nav-text">CGLIB动态代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">4.3.</span> <span class="nav-text">结语</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android依赖注入-ioc"><span class="nav-number">5.</span> <span class="nav-text">Android依赖注入 ioc</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring依赖注入原理分析"><span class="nav-number">6.</span> <span class="nav-text">Spring依赖注入原理分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android中的aop思路："><span class="nav-number">7.</span> <span class="nav-text">Android中的aop思路：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#术语（迷你术语表）"><span class="nav-number">7.1.</span> <span class="nav-text">术语（迷你术语表）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#那么…我们何时何地应用AOP呢？"><span class="nav-number">7.2.</span> <span class="nav-text">那么…我们何时何地应用AOP呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工具和库"><span class="nav-number">7.3.</span> <span class="nav-text">工具和库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么用-AspectJ？"><span class="nav-number">7.4.</span> <span class="nav-text">为什么用 AspectJ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例-1"><span class="nav-number">7.5.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工程结构"><span class="nav-number">7.5.1.</span> <span class="nav-text">工程结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建注解"><span class="nav-number">7.5.2.</span> <span class="nav-text">创建注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们的性能监控计时类"><span class="nav-number">7.5.3.</span> <span class="nav-text">我们的性能监控计时类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DebugLog-类"><span class="nav-number">7.5.4.</span> <span class="nav-text">DebugLog 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aspect-类"><span class="nav-number">7.5.5.</span> <span class="nav-text">Aspect 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我们的测试方法"><span class="nav-number">7.5.6.</span> <span class="nav-text">我们的测试方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行我们的应用"><span class="nav-number">7.5.7.</span> <span class="nav-text">运行我们的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾"><span class="nav-number">7.6.</span> <span class="nav-text">回顾</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fitz.Lee</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
